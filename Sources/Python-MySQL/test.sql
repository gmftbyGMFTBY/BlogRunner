-- MySQL dump 10.13  Distrib 5.7.19, for Linux (x86_64)
--
-- Host: localhost    Database: fortest
-- ------------------------------------------------------
-- Server version	5.7.19-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `aifeature`
--

DROP TABLE IF EXISTS `aifeature`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `aifeature` (
  `md5url` varchar(40) NOT NULL,
  `size` int(11) DEFAULT NULL,
  `number_reader` int(11) DEFAULT NULL,
  `number_like` int(11) DEFAULT NULL,
  `grade` double DEFAULT NULL,
  `number_code` int(11) DEFAULT NULL,
  `number_photo` int(11) DEFAULT NULL,
  `number_link` int(11) DEFAULT NULL,
  PRIMARY KEY (`md5url`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aifeature`
--

LOCK TABLES `aifeature` WRITE;
/*!40000 ALTER TABLE `aifeature` DISABLE KEYS */;
INSERT INTO `aifeature` VALUES ('00a2b338af862c80a1183516ce9efba9',11501,699,1,4,16,6,1),('0237f423bab0fd35c26d10b8afff58f6',1198,8055,6,3,0,19,5),('02bea7215c3728317068fe911def129b',639,160,1,0,1,0,0),('034d09ba839d54f9a283ee618aca2d0c',9216,1630,4,4,4,3,4),('037630fa19ca83472d182bdb60c7fad3',500,4246,3,0,0,21,0),('03c65112ce369254f94d2824866a2a33',2011,2515,0,0,1,12,0),('04c3ef30e7df96dd7bb29a997c8f6b3a',2129,1537,1,3,1,2,16),('0605fa6ad0321a91f715452c20a93b50',661,4450,4,0,0,5,2),('06943e11e2090ecfd4fb9cb24dad81bc',2641,152,0,0,1,0,2),('07aebe975d0bb080b40048e8e5663f6b',342,1050,0,0,0,0,0),('07bab65946d2ee200089a4e73d88e0d7',4594,315,1,1,4,0,0),('07fcbdac020ddc4089c44545f6b22c3a',699,2823,2,0,0,16,6),('08001296ed7349c1fc96f28462f054b8',376,98,0,1,1,0,0),('099bdb7ca56e0181c18e84de600c2138',502,1942,1,0,0,4,0),('0be9374840981df94a1c35b7d4e9c96c',959,18250,5,0,0,36,0),('0c5a964a9d4b48627b08ea745edf3bed',4998,710,3,4,3,3,1),('0dd56bf7262e66bcfacb4fab80f973d7',518,5382,3,0,0,9,4),('0f83981f8c807e6d7775ac507fd33680',1644,303,0,2,1,0,1),('107b61f763b01c3db33c036f200ac722',12708,4919,4,5,6,2,6),('10a86c6e292dcb463eb4ae7bbc66042a',1621,5934,2,0,0,0,3),('10ded500c5333a70c848db39e00e6862',3175,3088,2,2,1,1,2),('113fbc3d8ac8f7b3968dc1110b2cb0b7',2925,8025,12,5,8,0,0),('11b3d243cd23a3376d87c62e14ed4b7c',3699,3447,0,0,1,42,4),('11b99820a144e000e0d0fd44392d1de8',1545,402,1,1,3,0,0),('1272cd81b29ef228444c2ef86271b50d',2311,145,0,0,1,0,0),('13075d1c6b47863f4cb80a3efc718856',1328,206,1,1,1,0,1),('13d511bf4a620e6aca27bf200b9abfd8',833,27446,11,0,0,36,0),('14ded15154a6158a649db6d86727c4e2',2171,124,0,1,3,1,0),('176b8ec67b0282bf3081b3ab9884ad45',160,238,0,0,0,0,0),('184ff4c980e830eb2d07ff02d2c9d324',11249,570,1,4,4,3,2),('18ffffe49010526d896e7860f3744ca3',1376,2849,0,0,2,0,0),('1a6a2d7b2f80e174999594b02462c42f',232,122,0,0,0,0,0),('1a774fa11cbcf4e6aaa04c0e27064bac',1631,208,0,0,2,0,0),('1b2285c1780faebb68ef9c5b02eb9357',3609,2879,6,4,3,0,0),('1c4c5af5691ed60981c75df65cb154ba',2886,4307,1,0,0,16,5),('1c61f6c193600e6526a2d7acea004646',1104,209,0,1,1,0,0),('1ca6558d299fc12b750ece36c19c2516',3783,991,1,4,3,7,4),('1ce7127738cb33c7a6fae365b2d8dab4',2562,7064,1,0,0,75,6),('1d31efa7883668a1477f7cc036189fe7',495,392,0,0,0,0,2),('1d78cdbe4c8e63af43ad88b7bfe789c8',825,306,0,1,1,0,0),('1d7ef6ea8780bb316904ba16a7d01c2c',3886,888,0,3,0,18,3),('1dca7dcdec9ed2eca17fc8a78caa4b5c',6982,2347,1,0,3,9,1),('1e9329951b5ae5322faad6837db08f8e',1059,264,0,1,2,0,0),('1f3b33e8e51d911d1de610c4c40b2ec3',2399,4884,3,0,1,10,1),('1f714067d27988d93910597155cb6c85',1807,694,0,1,2,2,0),('1fdeb48d4c08a5e1e6620597c802064b',1469,246,1,0,0,0,0),('20f2f5ffe5e0038e1a298261cc14c6cd',2055,149,0,1,1,0,0),('2184772f27396a64001c440b4e3f38c1',905,161,0,1,1,0,0),('218cc79b7919eb44b8eba304e8378bf1',1249,153,0,0,0,0,0),('219023a5bd581be35dd4e3d1b495aa71',1115,2782,5,0,0,2,9),('21b6fef885152db6ee3b7d3270cd24dd',2765,322,0,1,3,0,0),('22c84dab5069fb06b3f2064f569bbc57',123,249,0,0,1,0,0),('23d775dc0ea085e9131faf761b929540',824,4467,0,0,0,28,2),('251bddab31c2f3083c00169d4ffe44d4',1327,110,0,1,1,0,0),('253316d7fde83fe0c03ca44883156572',4535,2158,3,4,5,3,4),('25d48d7f593789a19d61d25b8dee58da',1515,179,1,0,1,0,0),('266fe684c18f343f9380e1390d67807e',938,490,1,1,1,0,0),('28bcec8c422e63b598c6dd7b33126575',2495,355,1,1,3,0,3),('2917619330361b259209c29f797bc584',1746,3422,1,0,1,16,5),('2ad576284c05deddc5b198e36f52ad41',2479,378,0,1,1,0,0),('2ae9cd250326d37dc969c5c1d2da85d4',2683,200,1,1,1,0,0),('2af62b2fd05e3ac6c88a4dc3c247a79b',1077,167,1,0,1,0,0),('2bb04749f872ea65e3efd519e1f6d98d',608,470,1,0,1,0,1),('2bd642ffa77be3d17dfb4fcb139eb41b',1320,165,0,1,1,0,0),('2d55a7fd609f58667330bfad4ef552b5',1062,177,0,0,1,0,0),('2dbfe2c4c069b6e3d0044908d6cc03c8',2196,227,0,1,3,0,0),('2dcfb09ebd42398edf64acad16704c56',3983,3982,0,0,4,0,0),('2e11dfeb6df893c672ccf896f27f9474',612,12192,2,0,0,10,2),('2eb43c3df59f66b0c87c7ea08716bfa5',2841,2864,5,5,1,34,4),('2f144a2d18a2aa200915b66705ca2b7d',326,23513,8,0,1,0,0),('2f71249d6c716d2b3ed27ccf202fd9fa',1599,2990,1,0,1,26,0),('31f9222f4ba30e330b73e3f9f48cc333',1020,487,0,0,1,0,0),('32c0a17d888e6bfb5e9a50831f90d41a',103,117,0,0,0,0,0),('33b713d1b03f8bafdcfed16ad6f695d8',5958,512,2,3,3,9,0),('34f8f93165d0406366667470d1cb7cf5',3143,344,0,1,3,0,0),('350c96b4188f8961c93d4714c3a7516e',1337,257,0,0,0,0,0),('36059f5c40734914bfc32082dd42db45',1871,313,0,1,1,0,0),('36ce257e05ca20567ddcca2ded5086dc',2492,375,1,1,2,0,0),('380b59173caa467ce830b999e8c44a67',2710,1538,3,0,1,7,1),('38dc5bd9591f2619371066e4fe13b106',4052,356,1,2,3,0,0),('39e429b41da4567bd9aa14e7d6b77419',1388,278,0,1,1,0,0),('3a6b62b45aa72974e1321d2792c8d904',4731,222,1,2,3,0,0),('3c3205cf525925c9fbae594e7b36de27',6136,322,0,1,2,0,0),('3d8be14bf788253396c52edaa6a87d0b',2582,158,0,1,1,0,0),('3fe0357fe17763b590f98acb9dd6930d',1083,8331,1,0,0,0,2),('41b3f8acb0cad8220c5af12f8be9d72e',1550,3405,0,0,1,0,3),('42138e54874de4fe9a8fccb7da3b2703',1063,164,0,0,0,0,0),('43237a3a343c278e1a6e71eba5375c41',1992,150,0,2,3,0,0),('443fc92e998f5737d6b29a1e8f1c7bab',165,190,0,1,0,0,0),('447d5b9c2af6b6f8023903f7bd4bbb6d',922,3793,2,0,1,19,1),('46895068d450af64ed4a902c09517d09',417,122,0,0,1,0,0),('46b7c5ddc82af44de04e08c46223dbd9',2035,427,0,1,1,2,0),('470cb502a07dcdaee785823dabc6b6e7',1053,304,0,1,1,0,0),('47308dafde2fa3209ecfeb951489ba40',1987,479,3,2,1,0,0),('478db79c5f06e4ad6ca63e3c977e1d66',3055,604,1,2,2,0,0),('478f1128df0dd5282960850b106f78d6',1582,410,0,1,1,0,0),('47d53c29a468be6ee33429fde5d80ed0',2494,360,0,1,1,0,0),('48320f183b9fe17a517e9e53a5460fbf',1109,142,1,0,0,0,0),('48e582d95a1ecc7a0e06f7da2c85cbef',5021,687,2,4,2,3,0),('4acffe82b905c42d794404212f8e3daf',1086,219,0,0,0,0,0),('4c9dfc3e6568c37102f3f8f68520b9a6',13990,2654,1,0,4,7,4),('4d79c036f710cbea0aa48ad62fd1bf53',1527,206,0,1,1,0,0),('4d9cde1d54b5bdaa9dfdacac4267f181',1215,321,1,1,1,0,0),('4db3cb31e39db0f7db287a1422cb80bf',1598,153,0,0,0,0,0),('4df03da5d71ef098daedb9758aa4ce6e',6414,470,0,2,5,1,0),('4e0744fe8004854eee70a7ab98176c3c',793,435,1,2,1,0,0),('4e130028642ed99aacf65a292703578c',1950,480,0,1,1,0,0),('4e4bb5158a77bf5f37edc27ca7de612e',1372,8192,1,0,1,9,0),('4fa4f9e0e044de908a5a1b21409519e1',1595,259,0,1,1,0,0),('4fc324574064008eb3b9c3984b4ec76c',1506,770,1,1,1,0,1),('4fce2e74c13f013b65f08ad07f8b0097',1728,135,0,1,2,0,0),('51b356c8e1a782955a6df64f5b10b21d',3438,847,3,3,1,0,1),('53cdde910a21801450c4d7a5570a0d5c',11941,591,1,3,1,0,0),('544ea48427eac68f9694dff6bd2e1777',3285,1839,0,0,1,1,0),('55210c663904f426e500fa362dda51d0',3669,532,1,4,4,0,0),('553c020eb715c10a4bf59bd0cf5d0660',2330,241,1,0,3,0,0),('5682a041bd7c798dcfdc760407c284fe',1211,3233,0,0,0,1,0),('56c715c0a03cfa92570e8362a81b88eb',1020,6745,4,0,0,20,0),('570ad6d8683bd0db5476502faca23c6a',835,111,0,1,1,0,0),('5753762124a3af91aaf9855d004c44d0',3296,6333,8,0,1,48,4),('57ad1b2baf6fb051bab3335c10d764ea',2979,10092,3,0,1,14,4),('58484fb4edee14a71df58f0483f6740a',5399,1116,1,4,1,14,6),('59274bdf3fa29047debbc2df9a12e6bb',1476,130,0,0,2,0,2),('597fcc7d63377505143cfd154b9be0f2',3036,1473,2,0,2,0,2),('5a251e1310c21914932022862a7fcd87',218,579,0,0,0,0,0),('5b211a42b5d9a02fa7ff7f5d9c90f6e3',3921,756,2,3,3,1,0),('5ca2146b550ba69b1bfa2bb652edbcc1',952,276,0,0,1,0,0),('5e122f4c3cb2fb8c563aef07b99800a5',6336,1459,5,4,1,1,4),('5e6243ff25e6cae199e807a517e14588',6983,1642,2,0,1,47,2),('5eee68084652e5ff7bbafe419560879b',5068,797,1,4,11,0,0),('5ffb51f5dcb0dc87e1697ffc33b97176',6622,39503,12,5,1,6,11),('600b2aaab3d86604894aeffa81f77570',5302,146,1,1,2,0,0),('605204b93bc6d2ed3b9e5b072628e220',4060,3528,0,0,2,2,4),('61c4f254f85eb0d64aec038524eb54d0',1920,181,0,0,0,0,0),('632529ab5b9bda5d5f075354e5a1c3a8',12059,8782,4,0,2,1,0),('6484768ed9aa38231f0eae47f83ac2d7',5584,426,0,4,9,0,2),('660d4efeee326d5c496282e368dcb0f8',11351,6506,4,0,2,4,5),('665796d41a4ff88b954c53044da5ecde',14413,1276,1,4,2,2,0),('68579480461afd9e410b96cd724c2262',1273,141,0,0,1,0,0),('68d72bdd504050c5e48c12e2f7c7c87b',1486,119,0,0,1,0,0),('6913331d45bac1cca2966c747bfd0d8c',801,541,1,2,1,1,2),('69467a1e1005522c2cc3019a98581c0d',2646,757,1,3,6,0,0),('69abedfbd2207ec21e54cf274483bec5',1540,173,1,1,1,0,0),('69b6f17582a6b3a30c7e0621f895967a',7430,9339,5,0,2,80,2),('6af4ca7d92ef1a93ca90a8100447aa68',1254,4008,2,0,0,22,1),('6b04ae0d5f526b4b60f4af48b5842704',2251,158,1,1,1,0,0),('6b5d63bca2deb091220fb36bf147609c',2056,3466,4,0,2,0,0),('6c9ae4a931f214d3422ed5444df6edc6',5554,15872,4,0,2,48,1),('6d5d09f93bb79d1554fdce507b9be8d1',912,74,0,0,1,0,0),('70127a99e31e7a9dd63caafb50b1d37c',883,95,0,0,1,0,0),('7067c2409f6b7108cf5ff70416878c69',2777,12517,1,0,1,0,0),('712df2bd27a957b5053d2cbcbbd65e49',987,2156,0,0,1,0,1),('7154cd3aa3a669a7b45a57392579fb57',1315,9207,6,0,0,47,0),('72919bb289df2653d2e935c9bb3450be',467,120,0,0,1,0,0),('76b2024a08d92b3d4a1d60f386f0fa52',2537,724,1,2,1,0,0),('773559c60d09a36f0bd7a9bc016dc68f',2228,292,1,1,2,0,1),('78b1316b0e33e35bfe43031e89134efd',1134,148,0,0,0,0,0),('78bb285a9a6e651234cbb846d8968789',645,290,0,1,1,0,0),('792b7ae12c31217c2caff21baa9e69f0',2010,350,0,1,2,5,7),('796b9ff9c1d863eb406d735857f9b3f4',1833,176,1,1,1,0,0),('7975d1ad5334dcf35773d6e3604c4ae0',1614,161,0,1,1,0,0),('7a53b66b25899ab4ad9ddb1d7147cbf5',8634,9711,3,0,4,38,0),('7b153f9d758efb5f8debbb7f71afc002',1612,209,0,1,2,0,0),('7c7330aa91a812d28426839d31e3c4d9',2544,277,0,1,1,0,0),('7c7519badd7e95230c38c7f7c27873fd',252,330,0,0,0,0,0),('7ceb394cf67d1b3a054983c8a34c8eec',343,1705,1,0,0,20,1),('7d12eb53eae22dedce58512338e5c9b8',1493,2307,0,0,1,10,1),('7fe9d4d601c5edf7b833235f57e5efb3',683,151,0,1,2,0,0),('8000e983369664340e554ce4e9bec5ca',1548,118,0,0,3,0,0),('811a19d8eba2e5938ebc13132c0fdac0',1656,1267,2,0,3,3,1),('81231dc734a5c0195db95208f1814bdb',179,1231,1,0,0,15,0),('82ced4f285860e52d64dc9e0ff6a25b9',965,6239,3,0,0,15,0),('847150ad9b3e357d08b915e40bc44c8c',1333,2288,1,0,1,19,3),('850aa4315a0eb552863a889baa8b99b8',1147,108,0,0,1,0,0),('86deed3be67bf11420f7a04c3acf8dcc',588,907,0,2,1,0,0),('8a22a0815cfe9ee71c17c22a1cbfa291',2623,333,0,1,3,0,0),('8bc440fbc155d5d28aba81774b1ed45f',2718,211,0,1,4,0,0),('8c6b258dd33c6008a432d96744ec5f21',1402,1391,1,0,1,20,0),('8c835df3a6fe0f7417676f6d189592ba',2955,196,0,2,2,0,0),('8cdc44461ad45e04d2823d15e11f5b09',2876,4096,0,0,2,0,0),('8ded2c60f7323d361a1d1302a5a26849',1246,229,0,0,1,0,0),('8efde626072fa85e0f24e07fa382d6c6',1045,170,0,0,1,0,1),('8f4b0ef1601de83b334fff8001f6d50a',2734,138,0,0,2,0,0),('90f93e042ef17f54bae3ba9ffdecd4ab',1146,230,1,1,1,0,0),('91d4eae5ca78ef76971c493ae2ce6e21',3106,3478,1,0,2,2,0),('91f3f5776615b5458a5d6c0f2fa7e934',3866,9619,10,0,1,25,3),('933abebb16b8d0ba1310601628878085',621,311,0,0,0,0,0),('939cfe2513c87864203c802b94b3b345',1562,384,0,0,0,0,0),('9419a32605f2ec11e30ef04e36c5739d',1476,34842,11,0,0,33,7),('959477141e29a0dd5d9fd81963a4641e',1506,138,0,0,1,0,0),('969795d117d0046a59051ac212296854',11894,1667,4,4,6,0,7),('98540dd299f8123e697ac26c937a6eef',1279,246,1,1,2,1,0),('98c9e65fc9bd6dcb57f1c05ab6c2374f',1592,140,0,0,1,0,0),('996954f342e94e042f8988b3dac4ffbd',1287,440,0,2,1,0,0),('9a0d085d234baf4b9a58b88725bf30b1',1696,134,0,0,1,0,0),('9c2b79a615bff58c45e9f51f7f9aba7e',8679,243,1,2,0,0,0),('9cd7c0c3deb2b66eb328f935825356d7',3267,1117,2,3,4,1,0),('9cf9a00aa46b1fe0b1b84704cfe4348a',2693,266,1,1,3,0,0),('9e1799ac27ed59f99b3887e328ce7984',2913,334,1,2,3,0,1),('9f207252787c66b63cb5cf2cf9220606',540,3551,2,0,0,31,2),('9f635156d0c03560d40bed1799360db1',1656,786,0,2,1,0,1),('9f70d86fb6232f2b5332dd217029e1bc',902,132,0,0,1,0,1),('9fe0592ffa6a5a02209a1d41300ea5b7',2998,409,1,1,4,0,0),('a02be56adafc2065faaa9cd55ca05956',1737,290,1,0,0,0,0),('a07f8c70135a5b6963a734468f06483e',644,193,1,0,1,0,0),('a0c34d5a28bcaa06964fcc36ae4b5f5e',2286,3384,5,0,1,31,1),('a16ebafe7fb92a3c2a3036e31639c00a',3758,6791,12,0,2,63,2),('a451591c1006c647b0229a2754212b9e',1564,26506,11,0,0,30,1),('a4f145f1afb8fa8dd4bc1a05efe8f9f2',248,478,0,0,0,0,0),('a675a49d805120afdf4fe0ef53d7ce9f',2989,327,0,1,3,0,0),('a7806e3904ee4741ce50455d29b921f7',545,11265,7,0,0,18,0),('a845c06649e26235a6ea46733f9c697d',9012,89266,38,0,4,42,0),('a84af7a5470d479c208fe66b7613ba27',2691,349,0,1,1,0,0),('a9f333bf4fc28d0ac4d873ae06374600',3995,840,1,2,2,0,0),('ab3aa8ddb84d04cb9ad08a5a4b99bf3a',903,641,0,1,1,0,0),('ac1342f5c978ecefeb2b2c1723e480f6',1379,200,0,0,1,1,0),('ac857659deda8ab6c63453f563a3c111',3165,189,0,0,3,1,0),('ad93c249842133b1d8b11f9d6dba1aeb',2288,340,1,1,4,0,0),('adfde3e9991657167389307653e7bc85',6067,241,1,2,7,0,0),('ae186ca1b39dd7b651b4a31f04bc5f37',4472,7929,2,0,4,0,4),('aeec3a461ad65408ad98d6d803f6b2f3',713,128,1,0,1,0,0),('b05f249e46d6ed724d7bf5c2b76abc0f',3468,281,0,1,3,1,0),('b0a49e820977aa9b5b798a05810ac9f0',1795,24678,4,0,0,29,4),('b3a46a0d112423f46a3563a50e215f43',2288,567,1,2,3,0,0),('b4879acfeae5796e043cb678ee5be519',2581,121,1,1,3,0,1),('b4d110b310c51bbb72c1e3db58dd6786',4007,1942,4,4,3,2,0),('b4fbc24c81becd141e5d0597d47ec783',1580,1432,0,0,1,15,1),('b5aa026bdd910225105a20852a8af085',2105,348,0,1,1,0,1),('b6675e2efd74a869ddf08d9fd6cc3666',1224,2825,5,0,1,0,1),('b6d74f2c220e0826e7737e486991c82a',11260,44814,31,0,4,33,0),('b734649389d73b4c3003d375a698754a',5248,2611,1,0,3,1,1),('b81bc3c773cf39cbf1de30d92402e756',1733,256,0,1,1,0,0),('b8a70e672566aa45fe1c8bc1573504c1',3085,165,1,1,1,1,0),('b8cbdec366ed2d6f1183146a007f4f16',4765,952,1,3,4,0,0),('baa0f53625a6050e36ede49043cd75ac',1041,213,0,0,1,0,0),('bb96ebc2a8afc57269ffdac3cbb5b724',2098,149,1,1,3,0,0),('bc7d1e782762b3aabb2cb292572b0ad0',1176,626,1,1,1,0,0),('bce198b43aa2a32dd1435313b3b201fe',1250,733,1,2,2,1,1),('bed9760d644cb24d5436b3ccb616b15c',2360,447,0,1,1,0,0),('bf0ae593723c282ce17b0cb55e3cf869',2179,279,0,1,0,0,0),('bf6117e70f273d2db48fb77ebddfd627',5350,196,0,0,4,1,0),('c0183ee99714827f58b6c0e5cb102dc8',2782,5875,1,0,1,22,2),('c045f73b5b9c9d152db30b839bb58d16',4837,1130,1,4,7,1,0),('c12f3a16c70cf9cabf4463f744d08777',804,1315,0,1,2,0,0),('c15acf0441d2dfd9aeda6b43e859f7a9',295,3681,1,1,0,1,1),('c1d1d8e955cbd460dea2e596a3298447',2680,7646,2,0,1,3,2),('c38e9b3b7c5447f3fc6a9fd5bd17eae3',758,91,1,0,1,0,0),('c483f05652dfed8429bb6988b7c39e74',5620,1276,4,4,5,0,2),('c58fa5f635bee601f3ef8648533973d0',1747,3052,3,0,0,37,0),('c61a16732f880ca8aee5eaeedd3a6bd8',1717,366,0,0,0,0,5),('c6abd5ae3cc3ed0a2e1f3ec7d4d720be',4273,397,1,2,5,0,1),('c71ef0e61fccaaa38bfe38fbde3ebdb5',695,8188,0,0,0,13,0),('c94dad4538421d140b6678605749812f',2901,174,0,1,3,0,0),('ca8f581e97c0b2b548d455114d1155ee',264,2904,2,0,0,2,1),('cb69f71f7ce5f4d8c2099e45d065091f',2013,741,1,1,4,0,0),('cbb25aec76a77f67fc1ac67365ea1924',5461,6236,3,0,3,17,0),('cd6d50cd369e7c03be1b37bbe08c8516',2144,136,0,0,2,0,0),('cddf940503dd4228034a4037e087c9dd',1027,192,2,0,3,0,0),('ce0da0b5404cf689e3e94dc797370d16',1776,1929,1,0,3,0,0),('ce1ed2ba15f92006c1d67ea944cef29b',861,169,0,0,1,0,0),('cedb01cd68b6f4d3779ee2b4ad266851',165,648,0,1,0,1,0),('cff7f12fc853c934ca698b2235f0bf59',585,7195,1,0,0,6,2),('d00a87a06b466c626d073a017b9fee3a',3256,1410,3,3,1,5,7),('d0757874dbd624388b0d1754d6ab953d',3351,2755,0,0,6,1,1),('d09c1654f8f43f622a8097ea2c20fda4',5374,302,1,3,0,0,0),('d0e04f6d65f9d0c5ea0240db8e291270',3751,2923,1,0,1,0,1),('d1a12940c58b266ab01a4adba89894a6',1778,3623,0,0,1,0,0),('d1bbeb3766f7eec9c92a7a7033b78378',21037,180,2,0,0,0,0),('d2d11692cc4f0076a6ac379943e6c59d',3217,202,0,1,2,0,1),('d4574c38936d14a9987c2d7d57722d38',4485,9610,16,0,5,28,4),('d4a596e8aa41bc4b4f1424e71029fca7',1143,470,1,0,1,0,0),('d53006af98561402ab1be69090ece96a',8340,1490,3,4,5,1,8),('d55e92af46f1db9f6591e5b63282a09c',38086,8581,3,0,2,40,3),('d78ccd28fb332062d6e4909048b3c32d',7983,687,3,2,1,0,1),('da0609892e13b0ffd6f55260fa7f1c52',2862,24284,10,5,2,13,1),('dabb62e4558861ddf9b2468477a313d2',1222,186,0,0,1,0,1),('dc2cff14baba536436cc047d97285310',4847,375,0,1,1,0,0),('dc77ac49f267391f6f5962dc0b71ff85',2325,21614,8,0,0,37,3),('dca39f661ce7aa0b4cdc185f3a66f0bb',530,254,1,0,1,1,0),('dda474758e3d0d3ac105042a75cfcade',928,15154,3,0,0,14,6),('dde5be1a2e98ffd4b1b9f2785a355b9a',3724,12802,2,0,2,16,4),('de78adbece2a33da71d1487f1f5c422c',459,1947,0,0,0,0,8),('df83d3b34f7c58eeb7193f7b8db27dde',599,189,1,1,2,0,0),('dfee847ead718245d5fcb3711d2313b4',1324,192,2,0,2,0,0),('dff68f3da21c455027057a454f2d5ddd',252,2579,1,0,0,0,0),('e0c9b990f04a2e0e8533c503a8e5c693',229,1250,1,2,0,5,0),('e2a43a71b49f143c92d0d1d082d1d56d',4649,789,1,2,5,21,14),('e52dee5e50a48a9e7de044296cad9dcc',2186,170,0,1,6,0,0),('e5568b14bff666b7f49d30df7cf23b1a',1688,140,1,1,1,0,0),('e64f934d95e2938669fe04ab5b5132cf',1495,2453,1,3,1,3,2),('e7162473b38db391290626baed73d07a',6129,1989,2,3,1,5,11),('e8ae688336230a3d8b3f50eb308b8d4f',962,34616,11,0,0,15,1),('ea524f84b71248416a312360155e8a73',4045,222,0,0,0,0,0),('eaceef9143e36f2061ce6b97f59878d6',1408,169,0,1,1,0,0),('eb59a71b0083b133ff2c88f7d57fdeea',2170,189,0,1,0,15,3),('ec153712f4535a801a94e24a0a69ad15',1893,1009,2,2,1,0,0),('ecff16d1ff3282f5c3f319f08db3f7a5',130,109,0,0,0,0,1),('ed4ad348267d41a0ea1114bc7cce4f81',1269,702,1,2,1,0,0),('ed70f3689645512220f95a29fe978061',2414,1236,0,2,1,2,0),('ed7ba1d3a836fe65c6589c468b3e7e07',3832,174,1,1,1,0,0),('ed876a9c2c78e459df4dee6e151fce7a',3360,4434,2,0,0,16,2),('ee682def12293be7dcb77a80a60abe99',6957,221,1,3,1,0,0),('f206b9071a1f77c923af056378a217c2',493,2689,3,0,0,14,0),('f608746350d6c81ee8fbcae1dab6eed1',5814,36858,6,0,1,25,2),('f6481dd9bca008d221ca52b74d06f1f9',7609,706,0,2,2,1,1),('f6991b304d495950cd16010d04ea334e',2728,517,0,2,0,1,1),('f6e204f60f822e582a9b43389749744e',785,210,0,0,1,0,0),('f7ed70049dcb92e8b2f6244c9eeece3f',1230,227,0,0,1,0,0),('fa3f0b698f83ef8c9f9ae2670b694717',654,158,0,1,1,0,0),('fa98d3d04c8c5c29bcef136197124863',1194,1368,0,0,1,0,0),('fc0566579ca8e1f202a7ce694da3880a',4474,323,1,1,4,0,0),('fdb22e25a2d0703f9a32876e7a3ee5a5',955,661,2,0,0,0,0),('feb9a779767c89cde6d12baefee0c149',2027,485,1,3,5,0,1),('ffcb27ff8cf66bc64883765b33060320',1977,1581,0,0,0,41,0);
/*!40000 ALTER TABLE `aifeature` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `page`
--

DROP TABLE IF EXISTS `page`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `page` (
  `md5url` varchar(40) DEFAULT NULL,
  `content` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `page`
--

LOCK TABLES `page` WRITE;
/*!40000 ALTER TABLE `page` DISABLE KEYS */;
INSERT INTO `page` VALUES ('478f1128df0dd5282960850b106f78d6','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3295 - 位运算 + 模拟 +递归\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   本题是用枚举的思路来判断一个规定的逻辑表达式是不是永真式\n  </div>\n  <div>\n   首先题目意思是最多不会有超过5个逻辑变量，有五种运算\n  </div>\n  <div>\n   <table bgcolor=\'#ccffff\' border=\'1\' cols=\'1\' id=\'table1\' style=\'font-family:\'Times New Roman\',Times,serif\' width=\'80%\'>\n    <tbody>\n     <tr>\n      <td>\n       <center>\n        <strong>\n         <span size=\'+1\' style=\'color:#000099\'>\n          Definitions of K, A, N, C, and E\n         </span>\n        </strong>\n       </center>\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <table bgcolor=\'#ccffff\' border=\'1\' cols=\'6\' id=\'table2\' style=\'font-family:\'Times New Roman\',Times,serif\' width=\'80%\'>\n    <tbody>\n     <tr>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         <em>\n          w  x\n         </em>\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         K\n         <em>\n          wx\n         </em>\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         A\n         <em>\n          wx\n         </em>\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         N\n         <em>\n          w\n         </em>\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         C\n         <em>\n          wx\n         </em>\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         E\n         <em>\n          wx\n         </em>\n        </span>\n       </strong>\n      </td>\n     </tr>\n     <tr>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1  1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n     </tr>\n     <tr>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1  0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n     </tr>\n     <tr>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0  1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n     </tr>\n     <tr>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0  0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         0\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n      <td>\n       <strong>\n        <span size=\'+1\' style=\'font-family:Courier New,Courier\'>\n         1\n        </span>\n       </strong>\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   其中\n  </div>\n  <div>\n   K &amp;\n  </div>\n  <div>\n   A |\n  </div>\n  <div>\n   N !\n  </div>\n  <div>\n   C -&gt;\n  </div>\n  <div>\n   E 同或\n  </div>\n  <div>\n   其中的C我们可以利用 !A | B 实现\n  </div>\n  <div>\n   E利用==实现\n  </div>\n  <div>\n   本题的主要难点并不在于实现我们的语句计算的方式\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   1.难点1：\n  </div>\n  <div>\n   递归求解表达式，在这里真的是有深刻的理解了递归的强大之处，我们本题的做法真的离不开递归，我们的做法是一个一个字符的开始枚举的递归，每个字符分出10种情况，五种变量，五种运算符，这里我们添加一个指示器变量表示我们当前的递归的位置和深度，我们不用设置我们的递归的终止条件，因为我们的表达式保证了一定是正确的，我们的计算结果一定是会有返回值的，我们的计算结果是一层一层的返回的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.难点2：\n  </div>\n  <div>\n   位运算，我们本题如果不利用位运算的话，至少需要写5层循环来模拟我们的变量的所有的情况，这样太低效了，我们将我们的所有的变量封装到一个一个字节的存储器中，每次利用位运算提取相关的位置的数字就好了（虽然我们的表达式并不会运算所有的情况，但是至少不会错）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2026829\' name=\'code\' snippet_file_name=\'blog_20161204_1_2731221\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nint pos=0;\nstring data;\n\nbool cal(int i)\n{\n	int t=pos++;\n	switch(data[t])\n	{\n		case \'p\':\n			return (i &gt;&gt; 4)&amp;1;\n		case \'q\':\n			return (i &gt;&gt; 3)&amp;1;\n		case \'r\':\n		    return (i &gt;&gt; 2)&amp;1;\n		case \'s\':\n		    return (i &gt;&gt; 1)&amp;1;\n		case \'t\':\n		    return i&amp;1;\n		case \'K\':\n		    return cal(i) &amp; cal(i);\n		case \'A\':\n		    return cal(i) | cal(i);\n		case \'N\':\n			return !cal(i);\n		case \'C\':\n			return !cal(i) | cal(i);\n		case \'E\':\n			return cal(i) == cal(i);\n	}\n}\n\nbool isTautology()\n{\n	for(int i=0;i&lt;=31;i++)\n	{\n		pos=0;\n		if(cal(i)) continue;\n		else return false;\n	}\n	return true;\n}\n\nint main()\n{\n	while(cin&gt;&gt;data&amp;&amp;data[0]!=\'0\')\n	{\n		if(isTautology()) cout&lt;&lt;\'tautology\'&lt;&lt;endl;\n		else cout&lt;&lt;\'not\'&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('34f8f93165d0406366667470d1cb7cf5','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ 118 次小生成树\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold; font-family:Tahoma,Arial,sans-serif,simsun\'>\n    描述\n   </dt>\n   <dd style=\'margin:0px; padding:0px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     南将军率领着许多部队，它们分别驻扎在N个不同的城市里，这些城市分别编号1~N，由于交通不太便利，南将军准备修路。\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     现在已经知道哪些城市之间可以修路，如果修路，花费是多少。\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     现在，军师小工已经找到了一种修路的方案，能够使各个城市都联通起来，而且花费最少。\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     但是，南将军说，这个修路方案所拼成的图案很不吉利，想让小工计算一下是否存在另外一种方案花费和刚才的方案一样，现在你来帮小工写一个程序算一下吧。\n    </p>\n    <div class=\'clr\' style=\'clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n    </div>\n    <dl class=\'others\' style=\'margin:0px; padding:0px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      第一行输入一个整数T(1&lt;T&lt;20)，表示测试数据的组数\n      <br/>\n      每组测试数据的第一行是两个整数V,E，(3&lt;V&lt;500,10&lt;E&lt;200000)分别表示城市的个数和城市之间路的条数。数据保证所有的城市都有路相连。\n      <br/>\n      随后的E行，每行有三个数字A B L，表示A号城市与B号城市之间修路花费为L。\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      对于每组测试数据输出Yes或No（如果存在两种以上的最小花费方案则输出Yes,如果最小花费的方案只有一种，则输出No)\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_input\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>2\n3 3\n1 2 1\n2 3 2\n3 1 3\n4 4\n1 2 2\n2 3 2\n3 4 2\n4 1 2</pre>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_output\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>No\nYes</pre>\n     </dd>\n    </dl>\n    <h2>\n     2.Solution:\n    </h2>\n   </dd>\n  </div>\n  <div>\n   本题是次小生成树的模板题目，首先，我们需要明确\n  </div>\n  <div>\n   在一个图G中，我们的最小生成树是不唯一的，所以说，一个图可能存在多个权值相同的最小生成树，但是有的图G可能更加的充分，其中并不存在次小生成树，所以说，我们在这里的判断条件就是利用最小生成树和动态规划的原理判断一个图G中的最小生成树的唯一性\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先，我们证明如下：\n  </div>\n  <div>\n   在一个图中，我们构建次小生成树的方式就是，我们每一次都是在最小生成树上加上一条不在最小生成树上的边\n  </div>\n  <div>\n   我们可以利用反证法来证明，改变一定是加上之后构成的圈中的边中的权值最大的一条边\n  </div>\n  <div>\n   证明如下：\n  </div>\n  <div>\n   首先，我们假设我们目前找到了最小生成树C，那么我们在飞最小生成树上找到的这个边如果不是新构成的圈上的权值最大的边，说明，我们对于当前找到的最小生成树C完全可以通过替换成当前的不在最小生成树上的边从而进行权值的优化，那么我们就可以得到一个更优的最小生成树，这是胡，我们的得到的结论和我们的假设是矛盾的，所以说我们不在最小生成树上的班在新构成的圈中必定是权值最大的一条边\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么在这里，我们就会发现我们的次小生成树的构建方法了\n  </div>\n  <div>\n   我们枚举每一条不在最小生成树上的边，必定会构成一个圈，我们将圈中的第二大的边（没有构成圈时的路径上的最大的边）删去可以的到一个新的生成树，我们枚举所有的非最小生成树的边找到的最小值就是我们的次小生成树的情况\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在本题中，我们的如果次小生成树如果和我们的次小生成树的权值和我们的最小生成树的权值相同的说明我们的最小生成树的构建情况是不唯一的，这是后我们根据题意进行相应的处理就好了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在这里我们的利用动态规划的原理\n  </div>\n  <div>\n   定义状态：\n  </div>\n  <div>\n   dp[I][J]：i到j路径上的路径中的边的权值的最大值\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   dp[i][minpoint]=max(dp[i][pre[minpoint]],dis[minpoint])    minpoint是我们的当前的最小生成树算法中Prim当前挑选出来的距离生成树最近的节点\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2024642\' name=\'code\' snippet_file_name=\'blog_20161203_1_4995632\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'algorithm\'\n#define N 505 \n#define INF 0x3fffffff\n\nusing namespace std;\n\nint n,m;\nint map[N][N];\nbool book[N][N];\nbool vis[N];\nint dis[N];\nint pre[N];\nint dp[N][N];\n\nvoid init_map()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(i!=j) map[i][j]=INF;\n			else map[i][j]=0;\n		}\n	}\n}\n\nbool Prim()\n{\n	for(int i=1;i&lt;=n;i++) \n	{\n		dis[i]=map[1][i];\n		if(dis[i]!=INF) pre[i]=1;\n	}\n	memset(vis,0,sizeof(vis));\n	memset(book,0,sizeof(book));\n	for(int i=1;i&lt;=n;i++) book[i][i]=1;\n	vis[1]=1;\n	memset(dp,0,sizeof(dp));\n	\n	int sum_1=0;\n	int sum_2=0;\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int mink=INF;\n		int minpoint;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(vis[j]==0&amp;&amp;dis[j]&lt;mink)\n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		}\n		vis[minpoint]=1;\n		sum_1+=dis[minpoint];\n		book[minpoint][pre[minpoint]]=book[pre[minpoint]][minpoint]=1;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(vis[j])\n			{\n				dp[minpoint][j]=dp[j][minpoint]=max(dp[j][pre[minpoint]],dis[minpoint]);\n			}\n		} \n		\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(vis[j]==0 &amp;&amp; dis[j]&gt;map[minpoint][j])\n			{\n				dis[j]=map[minpoint][j];\n				pre[j]=minpoint;\n			} \n		}\n	}\n	\n	sum_2=INF;\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(!book[i][j]&amp;&amp;map[i][j]!=INF)\n			{\n				sum_2=min(sum_1+map[i][j]-dp[i][j],sum_2);\n				book[i][j]=book[j][i]=1;\n			}\n		}\n	}\n	\n	if(sum_2==sum_1) return true;\n	else return false;\n}\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		scanf(\'%d%d\',&amp;n,&amp;m);\n		init_map();\n		for(int i=1;i&lt;=m;i++)\n		{\n			int x,y,z;\n			scanf(\'%d%d%d\',&amp;x,&amp;y,&amp;z);\n			if(z&lt;map[x][y]) map[x][y]=map[y][x]=z;\n		}\n		if(Prim()) printf(\'Yes\n\');\n		else printf(\'No\n\');\n	} \n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('034d09ba839d54f9a283ee618aca2d0c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  胜者树 败者树 K-路最佳归并树 高效外部排序\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   外部排序\n  </h2>\n  <p>\n   外部排序和内部排序还是有非常的的不同的,我们的外部排序主要针对的优化目标也是不同的,这里我先从外部排序的物理基础开始进行讲解\n   <br/>\n  </p>\n  <h3>\n   1.外存:\n  </h3>\n  <p>\n   外部存储设备,相对于我们的内部存储设备而言具有一些特点\n   <br/>\n   <br/>\n   1.\n   <strong>\n    优点\n   </strong>\n   :永久存储能力,便携性,存储空间大\n   <br/>\n   2.\n   <strong>\n    缺点\n   </strong>\n   :访问速度相对于内存的访问速度来说极其低下(相差约5~6个数量级)\n   <br/>\n   <br/>\n   因此对于外存来说,我们要遵守的基本操作原则就是:\n   <strong>\n    尽可能的减少我们的对外存的访问的次数\n   </strong>\n   <br/>\n   对于外存的类型来说,我们分成了磁带和磁盘两个方面,在这里我们对磁带就不过多的赘述了,我们主要来看看磁盘\n   <br/>\n   <img alt=\'\' src=\'http://hi.csdn.net/attachment/201106/7/8394323_13074405911zG7.jpg\'/>\n   <br/>\n   如图所示,我们可以大致的了解到磁盘的主要的操作部件,在这里我们对操作的具体不见不做过多的描述,我们主要来考虑一下我们的这些部件对我们的计算机和磁盘之间的交互的时间效率的影响\n  </p>\n  <p>\n   <br/>\n   <strong>\n    磁盘的存取时间\n   </strong>\n   <br/>\n   磁盘访问时间主要由寻道时间，旋转延迟时间和数据传输时间组组成。\n   <br/>\n   寻道时间（Seek time）tseek：是移动磁盘臂，定位到正确磁道所需的时间。\n   <br/>\n   旋转延迟时间tla：是等待被存取的扇区出现在读写头下所需的时间。\n   <br/>\n   传输时间twm：是传输一个字符的时间。\n   <br/>\n   <strong>\n    TI/O=tseek + tek + la + twm\n   </strong>\n   <br/>\n   我们每次都是将我们的磁盘中的数据按**块**为单位传输到我们的内存的高速缓冲区中（cache）我们每次在内存中对数据进行读取的时候，都要先从cache中开始检查，如果cache中存在数据我们就从cache中读取，如果cache为空，我们在从磁盘中进行读取\n   <br/>\n   <br/>\n   我们在外存上的数据基本都可以看作是文件，我们对外部数据进行的操作主要可以分成这么几类\n   <br/>\n   文件上的操作\n   <br/>\n   **检索**：在文件中寻找满足一定条件的记录\n   <br/>\n   **修改**：对记录中某些数据值进行修改。若对关键字进行修改，就相当于删除加插入。\n   <br/>\n   **插入**：向文件中增加一个新记录。\n   <br/>\n   **删除**：从文件中删去一个记录 。\n   <br/>\n   **排序**：对指定好的数据项，按其值的大小把文件中的记录排成序列。常用按关键\n   <br/>\n   <br/>\n   简称就是：增删改查排\n  </p>\n  <h3>\n   外部排序流程\n  </h3>\n  <div>\n   1.外部跑排序基本上由两个独立的过程来组成，第一个就是产生初始的有序的顺串\n  </div>\n  <div>\n   2.对有序的顺串进行归并操作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   所以通过这样的流程，我们大致可以将我们的外部排序的实践耗费分成大致的这样几个部分\n  </div>\n  <div>\n   1.内部排序生成初始顺串的时间耗费\n  </div>\n  <div>\n   2.外存信息读写的时间耗费\n  </div>\n  <div>\n   3.内部的归并的时间耗费\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   T = m*Tis + d*Tio + s*u*Tmg\n  </div>\n  <div>\n   上面的就是我们的外部排序的大致的时间耗费的一个表达式\n  </div>\n  <div>\n   1.其中m代表我们要形成m个初始的顺串，Tis代表我们对构成每一个初始的顺串选哟的内部排序的时间耗费\n  </div>\n  <div>\n   2.d代表我们的依次外存的读写的次数，Tio代表我们的外存的依次都写的时间的耗费\n  </div>\n  <div>\n   3.s代表我们的归并的趟数，u代表我们的趟需要的归并的次数，Tmg代表依次归并的时间耗费\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   从上面的表达式中，我们可以大致的看出我们的需要优化的要点在哪里，首先，我们的Tio的时间耗费非常的恐怖，所以说我们呢选哟尽可能遵顼上面体积的原则，尽可能的减少我们的外存的读写的次数，也就是说，我们需要降低d的大小\n  </div>\n  <div>\n   在这里，我们需要知道外部排序的外部读写的次数和我们的归并的趟数有关系，我们要尽可能的减少我们的归并的趟数\n   <strong>\n    h = log(m,k) k - 代表我们采取k路归并\n   </strong>\n  </div>\n  <div>\n   对于减小h的大小，我们需要增大k，减少m(意味着我们构建的初始顺串要尽可能的大)\n  </div>\n  <div>\n   在这里的话，我们的优化思路就出来了，我们可以采用多路归并的方式从而减少外部读写的次数，降低我们的时间耗费\n  </div>\n  <div>\n   对于我们的m来说，这和我们的内存的规模大小有关，我们招惹里就不再多余的考虑这个问题\n  </div>\n  <div>\n   我们这里需要另外一个知识要点就是我们的两种选择树和一种K-Haffman树来进行对我们的依次归并的时间的耗费的优化\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   选择树\n  </h2>\n  <div>\n   对于我们归并的操作，我们需要一些优化的数据结构来满足我们的相应的要求\n  </div>\n  <div>\n   首先我们先引入我们的归并操作的步骤\n  </div>\n  <div>\n   1.当归并序列的数目只有两组的时候\n  </div>\n  <div>\n   我们采用依次扫描的O(n)时间复杂度和O(n)的空间复杂度我们呢就可以实现我们的归并操作\n  </div>\n  <div>\n   或者我们采用另一种优化后的算法\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52155097?locationNum=6&amp;fps=1\' target=\'_blank\'>\n    Lantian的手摇算法讲解\n   </a>\n  </div>\n  <div>\n   手摇算法O(n)的时间复杂度以及O(1)的空间复杂度就可以完成我们的归并操作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.但是当我们的归并序列的组数非常的多的时候，我们上面已经讨论过了，归并的路数越多可能我们的外部读写的次数会降低很多，这里我们的多路归并的思路还是非常有必要的，但是如果我们还是采用之前的朴素的方法来进行比较的话，我们会发现，我们的比较次数会变得非常的冗杂，假设我们每次都要进行k录归并的划，依次比较需要O(k)才能得到结果，我们如果需要找到最终的归并序列，需要至少O(k*n)的归并次数，在归并路数非常答的情况下，无疑非常的麻烦且并且效率底下，这里我们的优化思路就出来了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3\n   <strong>\n    .选择树的优化思路\n   </strong>\n  </div>\n  <div>\n   我们会发现，我们之所以朴素的方法效率底下的原因在于，我们依次只能找出一个最有数据信息，但是下一次，我们的最优信息就会选哟我们重新进行重复的操作来得到\n  </div>\n  <div>\n   我们的选择树构建的思路就是，依次不仅仅将我们的最优的欣喜求解出来，我们还要在依次的操作中将我们的之后的次优的信息都保存下来，下一次，我们就可以是按尽可能的高效读取了\n  </div>\n  <div>\n   这里的选择书我们有两种情况，下面我们一一道来\n  </div>\n  <h2>\n   胜者树\n  </h2>\n  <div>\n   我们对胜者树进行定义：\n  </div>\n  <div>\n   1.胜者树是一颗完全二叉树\n  </div>\n  <div>\n   2.胜者树的叶子结点保存我们的一个输入缓冲区（一路归并顺序表）\n  </div>\n  <div>\n   3.胜者树的非叶子节点保存当前比较的胜者的输入缓冲区的指针\n  </div>\n  <div>\n   4.胜者树的根节点保存我们的胜者树当前的的一次比较中的冠军（最优值）\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.my.csdn.net/uploads/201210/15/1350310110_2414.jpg\'/>\n  </div>\n  <div>\n   现在我们来看一下胜者树的操作：\n  </div>\n  <div>\n   当我们将我们的胜者树的最优值输入到我们的\n   <strong>\n    输出缓冲区（输出缓冲区从内存中额外开辟出来的一段，我们存储当前的归并的结果，缓冲区满写入磁盘）\n   </strong>\n  </div>\n  <div>\n   之后，我们的根节点便出现了空的情况，我们需要从根节点对应的输入缓冲区中在读入一个数据来充当下一次比较的选手，然后从下到上进行维护，我们的每一次的维护都需要比较兄弟的胜者然后选出新一轮的胜者然后一直优化到我们的根的路径上（从低至上，贯穿整个树）\n  </div>\n  <div>\n   之后我们不断地进行上述的操作，指导我们的所有的输入缓冲区已经为空为止\n  </div>\n  <h2>\n   败者树\n  </h2>\n  <div>\n   我们通过上面的胜者树可以发现，我们的胜者数虽然相对于我们的之前的擦偶哦已经进行了很大程度上的优化，今本上已经达到了我们的O(k*logk)的实践复杂度\n  </div>\n  <div>\n   但是我们会注意到，我们每一次每个接待你都保存着我们的生者的信息而不是败者的信息\n  </div>\n  <div>\n   那么这个差别会对我们的实践效率有什么影响呢\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    下面这段解释非常的重要：\n   </strong>\n  </div>\n  <div>\n   我们会发现，我们的胜者树维护的时候每次都需要去查找我们的根的兄弟节点的位置来进行比较，但是我们的每一次都要多一步查找兄弟的划，无论是对我们的程序的实现过程还是我们的时间效率上来看都还存在改进的余地\n  </div>\n  <div>\n   这里我们就要引入败者树\n  </div>\n  <div>\n   <strong>\n    败者树的定义：\n   </strong>\n  </div>\n  <div>\n   1.败者树是一颗完全二叉树\n  </div>\n  <div>\n   2.败者树的叶子结点保存的是我我们的输入缓冲区\n  </div>\n  <div>\n   3.败者树的非叶子结点保存我们的当前的比较中败者的对应的输入缓冲区的指针\n  </div>\n  <div>\n   4.败者树根保存我们的当前比较的亚军，根上面还有一个节点保存我们的冠军\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.ph.126.net/3eGZA35Xo1MmXzVzsaoXAQ==/2651775755607958867.jpg\'/>\n  </div>\n  <div>\n   如图所示，那么对于我们的调整树的过程中，我们只需要和当前的跟对应的败者的输入缓冲区的之比较就ok，减少了我们依次比较次数，那么在树庞大的时候，我们扽优化效果是非常的明显的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   败者树 VS 堆\n  </h2>\n  <div>\n   我们在进行我们的败者树选取的时候，读者那面都会遇到我的这种问题，如果我们的败者树进行归并排序的话，我们的堆排序的思路和败者树比较的话谁优谁劣？\n  </div>\n  <div>\n   这里的话，我们还真不好描述这个问题的最终结果，但是我想，败者树存在是有它的实际意义的\n  </div>\n  <div>\n   <strong>\n    <em>\n     1.堆排序\n    </em>\n   </strong>\n  </div>\n  <div>\n   首先，一旦存在了堆排序的划，我们就无需构建输出缓冲区，内存这个题就可以充当输出缓冲区，我们只要将我们n数据量的数据进行归并排序就好，实践复杂度是O(n*logn)\n  </div>\n  <div>\n   优点：\n  </div>\n  <div>\n   无输出缓冲区，充分利用内存资源\n  </div>\n  <div>\n   时间复杂度优秀O(n*logn)\n  </div>\n  <div>\n   相对于败者树来说，我们往往不需要从根维护到底，在维护的路径中有可能直接就中断\n  </div>\n  <div>\n   缺点：\n  </div>\n  <div>\n   树庞大，我们的logn值相对于我们的k路数来说很巨大，树的深度较大\n  </div>\n  <div>\n   建堆时间耗费很高，我们的缓冲区内的数据已经实现了按块基本有序\n  </div>\n  <div>\n   我们的堆维护的时候，每一层至少需要比较两次，败者树只需要一次就可以\n  </div>\n  <div>\n   <strong>\n    <em>\n     2.败者树\n    </em>\n   </strong>\n  </div>\n  <div>\n   优点：\n  </div>\n  <div>\n   相对于堆来说，我们的树的规模很小，似的我们的时间复杂度在在实践中可能会平均状态下更加优秀\n  </div>\n  <div>\n   每次维护我们每一层只需要比较一次\n  </div>\n  <div>\n   缺点：\n  </div>\n  <div>\n   我们的败者树的维护过程中必须要从底一直维护到根，这个路径不能中断，我们的堆实际中调整的次数可能会更小\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   最后究竟谁胜还真不好比较，我会再次问老师以求解答\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   K-路最佳归并树\n  </h2>\n  <div>\n   上面的选择树中的败者树已经给我们的依次归并的实践效率给予了很好的优化，现在我们需要从另一个角度来考虑减少我们的外部读写的次数了\n  </div>\n  <div>\n   首先，我们需要了解到，我们的每个输入缓冲区的数据量都不一定是一样的，这意味着什么\n  </div>\n  <div>\n   这意味着我们的每一次的每个块的外部读写的次数是不一样，数据量大的外部读写次数相对高，数据量小的外部读写次数相对底\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么我们想到了什么？\n  </div>\n  <div>\n   没错，就是我们的最有二叉树 - Haffman树\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52472653?locationNum=1&amp;fps=1\' target=\'_blank\'>\n    Lantian的Haffman讲解\n   </a>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们想到的方向很对，K-路最佳归并树实质上就是K-Haffman数，我们的优化的ing一需求是尽量的让我们的数据量大的块读写次数少，数据量小的读写次数多，利用我在Haffman中的反证贪心法，这样构成的K-路最佳归并树无疑可以让我们的外部读写次数降到最低值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   K-路最佳归并树的思路：\n  </div>\n  <div>\n   1.挑选出K个权值（数据量）最小的缓冲区\n  </div>\n  <div>\n   2.缓冲区利用败者树进行一次归并操作，生成一个新的大的缓冲区，加入到我们的选择序列\n  </div>\n  <div>\n   3.重复上述的过程指导只剩下一个输入缓冲区，我们的归并操作结束，生成了有序的外部文件\n  </div>\n  <div>\n   <strong>\n    <br/>\n   </strong>\n  </div>\n  <div>\n   <strong>\n    上面的操作1我们为了提高时间效率通常使用堆来进行优化\n   </strong>\n  </div>\n  <div>\n   <strong>\n    <br/>\n   </strong>\n  </div>\n  <h2>\n   核心伪代码：\n  </h2>\n  <div>\n   1.堆\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2022966\' name=\'code\' snippet_file_name=\'blog_20161202_1_7947335\'>heap - array save the number of the data\nheapnum - the size of the heap\n\nsiftdown(i):\n    t\n    while i*2&lt;=heapnum:\n        if heap[i]&gt;heap[i*2]: t=i*2\n        else t=i\n        if i*2+1&lt;=heapnum and heap[i*2+1]&lt;heap[t]:  t=i*2+1\n        if i!=t:\n            swap(i,t)\n            i=t\n        else break\n\nsiftup(i):\n    while i!=1:\n        if heap[i]&lt;heap[i/2]:\n            swap(i,i/2)\n            i=i/2\n        else break\n\ncreat_heap(heapnum):\n    for i=heapnum/2 to 1:\n        siftdown(i)\n</pre>\n   <br/>\n   2.K-路最佳归并树\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'2022966\' name=\'code\' snippet_file_name=\'blog_20161202_2_3759450\'>m - the size of the K-Haffman\ndata[] - the size is m,the input cache,waited to merge\n\nK_Merge(data,m):\n    creat_heap(m)\n    while heapnum!=1:\n        help=[]   //保存k个选出的缓冲区序列\n        for i=1 to k:\n            help.append(pop())   //弹出堆顶并进行维护最小堆性质\n        Loser_Tree(help,k)</pre>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.败者树:\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'2022966\' name=\'code\' snippet_file_name=\'blog_20161202_3_9921011\'>data - the size is the k,the array wait to merge\nk - the size\nls - 非叶子节点，保存我们的输入缓冲区指针\nMIN - 最小值，在我们建树的时候用来辅助维护\nMAX - 我们维护的时候，为了防止出现一个缓冲区为空的情况，添加的哨兵\n\nLoser_Tree(data,k):\n    new_input //新的输入缓冲区，需要返回的结果\n    creat_Loser_Tree(data,k)\n    while data[ls[0]].top()!=MAX:\n        new_input.append(data[ls[0]].top)\n        data[ls[0]].pop()\n        Adjust(ls[0])   //调整\n\ncreat_Loser_Tree(data,k):\n    data[0].append(MIN)   //哨兵,辅助构建败者树\n    clear ls\n    for i=1 to k:\n        data[i].append(MAX)   //哨兵，辅助维护败者树\n    for i=k down to 1:\n        Adjust(i)\n\n\nAdjust(int root):\n    father = root /2\n    winner = root\n    t = root\n    while t!=0:   //0是要维护到败者树的最顶端\n        if win:\n            swap(winner,loser)\n   ls[0]=winner      \n        </pre>\n  <h2>\n   <br/>\n   C++ Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2022966\' name=\'code\' snippet_file_name=\'blog_20161202_4_825301\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'algorithm\'\n#define N 1005\n#define INF 0x3fffffff\n#define MIN -INF\n\n/*\n利用OOP思路 构建cache高速缓存类 在不考虑内存容量的前提下 模拟最佳归并树，败者树 \ncache内利用栈模拟 \n*/\n\nusing namespace std;\n\nclass Empty_Error{}; \n\nclass cache   //模拟高速缓存 \n{\n	public:\n	    cache()\n		{\n			head=1;\n			memset(stack,0,sizeof(stack));\n			tail=1;\n		} \n		inline int top()\n		{\n			try\n			{\n				if(empty()) throw Empty_Error();\n				else return stack[head];\n			}\n			catch(Empty_Error x)\n			{\n				cout&lt;&lt;\'try to get the element from an empty cache!\'&lt;&lt;endl; \n			}\n		}\n		inline void pop()\n		{\n			try\n			{\n				if(empty()) throw Empty_Error();\n				else head++;\n			}\n			catch(Empty_Error x)\n			{\n				cout&lt;&lt;\'try to pop the element from an empty cache!\'&lt;&lt;endl; \n			}\n		}\n		inline int size()\n		{\n			return tail-head;\n		}\n		inline bool empty()\n		{\n			if(head == tail) return true;\n			else return false;\n		}\n		inline bool full()\n		{\n			if(tail &gt;= N) return true;\n			else false;\n		}\n		inline void append(int x)   //添加数据项接口 \n		{\n			stack[tail++]=x;\n		}\n	private:\n		int head;\n		int tail;\n		int stack[N];   \n};\n\ncache test[1005];\nint heapnum;\nint k;\nint m;\n\nvoid jiaohuan(int i,int t)\n{\n	cache p=test[i];\n	test[i]=test[t];\n	test[t]=p;\n}\n\nvoid sift_down(int i)\n{\n	int t;\n	while(i*2&lt;=heapnum)\n	{\n		if(test[i*2].size() &lt; test[i].size()) t=i*2;\n		else t=i;\n		if(i*2+1 &lt;= heapnum &amp;&amp; test[i*2+1].size() &lt; test[t].size()) t=i*2+1;\n		if(i != t)\n		{\n			jiaohuan(i,t);\n			i=t;\n		}\n		else break;\n	}\n} \n\nvoid sift_up(int i)\n{\n	int t;\n	while(i!=1)\n	{\n		if(test[i].size() &lt; test[i/2].size())\n		{\n			int k=i/2;\n			jiaohuan(i,k);\n			i=i/2;\n		}\n		else break;\n	}\n}\n\nvoid creat_heap(int num)\n{\n	for(int i=(num&gt;&gt;1);i&gt;=1;i--)\n	{\n		sift_down(i);\n	}\n}\n\nvoid Adjust_tree(int start,int ls[],cache* queue)\n{\n	int winner=start;\n	int t=(start+k-1)/2;\n	while(t!=0)\n	{\n		int a=queue[winner].top();\n		int b=queue[ls[t]].top();\n		if(a &gt; b)\n		{\n			int loser=winner;\n			winner=ls[t];\n			ls[t]=loser;\n		}\n		t=t/2;\n	}\n	ls[0]=winner;\n}\n\nvoid creat_Loser_tree(int ls[],cache* queue)\n{\n	for(int i=1;i&lt;N;i++) ls[i]=0;\n	for(int i=1;i&lt;=k;i++) queue[i].append(INF);   //加入最大项辅助维护败者树 \n	queue[0].append(MIN);   //插入min项，辅助构造败者树,这里的模板性质被破坏了，再深入考虑一下 \n	for(int i=k;i&gt;=1;i--)\n	{\n		Adjust_tree(i,ls,queue);\n	} \n}\n\ncache K_merge(cache* queue,int k)\n{\n    cache ans;\n	int ls[N];    //实际上只需要2*k+1的辅助空间  \n	creat_Loser_tree(ls,queue);\n	while(queue[ls[0]].top()!=INF)\n	{\n		ans.append(queue[ls[0]].top());\n		queue[ls[0]].pop();\n		Adjust_tree(ls[0],ls,queue);\n	}\n	return ans;\n}\n\nint main()   //测试入口 \n{\n	printf(\'决定K-路归并:\');\n	scanf(\'%d\',&amp;k);\n	printf(\'决定块数:\');\n	scanf(\'%d\',&amp;m);\n	int b=k-(m-1)%(k-1)-1;\n	int NUM = b+m;\n	heapnum = NUM;\n	\n	for(int i=1;i&lt;=m;i++)\n	{\n		int x;\n		int y;\n		printf(\'初始化高速缓存%d\n\',i);\n		printf(\'缓存容量:\n\');\n		scanf(\'%d\',&amp;x);\n		for(int j=1;j&lt;=x;j++)\n		{\n			scanf(\'%d\',&amp;y);\n			test[i].append(y);\n		 } \n    }\n	\n	creat_heap(NUM);\n	\n	cache Loser_tree[k+5];\n	for(int i=1;i&lt;=NUM;i *= k)\n	{\n		for(int j=1;j&lt;=k;j++)   //获取归并序列 \n		{\n			Loser_tree[j] = test[1];\n			test[1]=test[heapnum--];\n			sift_down(1);\n		} \n		cache ans=	K_merge(Loser_tree,k);\n		test[heapnum+1]=ans;\n		heapnum++;\n		sift_up(heapnum); \n	} \n	\n	//测试输出\n	while(!test[1].empty())\n	{\n		cout&lt;&lt;test[1].top()&lt;&lt;\' \';\n		test[1].pop();\n	} \n	cout&lt;&lt;endl;\n	return 0;\n}</pre>\n   <br/>\n  </div>\n  <h2>\n   遗留问题以及鸣谢：\n  </h2>\n  <div>\n   1.感谢屈老师的课件\n  </div>\n  <div>\n   2.\n   <a href=\'https://my.oschina.net/liudiwu/blog/387280\' target=\'_blank\'>\n    https://my.oschina.net/liudiwu/blog/387280\n   </a>\n  </div>\n  <div>\n   3.\n   <a href=\'https://segmentfault.com/q/1010000000315760\' target=\'_blank\'>\n    https://segmentfault.com/q/1010000000315760\n   </a>\n  </div>\n  <div>\n   4.《数据结构》 - 严老师\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   1.C++代码的模板类型 - 存在毛病\n  </div>\n  <div>\n   2.败者树和堆的效率比较\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b81bc3c773cf39cbf1de30d92402e756','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1062 - 昂贵的聘礼 - 经典题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   中文题不说什么了\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题的难点有两个\n  </div>\n  <div>\n   1.建图\n  </div>\n  <div>\n   2.限制\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   建图：\n  </div>\n  <div>\n   首先，我们需要明确本图G是一个有向图，我们的顶点代表庙我们的物品的编号，图采用邻接矩阵存储，我们的图中的邻接矩阵中存储我们的便宜价格这样的话，我们每个点只要在限制条件下都可以找到1点，那么我们就取到达1点的最小值当作我们的答案\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   限制：\n  </div>\n  <div>\n   本体的限制说的很明确，但是我们如何处理我们的限制确实非常的苦难，网上的大神采用了区间枚举的思路，我们对SPFA进行操作的时候，我们的松弛百年志松驰在限制区间范围的边才可以\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   另外，通过本体需要学会一种叫做超级源点的思路，我们的0视作超级源点，该点和其他的点之间的都有连边，连边的长度大小是我们的该点除的物品的权值，超级源点的思路非常的有用\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2018472\' name=\'code\' snippet_file_name=\'blog_20161130_1_5999090\'>/*\nProblem: 1062		User: lantianheyeqi\nMemory: 240K		Time: 32MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cmath\'\n#define N 0x3f3f3f3f\n\nint n,m;\nint map[105][105];\nint l[105];\n\nvoid init_map()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(i!=j) map[i][j]=N;\n			else map[i][j]=0;\n		}\n	}\n}\n\nint SPFA(int j,int k)\n{\n	int queue[100*100];\n	int head=1;\n	int tail=2;\n	bool book[105];\n	memset(book,0,sizeof(book));\n	book[0]=1;\n	queue[1]=0;\n	int dis[105];\n	for(int i=1;i&lt;=n;i++) dis[i]=N;\n	dis[0]=0;\n	while(head!=tail)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(l[i] &lt; j || l[i] &gt; k) continue;\n			if(dis[i] &gt; dis[queue[head]]+map[queue[head]][i])\n			{\n				dis[i] = dis[queue[head]]+map[queue[head]][i];\n				if(book[i]==0)\n				{\n					book[i]=1;\n					queue[tail++]=i;\n				}\n			}\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n	return dis[1];\n}\n\nint main()\n{\n	scanf(\'%d%d\',&amp;m,&amp;n);\n	init_map();\n	for(int i=1;i&lt;=n;i++)\n	{\n		int x,y,z;\n		scanf(\'%d%d%d\',&amp;x,&amp;y,&amp;z);\n		map[0][i]=x;\n		l[i]=y;\n		for(int j=1;j&lt;=z;j++)\n		{\n			int number,money;\n			scanf(\'%d%d\',&amp;number,&amp;money);\n			map[number][i]=money;\n		}\n	}\n	int mink=N;\n	for(int i=l[1]-m;i&lt;=l[1];i++)\n	{\n		int w=SPFA(i,i+m);\n		if(w&lt;mink) mink=w;\n	}\n	printf(\'%d\n\',mink);\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2ad576284c05deddc5b198e36f52ad41','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1860 - SPFA - 正权回路\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    我们的城市有几个货币兑换点。让我们假设每一个点都只能兑换专门的两种货币。可以有几个点，专门从事相同货币兑换。每个点都有自己的汇率，外汇汇率的A到B是B的数量你1A。同时各交换点有一些佣金，你要为你的交换操作的总和。在来源货币中总是收取佣金。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    例如，如果你想换100美元到俄罗斯卢布兑换点，那里的汇率是29.75，而佣金是0.39，你会得到（100 - 0.39）×29.75＝2963.3975卢布。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    你肯定知道在我们的城市里你可以处理不同的货币。让每一种货币都用唯一的一个小于N的整数表示。然后每个交换点，可以用6个整数表描述：整数a和b表示两种货币，a到b的汇率，a到b的佣金，b到a的汇率，b到a的佣金。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    nick有一些钱在货币S，他希望能通过一些操作（在不同的兑换点兑换），增加他的资本。当然，他想在最后手中的钱仍然是S。帮他解答这个难题，看他能不能完成这个愿望。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     输入数据：\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    第一行四个数，N，表示货币的总数；M，兑换点的数目；S，nick手上的钱的类型；V，nick手上的钱的数目；1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V 是一个实数 0&lt;=V&lt;=10\n    <sup>\n     3\n    </sup>\n    .\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    接下来M行，每行六个数，整数a和b表示两种货币，a到b的汇率，a到b的佣金，b到a的汇率，b到a的佣金（0&lt;=佣金&lt;=10\n    <sup>\n     2\n    </sup>\n    ，10\n    <sup>\n     -2\n    </sup>\n    &lt;=汇率&lt;=10\n    <sup>\n     2\n    </sup>\n    ）\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     输出数据：\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    如果nick能够实现他的愿望，则输出YES，否则输出NO。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     样例输入：\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    3 2 1 20.0\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    1 2 1.00 1.00 1.00 1.00\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    2 3 1.10 1.00 1.10 1.00\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     样例输出\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    YES\n   </p>\n   <h2>\n    2.Solution:\n   </h2>\n  </div>\n  <div>\n   求解图的正权回路的标准问题\n  </div>\n  <div>\n   我们求解图的负权回路的时候利用的是边的松弛操作和SPFA的回路判断（一个点入队超过点数）\n  </div>\n  <div>\n   我们求解图的政权回路的时候利用的是边的放大操作和SPFA的回路判断（一个点入队超过点数）\n  </div>\n  <div>\n   核心在于SPFA算法在出现回路的时候如果不加限定会导致无限的入队，这样的话，我们可以根据我们的入队次数来判断的图中是否存在环\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2016022\' name=\'code\' snippet_file_name=\'blog_20161129_1_7375063\'>/*\nProblem: 1860		User: lantianheyeqi\nMemory: 396K		Time: 0MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdio\'\n#define N 105\n\nusing namespace std;\n\nint n,m,s;\ndouble v;\ndouble cost[N][N];\ndouble change[N][N];\n\nbool SPFA()\n{\n	int queue[N*N];\n	int head=1;\n	int tail=2;\n	bool book[N];\n    double dis[N];\n    int num[N];\n    memset(book,0,sizeof(book));\n    memset(num,0,sizeof(num));\n    num[s]=1;\n    queue[1]=s;\n    book[s]=1;\n    memset(dis,0,sizeof(dis));\n    dis[s]=v;\n    while(head!=tail)\n    {\n    	for(int i=1;i&lt;=n;i++)\n    	{\n    		if(dis[i] &lt; (dis[queue[head]]-cost[queue[head]][i])*change[queue[head]][i])\n    		{\n    			dis[i] = (dis[queue[head]]-cost[queue[head]][i])*change[queue[head]][i];\n    			if(book[i]==0)\n    			{\n    				num[i]++; \n    				book[i]=1;\n    				if(num[i]&gt;n) return true;\n    				queue[tail++]=i;\n    			}\n    		}\n    	}\n    	book[queue[head]]=0;\n    	head++;\n    }\n    return false;\n}\n\nint main()\n{\n	scanf(\'%d%d%d%lf\',&amp;n,&amp;m,&amp;s,&amp;v);\n	memset(change,0,sizeof(change));\n	memset(cost,0,sizeof(cost));\n	for(int i=1;i&lt;=m;i++)\n	{\n		int x,y;\n		double change_x_y;\n		double cost_x_y;\n		double change_y_x;\n		double cost_y_x;\n		scanf(\'%d%d%lf%lf%lf%lf\',&amp;x,&amp;y,&amp;change_x_y,&amp;cost_x_y,&amp;change_y_x,&amp;cost_y_x);\n		cost[x][y]=cost_x_y;\n		change[x][y]=change_x_y;\n		cost[y][x]=cost_y_x;\n		change[y][x]=change_y_x; \n	} \n	bool judge=SPFA();\n	if(judge) printf(\'YES\n\');\n	else printf(\'NO\n\');\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4e130028642ed99aacf65a292703578c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2240 - SPFA - 正权环（最大路）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   输入n代表有n个国家\n  </div>\n  <div>\n   之后的n行代表n个国家的名称\n  </div>\n  <div>\n   输入m代表有向边的个数\n  </div>\n  <div>\n   之后的代表我们国家货币之间的汇率\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   现在求，是否存在一条回路是的我们的交换货币之后原本的货币量增多\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题是标准的判断回路的问题，我们需要将最短路的标准思路转变一下，首先，本题我们需要找到的是正权回路不是负权回路，我们只需要改变一下松弛策略就好，我们只要将松弛策略改成放大策略就ok，判断点进入队列的次数书否超过点数（这里有个问题，等于可以吗）\n  </div>\n  <div>\n   当然我们的Floyed算法也是可以的，我们的Floyed算法只需要判断我们的是否出现最后是否货币量比1大就好了\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2014478\' name=\'code\' snippet_file_name=\'blog_20161129_1_7105108\'>/*\nProblem: 2240		User: lantianheyeqi\nMemory: 376K		Time: 47MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstring\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define N 35\n\nusing namespace std;\n\ndouble dis[N];\ndouble map[N][N];\nint n,m;\nchar nation[35][500];\n\nint find(char data[])\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		if(strcmp(nation[i],data)==0) return i;\n	}\n}\n\nbool SPFA()\n{\n	memset(dis,0,sizeof(dis));\n	int queue[N*N*N];\n	int head=1;\n	int tail=2;\n	int num[N];\n	memset(num,0,sizeof(num));\n	bool book[N];\n	memset(book,0,sizeof(book));\n	queue[1]=1;\n	book[1]=1;\n	dis[1]=1;\n	num[1]=1;\n	while(head!=tail)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(dis[i] &lt; dis[queue[head]]*map[queue[head]][i])\n			{\n				dis[i] = dis[queue[head]]*map[queue[head]][i];\n				if(book[i] == 0)\n				{\n					book[i]=1;\n					queue[tail++]=i;\n					num[i]++;\n					if(num[i] &gt; n) return true;\n				}\n			}\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n	return false;\n}\n\nint main()\n{\n	int t=1;\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n!=0)\n	{\n		memset(map,0,sizeof(map));\n		for(int i=1;i&lt;=n;i++) scanf(\'%s\',nation[i]);\n		scanf(\'%d\',&amp;m);\n		double edge;\n		char n1[500];\n		char n2[500];\n		int flag=0;\n		for(int i=1;i&lt;=m;i++) \n		{\n			scanf(\'%s %lf %s\',n1,&amp;edge,n2);\n			int index1 = find(n1);\n    		int index2 = find(n2);\n	    	map[index1][index2] = edge ;\n	    	if(index1 == index2 &amp;&amp; edge &gt; 1) \n	    	{\n	    		printf(\'Case %d: Yes\n\',t++);\n	    		flag=1;\n	    		break;\n	    	}\n		}\n		if(flag == 1) continue;\n		bool judge = SPFA();\n		if(judge) printf(\'Case %d: Yes\n\',t++);\n		else printf(\'Case %d: No\n\',t++);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b3a46a0d112423f46a3563a50e215f43','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  关于快速排序算法本质的重要说明 - 考试考了不会就不要怪我\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   说明，本文章的针对已经大致的理解了快速排序的同学\n  </p>\n  <h2>\n   双向扫描 VS 单向扫描\n  </h2>\n  <div>\n   我们都知道，快速排序算法存在两种实现机制，一种是单向扫描法，一种是优化后的双向扫描法\n  </div>\n  <h3>\n   单向扫描：\n  </h3>\n  <div>\n   首先，我们需要知道，单向扫描是最正规的《算法导论》上给出的基本实现的过程\n  </div>\n  <div>\n   伪代码如下\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2014055\' name=\'code\' snippet_file_name=\'blog_20161128_1_8008532\'>data - array wait to sort\nn - the count of the array\ni - head point\nj - tail point\n\nquicksort (left,right)\n    if left&gt;=right return \n    else\n        partition(left,mid,right)   //引用传址\n        quicksort(left,i-1)\n        quicksort(i+1,right)\n        return\n\npartition (left,mid,right)\n    i=j=left-1\n    temp = data[right]\n    for j to right-1\n        if data[j]&lt;temp\n            t = data[i+1]\n            data[++i] = data[j]\n            data[j] = t\n    t = data[right]\n    data[right] = data[i+1]\n    data[i+1] = t</pre>\n   在单向扫描的过程中，我们的枢纽点选定的就是最后一个元素（随机化的过程我们只需要一步就是将我们的选取的枢纽点迁移到最后的 位置，没有什么多余的影响）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <h3>\n    双向扫描：\n   </h3>\n   <div>\n    双向扫描的伪代码：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'2014055\' name=\'code\' snippet_file_name=\'blog_20161128_2_4181285\'>data - array wait to sort\nn - the count of the array\ni - head point\nj - tail point\n//先动头指针的情况，之后会详细说明\nquicksort (left,right)\n    if left&gt;=right return\n    else\n        i = left\n        j = right\n        temp = data[left]\n        while i!=j\n            while i&lt;j and temp&lt;=data[j] j--\n            while i&lt;j and temp&gt;=data[i] i++\n            if i!=j swap(i,j)\n        swap(i,left)\n        quicksort(left,i-1)\n        quicksort(i+1,right)\n        return </pre>\n    <br/>\n   </div>\n   <h3>\n    比较和注意事项\n   </h3>\n   1.效率：\n  </div>\n  <div>\n   首先，我们来关注一下，那一个的效率更加的优秀\n  </div>\n  <div>\n   对于双向扫描的单向扫描的流程我们会发现，对于对于所有比枢纽点小的元素我们都要进行一次swap操作，但是双向扫描不一样，我们会发想，双向扫描对并不是对所有的小于枢纽点的元素都进行了swap操作，真是这一点，导致我们的双向扫描的效率高于单向扫描，我的上一篇的博客用Python对两种扫描方式进行了实验发现，实际上双向扫描确实比单向扫描快很多\n  </div>\n  <div>\n   本轮：双向扫描 better than 单向扫描\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.算法的细节\n  </div>\n  <div>\n   我们这里需要着重分析一下，对于不同的情况，我们的双向扫描的枢纽点的选取非常的重要（枢纽点的选取直接影响到我们的头尾指针的次序关系）\n  </div>\n  <div>\n   首先，我们先来假设一段序列经过快速排序的一次partition划分之后枢纽点的位置是i，如下简图所示\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2014055\' name=\'code\' snippet_file_name=\'blog_20161128_3_6657303\'>0 1 2 3 4 . . . . . . i . . . . . . n</pre>\n   那么我们的枢纽点在没有划分之前的位置 j 有很大的不同（下面解释利用升序排列，降序排列同理不用证明）\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   1. j &lt; i\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   在这时候，我们必须要先动尾指针\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   原因如下：\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   正面解释：我们先动尾指针可以保证我们最后尾指针停止的点处的元素的值一定是比枢纽点小（分两种情况，如果我们直接找到一个比枢纽点小的元素（没有强制终止，头尾指针不同）那么必定比枢纽点小，如果一直找到头尾指针相同的时候强制终止，这时候，因为上次的交换保证我们的此处的点的值必定比我们的枢纽点小）这时候我们进行最后的交换的时候，可以保证我们的枢纽点左边的元素都比枢纽点小，右边的元素都比枢纽点大，正确\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   反面解释：我们如果采用头指针先动的话，按照上面的描述过程，我们的乳沟在最后头尾指针强制终止的时候必定导致我们的最后一次交换之后，枢纽点右边的元素都比枢纽点大，但是左边存在一个数比我们的枢纽点大（这个书就是我们的强制头尾指针相遇的位置处的元素值，这个值必定比枢纽点大），错误\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2. j &gt; 1\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   解释和上面的是镜像的关系，很好证明\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   针对于单向扫描的时候，我们只需要将枢纽点和最后一个位置的元素进行交换就可以了\n  </div>\n  <div>\n   其实上面的双向扫描的这个缺点，在我们的随机化的挑选枢纽点的位置的时候，我们可以预处理将我们的枢纽点强制的放在第一个或者最后一个（这样可以保证我们采用先头指针动或者先尾指针动的选择方案）\n  </div>\n  <div>\n   本轮：单向扫描 &gt; 双向扫描\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1ca6558d299fc12b750ece36c19c2516','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Shell-Sort 增量排序算法 总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Shell - Sort\n  </h2>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    希尔排序(Shell Sort)是插入\n   </span>\n   <a href=\'http://baike.so.com/doc/5381751.html\' style=\'color:rgb(19,110,194); text-decoration:none; font-family:arial,sans-serif; font-size:14px; line-height:24px\' target=\'_blank\'>\n    排序\n   </a>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    的一种。是针对直接插入排序\n   </span>\n   <a href=\'http://baike.so.com/doc/2758411.html\' style=\'color:rgb(19,110,194); text-decoration:none; font-family:arial,sans-serif; font-size:14px; line-height:24px\' target=\'_blank\'>\n    算法\n   </a>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    的改进。该方法又称缩小\n   </span>\n   <a href=\'http://baike.so.com/doc/5430695.html\' style=\'color:rgb(19,110,194); text-decoration:none; font-family:arial,sans-serif; font-size:14px; line-height:24px\' target=\'_blank\'>\n    增量\n   </a>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    排序，因DL．Shell于1959年\n   </span>\n   <a href=\'http://baike.so.com/doc/1534298.html\' style=\'color:rgb(19,110,194); text-decoration:none; font-family:arial,sans-serif; font-size:14px; line-height:24px\' target=\'_blank\'>\n    提出\n   </a>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    而得名。\n   </span>\n   <br/>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    我们都知道直接插入排序算法是相对来说比较低效的算法，但是正是插入排序算法的特性决定了我们在数据量小的时候，数据基本有序的时候的排序效果往往比一些高级排序算法构架行之有效，更加快速\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    在我们开始了解Shell-Sort算法之前，我们先来复习一下插入排序算法\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    在这里我们先给出插入排序的伪代码：\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'2011949\' name=\'code\' snippet_file_name=\'blog_20161127_1_6013782\'>data - the array wait to sort\nn - the count of the elements of the array\n//本伪代码针对升序排列\nfor i=2 to (n-1)\n    temp = data[i]\n    j=i-1\n    while j&gt;=0 and temp&lt;data[j]   //这里不加等号保证排序的稳定性\n        data[j+1]=data[j]\n        j--\n    data[j+1]=temp</pre>\n   <br/>\n   从上面我们可以看出，直接插入排序算法的在我们的数组基本有序的时候复杂度非常的高效，但是一旦出现了杂糅的情况我们的耗时就非常的大，基本在O(n^2)的时间复杂度水平\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    我们注意到，我们的直接插入排序算法的效率低下的原因在于我们每次找到我们的带插入的位置后，我们都需要遍历这个位置的路径，大致我们的交换次数变得非常的冗长\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px; line-height:24px\'>\n    所以，聪明的Shell就想到了一种非稳定的基于直接插入排序算法的高效的排序算法，也就是大名鼎鼎的  Shell - Sort\n   </span>\n  </div>\n  <h2>\n   2.Shell - Sort 的原理\n  </h2>\n  <div>\n   我们先引出我们的优化的机理，我们对于直接插入排序的优化基于一点就是 - 直接插入排序在基本有序的时候插入效率非常的高效，所以说我们的优化的核心就浮出水面了\n  </div>\n  <div>\n   我们不断的令待排数组的的有序度上升，让数组的有序性逐步增加，每一次我们优化之后，数组都变得更加相对的有序，这时候下一次的插入排序的效率就会变得更加的高效\n  </div>\n  <div>\n   在这里，机智的科学家发明了Shell -Sort，也就是增量排序的想法来处理这个问题\n  </div>\n  <div>\n   我们每次选择一个增量，保证一个增量范围内的数组都是有序的，我们不断缩小我们的增量直到1，这是后我们最后增量位1的过程就相当于是一个直接插入排序，但是之前的操作已经保证我们的数组已经非常的有序，我们的最后的直接插入排序的过程的时间复杂度也变得非常的高效\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   每一个Shell - Sort需要几趟，每一趟都相当于一次断层的直接插入排序，如图所示\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://images2015.cnblogs.com/blog/318837/201604/318837-20160422102024757-37862627.png\'/>\n   <br/>\n  </div>\n  <h2>\n   3.Shell - Path的选择\n  </h2>\n  <div>\n   现在的事实已经证明了，希尔排序的核心在于我们的增量的选取，我们的增量选取要求最后都是要归终与一个为1的增量上\n  </div>\n  <div>\n   但是不同的选取导致我们的希尔排序的效率是不一样的\n  </div>\n  <div>\n   实践证明了有很多非常优秀的步长选择方案是的我们的希尔排序在中小规模上的排序时间效率甚至超过了快速排序\n  </div>\n  <div>\n   <p align=\'left\'>\n    步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。\n   </p>\n   <p align=\'left\'>\n    算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。\n    <br/>\n    Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就\n   </p>\n   <p align=\'left\'>\n    不会以如此短的时间完成排序了。\n   </p>\n   <table border=\'1\' cellpadding=\'0\' cellspacing=\'0\' style=\'color:rgb(0,0,0)\'>\n    <thead>\n     <tr>\n      <td>\n       <p align=\'left\'>\n        步长序列\n       </p>\n      </td>\n      <td>\n       <p align=\'left\'>\n        最坏情况下复杂度\n       </p>\n      </td>\n     </tr>\n    </thead>\n    <tbody>\n     <tr>\n      <td nowrap=\'nowrap\'>\n       <p align=\'left\'>\n        <img alt=\'\' src=\'http://images2015.cnblogs.com/blog/318837/201604/318837-20160422102025601-754434296.png\'/>\n       </p>\n      </td>\n      <td>\n       <p align=\'left\'>\n        <img alt=\'\' src=\'http://images2015.cnblogs.com/blog/318837/201604/318837-20160422102026195-1967182697.png\'/>\n        <img alt=\'\' src=\'http://images2015.cnblogs.com/blog/318837/201604/318837-20160422102026445-1387890072.png\'/>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td nowrap=\'nowrap\'>\n       <p align=\'left\'>\n        <img alt=\'\' src=\'http://images2015.cnblogs.com/blog/318837/201604/318837-20160422102027023-263403088.png\'/>\n       </p>\n      </td>\n      <td>\n       <p align=\'left\'>\n        <img alt=\'\' src=\'http://images2015.cnblogs.com/blog/318837/201604/318837-20160422102027632-511063615.png\'/>\n        <img alt=\'\' src=\'http://images2015.cnblogs.com/blog/318837/201604/318837-20160422102028320-2034939374.png\'/>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td nowrap=\'nowrap\'>\n       <p align=\'left\'>\n        (3**(t-k)-1)/2\n       </p>\n      </td>\n      <td>\n       <p align=\'left\'>\n        待查\n       </p>\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <p align=\'left\'>\n    <strong>\n     已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)，该序列的项来自\n    </strong>\n   </p>\n   <p align=\'left\'>\n    <strong>\n     9*4^i-9*2^i+1 或者是 4^i-3*2^i+1\n     <span style=\'font-size:12px\'>\n      这两个算式。\n     </span>\n    </strong>\n   </p>\n   <p align=\'left\'>\n    这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。\n   </p>\n   <p align=\'left\'>\n    希尔排序的伪代码如下：\n   </p>\n   <p align=\'left\'>\n   </p>\n   <pre class=\'cpp\' code_snippet_id=\'2011949\' name=\'code\' snippet_file_name=\'blog_20161127_2_5218177\'>data - array wait to sort\nn - the count of the array\ndlta - the array save the dlta_path\nfor path=0 to length_dlta\n    for i=path to n   //一趟分段直接插入排序\n        temp = data[i]\n        j=i-path\n        while j&gt;=0 and temp&lt;data[j]\n            data[j+path]=data[j]\n            j-=path\n        data[j+path]=temp</pre>\n   <h2>\n    3.Code of Python\n   </h2>\n   <div>\n    <pre class=\'python\' code_snippet_id=\'2011949\' name=\'code\' snippet_file_name=\'blog_20161127_3_6581380\'>from random import*\nfrom time import*\nfrom math import*\ndef shell_sort_0(data,n):\n    time=clock()\n    path=int(n/2);\n    while path:\n        i=path\n        while i&lt;n:\n            temp=data[i]\n            j=i-path\n            while j&gt;=0 and temp&lt;data[j]:\n                data[j+path]=data[j]\n                j-=path\n            data[j+path]=temp\n            i+=1\n        path=int(path/2)\n    return clock()-time\n\ndef init_data(data,n):\n    for i in range(n):\n        data.append(randint(1,100000))\n        \ndef make_dlta(dlta,n):\n    t=(int)(log(2*n+1,3))\n    for i in range(t):\n        dlta.append((int)(0.5*(3**(t-i)-1)))\n\ndef shell_sort_1(dlta,data,n):\n    time=clock()\n    for path in dlta:\n        i=path\n        while i&lt;n:\n            temp=data[i]\n            j=i-path\n            while j&gt;=0 and temp&lt;data[j]:\n                data[j+path]=data[j]\n                j-=path\n            data[j+path]=temp\n            i+=1\n    return clock()-time\n\ndata=[]\nn=eval(input(\'请输入数据量:\'))\ninit_data(data,n)\np=[]\ndlta=[]\n\np=[i for i in data]\nprint(\'-----------\')\nprint(\'time:%lf\'%(shell_sort_0(p,n)))\n\np=[i for i in data]\nmake_dlta(dlta,n)\nprint(\'-----------\')\nprint(\'time:%lf\'%(shell_sort_1(dlta,p,n)))\n\ntime=clock()\np.sort()\nprint(\'time:%lf\'%(clock()-time))\n</pre>\n    通过实验数据发现，我们的表格的第三种希尔排序的效率比我们的希尔最早提出的二分的鞥两还有更优\n   </div>\n   <div>\n    实际上，我们的希尔排序的步长选择的最优解实际上现在还是一个数学难题，我们目前只是找到了最好的解，但并不是说我们找到了最优的步长选择方案\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    实际上，因为希尔排序的常数因子的问题，在中小规模的时候，我们的希尔排序甚至比我们的快速排序还要更加的优秀，但是一旦数据量增大，我们也无能为力，只要采用O(n*logn)的效率的算法来进行优化\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    专家们建议：任何一个容许不稳定的排序任务我们都可以通过先用希尔排序的策略，一旦我们发现该问题还可以再度优化，我们再切换成更加高效的排序算法\n   </div>\n   <p>\n   </p>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('21b6fef885152db6ee3b7d3270cd24dd','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ 99 - 欧拉图 单词拼接\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold; font-family:Tahoma,Arial,sans-serif,simsun\'>\n    描述\n   </dt>\n   <dd style=\'margin:0px; padding:0px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     给你一些单词，请你判断能否把它们首尾串起来串成一串。\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     前一个单词的结尾应该与下一个单词的道字母相同。\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     如\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     aloha\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     dog\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     arachnid\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     gopher\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     tiger\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     rat\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     可以拼接成：\n     <span style=\'font-family:\'Courier New\',Courier,monospace; line-height:normal; font-size:16px; white-space:pre; border-spacing:2px\'>\n      aloha.arachnid.dog.gopher.rat.tiger\n     </span>\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n    </p>\n    <div class=\'clr\' style=\'clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n    </div>\n    <dl class=\'others\' style=\'margin:0px; padding:0px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      第一行是一个整数N(0&lt;N&lt;20)，表示测试数据的组数\n      <br/>\n      每组测试数据的第一行是一个整数M,表示该组测试数据中有M(2&lt;M&lt;1000)个互不相同的单词，随后的M行，每行是一个长度不超过30的单词,单词全部由小写字母组成。\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      如果存在拼接方案，请输出所有拼接方案中字典序最小的方案。(两个单词之间输出一个英文句号\'.\')\n      <br/>\n      如果不存在拼接方案，则输出\n      <br/>\n      ***\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_input\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>2\n6\naloha\narachnid\ndog\ngopher\nrat\ntiger\n3\noak\nmaple\nelm</pre>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_output\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>aloha.arachnid.dog.gopher.rat.tiger\n***</pre>\n     </dd>\n    </dl>\n    <h2>\n     2.Solution:\n    </h2>\n   </dd>\n  </div>\n  <div>\n   本题如果处理不当的话，非常容易造成TLE\n  </div>\n  <div>\n   首先，本题我们需要对题目进行抽象\n  </div>\n  <div>\n   我们将每个单词看作是一条边，单词的首字符和尾字符看作是边的起点和终点，这里我们就可以抽象出一个有26个顶点的稠密图，因为题目声明了图的稠密程度达到了1005:26所以说，在这里邻接矩阵的存储思路已经不再适用，我们需要利用邻接表来存储\n  </div>\n  <div>\n   并且，题目声明了搜索的顺序是边（和顶点）的字典序输出，所以本题我们需要利用strcmp函数来辅助构建有顺序的邻接表\n  </div>\n  <div>\n   PS：本题TLE很可能是因为没有考虑很多的特殊情况\n  </div>\n  <div>\n   1.入度与出度相差大不止1，造成TLE\n  </div>\n  <div>\n   2.不考虑回路的问题造成TLE\n  </div>\n  <div>\n   3.本日我给每条边加上了lazy标记，防止我搜索的时候进行重复搜索从而出现TLE或者WA的情况\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   有向图存在欧拉通路的充分必要条件：\n  </div>\n  <div>\n   有向图中只存在两个点的出度和入度相差位1，且相差情况刚好相反，其他点的入度和出度相等\n  </div>\n  <div>\n   并且欧拉通路存在之时，我们的通路的起点必定是入度小的那个点，终点必定是出度少的那个点\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 30\n\nusing namespace std;\n\ntypedef struct node\n{\n	char data[32];\n	struct node* next;\n	bool lazy;\n}point;\n\nint t,n;\npoint head[30];\nint in_degree[30];\nint out_degree[30];\nint begin,eend;\nchar s[1005][32];\nint s_num=0;\n\nvoid init()\n{\n	begin=eend=0;\n	s_num=0;\n	for(int i=0;i&lt;30;i++)\n	{\n		head[i].next=NULL;\n	}\n	memset(in_degree,0,sizeof(in_degree));\n	memset(out_degree,0,sizeof(out_degree));\n	return ;\n}\n\nbool dfs(int root)\n{\n	if(s_num==n)\n	{\n		for(int i=0;i&lt;n-1;i++)\n		{\n			printf(\'%s.\',s[i]);\n		}\n		printf(\'%s\n\',s[s_num-1]);\n		return true;\n	}\n	point* k=head[root].next;\n	while(k!=NULL)\n	{\n		if(k-&gt;lazy==1)\n		{\n			k=k-&gt;next;\n			continue;\n		}\n		k-&gt;lazy=1;\n		strcpy(s[s_num++],k-&gt;data);\n		bool judge=dfs(k-&gt;data[strlen(k-&gt;data)-1]-\'a\');\n		if(judge) return true;\n		s_num--;\n		k-&gt;lazy=0;\n		k=k-&gt;next;\n	}\n	return false;\n}\n\nint main()\n{\n	char pp[32];\n	scanf(\'%d\',&amp;t);getchar();\n	while(t--)\n	{\n		init();\n		scanf(\'%d\',&amp;n);getchar();\n		for(int i=1;i&lt;=n;i++)\n		{\n			scanf(\'%s\',pp);\n			out_degree[pp[0]-\'a\']++;\n			in_degree[pp[strlen(pp)-1]-\'a\']++;\n			point* p=new point;\n			strcpy(p-&gt;data,pp);\n			p-&gt;next=NULL;\n			p-&gt;lazy=0;\n			\n			point* w=&amp;head[pp[0]-\'a\'];\n			while(w-&gt;next!=NULL&amp;&amp;strcmp(w-&gt;next-&gt;data,pp)&lt;0)\n			{\n				w=w-&gt;next;\n			}\n			p-&gt;next=w-&gt;next;\n			w-&gt;next=p;\n		}\n		\n		bool flag=1;\n		int number=0;\n		for(int i=0;i&lt;30;i++)\n		{\n			if(in_degree[i]==out_degree[i]-1) begin=i;\n			else if(in_degree[i]==out_degree[i]+1) eend=i;\n			else\n			{\n				if(abs(in_degree[i]-out_degree[i])&gt;=2) \n				{\n					flag=0;\n					printf(\'***\n\');\n					break;\n				}\n				number--;\n			}\n			number++;\n		}\n		if(flag==0) continue;\n		if((number==0||number==2)&amp;&amp;dfs(begin));\n		else printf(\'***\n\');\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('07bab65946d2ee200089a4e73d88e0d7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3259 - SPFA负权回路 &lt; Floyed\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     POJ 3259\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    农夫约翰在探索他的许多农场，发现了一些惊人的虫洞。虫洞是很奇特的，因为它是一个单向通道，可让你进入虫洞的前达到目的地！他的N（1≤N≤500）个农场被编号为1..N，之间有M（1≤M≤2500）条路径，W（1≤W≤200）个虫洞。FJ作为一个狂热的时间旅行的爱好者，他要做到以下几点：开始在一个区域，通过一些路径和虫洞旅行，他要回到最开时出发的那个区域出发前的时间。也许他就能遇到自己了:)。为了帮助FJ找出这是否是可以或不可以，他会为你提供F个农场的完整的映射到（1≤F≤5）。所有的路径所花时间都不大于10000秒，所有的虫洞都不大于万秒的时间回溯。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     输入\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    第1行：一个整数F表示接下来会有F个农场说明。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    每个农场第一行：分别是三个空格隔开的整数：N，M和W\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    第2行到M+1行：三个空格分开的数字（S，E，T）描述，分别为：需要T秒走过S和E之间的双向路径。两个区域可能由一个以上的路径来连接。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    第M +2到M+ W+1行：三个空格分开的数字（S，E，T）描述虫洞，描述单向路径，S到E且回溯T秒。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <pre class=\'sio\' code_snippet_id=\'2009287\' name=\'code\' snippet_file_name=\'blog_20161126_1_8954933\' style=\'white-space: pre-wrap; word-wrap: break-word; color: rgb(85, 85, 85); line-height: 35px; font-family: \'Courier New\', Courier, monospace; font-size: 14px; background-color: rgb(255, 255, 255);\'>2\n3 3 1\n1 2 2\n1 3 4\n2 3 1\n3 1 3\n3 2 1\n1 2 3\n2 3 4\n3 1 8</pre>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     输出\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    F行，每行代表一个农场\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    每个农场单独的一行，” YES”表示能满足要求，”NO”表示不能满足要求。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <pre class=\'sio\' code_snippet_id=\'2009287\' name=\'code\' snippet_file_name=\'blog_20161126_2_7973414\' style=\'white-space: pre-wrap; word-wrap: break-word; color: rgb(85, 85, 85); line-height: 35px; font-family: \'Courier New\', Courier, monospace; font-size: 14px; background-color: rgb(255, 255, 255);\'>NO\nYES</pre>\n   <h2>\n    2.Solution:\n   </h2>\n  </div>\n  <div>\n   1.本题明显就是求一个图中的负权回路的问题，很明显Dijstra已经不能用了，这时候，我们采用SPFA或者Bellman-ford（最好用SPFA，SPFA是对Bellman的优化）来求负权回路，一旦一个点进入队列的次数超过了我们的点数，必定存在负权回路（小心必须是查过点数才对，用平凡一个负环的图来举例看看就明白）\n  </div>\n  <div>\n   2.第一次看到这道题，有人用Floyed来求负权回路，Floyed可以解决负权回路，如果一个点的map[i][i]&lt;0必定存在负权回路\n  </div>\n  <div>\n   但是在这里我对Floyed算法的本质又出现了理解偏差，我会发布论坛求解问题的根源\n  </div>\n  <div>\n   3.通过两种算法的测试，发现SPFA的单源最短路径算法求解负权回路的问题比Floyed要快很多很多\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   SPFA\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2009287\' name=\'code\' snippet_file_name=\'blog_20161126_3_4068937\'>/*\nProblem: 3259		User: lantianheyeqi\nMemory: 13548K		Time: 329MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1000000\n#define INF 0x3fffffff \n\nusing namespace std;\n\nint t,n,m,q;\nint u[N];\nint v[N];\nint w[N];\nint first[N];\nint next[N];\nint dis[N];\nbool book[N];\nint num[N];\nint queue[N];\n\nvoid init()\n{\n	memset(dis,0,sizeof(dis));\n	memset(first,-1,sizeof(first));\n	for(int i=1;i&lt;=n;i++) dis[i]=INF;\n	memset(book,0,sizeof(book));\n	memset(num,0,sizeof(num)); \n}\n\nbool SPFA()\n{\n	int head=1;\n	int tail=2;\n	queue[1]=1;\n	num[1]=1;\n	book[1]=1;\n	dis[1]=0;\n	while(head!=tail)\n	{\n		int k=first[queue[head]];\n		while(k!=-1)\n		{\n			if(dis[v[k]]&gt;dis[u[k]]+w[k])\n			{\n				dis[v[k]]=dis[u[k]]+w[k];\n				if(!book[v[k]])\n				{\n					book[v[k]]=1;\n					queue[tail++]=v[k];\n					num[v[k]]++;\n					if(num[v[k]]&gt;n) return true;\n				}\n			}\n			k=next[k];\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n	return false;\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		scanf(\'%d%d%d\',&amp;n,&amp;m,&amp;q);\n		init();\n		for(int i=1;i&lt;=m;i++)\n		{\n			scanf(\'%d%d%d\',&amp;u[i],&amp;v[i],&amp;w[i]);\n		}\n		for(int i=m+1;i&lt;=2*m;i++)\n		{\n			u[i]=v[i-m];\n			v[i]=u[i-m];\n			w[i]=w[i-m];\n		}\n		for(int i=2*m+1;i&lt;=2*m+q;i++)\n		{\n			scanf(\'%d%d%d\',&amp;u[i],&amp;v[i],&amp;w[i]);\n			w[i]=-w[i];\n		}\n		for(int i=1;i&lt;=2*m+q;i++)\n		{\n			next[i]=first[u[i]];\n			first[u[i]]=i;\n		}\n		bool judge=SPFA();\n		if(judge) printf(\'YES\n\');\n		else printf(\'NO\n\');\n	}\n	return 0;\n} </pre>\n   Floyed:有问题，在无限长路径的额问题上存在问题的解决\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2009287\' name=\'code\' snippet_file_name=\'blog_20161126_4_9848814\'>/*\nProblem: 3259		User: lantianheyeqi\nMemory: 1160K		Time: 1657MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 505\n#define INF 0x3f3f3f3f \n\nusing namespace std;\n\nint t,n,m,q;\n//int u[N];\n//int v[N];\n//int w[N];\n//int first[N];\n//int next[N];\n//int dis[N];\n//bool book[N];\n//int num[N];\n//int queue[N];\nint map[N][N];\n\n/*void init()\n{\n	memset(dis,0,sizeof(dis));\n	memset(first,-1,sizeof(first));\n	for(int i=1;i&lt;=n;i++) dis[i]=INF;\n	memset(book,0,sizeof(book));\n	memset(num,0,sizeof(num)); \n}*/\n\n/*bool SPFA()\n{\n	int head=1;\n	int tail=2;\n	queue[1]=1;\n	num[1]=1;\n	book[1]=1;\n	dis[1]=0;\n	while(head!=tail)\n	{\n		int k=first[queue[head]];\n		while(k!=-1)\n		{\n			if(dis[v[k]]&gt;dis[u[k]]+w[k])\n			{\n				dis[v[k]]=dis[u[k]]+w[k];\n				if(!book[v[k]])\n				{\n					book[v[k]]=1;\n					queue[tail++]=v[k];\n					num[v[k]]++;\n					if(num[v[k]]&gt;n) return true;\n				}\n			}\n			k=next[k];\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n	return false;\n}\n*/\nbool Floyed()\n{\n	for(int k=1;k&lt;=n;k++)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				int t=map[i][k]+map[k][j];\n				if(map[i][j]&gt;t)\n				{\n					map[i][j]=t;\n				}\n			}\n			if(map[i][i]&lt;0) return true;\n		}\n	}\n	return false;\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		scanf(\'%d%d%d\',&amp;n,&amp;m,&amp;q);\n		memset(map,0x3f3f3f3f,sizeof(map));\n		for(int i=1;i&lt;=n;i++) map[i][i]=0;\n	/*	init();\n		for(int i=1;i&lt;=m;i++)\n		{\n			scanf(\'%d%d%d\',&amp;u[i],&amp;v[i],&amp;w[i]);\n		}\n		for(int i=m+1;i&lt;=2*m;i++)\n		{\n			u[i]=v[i-m];\n			v[i]=u[i-m];\n			w[i]=w[i-m];\n		}\n		for(int i=2*m+1;i&lt;=2*m+q;i++)\n		{\n			scanf(\'%d%d%d\',&amp;u[i],&amp;v[i],&amp;w[i]);\n			w[i]=-w[i];\n		}\n		for(int i=1;i&lt;=2*m+q;i++)\n		{\n			next[i]=first[u[i]];\n			first[u[i]]=i;\n		}*/\n		//bool judge=SPFA();\n		for(int i=1;i&lt;=m;i++)\n		{\n			int x,y,z;\n			scanf(\'%d%d%d\',&amp;x,&amp;y,&amp;z);\n			if(z&lt;map[x][y]) map[x][y]=map[y][x]=z;\n		}\n		for(int i=1;i&lt;=q;i++)\n		{\n			int x,y,z;\n			scanf(\'%d%d%d\',&amp;x,&amp;y,&amp;z);\n			map[x][y]=-z;\n		}\n		bool judge=Floyed();\n		if(judge) printf(\'YES\n\');\n		else printf(\'NO\n\');\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('7c7330aa91a812d28426839d31e3c4d9','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1847 - Shortest Path Dijstra&gt;SPFA\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question：\n  </h2>\n  <div>\n   又一个火车网络系统\n  </div>\n  <div>\n   输入第一行:\n  </div>\n  <div>\n   n,a,b\n  </div>\n  <div>\n   分别代表网络中 节点的个数，初始节点，终止节点\n  </div>\n  <div>\n   接下来n行分别代表第i个节点的有向边的终点\n  </div>\n  <div>\n   每一行第一个代表的是有向边的个数，之后的第一个有向边的权值是0，之后的权值都是1\n  </div>\n  <div>\n   现在请给出从a到b的最短的路径权值和\n  </div>\n  <h2>\n   2.Solution：\n  </h2>\n  <div>\n   本题是标准的最短路径的问题\n  </div>\n  <div>\n   并且数据量比较水，所以说，我们的很多的最短路径好的算法都可以完成，不仅仅是单源最短路径，我们的Floyed的全局最短路径算法甚至也可以在题目的限制时间内完成\n  </div>\n  <div>\n   我在代码中对三种算法\n  </div>\n  <div>\n   Dijstra，SPFA，Floyed算法都进行了测试\n  </div>\n  <div>\n   在最终的权衡下，SPFA算是相对的额效率最高的一种算法（当然，针对这道题的单元最短路的性质之下）\n  </div>\n  <h2>\n   3.Code：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2005240\' name=\'code\' snippet_file_name=\'blog_20161124_1_4803314\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 105\n#define INF 0x7ffffff\n\nusing namespace std;\n\nint dis[N];\nint n,a,b,k;\nbool book[N];\nint map[N][N];\n\n/*\nProblem: 1847 User: lantianheyeqi\nMemory: 732K Time: 32MS\nLanguage: G++ Result: Accepted\nvoid dijstra()\n{\n	memset(book,0,sizeof(book));\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=map[a][i];\n	}\n	book[a]=1;\n	dis[a]=0;\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int mink=INF;\n		int minpoint;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&lt;mink)\n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		}\n		book[minpoint]=1;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;map[minpoint][j]&lt;INF&amp;&amp;dis[j]&gt;dis[minpoint]+map[minpoint][j])\n			{\n				dis[j]=dis[minpoint]+map[minpoint][j];\n			}\n		}\n	}\n}*/\n\n/*\nProblem: 1847 User: lantianheyeqi\nMemory: 736K Time: 16MS\nLanguage: G++ Result: Accepted\nvoid SPFA()\n{\n	memset(book,0,sizeof(book));\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=INF;\n	}\n	book[a]=1;\n	dis[a]=0;\n	int queue[N*N];\n	int head=1;\n	int tail=2;\n	queue[1]=a;\n	while(head!=tail)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(map[queue[head]][i]&lt;INF&amp;&amp;dis[i]&gt;dis[queue[head]]+map[queue[head]][i])\n			{\n				dis[i]=dis[queue[head]]+map[queue[head]][i];\n				if(book[i]==0)\n				{\n					book[i]=1;\n					queue[tail++]=i;\n				}\n			}\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n}\n*/\n\n\n/*\nProblem: 1847 User: lantianheyeqi\nMemory: 732K Time: 32MS\nLanguage: G++ Result: Accepted\n*/\nvoid floyed()\n{\n	for(int k=1;k&lt;=n;k++)\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(map[i][j]&gt;map[i][k]+map[k][j]) map[i][j]=map[i][k]+map[k][j]; \n		} \n	}\n}\n\nint main()\n{\n	while(scanf(\'%d%d%d\',&amp;n,&amp;a,&amp;b)!=EOF)\n	{\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(i==j) map[i][j]=0;   //小心这一句 \n			else map[i][j]=INF;\n		}\n	} \n	for(int i=1;i&lt;=n;i++)\n	{\n		scanf(\'%d\',&amp;k);\n		for(int j=1;j&lt;=k;j++)\n		{\n			int dy;\n			scanf(\'%d\',&amp;dy);\n			if(j==1) map[i][dy]=0;\n			else map[i][dy]=1;\n		}\n	}\n	//dijstra();\n	//SPFA();\n	floyed();\n	if(map[a][b]==INF) printf(\'-1\n\');\n	else printf(\'%d\n\',map[a][b]);\n	//if(dis[b]==INF) printf(\'-1\n\');\n	//else printf(\'%d\n\',dis[b]);\n    }\n	return 0;\n}</pre>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('43237a3a343c278e1a6e71eba5375c41','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ - 42 - 并查集+半欧拉图\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <p>\n  </p>\n  <dl class=\'problem-display\'>\n   <dt>\n    描述\n   </dt>\n   <dd>\n    <p>\n     <span style=\'font-family:SimSun\'>\n      zyc从小就比较喜欢玩一些小游戏，其中就包括画一笔画，他想请你帮他写一个程序，判断一个图是否能够用一笔画下来。\n     </span>\n    </p>\n    <p>\n     <span style=\'font-family:SimSun; font-size:14px; line-height:19px\'>\n      规定，所有的边都只能画一次，不能重复画。\n     </span>\n    </p>\n    <p>\n    </p>\n    <dl class=\'others\'>\n     <dt>\n      输入\n     </dt>\n     <dd>\n      第一行只有一个正整数N(N&lt;=10)表示测试数据的组数。\n      <br/>\n      每组测试数据的第一行有两个正整数P,Q(P&lt;=1000,Q&lt;=2000)，分别表示这个画中有多少个顶点和多少条连线。（点的编号从1到P）\n      <br/>\n      随后的Q行，每行有两个正整数A,B(0&lt;A,B&lt;P)，表示编号为A和B的两点之间有连线。\n     </dd>\n     <dt>\n      输出\n     </dt>\n     <dd>\n      如果存在符合条件的连线，则输出\'Yes\',\n      <br/>\n      如果不存在符合条件的连线，输出\'No\'。\n     </dd>\n     <dt>\n     </dt>\n     <dl class=\'others\'>\n      <dt>\n       样例输入\n      </dt>\n      <dd>\n       <pre id=\'sample_input\'>2\n4 3\n1 2\n1 3\n1 4\n4 5\n1 2\n2 3\n1 3\n1 4\n3 4</pre>\n      </dd>\n      <dt>\n       样例输出\n      </dt>\n      <dd>\n       <pre id=\'sample_output\'>No\nYes</pre>\n      </dd>\n     </dl>\n    </dl>\n   </dd>\n  </dl>\n  <h2>\n   2.Solution：\n  </h2>\n  <p>\n  </p>\n  <p>\n   本题一看是欧拉定理，直接上手求解发现并没有考虑图的连通性\n  </p>\n  <p>\n   所以说，我们的想要保证一笔画至少需要两点\n  </p>\n  <p>\n   1.图连通\n  </p>\n  <p>\n   2.所有的点的奇数度的点个数只能是0,2\n   <br/>\n  </p>\n  <p>\n   所以说，我们的处理思路就是，我们先用并查集对图的连通性进行判定操作\n  </p>\n  <p>\n   之后我们在对邻接表进行计数\n  </p>\n  <p>\n   利用欧拉订立就可以快速的求解出我们的一笔画的性质了\n  </p>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2004026\' name=\'code\' snippet_file_name=\'blog_20161123_1_1056483\'> \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 2005\n\nusing namespace std;\n\nint fa[N];\nint deep[N];\n\nvoid init(int n)\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		fa[i]=i;\n		deep[i]=1;\n	}\n}\n\nint find(int x)\n{\n	if(x==fa[x]) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y])\n		{\n			fa[y]=x;\n		}\n		else\n		{\n			fa[x]=y;\n			if(deep[x]==deep[y]) deep[y]++;\n		}\n	}\n} \n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nint main()\n{\n	int u[N];\n	int v[N];\n	int next[N];\n	int first[N];\n	int n,m;\n	int t;\n	int degree=0;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		memset(next,0,sizeof(next));\n		memset(first,-1,sizeof(first));\n		degree=0;\n		scanf(\'%d%d\',&amp;n,&amp;m);\n		init(n);\n		for(int i=1;i&lt;=m;i++)\n		{\n			scanf(\'%d%d\',&amp;u[i],&amp;v[i]);\n			if(same(u[i],v[i])) continue;\n			else unit(u[i],v[i]);\n		}\n		int x=0;\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(fa[i]==i) x++;\n		}\n		if(x&gt;1) \n		{\n			printf(\'No\n\');\n			continue;\n		} \n		for(int i=m+1;i&lt;=2*m;i++)\n		{\n			u[i]=v[i-m];\n			v[i]=u[i-m];\n		}\n		for(int i=1;i&lt;=2*m;i++)\n		{\n			next[i]=first[u[i]];\n			first[u[i]]=i; \n		}\n		for(int i=1;i&lt;=n;i++)\n		{\n			int k=first[i];\n			int number=0;\n			while(k!=-1)\n			{\n				number++;\n				k=next[k];\n			}\n			if(number &amp; 1) degree++;\n		}\n		if(degree==0||degree==2) printf(\'Yes\n\');\n		else printf(\'No\n\');\n	}\n	return 0;\n}         </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('8c835df3a6fe0f7417676f6d189592ba','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3268  - Shortest Path Dijstra+ SPFA\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question：\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   输入第一行n,m,t三个数代表的含义分别是图中的n个点，m条有向边，t为初始定点\n  </div>\n  <div>\n   之后的m行代表我们图中的m条有向边\n  </div>\n  <div>\n   在题目要求从t初始点到所有的点点额单源最短路径和将所有的有向边反向之后，我们再求一次单源最短路径\n  </div>\n  <div>\n   求两次的最短路径之和的最大值\n  </div>\n  <h2>\n   2.Solution：\n  </h2>\n  <div>\n   单元最短路径问题\n  </div>\n  <div>\n   本题因为牵扯到有向边的反向问题，所以我们最好选用矩阵的数据结构来进行存储\n  </div>\n  <div>\n   题中的要求设计到矩阵的转置\n  </div>\n  <div>\n   之后就是SPFA或者Dijkstra的模板\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   SPFA\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'2003526\' name=\'code\' snippet_file_name=\'blog_20161123_1_5934073\'>/*\nSource Code\nProblem: 3268\n\nUser: lantianheyeqi\nMemory: 4504K\n\nTime: 32MS\nLanguage: C++\n\nResult: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1005\n#define INF 0X7fffffff\n\nusing namespace std;\n\nint n,m,t;\nint dis[2][N];\nint map[N][N];\nbool book[N];\n\nvoid SPFA(int atom)\n{\n	memset(book,0,sizeof(book));\n	int queue[N*100];\n	int head=1;\n	int tail=2;\n	queue[1]=t;\n	book[t]=1;\n	for(int i=1;i&lt;=n;i++) dis[atom][i]=INF;\n	dis[atom][t]=0;\n	while(head!=tail)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(map[queue[head]][i]!=INF&amp;&amp;dis[atom][i]&gt;dis[atom][queue[head]]+map[queue[head]][i])\n			{\n				dis[atom][i]=dis[atom][queue[head]]+map[queue[head]][i];\n				if(book[i]==0)\n				{\n					book[i]=1;\n					queue[tail++]=i;\n				}\n			}\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n}\n\nint main()\n{\n	scanf(\'%d%d%d\',&amp;n,&amp;m,&amp;t);\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			map[i][j]=INF;\n		}\n	}\n	for(int i=1;i&lt;=m;i++)\n	{\n		int dx,dy,dz;\n		scanf(\'%d%d%d\',&amp;dx,&amp;dy,&amp;dz);\n		map[dx][dy]=dz;\n	}\n	SPFA(0);\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=i+1;j&lt;=n;j++)\n		{\n			int t=map[i][j];\n			map[i][j]=map[j][i];\n			map[j][i]=t;\n		}\n	}\n	SPFA(1);\n	int mink=-1;\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[0][i]+=dis[1][i];\n		if(mink&lt;dis[0][i]) mink=dis[0][i];\n	}\n	printf(\'%d\n\',mink);\n	return 0;\n}</pre>\n  <div>\n   Dijstra\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'2003526\' name=\'code\' snippet_file_name=\'blog_20161123_2_3360562\'>/*\nProblem: 3268\n\nUser: lantianheyeqi\nMemory: 4116K\n\nTime: 79MS\nLanguage: C++\n\nResult: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1005\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint map[N][N];\nint n,m,t;\nint dis[2][N];\nbool book[N];\n\nvoid dijstra(int atom)\n{\n	memset(book,0,sizeof(book));\n	book[t]=1;\n	for(int i=1;i&lt;=n;i++) dis[atom][i]=map[t][i];\n	dis[atom][t]=0;\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int mink=INF;\n		int minpoint;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[atom][j]&lt;mink)\n			{\n				mink=dis[atom][j];\n				minpoint=j;\n			}\n		}\n		book[minpoint]=1;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;map[minpoint][j]!=INF&amp;&amp;dis[atom][j]&gt;dis[atom][minpoint]+map[minpoint][j])\n			{\n				dis[atom][j]=dis[atom][minpoint]+map[minpoint][j];\n			}\n		}\n	}\n}\n\nint main()\n{\n	scanf(\'%d%d%d\',&amp;n,&amp;m,&amp;t);\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++) map[i][j]=INF;\n	}\n	for(int i=1;i&lt;=m;i++)\n	{\n		int dx,dy,dz;\n		scanf(\'%d%d%d\',&amp;dx,&amp;dy,&amp;dz);\n		map[dx][dy]=dz;\n	}\n	dijstra(0);\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=i+1;j&lt;=n;j++)\n		{\n			int t=map[i][j];\n			map[i][j]=map[j][i];\n			map[j][i]=t;\n		}\n	}\n	dijstra(1);\n	int mink=-1;\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[0][i]+=dis[1][i];\n		if(mink&lt;dis[0][i]) mink=dis[0][i];\n	} \n	printf(\'%d\n\',mink);\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('184ff4c980e830eb2d07ff02d2c9d324','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  AVL - 自平衡二叉树 - 详解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n  </h2>\n  <h2>\n   1.AVL\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   说到AVL，我们就必须先要了解一下BST\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52081538?locationNum=2&amp;fps=1\' target=\'_blank\'>\n    Lantian的BST总结\n   </a>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   在了解了有关BST的性质之后，我们现在就明白了\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   因为在我们的插入的节点有序的情况下，我们的BST会出现偏树的情况，这会导致我们的ASL（平均查找长度）大大增加从而降低我们的查找效率\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   因此，我们就需要一种BST的优化版本取克服这种输入造成的弊端（现在证明，在平均情况下，出现偏树的概率大致在45.6%），所以说，我们的优化是非常有必要的\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   因此我们需要对传统的BST进行一种平衡处理\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   在这里，历史上出现了大批的优秀的自平衡二叉查找树，相对有splay，treap，AVL，SBT，RBT，很多很多，这其中最经典也是最早发明的自平衡二叉树就是我们心在要说明的AVL，也是现阶段我们的数据结构课程中选取讲解的自平衡二叉树\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   PS:\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52237338?locationNum=1&amp;fps=1\' target=\'_blank\'>\n    Lantian的SBT讲解\n   </a>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   本人之前曾经讲解过一种有中国大神陈启峰发明的自平衡二叉树SBT，目前来说，SBT相对于算法竞赛来说非常好实现，但是与优化后的AVL下昂比的话，我们的SBT（Size Balance Tree）因为是节点的数量域作为平衡因子，这里的话，我们牵扯到对于树的修改为虎的探讨的话，SBT自始至终都是要从底向上一直到根来进行维护的，但是AVL的平衡因子的性质决定了AVL不需要一直维护到根，我们只需要维护到当前的第一个\n   <strong>\n    最小不平衡子树\n   </strong>\n   就可以了，但是毋庸置疑，SBT相对于AVL来说非常的好写，但是我在对AVL的平衡因子的优化之后，发现其实两者的AVL,SBT的维护效率相当，并不存在明显的难易之说\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <span style=\'color:rgb(51,51,51); font-family:arial,宋体,sans-serif; font-size:14px; line-height:24px\'>\n    AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文《An algorithm for the organization of information》中发表了它。也是目前已知的最早的自平衡二叉树\n   </span>\n   <br/>\n  </div>\n  <h2>\n   2.AVL\'s ADT\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   AVL的抽象数据类型基于BST\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   先给出BST的定义：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   1.BST是一颗空树\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   2.BST不是空树并且左子树的节点的大小都小于根节点，右子树节点的大小都大于根节点（在没有进行扩展的AVL平衡二叉树中，我们默认不存在键值相同的节点）\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   AVL的ADT基于BST的ADT的定义如下：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'2002846\' name=\'code\' snippet_file_name=\'blog_20161123_1_7487972\'>ADT\n{\n    数据对象：节点\n    数据关系：节点的指向关系，套用BST的定义\n    数据操作：\n        1.中序遍历\n        2.插入\n        3.删除\n        4.旋转维护\n        5.查找\n}</pre>\n   主要的数据操作如上：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   在这里我先来讲解一下对于AVL树的操作的时间复杂度：\n  </div>\n  <h3>\n   1.中序遍历：\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   这里我们强调中序遍历的原因就是，对于BST/AVL来说，我们定义保证了我们的中序序列一定构成一个定义的有序序列，所以说我们的中序遍历可以获取我们的当前的AVL树中有序的序列值\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   时间复杂度:O(number_point)\n  </div>\n  <h3>\n   2.插入：\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   插入节点，对于我们考虑的时候需要考虑两种情况\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   首先，如果插入之后我们不需要对树进行维护，那么时间复杂度同查找就是O(logn)，这是我么的平衡二叉树的性质保证的\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   但是对于如果插入后节点我们需要对树进行维护的时候，我们除了O(logn)的查找操作之外，我们还需要O(c)的常数时间的旋转维护操作，乳沟我们之简简单单考虑时间复杂度的话，我们的市价复杂度都是O(logn)\n  </div>\n  <h3>\n   3.删除:\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   首先，如果我们删除之后，树的平衡因子保证了树的平衡性，那么我们其实也只需要O(logn)的时间复杂度\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   但是一旦我们需要进行维护，的话，时间复杂度无非就是O(logn+C)没有什么本质的影响\n  </div>\n  <h3>\n   4.查找：\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   对于AVL树的查找，因为平衡树已经保证了我们的树基本上额深度和O(logn)是同一个数量级上的，所以说我们的查找你的时间复杂度最坏的情况下也就是O(logn)\n  </div>\n  <h3>\n   5.旋转维护：\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   对于AVL树的旋转维护，因为只是牵扯到指针的修改，所以在全局范围内来看的话，时间复杂度还是简单的O(c)在大输入的情况下，我们完全可以对市价耗费进行忽略（无限接近常数阶）,我们之后会有对旋转操作详细的讲解\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   PS:\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   在接下来的AVL树的讲解过程中，我们可能会要一个小的要点：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   我们需要记住，对于平衡二叉树AVL（这里好像仅限于AVL）的平衡维护操作实际上就是尽可能保证我们的树高不变\n  </div>\n  <h2>\n   3.Point - ADT\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   我们的AVL树的节点是要非常的小心的，这里我们对接点有如下的ADT的定义：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'2002846\' name=\'code\' snippet_file_name=\'blog_20161123_2_3170357\'>template&lt;typename T&gt;\nclass point\n{\n	public:\n		point()\n		{\n			left=right=NULL;\n			height=0;\n			freq=1;\n		}\n		point(T x)\n		{\n			dt=x;\n			left=right=NULL;\n			height=0;\n			freq=1;\n		}\n		~point()   //方便测试的析构函数 \n		{\n			cout&lt;&lt;\'节点\'&lt;&lt;dt&lt;&lt;\'被删除!\'&lt;&lt;endl; \n		}\n		inline void set_data(T x)\n		{\n			dt=x;\n		} \n		inline T get_data()\n		{\n			return dt;\n		}\n		friend void set_height(point&lt;T&gt;* p,int ht)\n		{\n			p-&gt;height=ht;\n		}\n		friend int get_height(point&lt;T&gt;* p)\n		{\n			if(p == NULL) return -1; \n			else return p-&gt;height;\n		}\n		inline void set_freq()\n		{\n			freq++;\n		}\n		point* left;\n		point* right;\n	protected:\n		T dt;    //数据 \n		int height;   //树高 \n		int freq;   //频度，扩展的AVL树的功能单元 \n};</pre>\n   这是我的代码上的对于AVL的point的描述，这里我们需要注意到，对于AVL树的平衡因子的定义\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   众所周知,AVL树的书写是非常的困难的，困难的点就在于我们在平衡维护的时候，需要考虑的要点太多，不容易思考，原本的AVL树的定义的平衡因子的内容是左右子树的高度差，在这里，我将平衡因子该位当前节点的高度（距离叶子节点），这里我只需要添加set_height和get_height（定义这两个接口的必要性原因在与如果节点为空的话，我们必须要对其进行取高操作）两个几口就可以简单的取代之前的AVL的困难的树的平衡因子的定义了，非常的简便\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   对于平衡因子定义：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   树高：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   1.叶子节点的树高是0\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   2.空树的树高是-1\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   3.其余点的树高由以上的内容类推\n  </div>\n  <h2>\n   4.Rotation - Maintain操作\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   对于一个平衡二叉树来说，我们我们在了解了BST之后，我们唯一需要攻破的就是这个Rotation操作了\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   在广泛的定义上，我们将AVL等平衡树的维护操作采用了四种分类的旋转来代替\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   参考SBT的资料来看看：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20131129201336156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVybXVyZWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\'/>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   我们先来看看旋转操作：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   左旋右旋的代码如下（封装了对平衡因子的修改）：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'2002846\' name=\'code\' snippet_file_name=\'blog_20161123_3_6310683\'>template&lt;typename T&gt;\nvoid AVL&lt;T&gt;::left_rotation(point&lt;T&gt;*&amp; p)\n{\n	point&lt;T&gt;* k=p-&gt;right;\n	p-&gt;right=k-&gt;left;\n	k-&gt;left=p;\n	set_height(p,max(get_height(p-&gt;left),get_height(p-&gt;right))+1);\n	set_height(k,max(get_height(k-&gt;left),get_height(k-&gt;right))+1);\n	p=k;\n}\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::right_rotation(point&lt;T&gt;*&amp; p)\n{\n	point&lt;T&gt;* k=p-&gt;left;\n	p-&gt;left=k-&gt;right;\n	k-&gt;right=p;\n	set_height(p,max(get_height(p-&gt;left),get_height(p-&gt;right))+1);\n	set_height(k,max(get_height(k-&gt;left),get_height(k-&gt;right))+1);\n	p=k;\n}</pre>\n   我们可以看到，对于AVL的核心旋转操作来说，无非就是对指针的修改而已,算法非常的简明高效\n  </div>\n  <h3>\n   1.Case 1:左左\n  </h3>\n  <div>\n   <br/>\n  </div>\n  <p>\n   <img alt=\'\' src=\'http://pic002.cnblogs.com/images/2012/457289/2012111323091813.jpg\'/>\n  </p>\n  <p>\n   <span style=\'font-family:FangSong_GB2312\'>\n    <span style=\'font-size:18.018px; line-height:37.8378px\'>\n     单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。\n    </span>\n    <br/>\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:18.018px; line-height:37.8378px\'>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; font-size:18.018px; line-height:37.8378px\'>\n   <span style=\'font-family:FangSong_GB2312\'>\n    为使树恢复平衡，我们把k2（\n    <span style=\'color:rgb(255,0,0)\'>\n     此处可能是作者笔误，应该为k1\n    </span>\n    ）变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。\n   </span>\n  </p>\n  <p style=\'margin:10px auto; font-size:18.018px; line-height:37.8378px\'>\n   <span style=\'font-family:FangSong_GB2312\'>\n    这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。\n   </span>\n  </p>\n  <h3 style=\'margin:10px auto; font-size:18.018px; line-height:37.8378px\'>\n   <span style=\'font-family:FangSong_GB2312\'>\n    2.Case 2：左右\n   </span>\n  </h3>\n  <div>\n   <span style=\'font-family:FangSong_GB2312\'>\n    <img alt=\'\' src=\'http://pic002.cnblogs.com/images/2012/457289/2012111323093397.jpg\'/>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:FangSong_GB2312\'>\n    对于左右的情况，我们对于树的左节点为根进行左旋操作，然后对跟进行右旋操作，最后得到根子树就会被自动的修改完成\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:FangSong_GB2312\'>\n    对于右右和右左的情况和上面两种是镜像的，没有必要赘语了\n   </span>\n  </div>\n  <h2>\n   <span style=\'font-family:FangSong_GB2312\'>\n    5.模板类代码：\n   </span>\n  </h2>\n  <div>\n   <span style=\'font-family:FangSong_GB2312\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'2002846\' name=\'code\' snippet_file_name=\'blog_20161123_4_8263313\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cmath\'\n#define N 100005\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass point\n{\n	public:\n		point()\n		{\n			left=right=NULL;\n			height=0;\n			freq=1;\n		}\n		point(T x)\n		{\n			dt=x;\n			left=right=NULL;\n			height=0;\n			freq=1;\n		}\n		~point()   //方便测试的析构函数 \n		{\n			cout&lt;&lt;\'节点\'&lt;&lt;dt&lt;&lt;\'被删除!\'&lt;&lt;endl; \n		}\n		inline void set_data(T x)\n		{\n			dt=x;\n		} \n		inline T get_data()\n		{\n			return dt;\n		}\n		friend void set_height(point&lt;T&gt;* p,int ht)\n		{\n			p-&gt;height=ht;\n		}\n		friend int get_height(point&lt;T&gt;* p)\n		{\n			if(p == NULL) return -1; \n			else return p-&gt;height;\n		}\n		inline void set_freq()\n		{\n			freq++;\n		}\n		point* left;\n		point* right;\n	protected:\n		T dt;    //数据 \n		int height;   //树高 \n		int freq;   //频度，扩展的AVL树的功能单元 \n};\n\ntemplate&lt;typename T&gt;\nclass AVL\n{\n	public:\n		AVL()\n		{\n			root=NULL;\n			number_point=0;\n		}\n		~AVL()\n		{\n			clear(root);\n		}\n		void left_rotation(point&lt;T&gt;*&amp;);\n		void right_rotation(point&lt;T&gt;*&amp;); \n		void mid_order(point&lt;T&gt;*); \n		void clear(point&lt;T&gt;*);   \n		point&lt;T&gt;* find(point&lt;T&gt;*,T);\n		void insert(point&lt;T&gt;*&amp;,T);     //支持针对子树的操作，灵活性更高 \n		bool do_insert(T);\n		bool delete_(point&lt;T&gt;*&amp;,T);   \n		void do_delete_(point&lt;T&gt;*&amp;,point&lt;T&gt;*); \n		inline point&lt;T&gt;* get_father(point&lt;T&gt;* p)   //辅助函数，获取父亲 \n		{\n			point&lt;T&gt;* k=root;\n			point&lt;T&gt;* help=root;\n			while(k != p)\n			{\n				help=k;\n				if(k==NULL) return NULL;\n				else if(k-&gt;get_data() &gt; p-&gt;get_data()) k=k-&gt;left;\n				else if(k-&gt;get_data() &lt; p-&gt;get_data()) k=k-&gt;right;\n			} \n			return help;\n		}\n		void test_print(point&lt;T&gt;*);\n		inline point&lt;T&gt;* return_root()\n		{\n			return root;\n		}\n		inline point&lt;T&gt;*&amp; returnroot()\n		{\n			return root;\n		}\n	protected:\n		point&lt;T&gt;* root;\n		int number_point;    \n};\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::test_print(point&lt;T&gt;* p)   //层序 \n{\n	point&lt;T&gt;* queue[N];\n	int head=1;\n	int tail=2;\n	if(p==NULL) return ;   //空树 \n	queue[1]=p;\n	while(head!=tail)\n	{\n		if(queue[head]-&gt;left!=NULL) queue[tail++]=queue[head]-&gt;left;\n		if(queue[head]-&gt;right!=NULL) queue[tail++]=queue[head]-&gt;right;\n		head++;\n	}\n	for(int i=1;i&lt;tail;i++) cout&lt;&lt;queue[i]-&gt;get_data()&lt;&lt;\' \';\n	cout&lt;&lt;endl; \n}\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::mid_order(point&lt;T&gt;* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		AVL&lt;T&gt;::mid_order(p-&gt;left);\n		cout&lt;&lt;p-&gt;get_data()&lt;&lt;\' \';\n		AVL&lt;T&gt;::mid_order(p-&gt;right);\n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::clear(point&lt;T&gt;* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		AVL&lt;T&gt;::clear(p-&gt;left);\n		AVL&lt;T&gt;::clear(p-&gt;right);\n		delete p;\n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::left_rotation(point&lt;T&gt;*&amp; p)\n{\n	point&lt;T&gt;* k=p-&gt;right;\n	p-&gt;right=k-&gt;left;\n	k-&gt;left=p;\n	set_height(p,max(get_height(p-&gt;left),get_height(p-&gt;right))+1);\n	set_height(k,max(get_height(k-&gt;left),get_height(k-&gt;right))+1);\n	p=k;\n}\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::right_rotation(point&lt;T&gt;*&amp; p)\n{\n	point&lt;T&gt;* k=p-&gt;left;\n	p-&gt;left=k-&gt;right;\n	k-&gt;right=p;\n	set_height(p,max(get_height(p-&gt;left),get_height(p-&gt;right))+1);\n	set_height(k,max(get_height(k-&gt;left),get_height(k-&gt;right))+1);\n	p=k;\n}\n\ntemplate&lt;typename T&gt;\npoint&lt;T&gt;* AVL&lt;T&gt;::find(point&lt;T&gt;* p,T x)\n{\n	point&lt;T&gt;* k=NULL;\n	if(p==NULL) return NULL;\n	else if(x &gt; p-&gt;get_data()) \n	{\n		if((k=find(p-&gt;right,x))==NULL) return NULL;\n		else return k;\n	}\n	else if(x &lt; p-&gt;get_data())\n	{\n		if((k=find(p-&gt;left,x))==NULL) return NULL;\n		else return k;\n	}\n	else return p;\n}\n\ntemplate&lt;typename T&gt;\nbool AVL&lt;T&gt;::do_insert(T x)\n{\n	point&lt;T&gt;* k=NULL;\n	k=find(root,x);\n	AVL&lt;T&gt;::insert(root,x);\n	if(k==NULL) \n	{\n		number_point++;\n		return true;\n	}\n	else return false;\n}\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::insert(point&lt;T&gt;*&amp; p,T x)\n{\n	if(p==NULL)\n	{\n		p=new point&lt;T&gt;(x);\n		return ;\n	}\n	else if(p-&gt;get_data() &gt; x)\n	{\n		insert(p-&gt;left,x);\n		if(get_height(p-&gt;left) - get_height(p-&gt;right) == 2)\n		{\n			if(x &gt; p-&gt;left-&gt;get_data())\n			{\n				AVL&lt;T&gt;::left_rotation(p-&gt;left);\n				AVL&lt;T&gt;::right_rotation(p); \n			}\n			else\n			{\n				AVL&lt;T&gt;::right_rotation(p); \n			}\n		}\n	}\n	else if(p-&gt;get_data() &lt; x)\n	{\n		insert(p-&gt;right,x);\n		if(get_height(p-&gt;left) - get_height(p-&gt;right) == -2)\n		{\n			if(x &gt; p-&gt;right-&gt;get_data())\n			{\n				AVL&lt;T&gt;::left_rotation(p);\n			}\n			else\n			{\n				AVL&lt;T&gt;::right_rotation(p-&gt;right);\n				AVL&lt;T&gt;::left_rotation(p);\n			}\n		}\n	}\n	else \n	{\n		p-&gt;set_freq();\n	}\n	set_height(p,max(get_height(p-&gt;left),get_height(p-&gt;right))+1);\n}\n\ntemplate&lt;typename T&gt; \nbool AVL&lt;T&gt;::delete_(point&lt;T&gt;*&amp; p,T x)\n{\n	point&lt;T&gt;* k=find(p,x);\n	if(k-&gt;get_data() == x)\n	{\n		number_point--; \n		AVL&lt;T&gt;::do_delete_(p,k);\n		return true;\n	}\n	else return false;   //删除失败 \n}\n\ntemplate&lt;typename T&gt;\nvoid AVL&lt;T&gt;::do_delete_(point&lt;T&gt;*&amp; p,point&lt;T&gt;* k)\n{\n	if(p-&gt;get_data() &gt; k-&gt;get_data())\n	{\n	    AVL&lt;T&gt;::do_delete_(p-&gt;left,k);\n	    if(get_height(p-&gt;left) - get_height(p-&gt;right) == -2)\n	    {\n	    	if(p-&gt;right-&gt;left!=NULL &amp;&amp; get_height(p-&gt;right-&gt;left)&gt;get_height(p-&gt;right-&gt;right) )\n	        {\n	            AVL&lt;T&gt;::right_rotation(p-&gt;right);\n				AVL&lt;T&gt;::left_rotation(p); 	 	\n			}\n			else\n			{\n				AVL&lt;T&gt;::left_rotation(p);\n			}\n		}\n	}\n	else if(p-&gt;get_data() &lt; k-&gt;get_data())\n	{\n		AVL&lt;T&gt;::do_delete_(p-&gt;right,k);\n		if(get_height(p-&gt;left) - get_height(p-&gt;right) == 2)\n		{\n			if(p-&gt;left-&gt;right!=NULL &amp;&amp; get_height(p-&gt;left-&gt;right)&gt;get_height(p-&gt;left-&gt;left))\n			{\n				AVL&lt;T&gt;::left_rotation(p-&gt;left);\n				AVL&lt;T&gt;::right_rotation(p); \n			}\n			else\n			{\n				AVL&lt;T&gt;::right_rotation(p);\n			}\n		}\n	}\n	else\n	{\n		if(p-&gt;left != NULL &amp;&amp; p-&gt;right != NULL)\n		{\n			point&lt;T&gt;* temp=p-&gt;right;\n			while(temp-&gt;left!=NULL) temp=temp-&gt;left;\n			p-&gt;set_data(temp-&gt;get_data());\n			AVL&lt;T&gt;::do_delete_(p-&gt;right,temp);\n			if(get_height(p-&gt;left) - get_height(p-&gt;right) == 2)   //选择删除右子树的替代节点 \n			{\n				if(p-&gt;left-&gt;right!=NULL &amp;&amp; get_height(p-&gt;left-&gt;right)&gt;get_height(p-&gt;left-&gt;left))\n		    	{\n	    			AVL&lt;T&gt;::left_rotation(p-&gt;left);\n	    			AVL&lt;T&gt;::right_rotation(p); \n	    		}\n	    		else\n    			{\n    				AVL&lt;T&gt;::right_rotation(p);\n	    		}\n			}\n		}\n		else\n		{\n			point&lt;T&gt;* w=p;\n			if(p-&gt;left == NULL)\n			{\n				p=p-&gt;right;\n				delete w;\n			}\n			else\n			{\n				p=p-&gt;left;\n				delete w;\n			}\n		}\n	}\n	if(p!=NULL) set_height(p,max(get_height(p-&gt;left),get_height(p-&gt;right))+1);   //回溯维护高度域 \n}\n\nint main()  //测试入口 \n{\n	//整形测试\n	/*\n	AVL&lt;int&gt; test; \n	test.test_print(test.return_root());\n	cout&lt;&lt;\'节点个数\'&lt;&lt;endl;\n	int t;\n	cin&gt;&gt;t;\n	for(int i=1;i&lt;=t;i++)\n	{\n		int y;\n		cin&gt;&gt;y;\n		bool judge=test.do_insert(y);\n		if(judge==true) cout&lt;&lt;\'节点插入成功\'&lt;&lt;endl;\n		else cout&lt;&lt;\'尝试插入已经存在的同键节点，节点频度增加\'&lt;&lt;endl;\n		test.test_print(test.return_root());cout&lt;&lt;endl;\n	}\n	test.mid_order(test.return_root());\n	cout&lt;&lt;endl;\n	test.test_print(test.return_root());\n	\n	test.delete_(test.returnroot(),37);\n	test.test_print(test.return_root());cout&lt;&lt;endl;\n	test.delete_(test.returnroot(),53);\n	test.test_print(test.return_root());cout&lt;&lt;endl;\n	test.delete_(test.returnroot(),93);\n	test.test_print(test.return_root());cout&lt;&lt;endl;*/\n    //浮点型测试\n	/*AVL&lt;double&gt; test;\n	int t;\n	cout&lt;&lt;\'节点个数\'&lt;&lt;endl;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		double x;\n		cin&gt;&gt;x;\n		bool judge=test.do_insert(x);\n		if(judge == true) cout&lt;&lt;\'节点插入成功\'&lt;&lt;endl;\n		else cout&lt;&lt;\'节点插入失败\'&lt;&lt;endl;\n		test.test_print(test.returnroot());cout&lt;&lt;endl;\n	}*/\n	//对于其他的自定义类型，我们还需要自己对于相应的 &gt; , &lt; ,=运算符进行运算符重载就ok，实现一个比较大小的接口就ok \n	return 0;\n}\n</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('d2d11692cc4f0076a6ac379943e6c59d','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2253 - 最短路变形 SPFA+Dijstra\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意:\n  </div>\n  <div>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312; font-size:18px\'>\n     题意：给出青蛙A,B和若干石头的坐标，现青蛙A想到青蛙B那，A可通过任意石头到达B,\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312; font-size:18px\'>\n     问从A到B多条路径中的   最长边   中的   最短距离\n    </span>\n   </p>\n   <h2>\n    2.Solution:\n   </h2>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312; font-size:18px\'>\n     分析：这题是最短路的变形，以前求的是路径总长的最小值，而此题是通路中最长边的最小值，每条边的权值可以通过坐标算出，\n    </span>\n    <span style=\'font-family:KaiTi_GB2312; font-size:18px\'>\n     因为是单源起点，直接用SPFA\n     <a class=\'replace_word\' href=\'http://lib.csdn.net/base/datastructure\' style=\'color:#df3434; font-weight:bold\' target=\'_blank\' title=\'算法与数据结构知识库\'>\n      算法\n     </a>\n     或dijkstra算法就可以了\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      在这里，我对两种方法都进行了测试，发现时间效率是差不多的\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      但是我需要在这里解析一下题意：\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      在这道题中，我们单源最短路径中要维护的数据的性质发生了本质上的变化\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      1.在纯Shortest Path问题中，我们的要维护的数据时从源点到其他各点之间的最短的路径的总长度\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      2.在本题中，我们的题意是求在A,B两点中的所有的通路的最长边的最小值\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      所以说，我们这里的dis维护数组的实际上的内涵就是从源点到其他各点的通路中的最长的弧的最小值\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      在维护和松弛的过程中，我们的松弛策略也发生了变化，我们以前的最短路问题的松弛策略都是如果现在的新的通路dis权值小于之前的dis权值，我们松弛修改\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      但是在这里我们的松弛策略是，如果当前的通路的之前的dis和现在的选取的点的出边之间选取一个最大的，如果这个选出来的值比我们的dis要小，我们进行松弛\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      在SPFA中，我们是用边进行松弛，在队列顶点的的所有的出边和之前的顶点的dis中我们选取最大的一个\n     </span>\n    </span>\n   </p>\n   <p>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      在Dijstra中，我们选择dis权值最小的一个然后用这个和所有的出边的最大值选取一个进行优化\n     </span>\n    </span>\n   </p>\n   <h2>\n    3.Code:\n   </h2>\n   <div>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      Dijstra\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n     </span>\n    </span>\n    <pre class=\'cpp\' code_snippet_id=\'2000740\' name=\'code\' snippet_file_name=\'blog_20161122_1_5714061\'>/*\nProblem: 2253		User: lantianheyeqi\nMemory: 516K		Time: 16MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cmath\'\n#define N 205\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint n;\ndouble dis[N];\ndouble map[N][N];\nbool book[N];\nint dx[N];\nint dy[N];\n\ndouble cal(int i,int j)\n{\n	double x=(dx[i]-dx[j])*(dx[i]-dx[j]);\n	double y=(dy[i]-dy[j])*(dy[i]-dy[j]);\n	return sqrt(0.0+x+y);\n}\n\ndouble dijstra()\n{\n	memset(book,0,sizeof(book));\n	book[1]=1;\n	for(int i=1;i&lt;=n;i++) dis[i]=map[1][i];\n	dis[1]=0;\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		double mink=INF;\n		int minpoint;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&lt;mink)\n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		}\n		book[minpoint]=1;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&gt;max(dis[minpoint],map[minpoint][j])) dis[j]=max(dis[minpoint],map[minpoint][j]);\n		}\n	} \n	return dis[2];\n}\n\nint main()\n{\n	int t=1;\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n!=0)\n	{\n		for(int i=1;i&lt;=n;i++) scanf(\'%d%d\',&amp;dx[i],&amp;dy[i]);\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				map[i][j]=cal(i,j);\n			}\n		}\n		double k=dijstra();\n		printf(\'Scenario #%d\nFrog Distance = %.3lf\n\n\',t++,k);\n	}\n	return 0;\n}</pre>\n    <br/>\n    SPFA\n   </div>\n   <div>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n     </span>\n    </span>\n    <pre class=\'cpp\' code_snippet_id=\'2000740\' name=\'code\' snippet_file_name=\'blog_20161122_2_6161002\'>/*\nProblem: 2253		User: lantianheyeqi\nMemory: 676K		Time: 16MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cmath\'\n#define N 205\n#define INF 0x7fffffff\n\nusing namespace std;\n\ndouble map[N][N];\nint dx[N];\nint dy[N];\nint n;\ndouble dis[N];\nbool book[N];\n\ndouble cal(int i,int j)\n{\n	double x=(dx[i]-dx[j])*(dx[i]-dx[j]);\n	double y=(dy[i]-dy[j])*(dy[i]-dy[j]);\n	return sqrt(x+y+0.0);\n}\n\ndouble SPFA()\n{\n	memset(book,0,sizeof(book));\n	memset(dis,0,sizeof(dis));\n	int queue[N*N];\n	int head=1;\n	int tail=2;\n	queue[1]=1;\n	book[1]=1;\n	for(int i=1;i&lt;=n;i++) dis[i]=INF;\n	dis[1]=0;\n	while(head!=tail)\n	{\n		int point=queue[head];\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(dis[i]&gt;max(dis[point],map[point][i]))\n			{\n				dis[i]=max(dis[point],map[point][i]);\n				if(book[i]==0)\n				{\n					book[i]=1;\n					queue[tail++]=i;\n				}\n			}\n		}\n		book[point]=0;\n		head++;\n	}\n	return dis[2];\n}\n\nint main()\n{\n	int t=1;\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n!=0)\n	{\n		for(int i=1;i&lt;=n;i++) scanf(\'%d%d\',&amp;dx[i],&amp;dy[i]);\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				map[i][j]=cal(i,j);\n			}\n		}\n		double k=SPFA();\n		printf(\'Scenario #%d\nFrog Distance = %.3lf\n\n\',t++,k); \n	}\n	return 0;\n} </pre>\n    <br/>\n    <br/>\n   </div>\n   <div>\n    <span style=\'font-family:KaiTi_GB2312\'>\n     <span style=\'font-size:18px\'>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('38dc5bd9591f2619371066e4fe13b106','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1502 - Shortest Path - SPFA+Dijstra\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   MPI微处理器求解1号MPI到其他的所有的MPI的最短的路径中的最长的一条\n  </div>\n  <div>\n   Shortest Path版题\n  </div>\n  <div>\n   题目保证有解，且没有负权边\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题我用了两种思路去求解\n  </div>\n  <div>\n   SPFA+Dijstra\n  </div>\n  <div>\n   在同为邻接表的情况下，运行的时间效率相当\n  </div>\n  <div>\n   但是，我通过左本题发现，我对SPFA的算法的本质理解存在有很大的漏洞\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   SPFA 邻接表\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1996841\' name=\'code\' snippet_file_name=\'blog_20161121_1_4548931\'>/*\nProblem: 1502		User: lantianheyeqi\nMemory: 296K		Time: 16MS\nLanguage: C++		Result: Accepted\n*/ \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'algorithm\'\n#define N 105\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint dis[N];\nint n;\nint u[N*N];\nint v[N*N];\nint w[N*N];\nint nextk[N*N];\nint first[N];\nint book[N];\n\nvoid SPFA()\n{\n	memset(book,0,sizeof(book));\n	int queue[N*N];\n	int head=1;\n	int tail=2;\n	queue[head]=1;\n	book[1]=1;\n	for(int i=1;i&lt;=n;i++) dis[i]=INF;\n	dis[1]=0;\n	while(head!=tail)\n	{\n		int k=first[queue[head]];\n		book[queue[head]]=0;   //这一步必不可少 \n		while(k!=-1)\n		{\n			if(dis[v[k]]&gt;dis[u[k]]+w[k])\n			{\n				dis[v[k]]=dis[u[k]]+w[k];\n				if(book[v[k]]==0)\n				{\n					book[v[k]]=1;\n					queue[tail++]=v[k];\n				}\n			}\n			k=nextk[k];\n		}\n		head++;\n	}\n} \n\nint main()\n{\n	char data[N];\n	scanf(\'%d\',&amp;n);\n	int number_edge=0;\n	for(int i=1;i&lt;=n;i++) first[i]=-1;\n	for(int i=2;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=i-1;j++)\n		{\n			scanf(\'%s\',data);\n			if(data[0]!=\'x\')\n			{\n				number_edge++;\n				u[number_edge]=i;\n				v[number_edge]=j;\n				w[number_edge]=atoi(data);\n			}\n		}\n	}\n	for(int i=number_edge+1;i&lt;=2*number_edge;i++)\n	{\n		u[i]=v[i-number_edge];\n		v[i]=u[i-number_edge];\n		w[i]=w[i-number_edge];\n	}\n	for(int i=1;i&lt;=2*number_edge;i++)\n	{\n		nextk[i]=first[u[i]];\n		first[u[i]]=i;\n	}\n	SPFA();\n	int maxp=-1;\n	for(int i=1;i&lt;=n;i++) if(maxp&lt;dis[i]) maxp=dis[i];\n	printf(\'%d\n\',maxp);\n	return 0;\n}</pre>\n   Dijstra\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1996841\' name=\'code\' snippet_file_name=\'blog_20161121_2_9991335\'>/*\nProblem: 1502		User: lantianheyeqi\nMemory: 208K		Time: 16MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 105\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint map[N][N];\nint n;\nint dis[N];\nbool book[N];\n\nvoid init_map()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			map[i][j]=map[j][i]=INF;\n		}\n	}\n}\n\nvoid dijstra()\n{\n	for(int i=1;i&lt;=n;i++) dis[i]=map[1][i];\n	memset(book,0,sizeof(book));\n	book[1]=1;\n	dis[1]=0;\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int mink=INF;\n		int minpoint;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;mink&gt;dis[j]) mink=dis[j],minpoint=j;\n		}\n		book[minpoint]=1;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;map[minpoint][j]!=INF&amp;&amp;dis[j]&gt;dis[minpoint]+map[minpoint][j])\n			{\n				dis[j]=dis[minpoint]+map[minpoint][j];\n			}\n		}\n	}\n}\n\nint main()\n{\n	char data[100];\n	scanf(\'%d\',&amp;n);\n	init_map();\n	for(int i=2;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=i-1;j++)\n		{\n			scanf(\'%s\',data);\n			if(data[0]!=\'x\') map[i][j]=map[j][i]=atoi(data);\n		} \n	}\n	dijstra();\n	int maxp=-1;\n	for(int i=1;i&lt;=n;i++)\n	{\n		if(maxp&lt;dis[i]) maxp=dis[i];\n	}\n	printf(\'%d\n\',maxp);\n	return 0;\n}</pre>\n   SPFA 邻接矩阵\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1996841\' name=\'code\' snippet_file_name=\'blog_20161121_3_8115380\'>/*\nProblem: 1502		User: lantianheyeqi\nMemory: 244K		Time: 16MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 105\n#define INF 0x7fffffff \n\nusing namespace std;\n\nint dis[N];\nbool book[N];\nint map[N][N];\nint n;\n\nvoid init_map()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			map[i][j]=INF;\n		}\n	}\n}\n\nvoid SPFA()\n{\n	for(int i=1;i&lt;=n;i++) dis[i]=INF;\n	memset(book,0,sizeof(book));\n	int queue[N*N];\n	int head=1;\n	int tail=2;\n	queue[head]=1;\n	book[1]=1;\n	dis[1]=0;\n	while(head!=tail)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(map[queue[head]][i]!=INF&amp;&amp;dis[i]&gt;dis[queue[head]]+map[queue[head]][i])\n			{\n				dis[i]=dis[queue[head]]+map[queue[head]][i];\n				if(book[i]==0)\n				{\n			    	book[i]=1;\n			    	queue[tail++]=i;\n			    }\n			}\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n}\n\nint main()\n{\n	char data[N];\n	scanf(\'%d\',&amp;n);\n	init_map();\n	for(int i=2;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=i-1;j++)\n		{\n			scanf(\'%s\',data);\n			if(data[0]!=\'x\') map[i][j]=map[j][i]=atoi(data);\n		}\n	}\n	SPFA();\n	int maxp=-1;\n	for(int i=1;i&lt;=n;i++) if(maxp&lt;dis[i]) maxp=dis[i];\n	printf(\'%d\n\',maxp);\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b4d110b310c51bbb72c1e3db58dd6786','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Euler Graph - 欧拉图 详解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.哥尼斯堡七桥问题\n  </h2>\n  <div>\n   哥尼斯堡七桥问题：\n  </div>\n  <div>\n   18世纪中叶在欧洲普鲁士的哥尼斯堡城内有一条贯穿全市的和河中有两个小岛，现在四块陆地有七座桥连接，引入问题，如何规划线路才能保证我们可以走过所有的边但是却保证不会重复呢\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img4.imgtn.bdimg.com/it/u=2227547672,2096914110&amp;fm=21&amp;gp=0.jpg\'/>\n   <br/>\n  </div>\n  <div>\n   这就是著名的哥尼斯堡七桥问题，现在通过图论证明哥尼斯堡问题是不存在解的，第一个发表论文证明了这个事实的人就是欧拉，该论文也是目前为止发现的最早的关于图论的论文，当然，这种问题也就被命名为欧拉图的问题，现在我们即将从图论的角度来仔细的阐释一下欧拉图的相关定理以及证明，最后附上相应的求解模板代码\n  </div>\n  <h2>\n   2.欧拉图\n  </h2>\n  <div>\n   首先我们需要先来了解一些有关欧拉图的性质和定义：\n  </div>\n  <h3>\n   1.定义：\n  </h3>\n  <div>\n   <strong>\n    1.我们的定义的数据对象的范围是有向图和无向图\n   </strong>\n  </div>\n  <div>\n   <strong>\n    2.图的通路：\n   </strong>\n  </div>\n  <div>\n   图中的顶点与边的交替序列我们称之为是图的通路\n  </div>\n  <div>\n   <strong>\n    3.欧拉通路：\n   </strong>\n  </div>\n  <div>\n   我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路\n  </div>\n  <div>\n   <strong>\n    4.欧拉回路：\n   </strong>\n  </div>\n  <div>\n   如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路\n  </div>\n  <div>\n   <strong>\n    5.欧拉图：\n   </strong>\n  </div>\n  <div>\n   具有欧拉回路的图称之为欧拉图，规定平凡图（只有一个顶点的空图）属于欧拉图\n  </div>\n  <div>\n   <strong>\n    6.半欧拉图：\n   </strong>\n  </div>\n  <div>\n   具有欧拉通路的图我们称之为是半欧拉图\n  </div>\n  <h3>\n   2.定理：\n  </h3>\n  <div>\n   <strong>\n    1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点\n   </strong>\n  </div>\n  <div>\n   证明：\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   平凡图显然成立\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   必要性：图G是欧拉图，证明G中没有奇数度节点\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   G是欧拉图——G中存在欧拉回路——欧拉回路中每个点每出现在欧拉回路的序列中就必定会获得两个度——所以欧拉序列中的所有的点必然都是偶数度的节点——不存在奇数度的节点\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   充分性：G中没有奇数度的节点，证明G是欧拉图——数学归纳法\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   假设边数是m\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.m=1，没有奇数度节点——该边只能是一个环——G是欧拉图\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.假设m&lt;=k成立，现在证明m=k+1成立\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   G连通且没有奇数度顶点——G中必然存在圈——删去圈上的所有的边——假设获得了s个连通分量，每个连通分量有最多k条边，并且都是偶数度的节点（圈上的边每条给顶点贡献两个度）——根据上述的归纳假设每个连通分量都是一个欧拉图——我们现在将圈复原——必然存在一条欧拉回路连接了所有的节点并回到原点（这条回路的主路就是刚才删去的圈，每次进入连通分量的时候，遍历连通分量的欧拉回路在出来继续走圈）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点\n   </strong>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   G是半欧拉图，存在一条欧拉通路——通路上非端点节点必然是偶数度的——通路上的两个端点，必然都是奇数度\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   充分性：图G是连通的并且恰好有两个奇数度的顶点，证明G是半欧拉图\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   假设现在我们向G中添加一条连接两个奇数度顶点的边，那么必然满足欧拉图的性质——存在欧拉回路——那么我们将欧拉回路中的那条新加的边删去就会的到一条端点是两个奇数度顶点的欧拉通路\n  </div>\n  <div>\n   <strong>\n    定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图\n   </strong>\n   ，原因就是每一次遍历走完两个奇数度顶点之间的欧拉通路，知道所有的奇数度顶点都走完位置图就遍历完了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度\n   </strong>\n  </div>\n  <div>\n   <strong>\n    4.有向图G是半欧拉图的充分必要条件是图单向连通并且恰好有两个奇数度顶点，这两个奇数度顶点一个的出度比入度大1，一个刚好反过来，其余的顶点的出度等于入度\n   </strong>\n  </div>\n  <div>\n   <strong>\n    <br/>\n   </strong>\n  </div>\n  <div>\n   <strong>\n    5.G是非平凡的欧拉图当且仅当G是连通的并且是若干个边不重合的圈的并\n   </strong>\n  </div>\n  <div>\n   <strong>\n    <br/>\n   </strong>\n  </div>\n  <h2>\n   <strong>\n    3.求解欧拉回路：\n   </strong>\n  </h2>\n  <div>\n   现在我们已经了解了什么是欧拉回路了，我们现在开始着手来书写找寻欧拉回路的算法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    1.逐步插入回路法\n   </strong>\n  </div>\n  <div>\n   根据我们上面的定理1的充分性的证明，我们其实已经得到了一种求解欧拉回路的算法，那就是我们找到了一个圈，我们从圈开始，每次找到一个连通分量就进入走完连通分量的回路，知道我们的主路的圈全部走完，那么我们的走过的序列就是一个欧拉回路\n  </div>\n  <div>\n   现在这个算法的的描述我们已经很清楚了，但是实现呢？\n  </div>\n  <div>\n   这是一个很麻烦的问题，机缘巧合之下，我读了一些来自POJ2230的源代码，本题是有向图的欧拉回路的模板题，从这道题，我是真的明白了求解欧拉回路的算法——逐步插入回路法\n  </div>\n  <div>\n   <strong>\n    本算法的精髓在于DFS深度优先搜索\n   </strong>\n  </div>\n  <div>\n   <strong>\n    因为遍历了G所有的边和顶点，时间复杂度是O(e+v)\n   </strong>\n  </div>\n  <div>\n   先附上伪代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1994657\' name=\'code\' snippet_file_name=\'blog_20161119_1_7800120\'>DFS_Graph(root):\n    for (root,j) in Graph:\n        if visit[(root,j)]==0:\n            visit[(root,j)]=1\n            DFS_Graph(j)\n    add root in answer</pre>\n   短短几行代码，我们就交代了逐步插入回路法的精髓，但是想要真正理解这段代码是非常的不容易的\n  </div>\n  <div>\n   首先，我们需要注意，这段代码对于有向图和无向图都是适用的\n  </div>\n  <div>\n   下面我们来模拟一下这个深搜的过程：\n   <span style=\'font-size:12px\'>\n    CSDN没有办法很好的上传图片，我在这里简单的模拟一下\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <strong>\n     本图是一个有向图\n    </strong>\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n   </strong>\n   <pre class=\'cpp\' code_snippet_id=\'1994657\' name=\'code\' snippet_file_name=\'blog_20161119_2_2117736\'>1——2\n|    |\n|    |\n3——\n|\n|\n4</pre>\n  </div>\n  <div>\n   如上所示，1,2,3,4之间有连边，现在开始模拟\n  </div>\n  <div>\n   我们从1开始深搜(随机的，别的情况也会出现，这里模拟最容易看清本质的搜索过程)\n  </div>\n  <div>\n   1——&gt;2——&gt;3——&gt;1——&gt;3——&gt;2——&gt;1\n  </div>\n  <div>\n   这时候我们会发现回到原点了，但是显然我们并没并且1走到了死胡同里，算法除了问题吗？\n  </div>\n  <div>\n   并不是，我们接着看\n  </div>\n  <div>\n   DFS搜索到1，这时候并没有出边开始执行add操作，我们将1节点加入最后的欧拉回路序列\n  </div>\n  <div>\n   函数递归回溯，2依然没有多余的的出边add 2\n  </div>\n  <div>\n   函数递归回溯，3这时有多余的出边指向4，继续递归至顶点4\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    1——&gt;2——&gt;3——&gt;1——&gt;\n   </span>\n   3——&gt;4——&gt;3\n  </div>\n  <div>\n   又回到了顶点3这时候，顶点3也没有多余的出边，add 3\n   <span style=\'font-size:12px\'>\n    目前的序列有:1,2,3\n   </span>\n  </div>\n  <div>\n   函数回溯至顶点4，顶点4没有多余的出边，add 4\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    1——&gt;2——&gt;3——&gt;1——&gt;\n   </span>\n   <span style=\'font-size:13.3333px\'>\n    3\n   </span>\n   <br/>\n  </div>\n  <div>\n   函数回溯至顶点3,3没有多余的出边，add 3\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    1——&gt;2——&gt;3——&gt;1 add1\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     1——&gt;2——&gt;3 add 3\n    </span>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      1——&gt;2 add 2\n     </span>\n     <br/>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <span style=\'font-size:13.3333px\'>\n       1 add 1\n      </span>\n      <br/>\n     </span>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <span style=\'font-size:13.3333px\'>\n       最终结果1 2 3 4 3 1 3 2 1\n      </span>\n     </span>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <span style=\'font-size:13.3333px\'>\n       <br/>\n      </span>\n     </span>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <span style=\'font-size:13.3333px\'>\n       通过上面的模拟我们已经可以发现了这个逐步插入回路法的DFS的实现的精髓了\n      </span>\n     </span>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <span style=\'font-size:13.3333px\'>\n       实际上我们第一次搜索会起点的时候，就是找到了一个圈，然后我们函数回溯找每个节点是否还有多余的出边，有多余的出边就从这个入口节点我们就继续递归下去（进入一个连通分量），直到返回到入口节点，直到入口节点没有多余的出边的时候我们这时开始回溯一次回溯连通分量，将连通分量加入结果序列直到将整个圈上的所有的顶点都回溯完之后，返回最开始的起点，欧拉回路查找完毕\n      </span>\n     </span>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <span style=\'font-size:13.3333px\'>\n       <br/>\n      </span>\n     </span>\n    </span>\n   </span>\n  </div>\n  <div>\n   当然，大家会说这是有向图的算法啊，无向图其实也是一样的思路和想法\n  </div>\n  <div>\n   先附上有向图的代码：\n  </div>\n  <div>\n   POJ 2230\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1994657\' name=\'code\' snippet_file_name=\'blog_20161119_3_5389359\'>/*\nProblem: 2230		User: lantianheyeqi\nMemory: 3776K		Time: 860MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 100005\n\nusing namespace std;\n//实现的数据结构是用链式前向星模拟邻接表\nint u[N];\nint v[N];\nint next[N];\nint first[N];\nint n,m;\nbool book[N];\n\nvoid dfs(int root)\n{\n	int k=first[root];\n	while(k!=-1)\n	{\n		if(book[k]!=1)\n		{\n			book[k]=1;\n			dfs(v[k]);\n		}\n		k=next[k];\n	}\n	printf(\'%d\n\',root);\n}\n\nint main()\n{\n	memset(book,0,sizeof(book));\n	scanf(\'%d%d\',&amp;n,&amp;m);\n	for(int i=1;i&lt;=m;i++) scanf(\'%d%d\',&amp;u[i],&amp;v[i]);\n	memset(first,-1,sizeof(first));\n	for(int i=1;i&lt;=2*m;i++)\n	{\n		next[i]=first[u[i]];\n		first[u[i]]=i;\n	}\n	dfs(1);\n	return 0;\n}</pre>\n   <h2>\n    4.Fleury算法\n   </h2>\n  </div>\n  <div>\n   Fleury(弗洛莱)算法\n  </div>\n  <div>\n   所谓的更为简单的求解欧拉回路的算法\n  </div>\n  <div>\n   首先我们需要了解一下边割集合的概念：\n  </div>\n  <div>\n   我们定义在图G中，如果我们删去边集E得到GN，导致图的连通分量的个数p(GN)&gt;p(G)，并且G删去E的任何一个子集都不会导致p(G)增加，那么我们定义E为G的一个边割集，如果边割集中只有一个元素，我们成该边为\n   <strong>\n    桥\n   </strong>\n  </div>\n  <div>\n   <strong>\n    <br/>\n   </strong>\n  </div>\n  <div>\n   <strong>\n    Fleury算法：\n   </strong>\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/278549/201304/22202826-99e00b3bc7064fa2a2c6d08b86ff7f35.jpg\'/>\n   <br/>\n  </div>\n  <div>\n   证明不会，但是我需要讲解几点算法的实现的步骤\n  </div>\n  <div>\n   1.首先我们想要快速的判断一个边是不是桥，这里我们需要引入Tarjan算法，时间复杂度是O(E+V)\n  </div>\n  <div>\n   2.之后我们遍历完整个图找到一条欧拉回路，算法的时间复杂度是O(E)\n  </div>\n  <div>\n   3.整体的时间复杂度大致是O(E+V)\n  </div>\n  <h2>\n   5.遗留问题\n  </h2>\n  <div>\n   1.Tarjan算法\n  </div>\n  <div>\n   2.为什么都说Fleury比DFS的效率高\n  </div>\n  <div>\n   3.求解半欧拉图（欧拉通路）的算法\n  </div>\n  <div>\n   4.无向图的补充\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('3a6b62b45aa72974e1321d2792c8d904','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1287 MST Prim+Krustral\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Code:\n  </h2>\n  <div>\n   Prim：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1990622\' name=\'code\' snippet_file_name=\'blog_20161117_3_395351\'>/*\nProblem: 1287		User: lantianheyeqi\nMemory: 4132K		Time: 63MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1005\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint map[N][N];\nint n,m;\nint heap[N];\nint pos[N];\nint heapnum;\nint dis[N];\n\nvoid swap(int x,int y)\n{\n	int t=heap[x];\n	heap[x]=heap[y];\n	heap[y]=t;\n	\n	t=pos[heap[x]];\n	pos[heap[x]]=pos[heap[y]];\n	pos[heap[y]]=t;\n}\n\nvoid siftdown(int x)\n{\n	int t;\n	while(2*x&lt;=heapnum)\n	{\n		if(dis[heap[x]]&gt;dis[heap[x*2]]) t=x*2;\n		else t=x;\n		if(x*2+1&lt;=heapnum&amp;&amp;dis[heap[x*2+1]]&lt;dis[heap[t]]) t=x*2+1;\n		if(x!=t)\n		{\n			swap(x,t);\n			x=t; \n		}\n		else break;\n	}\n} \n\nvoid siftup(int i)\n{\n	while(i!=1)\n	{\n		if(dis[heap[i]]&lt;dis[heap[i/2]])\n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else break;\n	}\n}\n\nint pop()\n{\n	int tt=heap[1];\n	heap[1]=heap[heapnum--];\n	siftdown(1);\n	return tt;\n}\n\nvoid init()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		heap[i]=i;\n		pos[i]=i;\n	}\n	for(int i=heapnum/2;i&gt;=1;i--) siftdown(i);\n}\n\nvoid prim()\n{\n	int book[N];\n	memset(book,0,sizeof(book));\n	heapnum=n;\n	for(int i=1;i&lt;=n;i++) dis[i]=map[1][i];\n	int sum=0;\n	book[1]=1;\n	dis[1]=0;\n	init();\n	pop();\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int minpoint=pop();\n		book[minpoint]=1;\n		sum+=dis[minpoint];\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j])\n			{\n				dis[j]=map[minpoint][j];\n				siftup(pos[heap[j]]);\n			}\n		}\n	}\n	printf(\'%d\n\',sum);\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)&amp;&amp;n!=0)\n	{\n		for(int i=1;i&lt;N;i++)\n		{\n			for(int j=1;j&lt;N;j++)\n			{\n				map[i][j]=INF;\n			}\n		}\n		for(int i=1;i&lt;=m;i++)\n		{\n			int dx,dy,dz;\n			scanf(\'%d%d%d\',&amp;dx,&amp;dy,&amp;dz);\n			if(dz&lt;map[dx][dy]) map[dx][dy]=map[dy][dx]=dz;\n		}\n		prim(); \n	}\n	return 0;\n}</pre>\n   Krustral：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1990622\' name=\'code\' snippet_file_name=\'blog_20161117_2_602311\'>/*\nProblem: 1287		User: lantianheyeqi\nMemory: 980K		Time: 32MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'algorithm\'\n#define N 100000\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n	int weight;\n}point;\n\nint n,m;\npoint edge[N];\nint fa[N];\nint deep[N];\n\nbool cmp(point a,point b)\n{\n	if(a.weight&gt;b.weight) return false;\n	else return true;\n}\n\nvoid init()\n{\n	for(int i=1;i&lt;N;i++)\n	{\n		fa[i]=i;\n		deep[i]=1;\n	}\n}\n\nint find(int x)\n{\n	if(x==fa[x]) return x;\n	else return fa[x]=find(fa[x]); \n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y]) fa[y]=x;\n		else\n		{\n			fa[x]=y;\n			if(deep[y]==deep[x]) deep[y]++;\n		}\n	}\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)&amp;&amp;n!=0)\n	{\n		init();\n		int sum=0;\n		for(int i=1;i&lt;=m;i++)\n		{\n			scanf(\'%d%d%d\',&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].weight);\n		}\n		sort(edge+1,edge+1+m,cmp);\n		for(int i=1;i&lt;=m;i++)\n		{\n			if(!same(edge[i].x,edge[i].y))\n			{\n				sum+=edge[i].weight;\n				unit(edge[i].x,edge[i].y);\n			}\n		}\n		printf(\'%d\n\',sum);\n	}\n	return 0;\n} </pre>\n   <div>\n    <br/>\n   </div>\n   堆优化Prim始终过不了，急求大神：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1990622\' name=\'code\' snippet_file_name=\'blog_20161117_3_395351\'>/*\nProblem: 1287		User: lantianheyeqi\nMemory: 4132K		Time: 63MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1005\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint map[N][N];\nint n,m;\nint heap[N];\nint pos[N];\nint heapnum;\nint dis[N];\n\nvoid swap(int x,int y)\n{\n	int t=heap[x];\n	heap[x]=heap[y];\n	heap[y]=t;\n	\n	t=pos[heap[x]];\n	pos[heap[x]]=pos[heap[y]];\n	pos[heap[y]]=t;\n}\n\nvoid siftdown(int x)\n{\n	int t;\n	while(2*x&lt;=heapnum)\n	{\n		if(dis[heap[x]]&gt;dis[heap[x*2]]) t=x*2;\n		else t=x;\n		if(x*2+1&lt;=heapnum&amp;&amp;dis[heap[x*2+1]]&lt;dis[heap[t]]) t=x*2+1;\n		if(x!=t)\n		{\n			swap(x,t);\n			x=t; \n		}\n		else break;\n	}\n} \n\nvoid siftup(int i)\n{\n	while(i!=1)\n	{\n		if(dis[heap[i]]&lt;dis[heap[i/2]])\n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else break;\n	}\n}\n\nint pop()\n{\n	int tt=heap[1];\n	heap[1]=heap[heapnum--];\n	siftdown(1);\n	return tt;\n}\n\nvoid init()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		heap[i]=i;\n		pos[i]=i;\n	}\n	for(int i=heapnum/2;i&gt;=1;i--) siftdown(i);\n}\n\nvoid prim()\n{\n	int book[N];\n	memset(book,0,sizeof(book));\n	heapnum=n;\n	for(int i=1;i&lt;=n;i++) dis[i]=map[1][i];\n	int sum=0;\n	book[1]=1;\n	dis[1]=0;\n	init();\n	pop();\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int minpoint=pop();\n		book[minpoint]=1;\n		sum+=dis[minpoint];\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j])\n			{\n				dis[j]=map[minpoint][j];\n				siftup(pos[heap[j]]);\n			}\n		}\n	}\n	printf(\'%d\n\',sum);\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)&amp;&amp;n!=0)\n	{\n		for(int i=1;i&lt;N;i++)\n		{\n			for(int j=1;j&lt;N;j++)\n			{\n				map[i][j]=INF;\n			}\n		}\n		for(int i=1;i&lt;=m;i++)\n		{\n			int dx,dy,dz;\n			scanf(\'%d%d%d\',&amp;dx,&amp;dy,&amp;dz);\n			if(dz&lt;map[dx][dy]) map[dx][dy]=map[dy][dx]=dz;\n		}\n		prim(); \n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4fa4f9e0e044de908a5a1b21409519e1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2349 MST Prim\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   抽象概括题意：\n  </div>\n  <div>\n   现在给你一个些点的坐标，每个坐标都是正整数，现在每个点之间都有一个连边（稠密图）\n  </div>\n  <div>\n   现在求最小生成树MST的第n-s/n-1条边的长度，具体选哪个，我们根据s代销来判断，在程序中我已经写明了\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   标准的稠密图，我们最好用Prim，如果用Krustral的话，最坏的情况500*500的边，很容易超时\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1988951\' name=\'code\' snippet_file_name=\'blog_20161116_1_5558733\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'algorithm\'\n#include\'cmath\'\n#define N 505\n#define INF 0x7fffffff\n\nusing namespace std;\n\ndouble dis[N];\ndouble map[N][N];\nint s,p;\ndouble save[N];\nint num_edge;\nint book[N];\nint dx[N];\nint dy[N];\n\ndouble cal(int x,int y)\n{\n	double a=1.0*(dx[x]-dx[y])*(dx[x]-dx[y]);\n	double b=1.0*(dy[x]-dy[y])*(dy[x]-dy[y]);\n	return sqrt(0.0+a+b);\n}\n\nbool cmp(double x,double y)\n{\n	if(x&gt;y) return false;\n	else return true;\n}\n\nvoid prim()\n{\n	memset(book,0,sizeof(book));\n	for(int i=0;i&lt;p;i++) dis[i]=map[0][i];\n	num_edge=0;\n	book[0]=1;\n	for(int i=1;i&lt;=p-1;i++)\n	{\n		int mink=INF;\n		int minpoint;\n		for(int j=0;j&lt;p;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&lt;mink)\n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		}\n		book[minpoint]=1;\n		save[num_edge++]=dis[minpoint];\n		for(int j=0;j&lt;p;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j])\n			{\n				dis[j]=map[minpoint][j];\n			}\n		}\n	}\n	sort(save,save+num_edge,cmp);\n	if(s==0) printf(\'%.2lf\n\',save[num_edge-1]);\n	else printf(\'%.2lf\n\',save[num_edge-s]);\n}\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		scanf(\'%d%d\',&amp;s,&amp;p);\n		memset(map,0,sizeof(map));\n		for(int i=0;i&lt;p;i++) scanf(\'%d%d\',&amp;dx[i],&amp;dy[i]);\n		for(int i=0;i&lt;p;i++)\n		{\n			for(int j=0;j&lt;p;j++)\n			{\n				map[i][j]=cal(i,j);\n			}\n		}\n		prim();\n	} \n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('48e582d95a1ecc7a0e06f7da2c85cbef','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  DAG - AOV - AOE - CPM - Topological-Sort 详解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.DAG(Directed acycline graph)\n  </h2>\n  <div>\n   DAG图，又称有向无环图，简称为DAG，DAG是相对更像是有向树一样的数据结构，用处十分的广泛\n  </div>\n  <div>\n   <strong>\n    1.表达式树：\n   </strong>\n  </div>\n  <div>\n   DAG可以模拟表达式树，按照数据结构老师的话来说，在操作系统方面的用处更加的广泛\n  </div>\n  <div>\n   <strong>\n    2.检查图的环路：\n   </strong>\n  </div>\n  <div>\n   我们都知道检查一个无向图是否存在回路是非常的简单的，我们只需要DFS遍历一遍就能判断出来\n  </div>\n  <div>\n   但是我们检查一个有向图是否有环确实非常的困难，这是后我们就需要用到基于DAG的一些基本而算法来解决这类或者更加复杂的问题\n  </div>\n  <div>\n   <strong>\n    3.工程项目管理中：\n   </strong>\n  </div>\n  <div>\n   在现实生活中，我们的工程项目的管理完全可以用DAG图进行模拟，一般来说，我们的模拟的形式有两种，一种是AOV，一种是AOE，这两种我们后续会进行讲解\n  </div>\n  <div>\n   现在我们基本上了解了什么是DAG，我们现在来看一下在DAG上的一些基本的操作和算法\n  </div>\n  <h2>\n   2.Topological-Sort\n  </h2>\n  <div>\n   拓扑排序：\n  </div>\n  <div>\n   什么是拓扑排序，我用我自己的语言来组织一下，拓扑排序的意思就是，在一个偏序关系上\n  </div>\n  <div>\n   我们通过排序操作生成一个序列，这个序列中的任意两个元素之间如果存在偏序关系的话，那么前面的元素必定在后面元素的前面\n  </div>\n  <div>\n   我们重新理解一下就是，我们将DAG图中的（有向图）中的所有的偏序关系我们通过一个序列的形式抽象成一个逻辑关系，这个逻辑关系保证了所有元素并第十按照次序发生（推导）的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   摘引一些好理解的话：（援引自百度百科）\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://g.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=41e28531040828387c00d446d9f0c264/37d12f2eb9389b50295fce7c8635e5dde7116e7f.jpg\'/>\n   <br/>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:arial,宋体,sans-serif; font-size:14px; line-height:24px; text-indent:28px\'>\n    例如，假定一个计算机专业的学生必须完成图3-4所列出的全部课程。在这里，课程代表活动，学习一门课程就表示进行一项活动，学习每门课程的先决条件是学完它的全部先修课程。如学习《数据结构》课程就必须安排在学完它的两门先修课程《离散数学》和《算法语言》之后。学习《高等数学》课程则可以随时安排，因为它是基础课程，没有先修课。若用AOV网来表示这种课程安排的先后关系，则如图3-5所示。图中的每个顶点代表一门课程，每条有向边代表起点对应的课程是终点对应课程的先修课。图中的每个顶点代表一从图中可以清楚地看出各课程之间的先修和后续的关系。如课程C5的先修课为C2，后续课程为C4和C6。\n   </span>\n   <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px; font-family:arial,宋体,sans-serif; text-indent:28px\'>\n    [2]\n   </span>\n   <br/>\n  </div>\n  <div>\n   <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px; font-family:arial,宋体,sans-serif; text-indent:28px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px; font-family:arial,宋体,sans-serif; text-indent:28px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px; font-family:arial,宋体,sans-serif; text-indent:28px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px; font-family:arial,宋体,sans-serif; text-indent:28px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px; font-family:arial,宋体,sans-serif; text-indent:28px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px; font-family:arial,宋体,sans-serif; text-indent:28px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   现在我们对拓扑排序有了一定的了解，我们现在来关注于如何求解拓扑序列\n  </div>\n  <div>\n   求解拓扑序列有两种方法：\n  </div>\n  <h3>\n   1.Kahn算法：\n  </h3>\n  <div>\n   算法的原理如下：\n  </div>\n  <div>\n   1.我们找到图中的所有的入度为0的节点加入栈\n  </div>\n  <div>\n   2.将栈顶的节点的所有的边的弧头顶点入度递减\n  </div>\n  <div>\n   3.如果递减之后的结果为0，我们入栈，否则，pass\n  </div>\n  <div>\n   4.弹出栈顶\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   如果我们的生成的拓扑序列中的节点的个数和图中的定点的个数是相同的话，说明我们的图是拓扑有序的，也就间接证明了我们的图是DAG图\n  </div>\n  <div>\n   但是一旦缺少节点，就说明途中存在环，因为在环路中任何的节点的入度都不是0，所以我们没有办法删除节点\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   Kahn算法不仅可以生成拓扑序列还可以帮助我们检测一个有向图是不是DAG\n  </div>\n  <div>\n   对于时间复杂度来说，因为我们的Kahn算法只进行了遍历所有的点和所有的的边的操作，所以时间复杂度是O(v+e),V,E都是顶点和边的数目\n  </div>\n  <div>\n   但是我们为了达到这个时间复杂度需要引入栈这个数据结构，这是唯一的缺点\n  </div>\n  <h3>\n   2.DFS - 反向构图\n  </h3>\n  <div>\n   我们求解拓扑序列的另一个方法就是DFS,不过在这里我们的DFS的思路有些不同\n  </div>\n  <div>\n   首先，我们先说明，该算法虽然我们不需要Kahn算法的引入一个额外的辅助数据结构栈，但是我们DFS需要堆图进行反向构图\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   先上伪代码：（摘引自Wiki）\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1987854\' name=\'code\' snippet_file_name=\'blog_20161116_1_4692430\'>L ← Empty list that will contain the sorted nodes\nS ← Set of all nodes with no outgoing edges   //刚好和Kahn反过来，我们从没有出度的顶点开始\nfor each node n in S do\n    visit(n) \nfunction visit(node n)\n    if n has not been visited yet then\n        mark n as visited\n        for each node m with an edgefrom m to ndo\n            visit(m)\n        add n to L</pre>\n   该算法最核心的一步操作就是我们的最后的add n to l\n  </div>\n  <div>\n   算法的原理我描述一下就是，我们反向构图的时候，我们的目的是为了可以正确的查找到该点的前驱，就是这个目的，所以我们的所有的有向边都需要反向，在我们内存中，我们的抽象的数据的存储结构可以通过增加逆邻接表实现\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   算法的原理：\n  </div>\n  <div>\n   我们从任意一个汇点出发，一旦找到了没有出度的顶点，我们就需要开始进行回溯操作，这时候我们存出结果就是拓扑序列\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   相对于Kahn算法来说，我们DFS的方法虽然不需要利用栈来存储结构，但是我们需要对图进行反向，这时候一旦我们对有向图有些的要求的时候，我们就不能满足了，在实际情况中，我们视情况来决定就好\n  </div>\n  <div>\n   时间复杂度也是一样，因为我们都是遍历了所有的顶点和所有的边O(v+e)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.AOV\n  </h2>\n  <div>\n   AOV网的定义是我们的所有的顶点代表我们的活动，我们的所有的边代表我们的活动之间的次序关系，AOV网的图更符合我们的显示生活中的习惯，我们的AOV王德图实际上更像是一个哈斯图，我们吐过AOV网可以清楚地明确所哟的活动之间的发生的次序关系\n  </div>\n  <div>\n   AOV王德定义决定AOV必须是一个DAG图，因为AOV网中不允许一个活动是以自己为其实的条件的，这和我们的显示的逻辑是相矛盾的\n  </div>\n  <div>\n   但是在求解CPM问题的时候，我们的AOV网的用处不大，因为我们的CPM要求姐关键路径的话，我们需要知道活动的权值和长度，这在AOV中反应的并不明显\n  </div>\n  <div>\n   这时候，我们引入另一个DAG图\n  </div>\n  <h2>\n   3.AOE+CPM（DP思想）\n  </h2>\n  <div>\n   AOE网：\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先引入两个必要的性质\n  </div>\n  <div>\n   <p style=\'font-size:18.018px; line-height:29.2793px; margin:10px auto; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif\'>\n    <strong>\n     AOE网的性质\n    </strong>\n    ：\n   </p>\n   <p style=\'font-size:18.018px; line-height:29.2793px; margin:10px auto; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif\'>\n    ⑴ 只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始；\n   </p>\n   <p style=\'font-size:18.018px; line-height:29.2793px; margin:10px auto; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif\'>\n    ⑵ 只有在进入某顶点的各活动都结束，该顶点所代表的事件才能发生。\n   </p>\n   <br/>\n  </div>\n  <div>\n   边表示活动的网，边的权值代表了活动的周期，顶点表示事件，弧表示活动，我们通常利用AOE网来估算项目的工期\n  </div>\n  <div>\n   首先为了求解cpm问题（关键路径）我们先来了解几个定义和性质\n  </div>\n  <div>\n   <strong>\n    1.CP的定义\n   </strong>\n  </div>\n  <div>\n   CP全称是Critical Path，又叫关键路径，关键路径的长度是指从项目的起始点开始一直到终止点的最长的路径的长度，在关键路径上的活动的长度可以直接的反应出我们的工期的大小\n  </div>\n  <div>\n   <strong>\n    2.事件：\n   </strong>\n  </div>\n  <div>\n   我们在AOV网中定义事件为网的节点，我们成一个时间代表的含义就是，该事件的表示（在该事件之前的所有的邻接的活动全部的终止和之后的所有的临街的活动的开始）这个事件，有些绕口，好好理解就明白了\n  </div>\n  <div>\n   <strong>\n    3.活动：\n   </strong>\n  </div>\n  <div>\n   我们在AOV网中的活动定义为DAG图的有向b边，有向边的权值代表我们的活动的周期\n  </div>\n  <div>\n   <strong>\n    DP思想\n   </strong>\n  </div>\n  <div>\n   <strong>\n    4.事件的最早发生时间 - Ve\n   </strong>\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://pic002.cnblogs.com/images/2010/202684/2010120210112337.png\'/>\n   <br/>\n  </div>\n  <div>\n   如图来说，我们的vk事件想要发生的话，按照我么AOV网的性质，vk之前的所有的活动必须都要结束才行，这里的货，我们的最早发生时间就必须要取\n  </div>\n  <div>\n   max(ve[j]+weight&lt;j,k&gt;)才可以\n  </div>\n  <div>\n   定义\n  </div>\n  <div>\n   ve[k]=\n   <span style=\'font-size:13.3333px\'>\n    max(ve[j]+weight&lt;j,k&gt;) (&lt;j,k&gt;在DAG边集中)\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    ve[0]=0\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <strong>\n     5.事件的最晚发生时间 - Vl\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <strong>\n     <img alt=\'\' src=\'http://pic002.cnblogs.com/images/2010/202684/2010120210171421.png\'/>\n     <br/>\n    </strong>\n   </span>\n  </div>\n  <div>\n   如图，我们求解事件的最晚发生时间，需要逆推\n  </div>\n  <div>\n   因为我们vk事件想要最晚发生，至少我们必须要让之后的所有的事件的最晚发生时间都要保证满足，这是性质2\n  </div>\n  <div>\n   定义：\n  </div>\n  <div>\n   vl[k]=min(vl[j]-weight&lt;k,j&gt;) (&lt;k,j&gt;在DAG的边集中)\n  </div>\n  <div>\n   vl[n]=ve[n]\n  </div>\n  <div>\n   <strong>\n    6.活动的最早发生时间 - E\n   </strong>\n  </div>\n  <div>\n   我们的活动的想要最早发生只有当活动的前驱关联顶点事件最早发生即可，所以这里\n  </div>\n  <div>\n   E[k]=Ve[i] (i是k边（活动）的前驱结点)\n  </div>\n  <div>\n   <strong>\n    7.活动的最晚发生时间 - L\n   </strong>\n  </div>\n  <div>\n   我们的活动的最晚发生时间仍然需要我们逆推来进行\n  </div>\n  <div>\n   L[k]=Vl[i]-weight&lt;K&gt; (i是K活动的后继节点)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    我们定义E[k]=L[k]的活动就是关键活动，从起点到汇点的连续的关键活动构成关键路径\n   </strong>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么上面的我就已经列举了我们的所有的需要求解CPM问题的所有的内容了\n  </div>\n  <div>\n   下面我们开始商讨一下怎么求解\n  </div>\n  <div>\n   1.拓扑排序\n  </div>\n  <div>\n   求解关键路径，我们需要再AOE网的拓扑有序的前提下进行，我们首先需要对AOE网进行拓扑排序\n  </div>\n  <div>\n   如果我们的拓扑排序的结果显示AOE网不是一个DAG图的话，我们就会发现，该图就不存在CP\n  </div>\n  <div>\n   也就是换句话来说，我们只有在拓扑有序和逆拓扑有序的前提下，我们的AOE网存在CP，否则不存在关键路径\n  </div>\n  <div>\n   但是我们这里需要注意一下，并不是说所有的关键活动都可以构成关键路径，但是关键路径上的活动都是关键活动，有的关键活动并不参与构成关键路径\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.\n  </div>\n  <div>\n   在拓扑排序的前提下之后\n  </div>\n  <div>\n   我们开始在拓扑序列的基础上开始求解Ve,Vl,E,L\n  </div>\n  <div>\n   我们的定义拓扑排序的序列的第一个元素的Ve=0，那么我们就可以顺利的得到所有的Ve，Vl，E，L\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.\n  </div>\n  <div>\n   我们找到所有的E,L相同的活动，这些活动就是我们的关键活动，此时我们想要打印我们的关键路径的时候，我们可以利用DFS的图的遍历的思路，从起点开始一次的向下查找，知道找到终点的时候我们将保存的节点的序列输出就是我们的关键路径的节点的序列\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   4.Code:\n  </h2>\n  <div>\n   核心的求解四个重要的参数的函数\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1987854\' name=\'code\' snippet_file_name=\'blog_20161116_2_2675326\'>void creat_important_data()\n{\n	ve[stack[0]]=0;\n	for(int i=1;i&lt;stack_num;i++)\n	{\n		eedge* help=reve_table[stack[i]].next;\n		int maxp=-1;\n		if(help==NULL)\n		{\n			ve[stack[i]]=0;\n			continue;\n		}\n		while(help!=NULL) \n		{\n			int sum=ve[help-&gt;i]+help-&gt;weight;\n			if(maxp&lt;sum) maxp=sum;\n			help=help-&gt;next;\n		}\n		ve[stack[i]]=maxp;\n	}\n	\n	vl[stack[stack_num-1]]=ve[stack[stack_num-1]];\n	for(int i=stack_num-2;i&gt;=0;i--)\n	{\n		eedge* help=next_table[stack[i]].next;\n		int minp=INF;\n		while(help!=NULL)\n		{\n			int sum=vl[help-&gt;j]-help-&gt;weight;\n			if(minp&gt;sum) minp=sum;\n			help=help-&gt;next;\n		}\n		vl[stack[i]]=minp;\n	}\n\n    for(int i=0;i&lt;num_edge;i++) e[i]=ve[search[i].i];\n    for(int i=0;i&lt;num_edge;i++) \n    {\n    	l[i]=vl[search[i].j]-search[i].weight;\n    }\n    \n    memset(important_path,0,sizeof(important_path));\n    memset(important_point,0,sizeof(important_point));\n    for(int i=0;i&lt;num_edge;i++)\n    {\n    	if(e[i]==l[i]) important_path[i]=1,important_point[search[i].j]=1;\n    }\n}</pre>\n   <br/>\n   <h2>\n    5.遗留问题：\n   </h2>\n  </div>\n  <div>\n   1.如何找到缩短工期的CPM的松弛时间和松弛策略\n  </div>\n  <div>\n   2.如何自动根据输入的活动关系自动生成AOE网\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4d79c036f710cbea0aa48ad62fd1bf53','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1251 MST Krustral\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意:\n  </div>\n  <div>\n   题目中说明了是边数不会超过75，可见是稀疏图，我们直接Krustral 0MS水过\n  </div>\n  <div>\n   来测模板了\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题唯一的难点在于理解题意，和图的构建\n  </div>\n  <div>\n   没什么难的\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1985064\' name=\'code\' snippet_file_name=\'blog_20161115_1_8671373\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'algorithm\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	char atom;\n	int x;\n	int y;\n	int weight;\n}point;\n\npoint edge[100];\nint n;\nint edgenum=0;\nint fa[10000];\nint book[10000];\n\nvoid init(int n)\n{\n	for(int i=0;i&lt;n;i++) fa[i]=i;\n}\n\nint find(int x)\n{\n	if(fa[x]==x) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else fa[x]=y;\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nbool cmp(point a,point b)\n{\n	if(a.weight&gt;b.weight) return false;\n	else return true;\n}\n\nint main()\n{\n	int ans=0;\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n)\n	{\n		edgenum=0;\n		memset(edge,0,sizeof(edge));\n		memset(book,0,sizeof(book));\n		ans=0;\n		getchar();\n		for(int i=1;i&lt;n;i++) \n		{\n			int k;\n			char p[10];\n			scanf(\'%s%d\',p,&amp;k);\n			for(int j=0;j&lt;k;j++)\n			{\n				char save[10];\n				int kk;\n				scanf(\'%s%d\',save,&amp;kk);\n				edgenum++;\n				edge[edgenum].atom=p[0];\n				edge[edgenum].x=p[0]-\'A\';\n				edge[edgenum].y=save[0]-\'A\';\n				edge[edgenum].weight=kk;\n			}\n		}\n		sort(edge+1,edge+edgenum+1,cmp);\n		init(n);\n		int count=0;\n		for(int i=1;i&lt;=edgenum;i++)\n		{\n			if(!same(edge[i].x,edge[i].y))\n			{\n				count++;\n				ans+=edge[i].weight;\n				unit(edge[i].x,edge[i].y);\n				if(count==n-1) break;\n			}\n		}\n		printf(\'%d\n\',ans);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('e5568b14bff666b7f49d30df7cf23b1a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3625 - MST\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   输入：n,m\n  </div>\n  <div>\n   n代表已经点个数，m表示有多少条边已经连接成功\n  </div>\n  <div>\n   本题是一个稠密图，每两个点之间都有边相连\n  </div>\n  <div>\n   之后的输入的代表两个点之间有连边\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   输出：\n  </div>\n  <div>\n   最小的需求，本题是一个稠密图\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   因为是稠密图，本题的Krustral没有Prim快\n  </div>\n  <div>\n   本题是一个Prim的版题，但是不知道为什么，可能是精度的问题，导致的已知在WA\n  </div>\n  <div>\n   之后莫名其妙的AC\n  </div>\n  <div>\n   我们的已经存在的连边，我们只要在稠密图中优先连接就可以了\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1983335\' name=\'code\' snippet_file_name=\'blog_20161114_1_5051478\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'cmath\'\n#define INF 0x3f3f3f3f\n#define N 1010\n\nusing namespace std;\n\ntypedef struct node\n{\n	double x,y;\n}point;\n\ndouble map[N][N];\ndouble dis[N];\nint n,m;\npoint save[N];\nint book[N];\n\ndouble cal(int i,int j)\n{\n	double vx=(save[i].x-save[j].x)*(save[i].x-save[j].x);\n	double vy=(save[i].y-save[j].y)*(save[i].y-save[j].y);\n	return sqrt(vx+vy+0.0);\n}\n\ndouble prim()\n{\n	memset(dis,0,sizeof(dis));\n	memset(book,0,sizeof(book));\n	double sum=0;\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=map[1][i];\n	}\n	dis[1]=0;\n	book[1]=1;\n	for(int i=1;i&lt;=n;i++)\n	{\n		double mink=100000000;\n		int minpoint;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&lt;mink) \n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		}\n		if(mink==100000000) break;\n		book[minpoint]=1;\n		sum+=mink;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j])\n			{\n				dis[j]=map[minpoint][j];\n			}\n		}\n	}\n	return sum;\n}\n\nint main()\n{\n	scanf(\'%d%d\',&amp;n,&amp;m);\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=i;j&lt;=n;j++)\n		{\n			map[i][j]=100000000;\n		}\n	}\n	for(int i=1;i&lt;=n;i++)\n	{\n		scanf(\'%lf%lf\',&amp;save[i].x,&amp;save[i].y);\n	}\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		    map[i][j]=cal(i,j);\n	}\n	for(int i=1;i&lt;=m;i++)\n	{\n		int dx,dy;\n		scanf(\'%d%d\',&amp;dx,&amp;dy);\n		map[dx][dy]=map[dy][dx]=0;\n	}\n	double kk=prim();\n	printf(\'%.2lf\n\',kk);\n	return 0;\n}\n</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('7975d1ad5334dcf35773d6e3604c4ae0','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1861 - MST - Krustral\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   输入：\n  </div>\n  <div>\n   第一行两个数字，第一个n\n   <span style=\'font-size:12px\'>\n    代表是点数，第二个m代表边数\n   </span>\n  </div>\n  <div>\n   之后的m行代表有m个边，前两个代表两个点，第三个数字代表权重\n  </div>\n  <div>\n   输出：\n  </div>\n  <div>\n   MST中最大的边\n  </div>\n  <div>\n   边的个数（n-1）\n  </div>\n  <div>\n   将边集列出来\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   标准的套模板，1861的题目的标准样例有一些问题，但是不应向我们做题，毕竟是Special Judge\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1981539\' name=\'code\' snippet_file_name=\'blog_20161112_1_9593064\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'algorithm\'\n#define N 20000\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n	int weight;\n}point;\n\npoint edge[N];\nint number_of_point;\nint number_of_edge;\nint fa[N];\nint deep[N];\nbool book[N];   //记录那个边被选择 \n\nvoid init()\n{\n	for(int i=0;i&lt;=number_of_point;i++) fa[i]=i,deep[i]=0;\n}\n\nint find(int x)\n{\n	if(fa[x]==x) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y]) fa[y]=x;\n		else\n		{\n			fa[x]=y;\n			if(deep[x]==deep[y]) deep[y]++;\n		}\n	}\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nbool cmp(point a,point b)\n{\n	if(a.weight&gt;b.weight) return false;\n	else return true;\n}\n\nint main()\n{\n	int maxp=0;\n	cin&gt;&gt;number_of_point&gt;&gt;number_of_edge;\n	init();\n	for(int i=1;i&lt;=number_of_edge;i++) cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].weight;\n	sort(edge+1,edge+number_of_edge+1,cmp);\n	\n	int count=0;\n	for(int i=1;i&lt;=number_of_edge;i++)\n	{\n		if(!same(edge[i].x,edge[i].y))\n		{\n			count++;\n			maxp=maxp&gt;edge[i].weight?maxp:edge[i].weight;\n			book[i]=true;\n			unit(edge[i].x,edge[i].y);\n		}\n		if(count==number_of_point-1) break;\n	}\n	printf(\'%d\n%d\n\',maxp,number_of_point-1);\n	for(int i=1;i&lt;=number_of_edge;i++) if(book[i]) printf(\'%d %d\n\',edge[i].x,edge[i].y);\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('d09c1654f8f43f622a8097ea2c20fda4','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  正则表达式 详解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.作用：搜索和替换——正则表达式的作用\n  </h2>\n  <br/>\n  <br/>\n  <h2>\n   2.匹配单个字符：\n  </h2>\n  <span style=\'white-space:pre\'>\n  </span>\n  正则表达式可以包含纯文本当然，这样用正则表达式也是一种浪费\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  正则表达式字母大小写敏感\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  匹配任意字符：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  .元字符可以匹配任意的 一个 字符\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  我们有时候在文本中还需要去匹配字符.这时候我们的正则表达式中的元字符.已经有了实际的含义，我们就必须对模式中的.进行转义\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  这时候我们利用元字符堆元字符.进行转义，这时候的正则表达式中.代表的就不是元字符的含义了，我们这时候代表的是.这个这个字符本身\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  换句话来说，正则表达式更像是一个模式，我们通过指定的模式去在源字符串中匹配相应的子串\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  但是并不是说正则表达式处理出来的说就是我们需要的而结果，我们还需要对正则表达式处理之后的数据结果再度利用\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   3.匹配一组字符\n  </h2>\n  <span style=\'white-space:pre\'>\n  </span>\n  元字符[],代表定义一个字符的范围，我们在该位置要待查的单个字符必须在这个元字符所框定的区间范围内，注意我们这里[]待查的是一个单个字符，只不过我们确定了一个范围的模式\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  优化，在正则表达式中，我么还要定义一种区间，在这个区间范围内的字符全部都满足我们正则表达式的要求\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  定义元字符-，在[]元字符之间，我们通过这种方式我们来表示一段字符区间，减少了我们枚举大量的字符的工作量\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  合法的字符区间：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  A-Z\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a-z\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  A-F\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  A-z  这里用的是ASCII的定义，我们的-连字符表示的是在ASCII范围内的字符连续区间，但常用的区间还是数字和字符区间\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  注意：我们定义区间的时候首位置必须要低于尾位置，否则会使得模式匹配失败\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  -元字符之后在[]之间才有司机的含义，在[]之外只是一个简单的纯文本匹配\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ^元字符表示我们取非，这个范围外的所有的字符都是符合匹配的，^效果是[]全局性的·\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   4.转义：\n  </h2>\n  我们都只到正则表达式存在很多的元字符，但是我们需要对元字符本身进行匹配的话的时候，我们就需要用到转义字符\n  <br/>\n  配对的[]不用做元字符的功用的时候我们必须要将其转移掉，否则正咋表达是会返回一个错误\n  <br/>\n  <br/>\n  <br/>\n  5.匹配空白元字符：\n  <br/>\n  在正则表达式中，我们的元字符的对象基本可以分为两种，一种是纯文本，另一种比较特殊的就是我们匹配空白字符\n  <br/>\n  \n\n  <br/>\n  \r\n  <br/>\n  f换页\n  <br/>\n  	\n  <br/>\n  v\n  <br/>\n  \r\n文本行的结束标记\n  <br/>\n  <br/>\n  <br/>\n  6.匹配特定的字符序列：\n  <br/>\n  字符类，我们称之为字符类\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  匹配数字（非数字）：[0-9]~[0123456789]~[^0123456789]~[^0-9]\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  但是我们的正则表达式支持我们的d（任何一个数字）,D（任何一个非数字）\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  匹配数字和字母：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  w任何一个数字字母下划线,相当于[a-zA-Z0-9_]\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  W[^a-zA-Z0-9_]\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  匹配空白字符：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  s任何一个空白字符[f\n\r	v]\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  S相反[^f\n\r	v]\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  匹配十六进制或者匹配八进制\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   第五章：\n   <span style=\'white-space:pre\'>\n   </span>\n   重复匹配\n  </h2>\n  以上的内容我们讲解了如何匹配单个字符，现在下面的额内容我们来讲解一下如何同一时间匹配大量的多个字符（重复出现的字符或字符集合）\n  <br/>\n  <br/>\n  <br/>\n  <h3>\n   1.+\n  </h3>\n  想要多次的匹配一个字符我们就只需要在要重复的字符后面加上+，表示重复就可以了\n  <br/>\n  这里注意+至少匹配一个，不匹配0个字符\n  <br/>\n  给字符集合加上+的时候，我们的+必须放置在元字符[]的外面\n  <br/>\n  在这里，+也是一个元字符，我们想要匹配+就必须要对+进行转义\n  <br/>\n  其实在字符集合元字符[]中，我们的其他的元字符都不用手动转移，我们的编辑器自动会将我们的[]元字符内的元字符转义\n  <br/>\n  <br/>\n  <br/>\n  <h3>\n   2.*\n  </h3>\n  但是有的时候，我们对摸个字符的需要又是，我们有时候还需要匹配到没有该字符的情况，也就是该字符我们可以匹配0到任意多次\n  <br/>\n  这是后我们的+元字符就没有用处了，我们这时候需要用到*元字符来实现这个功能\n  <br/>\n  <br/>\n  <br/>\n  <h3>\n   3.?\n  </h3>\n  有时候，我们有需要匹配0个或者1个字符，这时候我们就需要用到?元字符，该元字符的意义就是，前面被限定的字符或者字符集合只能被匹配0，或者1次\n  <br/>\n  <br/>\n  <br/>\n  <h3>\n   4.重复次数{}\n  </h3>\n  在这里，我们会发现+，*，？匹配的次数下线是0，或者1，上限没有确定，但是一旦我们需要确定一个重复的范围，我们就没有办法只通过这三种元字符来实现精确的控制了\n  <br/>\n  这时候，我们引入{}元字符\n  <br/>\n  首先{}本身也是两个元字符，如果我么想要对他们本身做模式匹配我们就需要使用转移符号\n  <br/>\n  就用#336633这种颜色的RGB值来看，我们会发现我们如果想用+*?来精确匹配是必须要连着写六次的，但是我们完全可以用{6}来表示这个意思，只有精确的匹配了六次我们才算是一个成功的匹配，否则我们都认为匹配失败\n  <br/>\n  <br/>\n  <br/>\n  <h3>\n   5.{}设定重复的范围区间\n  </h3>\n  {}语法还支持我们为串设定一个匹配的次数的区间，也就是说，我们可以为重复的匹配次数设定一个最小值和最大值，语法类似于{2,4}意思就是最少重复2次，最大重复4次\n  <br/>\n  重复的次数设定成0次\n  <br/>\n  {3,}表示只设定了最小下界，上界没有限制\n  <br/>\n  <br/>\n  <br/>\n  <h3>\n   6.过度匹配\n  </h3>\n  除了{},?这种确定性的匹配元字符\n  <br/>\n  我们定义的+*都是不确定长度的元字符，这两种元字符我们在进行处理的时候实际上都是采用贪婪的准则，尽可能在允许的范围内匹配尽可能多匹配串\n  <br/>\n  但是我们有时候与不想一次性匹配那么多的元字符，这时候我们就需要懒惰版本的+*元字符，实际上就是在\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  1.*?\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  2.+?\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  3.{n,}?\n  <br/>\n  就有这三种懒惰的元字符匹配版本\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   第六章：位置匹配\n  </h2>\n  注意这里的^,$代表的是要匹配的字符串的开头和结尾的性质，如果开头有则满足这个性质开始匹配，开头没有这个性质我们则认为没有找到任何匹配，^$之后和之前的紧邻的一个字符就是我们要找的字符串的开头或者结尾的属性\n  <br/>\n  1.\n  <br/>\n  首先我们需要了解位置匹配符匹配的不是一个字符，他只是匹配一个位置\n  <br/>\n  有时候我们不只是要对所有的文章进行匹配，我们需要对一段文章的某一段的位置的文本进行匹配，这时候我们就引入了位置匹配的概念\n  <br/>\n  在正则表达式中我么使用位置界定元字符来界定我们的匹配的位置\n  <br/>\n  只匹配一个位置，不匹配任何的字符\n  <br/>\n  匹配的位置的描述是匹配一个w和W之间的一个位置，也就是它用来分割一个单词\n  <br/>\n  相反，B匹配的是一个不是单词边界的一个字符位置（可能的情况是：非单词+非单词，这里的+代表的是连接）\n  <br/>\n  <br/>\n  <br/>\n  2.字符串边界\n  <br/>\n  定义字符串边界的元字符有两个\n  <br/>\n  定义字符串开头^(这里的^元字符实际上是一种多用途元字符)——只有在^紧跟在[之后的时候才会发挥求非操作，如果放在[]的外面并且位于模式串的开头我们知识后定义为字符串位置元字符开头，其余的时候都只是简单地模式匹配\n  <br/>\n  定义字符串结尾$\n  <br/>\n  <br/>\n  <br/>\n  3.分行匹配模式\n  <br/>\n  有的语言的正则表达式引擎支持分行字符串分割标志\n  <br/>\n  有时候我们要将一整段文本匹配出来，我们这时候就需要用(?m)分行字符串匹配元字符，这个元字符的意思是，我们定义分行符是做字符串模式匹配的结尾，这样就会避免贪婪字符的任意匹配从而实现将一行的元素都匹配出来\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   第七章: 子表达式\n  </h2>\n  1.什么是子表达式：\n  <br/>\n  我们都知道，大多数的元字符都只是支持对我们的元字符的前一个或者后一个字符进行修饰\n  <br/>\n  eg:\n  <br/>\n  ;{2,}\n  <br/>\n  但是我们有时候想让{2,}对一个表达式进行修饰，而不仅仅是{}之前的一个字符，这个时候我们就需要用的打字表达式\n  <br/>\n  <br/>\n  <br/>\n  2.定义：\n  <br/>\n  子表达式是更大的表达式的一部分，我们将一个大的表达式进行分解，分解成相应的几个小的表达式，我们的目的是将这些表达式当成一个独立的元素来使用，子表达式我们用()阔起来\n  <br/>\n  注意()也是一种元字符，一旦我们需要在文本中对()进行匹配的话，我们就需要用转义符号(或者)\n  <br/>\n  这时候我们的一个子表达式中的所有的元素就会单独作为一种元素被整体的修饰\n  <br/>\n  这里我们再引入一个|元字符，该元字符的作用是或匹配，我们每次都匹配|前或者后面的文本，但是这里就会要注意到和()的联合使用，因为|识别的时候我们的|有可能将后面的整个文本都当成是一个元素，这时我们就需要()\n  <br/>\n  (|)就可以很好的解决这个问题\n  <br/>\n  <br/>\n  <br/>\n  3.子表达式的嵌套\n  <br/>\n  理论上子表达式的嵌套没有限制层数，但是在实际中我们要适可而止，我们通常将()和|紧密结合，可以写出\n  <br/>\n  功能强大的枚举出所有的可行解的情况的正则表达式\n  <br/>\n  其实我们还可以说，()是对|做出了精确地定义        其实()子表达式优点相当于是我们的高级程序设计语言中的逻辑判断的结合\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   第八章：\n   <span style=\'white-space:pre\'>\n   </span>\n   回溯引用，前后一致匹配\n  </h2>\n  这一张我们来讲解子表达式的另一个用处，就是定义定义回溯引用\n  <br/>\n  1.回溯引用有什么用处：\n  <br/>\n  加入我们需要匹配HTML文档中的标签，我们就需要利用&lt;[Hh][1-6]&gt;.*?&lt;/[hH][1-6]&gt;这样的文档标签，但是我们这里需要注意到，如果出现了\n  <br/>\n  &lt;h2&gt;....&lt;/h3&gt;的情况，我们的正则表达式是检查不出错误的，这时候我们就需要利用子表达是的另一个应用，也就是我们所谓的回溯引用\n  <br/>\n  <br/>\n  <br/>\n  2.定义回溯引用，回溯引用值得是模式的后半部分 引用在前半部分中定义的子表达式，说实在的回溯引用有点相当于是一个变量\n  <br/>\n  我们这里的回溯引用1,2,3...\n的意思就是我们那回溯引用之前定义的第n个子表达式\n  <br/>\n  <br/>\n  <br/>\n  3.注意：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  回溯引用只能引用模式里的子表达式\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  回溯引用通常从1开始计数，但是有时候\0也是合法的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  这里的第几个子表达式的定义我们是根据相对位置来判断的\n  <br/>\n  <br/>\n  <br/>\n  4.这里的回溯引用在文本的替换操作的时候，用的将会非常的频繁，但是我们的替换操作需要两个正则表达式，一个用来个给出搜索模式，另一个我们用来寻求文本的替换模式，回溯引用可以跨模式使用\n  <br/>\n  在第一个搜索的正则表达式中的文本我们可以在替换的正则表达式中进行回溯引用\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   第九章：前后查找\n  </h2>\n  前言，有时候，我们需要对文本的莫一部分特定的查找内容，但是我们又不想将文本的特定的表示符抽取出来，我们只想要文本的内容，这时候后我们\n  <br/>\n  为了防止文本的多余查找，引入了前后查找的概念\n  <br/>\n  <br/>\n  <br/>\n  1.向前查找：\n  <br/>\n  向前查找制定了一个我们必须要匹配的但是不在结果中返回的模式，向前查找实际上也就是一个子表达式\n  <br/>\n  eg:\n  <br/>\n  我们想要将URL的协议名称提取出来，但是我们只要协议的名称，这时候，我们这么来用向前查找的子表达式\n  <br/>\n  .+(?=:)这里我们的.+的意思就是提取协议的名称，比如http，https，ftp等等\n  <br/>\n  之后的(?=:)子表达式的意思就是，我们定义一个子表达式（向前查找）制定的内容是:也就是说，我们将:之前的所有的文本都匹配出来，但是我们又不要:这个符号作为我们的匹配的返回的结果\n  <br/>\n  <br/>\n  <br/>\n  2.根据我们的额描述，其实任意一个子表达式都可以转化成对应的一个向前查找的模式匹配的子串，我们需要做的额就是只是给子表达式加上一个?=的子串罢了\n  <br/>\n  <br/>\n  <br/>\n  3.?=我们称之为是向前查找操作符，除了向前查找之外，很多的正则表达式还支持向后查找?&lt;=\n  <br/>\n  <br/>\n  <br/>\n  4.向前查找的模式的长度是随意的，是可变的，我们支持在子表达式中使用.*/.+之类的元字符，但是向后查找我们限定了固定的长度，这是所有的正则表达式都遵守的规则\n  <br/>\n  <br/>\n  <br/>\n  5.我们那还可以将向前查找和向后查找结合起来就可以实现对我们上述提到的HTML 文本的标题内容提取的作用了\n  <br/>\n  <br/>\n  <br/>\n  6.总计一下，我们的前后查找额实际上的作用是帮我们确定一个我们想要确定的模式的一个具体位置，这里我们引入一条书与，在之前的我们利用前后查找的思路实际上都可以称作是正向前或者\n  <br/>\n  正向后查找，整的意思是寻找匹配\n  <br/>\n  还有一种匹配的模式叫做负向前和负向后查找文本，即我们向前或者向后擦好渣和莫表的文本不匹配的文本，我们的这种的表示符也很简单\n  <br/>\n  (?=) -&gt; (?!)\n  <br/>\n  (?&lt;=) -&gt; (?&lt;!)\n  <br/>\n  <br/>\n  <br/>\n  <h2>\n   第十章：  嵌入条件\n  </h2>\n  1.正则表达式支持在表达式的内部嵌入条件处理的功能\n  <br/>\n  2.正则表达式中的条件我们必须要用?去处理和定义\n  <br/>\n  <br/>\n  <br/>\n  3.回溯引用条件：\n  <br/>\n  回溯引用条件只在我们的前一个表达式搜索成功的时候我们才允许使用一个表达式\n  <br/>\n  <br/>\n  <br/>\n  4.定义语法:\n  <br/>\n  (?(一个回溯引用代表条件,这里的天上的是前面的子表达式的下跪的为止，一般都是从1开始,并且里面的数字不能用之前我么扽回溯引用的转义，这是个特殊的语法格式，记住就好)(........这是一个只有在前面的回溯引用执行成功的时候才会执行的子表达式))\n  <br/>\n  上面的条件判断式是没有else语句的，要加上否则判断的话，我们需要另外一个语法格式\n  <br/>\n  (?(回溯引用的标号)(yes时执行的子表达式)|(false执行的子表达式))\n  <br/>\n  <br/>\n  <br/>\n  5.前后查找条件\n  <br/>\n  上面我们讲述了回溯引用的查找条件，现在我们来讲解另一个查找条件，家偶偶前后查找条件\n  <br/>\n  前后查找条件，我们只在一个向前查找或者向后查找成功的时候我们才调用\n  <br/>\n  我们的语法的格式是\n  <br/>\n  (?(?=)(操作成功之后要执行匹配的子表达式))\n  <br/>\n  但是实际上，我们的工作中很少会用到嵌入了前后查找的子表达式\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1c61f6c193600e6526a2d7acea004646','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2531 - DFS - 经典\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   有一个无向图，现在，我们需要将无向图进行划分，是的，每两个点之间都有连边，并且两边集合的点之间边有权值，集合内的点之间没有权值，现在求最大的情况是多少\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   真的是一道非常新颖的DFS的思路，我们需要做的就是穷尽所有的可能情况\n  </div>\n  <div>\n   1.我们首先假设，所有的点都在0集合\n  </div>\n  <div>\n   2.我们穷举的情况是，所有的点在0,1之间的分布\n  </div>\n  <div>\n   3.在DFS中，我们不断的维护最大值就好了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   本题的新颖指出不仅在于思想\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   还在于代码的实现过程中\n  </div>\n  <div>\n   我们穷举所有的情况的过程中，要动态的维护一个book全局变量，我们在DFS中的搜索顺序是将\n  </div>\n  <div>\n   所有的的点不管是不是属于1集合，我们都默认的将其加入1集合，然后再反向回溯从而枚举素有的情况\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1979154\' name=\'code\' snippet_file_name=\'blog_20161111_1_6737698\'>/*\nProblem: 2531		User: *************\nMemory: 676K		Time: 141MS\nLanguage: G++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 23\n\nusing namespace std;\n\nint map[N][N];\nint n;\nbool book[N];   //判断是在0,1中 \nint sum=0;\n\nvoid dfs(int p,int ans)\n{\n	book[p]=1;\n	int count=ans;\n	for(int i=1;i&lt;=n;i++)\n	{\n		if(book[i]==1) count-=map[p][i];\n		else count+=map[p][i]; \n	}\n	if(count&gt;sum) sum=count;\n	for(int i=p+1;i&lt;=n;i++)\n	{\n		dfs(i,count);\n		book[i]=0;\n	}\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;n);\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++) scanf(\'%d\',&amp;map[i][j]);\n	}\n	memset(book,0,sizeof(book));\n	\n	dfs(1,0);\n	printf(\'%d\n\',sum);\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('996954f342e94e042f8988b3dac4ffbd','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Leetcode 3 - 最大不重复子串\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   有一个字符串，现在让我们求出最大的不重复的连续的子串的长度\n  </div>\n  <div>\n   <p style=\'margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:30px\'>\n    <span style=\'font-weight:700\'>\n     Examples:\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:30px\'>\n    Given\n    <code style=\'font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n     \'abcabcbb\'\n    </code>\n    , the answer is\n    <code style=\'font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n     \'abc\'\n    </code>\n    ,\r\n which the length is 3.\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:30px\'>\n    Given\n    <code style=\'font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n     \'bbbbb\'\n    </code>\n    , the answer is\n    <code style=\'font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n     \'b\'\n    </code>\n    ,\r\n with the length of 1.\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:30px\'>\n    Given\n    <code style=\'font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n     \'pwwkew\'\n    </code>\n    , the answer is\n    <code style=\'font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n     \'wke\'\n    </code>\n    ,\r\n with the length of 3. Note that the answer must be a\n    <span style=\'font-weight:700\'>\n     substring\n    </span>\n    ,\n    <code style=\'font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n     \'pwke\'\n    </code>\n    is\r\n a\n    <span style=\'\'>\n     subsequence\n    </span>\n    and not a substring.\n   </p>\n   <h2>\n    2.Solution:\n   </h2>\n  </div>\n  <div>\n   本题有两种思路：\n  </div>\n  <div>\n   第一种，我们视每一个字母都是一个连续的不重复的子串的开始的话，我们可以利用O(n^2)的时间复杂度遍历每一种情况，然后找到最大的一种情况\n  </div>\n  <div>\n   这种思路会超时\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   第二种思路很好想，我一开始就想到是这种的解题思路：\n  </div>\n  <div>\n   我们定义一个头指针，定义一个尾指针，每一次我们头尾指针确定一个不重复的连续 的子串\n  </div>\n  <div>\n   一旦我们遇到一个相同的我们就让头指针后移到不重复的位置然后维护我们的最大只存放的变量，知道我们的为指针扫描完整个的字符串\n  </div>\n  <div>\n   直接输出最大的长度就可以啦\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   本质上，第二种思路算是一种动态规划，我们的状态就是头尾指针的位置（最大的维护的长度）\n  </div>\n  <div>\n   状态转移方程就是，每次不重复的话，我们直接的递增\n  </div>\n  <div>\n   相同的话，位移头指针然后继续\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于判断重复的情况，因为题目限定用字符串的，我们采用256大小的数组散列一下就可以了\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1977838\' name=\'code\' snippet_file_name=\'blog_20161110_1_8716565\'>int lengthOfLongestSubstring(char* s) {\n    int max_lengthp=0;\n    int book[256];\n    for(int i=0;i&lt;256;i++) book[i]=0;\n    int i=0;\n    int j=0;\n    int length=strlen(s);\n    while(j&lt;length)\n    {\n        if(book[(int)s[j]]==1)\n        {\n            while(s[i]!=s[j]) book[(int)s[i++]]=0;\n            i++;\n        }\n        book[(int)s[j]]=1;\n        j++;\n        if(j-i&gt;max_lengthp) max_lengthp=j-i;\n    }\n    max_lengthp=max_lengthp&gt;(j-i)?max_lengthp:(j-i);\n    return max_lengthp;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2ae9cd250326d37dc969c5c1d2da85d4','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3087 - STL(map)+滚动数组\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <strong>\n    <em>\n     目的：通过本题熟悉C++，STL标准模板库中的map强大容器的基本操作\n    </em>\n   </strong>\n  </div>\n  <div>\n   题意：\n  </div>\n  <div>\n   Shuffle游戏\n  </div>\n  <div>\n   输入：\n  </div>\n  <div>\n   第一次输入的t代表数据的测试用例个数\n  </div>\n  <div>\n   之后的c代表我们玩的牌的每组牌的牌数(0&lt;C&lt;100)\n  </div>\n  <div>\n   之后两行代表我们的两座拍的顺序，顺序输入时从底向上的（从左到右）\n  </div>\n  <div>\n   最后一行输入代表我们要活的的最终的状态，现在问我们进过多少次操作可以获得我们的最终状态，如果我们可以获得最终状态，输出我们的最小步数，如果不能到达最终的状态，输出-1\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   现在定义操作，我们每次从S1牌堆底部抽取出一张牌，我们再从S2牌堆的底部抽取一张牌，反别反顾一个新牌堆的顶部\n  </div>\n  <div>\n   之后混合后的牌堆，我们去最底下的c个是一个牌堆S1，上面的c个是新的S2重新进行操作，直到与我们的目标相同位置\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题说实话其实和搜索没有关系，只是一道简单的查找题目，如果我们硬要说的话，就是一个但入口的DFS/BFS，我们的核心不在于搜索，而在于判重，一旦重复，说明形成回路，永远无法到达目标，这时候我们输出-1\n  </div>\n  <div>\n   但是这是一个长度位100的字符串，我们想要对字符串进行标记的话，我们只能想到哈希表的散列了\n  </div>\n  <div>\n   为了哈希充分的话，我们的采用拉链法更节省时间，但是我们首先要知道，既然长度是100位的话，就算我们用二进制来模拟的娿，至少需要10^30大小的一个洒泪范围，或者说我们让装填因子达到 200%的话，65536K的内存限制的话，我们最大只允许开到10^8的散列，按照我们的最坏的情况的话，装填因子都是10^28这是绝对无法容忍的\n  </div>\n  <div>\n   这里字符串哈希的我们的思路就只能作罢\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   所以这时候我们就需要用到STL 的map\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先我们来简单的了解一下STL类的map容器，这里面的map其实就相当于是Python的字典，爱时记得实现中STL的map容器采用的是红黑树，平衡二叉树的算法非常的精妙，我们这里就不考虑map的核心实现，我们这里考虑map容器的接口\n  </div>\n  <div>\n   主要操作函数：\n  </div>\n  <div>\n   0.首先，我们需要引入map库，#include\'map\'\n  </div>\n  <div>\n   1.定义一个map，默认的值是0，map&lt;type1,type2&gt;name;\n  </div>\n  <div>\n   2.插入一个项：\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   name[key]=value;   //该操作的插入式覆盖式的插入\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   map&lt;type1,type2&gt;.insert(pair&lt;type1,type2&gt;(value1,value2))\n  </div>\n  <div>\n   3.empty():判断是否存在过，否说明没有\n  </div>\n  <div>\n   4.clear():清空\n  </div>\n  <div>\n   5.size():大小\n  </div>\n  <div>\n   6.迭代：\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     map&lt;int, string&gt;::reverse_iterator  iter;\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     {\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     Cout&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     }\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     7.find():根据键值查找项\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     8.删除数据项：\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     map&lt;int, string&gt;::iterator iter;\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     iter = mapStudent.find(1);\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     mapStudent.erase(iter);\n    </span>\n   </p>\n   <br/>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     本题中，我们利用到的map的是判断的函数就是数组调用，判断数据项是否存在就可以，速度很快\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     <br/>\n    </span>\n   </p>\n   <p style=\'color:rgb(51,51,51)\'>\n    <span style=\'font-family:Times New Roman; font-size:14px\'>\n     另外，本题我才用了滚动数组进行优化，利用了标志域atom和1的异或实现了滚动的效果\n    </span>\n   </p>\n   <h2 style=\'color:rgb(51,51,51)\'>\n    3.Code:\n   </h2>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1977594\' name=\'code\' snippet_file_name=\'blog_20161110_1_770471\'>/*\nProblem: 3087		User: *************\nMemory: 708K		Time: 0MS\nLanguage: G++		Result: Accepted\n*/ \n#include\'iostream\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'cstdio\'\n#include\'map\'\n\nusing namespace std;\n\nchar s1[105];\nchar s2[105];\nchar e[210];\nchar move[2][210];\nint c;\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);getchar();\n	int step;\n	for(int j=1;j&lt;=t;j++)\n	{\n		memset(move,0,sizeof(move));\n		memset(s1,0,sizeof(s1));\n		memset(s2,0,sizeof(s2));\n		map&lt;string,bool&gt;book;   //map缺省值是0 \n		step=0;\n		scanf(\'%d\',&amp;c);getchar(); \n		gets(s1);\n		gets(s2);\n		gets(e);\n		for(int i=0;s1[i]!=\'\0\';i++) move[0][i]=s1[i];\n		for(int i=0;s2[i]!=\'\0\';i++) move[0][i+c]=s2[i];\n		if(strcmp(move[0],e)==0)\n		{\n			 printf(\'%d 0\n\',j);\n			 continue;\n		} \n		int atom=0;\n		while(true)\n		{\n			int k;\n			for(int i=0,k=0;k&lt;2*c;i++,k+=2)\n			{\n				move[atom^1][k]=move[atom][i+c];\n				move[atom^1][k+1]=move[atom][i];\n			}\n			if(strcmp(e,move[atom^1])==0) \n			{\n				step++;\n				break;\n			}\n			if(book[move[atom^1]])\n			{\n				step=-1;\n				break;\n			}\n			else book[move[atom^1]]=true,step++;\n			atom^=1;\n		}\n		printf(\'%d %d\n\',j,step);\n	} \n	return 0;\n}</pre>\n    <br/>\n    <br/>\n   </div>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ed7ba1d3a836fe65c6589c468b3e7e07','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3414 - Easy BFS - 六入口倒水问题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题目描述：\n  </div>\n  <div>\n   有两个杯子，a，b，我们现在给定一个数据c\n  </div>\n  <div>\n   现在有这么三种操作：\n  </div>\n  <div>\n   <ol style=\'font-family:\'Times New Roman\',Times,serif; font-size:16px\'>\n    <li>\n     FILL(i)        fill the pot\n     <strong>\n      i\n     </strong>\n     (1 ≤\n     <strong>\n      i\n     </strong>\n     ≤ 2) from the tap;\n    </li>\n    <li>\n     DROP(i)      empty the pot\n     <strong>\n      i\n     </strong>\n     to the drain;\n    </li>\n    <li>\n     POUR(i,j)    pour from pot\n     <strong>\n      i\n     </strong>\n     to pot\n     <strong>\n      j\n     </strong>\n     ; after this operation either the pot\n     <strong>\n      j\n     </strong>\n     is full (and there may be some water left in the pot\n     <strong>\n      i\n     </strong>\n     ), or the pot\n     <strong>\n      i\n     </strong>\n     is empty (and all its\r\n contents have been moved to the pot\n     <strong>\n      j\n     </strong>\n     ).\n    </li>\n   </ol>\n   1.的意思是哦们将i杯子倒满\n  </div>\n  <div>\n   2.意思是我们将i杯子倒空\n  </div>\n  <div>\n   3.意思是我们将i的水倒入j中，直到i为空或者j已经满为止\n  </div>\n  <div>\n   现在求我们如果可以能够任意一个杯子实现装够c水量认为操作成功，让我们输出操作的序列，如果不存在这样的一组操作，输出impossible\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   因为本题的数据量很小，只有1~100，所以说本题就是一道经典的BFS题目\n  </div>\n  <div>\n   我们将题目抽象一下，其实本题就相当于一个有六个入口的BFS\n  </div>\n  <div>\n   FILL(1)\n  </div>\n  <div>\n   FILL(2)\n  </div>\n  <div>\n   DROP(1)\n  </div>\n  <div>\n   DROP(2)\n  </div>\n  <div>\n   POUR(1)\n  </div>\n  <div>\n   POUR(2)\n  </div>\n  <div>\n   这六种操作只要我们可以人以实现对应的操作的处理数据对象的是c，我们救人为成功，本题没有什么的思维难度\n  </div>\n  <div>\n   有几个注意点\n  </div>\n  <div>\n   PS:本题既然强调我们打印出操作的序列，我们就需要用到栈和队列的回溯指针，其实我们在队列的每个元素中添加一个指向前一个head位置的指针域就可以很好的解决回溯查找的问题\n  </div>\n  <div>\n   2.我们回溯查找的时候，记得将本次的操作的状态变量一起保存起来\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1974938\' name=\'code\' snippet_file_name=\'blog_20161109_1_3408095\'>/*\nProblem: 3414		User: *************\nMemory: 752K		Time: 16MS\nLanguage: G++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 100000\n\nusing namespace std;\n\ntypedef struct node\n{\n	int a;\n	int b;\n	int pre;   //记录队列中的前驱\n	char pre_atom;   //上一个动作，\'1\'代表fill1 \'2\'代表fill2 \'3\'drop1  \'4\'drop2 \'5\'pour1-&gt;2 \'6\'pour2-&gt;1 \n}point;\n\nint a,b,c;\npoint queue[N];\nint head;\nint tail;\nbool book[105][105];   //标记数组 \n\nvoid print()\n{\n	char stack[N];\n	int n=1;\n	for(int i=tail-1;;)\n	{\n		if(queue[i].pre==-1) break;\n		else stack[n++]=queue[i].pre_atom;\n		i=queue[i].pre;\n	}\n	printf(\'%d\n\',n-1);\n	for(int i=n-1;i&gt;=1;i--)\n	{\n		switch(stack[i])\n		{\n			case \'1\':printf(\'FILL(1)\n\');break;\n			case \'2\':printf(\'FILL(2)\n\');break;\n			case \'3\':printf(\'DROP(1)\n\');break;\n			case \'4\':printf(\'DROP(2)\n\');break;\n			case \'5\':printf(\'POUR(1,2)\n\');break;\n			case \'6\':printf(\'POUR(2,1)\n\');break;\n		}\n	}\n}\n\nbool bfs()\n{\n	memset(book,0,sizeof(book));\n	head=1;\n	tail=2;\n	queue[1].a=0,queue[1].b=0,queue[1].pre=-1,queue[1].pre_atom=\'\0\';   //第一个动作的特殊标记\n	book[a][b]=1;\n	point p;\n	while(head!=tail)\n	{\n		//fill 1\n		p.a=a;\n		p.b=queue[head].b;\n		p.pre=head;\n		p.pre_atom=\'1\';\n		if(book[p.a][p.b]);\n		else queue[tail++]=p,book[p.a][p.b]=1;\n		if(queue[tail-1].a==c||queue[tail-1].b==c) return true;\n		//2\n		p.a=queue[head].a;\n		p.b=b;\n		p.pre=head;\n		p.pre_atom=\'2\';\n		if(book[p.a][p.b]);\n		else queue[tail++]=p,book[p.a][p.b]=1;\n		if(queue[tail-1].a==c||queue[tail-1].b==c) return true;\n		//3\n		p.a=0;\n		p.b=queue[head].b;\n		p.pre=head;\n		p.pre_atom=\'3\';\n		if(book[p.a][p.b]);\n		else queue[tail++]=p,book[p.a][p.b]=1;\n		if(queue[tail-1].a==c||queue[tail-1].b==c) return true;\n		//4\n        p.a=queue[head].a;\n		p.b=0;\n		p.pre=head;\n		p.pre_atom=\'4\';\n		if(book[p.a][p.b]);\n		else queue[tail++]=p,book[p.a][p.b]=1;\n		if(queue[tail-1].a==c||queue[tail-1].b==c) return true;\n		//5\n		if(queue[head].a&lt;(b-queue[head].b))\n		{\n			p.a=0;\n			p.b=queue[head].b+queue[head].a;\n			if(book[p.a][p.b]);\n			else\n			{\n				book[p.a][p.b]=1;\n				p.pre=head;\n				p.pre_atom=\'5\';\n				queue[tail++]=p;\n			}\n		}\n		else\n		{\n			p.a=queue[head].a-(b-queue[head].b);\n			p.b=b;\n			if(book[p.a][p.b]);\n			else\n			{\n				book[p.a][p.b]=1;\n				p.pre=head;\n				p.pre_atom=\'5\';\n				queue[tail++]=p;\n			}\n		}\n		if(queue[tail-1].a==c||queue[tail-1].b==c) return true;\n		//6\n		if(queue[head].b&lt;(a-queue[head].a))\n		{\n			p.a=queue[head].a+queue[head].b;\n			p.b=0;\n			if(book[p.a][p.b]);\n			else\n			{\n				book[p.a][p.b]=1;\n				p.pre=head;\n				p.pre_atom=\'6\';\n				queue[tail++]=p;\n			}\n		}\n		else\n		{\n			p.a=a;\n			p.b=queue[head].b-(a-queue[head].a);\n			if(book[p.a][p.b]);\n			else\n			{\n				book[p.a][p.b]=1;\n				p.pre=head;\n				p.pre_atom=\'6\';\n				queue[tail++]=p;\n			}\n		}\n		if(queue[tail-1].a==c||queue[tail-1].b==c) return true;\n		head++;\n	} \n	return false;\n} \n\nint main()\n{\n	scanf(\'%d%d%d\',&amp;a,&amp;b,&amp;c);\n	if(bfs()) print();\n	else printf(\'impossible\n\');\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('39e429b41da4567bd9aa14e7d6b77419','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  LeetCode 1 - 哈希\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   给你一个字符串序列，再给你一个指定的数字的大小，现在询问你有没有尽可能快的思路去找到两个数的和满足这个目标的数\n  </div>\n  <div>\n   本题的原型大致是这样的，我们给你一个有序的数列，现在要你在有序的序列中去找两个数之和满足一个条件\n  </div>\n  <div>\n   在一个有序的数列中，找到这样的要求的两个数是十分的简单的\n  </div>\n  <div>\n   我们大致的思路就是头指针，尾指针，然后不断的向中间移动，比预计的数字大的话，我们就西安移动右指针缩小我们的数字的和，但是一旦我们的两书之和比预计的额数要小，我们就移动左指针，目的是让我们的预计和变大\n  </div>\n  <div>\n   证明这个算法的思路的正确性：\n  </div>\n  <div>\n   我们可以逆推，我们加入找到了两个数之和满足这个性质，很显然我们任意向外移动在会两个指针，那么我们在有序的列表中找到的，必然是一个小的数挥着一个大的数，那么我们的变换总可以通过郑重形式转化到新的正确的成立的两个树的位置上去\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   但是恩替不一样，本题强调的是无序的数组，要求我们返回的是两个数字的下表\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   对于无序的两个数，我们也不是没有办法，我们完全可以利用哈希的思路\n  </div>\n  <div>\n   与到一个数，我们见这个数存储到相应的地址下表上，然后遇到下一个数我们就直接判断一下和目标数的插存不存在者只需要O(1)的时间复杂度，比我们枚举所有的情况的O(n*2)要好很多了\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1973481\' name=\'code\' snippet_file_name=\'blog_20161108_1_7750815\'>/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* twoSum(int* nums, int numsSize, int target) {\n    int* result=(int*)malloc(sizeof(int)*2);\n    int hash[100000];\n    int rehash[100000];\n    for(int i=0;i&lt;100000;i++) hash[i]=rehash[i]=-1;\n    for(int i=0;i&lt;numsSize;i++)\n    {\n        int key=target-nums[i];\n        if(key&gt;=0&amp;&amp;hash[key]!=-1)\n        {\n            result[0]=hash[key];\n            result[1]=i;\n            break;\n        }\n        else if(key&lt;0&amp;&amp;rehash[-key]!=-1)\n        {\n            result[0]=rehash[-key];\n            result[1]=i;\n            break;\n        }\n        else\n        {\n            if(nums[i]&gt;=0) hash[nums[i]]=i;\n            else rehash[-nums[i]]=i;\n        }\n    }\n    return result;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b5aa026bdd910225105a20852a8af085','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Leetcode 2 - Add Two Numbers\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <div class=\'question-title clearfix\' style=\'padding-bottom:10px; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(238,238,238); margin-top:1em; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\'>\n    <h3 style=\'font-family:inherit; font-weight:500; line-height:1.1; color:inherit; margin-top:0px; margin-bottom:10px; font-size:24px; display:inline-block; margin-right:0.5em\'>\n     2. Add Two Numbers\n    </h3>\n    <span class=\'fa fa-lg fa-star add-favor not-favor\' style=\'\' title=\'\'>\n    </span>\n    <div class=\'pull-right top-buttons\' style=\'float:right\'>\n     <div class=\'btn-group right-pad\' style=\'position:relative; display:inline-block; vertical-align:middle; margin-right:15px\'>\n      <button class=\'btn btn-default active\' style=\'\' type=\'button\'>\n       Question\n      </button>\n      <button class=\'btn btn-default\' style=\'\' type=\'button\'>\n       Editorial Solution\n      </button>\n     </div>\n     <a class=\'btn btn-default\' href=\'https://leetcode.com/problems/add-two-numbers/submissions/\' style=\'\' target=\'_blank\'>\n      My Submissions\n     </a>\n    </div>\n   </div>\n   <div class=\'row col-md-12\' style=\'margin-right:-15px; margin-left:-15px; position:relative; min-height:1px; padding-right:15px; padding-left:15px; float:left; width:1140px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\'>\n   </div>\n   <div class=\'row\' style=\'margin-right:-15px; margin-left:-15px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\'>\n    <div class=\'col-md-12\' style=\'position:relative; min-height:1px; padding-right:15px; padding-left:15px; float:left; width:1170px\'>\n     <div class=\'question-info text-info\' style=\'color:rgb(49,112,143); float:right; margin:20px 0px 20px 20px; border:1px solid rgb(221,221,221); padding:15px 30px 15px 0px\'>\n      <ul style=\'margin-top:0px; margin-bottom:0px\'>\n       <li style=\'\'>\n        Total Accepted:\n        <span style=\'font-weight:700\'>\n         206533\n        </span>\n       </li>\n       <li style=\'\'>\n        Total Submissions:\n        <span style=\'font-weight:700\'>\n         804547\n        </span>\n       </li>\n       <li style=\'\'>\n        Difficulty:\n        <span style=\'font-weight:700\'>\n         Medium\n        </span>\n       </li>\n       <li style=\'\'>\n        Contributors:\n        <span style=\'font-weight:700\'>\n         Admin\n        </span>\n       </li>\n      </ul>\n     </div>\n     <div class=\'question-content\' style=\'margin-top:20px; margin-bottom:5px; line-height:30px; padding-bottom:2px\'>\n      <p style=\'margin-top:0px; margin-bottom:10px\'>\n      </p>\n      <p style=\'margin-top:0px; margin-bottom:10px\'>\n       You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n      </p>\n      <p style=\'margin-top:0px; margin-bottom:10px; font-family:monospace\'>\n       <span style=\'font-weight:700\'>\n        Input:\n       </span>\n       (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n       <br style=\'\'/>\n       <span style=\'font-weight:700\'>\n        Output:\n       </span>\n       7 -&gt; 0 -&gt; 8\n      </p>\n      <h2 style=\'margin-top:0px; margin-bottom:10px; font-family:monospace\'>\n       2.Solution:\n      </h2>\n      <div>\n       标准的链表的操作的题，本题我们模拟加法就可以了，注意进位，没有什么难的\n      </div>\n      <h2>\n       3.Code:\n      </h2>\n      <div>\n       <pre class=\'cpp\' code_snippet_id=\'1973452\' name=\'code\' snippet_file_name=\'blog_20161108_1_3540807\'>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode* p=l1;\n    struct ListNode* w=l2;\n    int lenp=0;\n    int lenw=0;\n    while(p!=NULL) p=p-&gt;next,lenp++;\n    while(w!=NULL) w=w-&gt;next,lenw++;\n    p=l1;\n    w=l2;\n    //struct ListNode* h;\n    int un=0;\n    if(lenw&gt;=lenp)\n    {\n        while(w!=NULL)\n        {\n            if(p!=NULL) w-&gt;val+=p-&gt;val+un;\n            else w-&gt;val+=un;\n            un=0;\n            if(p!=NULL) p=p-&gt;next;\n            if(w-&gt;val&gt;=10) w-&gt;val-=10,un++;\n            w=w-&gt;next;\n        }\n        if(un!=0)\n        {\n            w=l2;\n            while(w-&gt;next!=NULL) w=w-&gt;next;\n            struct ListNode* h=(struct ListNode*)malloc(sizeof(struct ListNode*));\n            h-&gt;val=un;\n            h-&gt;next=NULL;\n            w-&gt;next=h;\n        }\n        return l2;\n    }\n    else\n    {\n        while(p!=NULL)\n        {\n            if(w!=NULL) p-&gt;val+=w-&gt;val+un;\n            else p-&gt;val+=un;\n            un=0;\n            if(w!=NULL) w=w-&gt;next;\n            if(p-&gt;val&gt;=10) p-&gt;val-=10,un++;\n             p=p-&gt;next;\n        }\n        if(un!=0)\n        {\n            p=l1;\n            while(p-&gt;next!=NULL) p=p-&gt;next;\n            struct ListNode* h=(struct ListNode*)malloc(sizeof(struct ListNode*));\n            h-&gt;val=un;\n            un=0;\n            h-&gt;next=NULL;\n            p-&gt;next=h;\n        }\n        return l1;\n    }\n}</pre>\n       <br/>\n       <br/>\n      </div>\n      <div>\n       <br/>\n      </div>\n     </div>\n    </div>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('600b2aaab3d86604894aeffa81f77570','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3083 - 变向DFS + BFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   本题是一道非常好的搜索题，号不是好在本题混合了深搜和广搜，而是好在了本题的新的思路\n  </div>\n  <div>\n   首先，题意：\n  </div>\n  <div>\n   有一个迷宫，我们现在要求出在各种限制下的从S走到E的步数\n  </div>\n  <div>\n   首先题目限制了一定有解存在\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   1.我们现在定义初始方向，题目中明确说明了（我没有看到，半天没有理解题意），我们定义S的状态只有这么几种情况\n  </div>\n  <div>\n   S不会出现在地图的中间，S不会出现在地图的四个角落,S只会在地图的四条边上，我们现在声明S的初始方向就是S邻近的边的反方向\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.题目中第一个要求的限制就是，现在我们的移动策略是左转优先，也就是当前的方向的顺时针方向转动\n  </div>\n  <div>\n   题目中的第二个要求的限制就是，现在我们的移动策略是右转优先，也就是当前的方向的逆时针方向转动\n  </div>\n  <div>\n   题目中的第三个要求的限制就是，要求我们求出从S到E的最短路径，这个第三个是最好求得一个，简简单单的BFS就可以搞定\n  </div>\n  <div>\n   所以说我们的难点在于求有优先的第一和第二要求了，也就是变向的DFS\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   在这里我们会注意到，因为出现了左右转优先的定义，实际上，本题的难点不在于DFS本身，而在于DFS的变换方向的特性（这正是因为我们的左右转的优先引起的）\n  </div>\n  <div>\n   但是在这里我们解决问题的思路有两点需要注意：\n  </div>\n  <div>\n   1.不能标记：\n  </div>\n  <div>\n   根据我们题目的样例来看，我们左右转优先的步数是按照找到E的最终的步数来统计的，也就是说，本题中我们是允许走回头路的（但是回头路始终是最后一个需要考虑的走的方向，无论是顺时针还是逆时针）,所以，很显然，我们这里就不能标记方向了\n  </div>\n  <div>\n   但是我们处理的思路很奇妙，既然回头路是最后一个走的，说明走回头路的时候，其他的三个方向都行不通，也就是说，我们走到了死胡同，但是我们也不仅仅是走到了死胡同的时候才会走回头路（这一点自己体会，这里不好描述）\n  </div>\n  <div>\n   所以我们只要确定好了顺序的话其实是不不会出现无限循环的情况的，这一点我们即将解决\n  </div>\n  <div>\n   2.变向：\n  </div>\n  <div>\n   变向的处理，我们引入一个参数叫做\'当前的方向\'\n  </div>\n  <div>\n   我们怎么定义当前的方向都好，这里我给出我的参考：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1972812\' name=\'code\' snippet_file_name=\'blog_20161108_1_8741413\'>    4\n3  0  1\n    2\n这里的0代表当前的位置，3,4,1,2分别是我们的方向坐标系，在左转右转的条件下，我们的坐标系的转化就好写了\n定义当前的格子：\n    2\n1  N  3\n    4\n左转条件下的变换：\n方向4:1 2 3 4\n方向3:4 1 2 3\n方向2:3 4 1 2\n方向1:2 3 4 1\n右转条件下的变换：\n方向4:3 2 1 4\n方向3:2 1 4 3\n方向2:1 4 3 2\n方向1:4 3 2 1</pre>\n   以上，我们根据不同的转换规则写我们的move转移数组就好了\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1972812\' name=\'code\' snippet_file_name=\'blog_20161108_2_3136259\'>/*\nProblem: 3083		User: *************\nMemory: 728K		Time: 16MS\nLanguage: G++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n	int step;\n}point;\n\nint x,y;\nchar map[45][45];\nbool book[45][45];  //bfs\nint move_1[4][4][2]=    //map[0] - 1,map[1]-2   map[2]-3   map[3]-4 左偏向 \n{\n    {{-1,0},{0,1},{1,0},{0,-1}},\n    {{0,1},{1,0},{0,-1},{-1,0}},\n    {{1,0},{0,-1},{-1,0},{0,1}},\n    {{0,-1},{-1,0},{0,1},{1,0}}\n};\nint move_2[4][4][2]=   //右偏向 \n{\n	{{1,0},{0,1},{-1,0},{0,-1}},\n    {{0,-1},{1,0},{0,1},{-1,0}},\n    {{-1,0},{0,-1},{1,0},{0,1}},\n    {{0,1},{-1,0},{0,-1},{1,0}}\n};\nint bx,by,ex,ey;\nint left_;\nint right_;\nint minp;\nint pre_dir;\nbool bl;\nbool br;\n\nvoid dfs_left(int dx,int dy,int atom,int time)\n{\n	int px,py;\n	for(int i=0;i&lt;4;i++)\n	{\n		px=dx+move_1[atom-1][i][0];\n		py=dy+move_1[atom-1][i][1];\n		if(px==ex&amp;&amp;py==ey) \n		{\n			left_=time+1;\n			bl=true;\n			return ;\n		}\n		if(map[px][py]==\'#\'||px&lt;1||px&gt;x||py&lt;1||py&gt;y) continue;\n		else\n		{\n			if(atom==4)\n			{\n				if(i==0) dfs_left(px,py,3,time+1);\n				else if(i==1) dfs_left(px,py,4,time+1);\n				else if(i==2) dfs_left(px,py,1,time+1);\n				else dfs_left(px,py,2,time+1);\n			}\n			else if(atom==3)\n			{\n				if(i==0) dfs_left(px,py,2,time+1);\n				else if(i==1) dfs_left(px,py,3,time+1);\n				else if(i==2) dfs_left(px,py,4,time+1);\n				else dfs_left(px,py,1,time+1);\n			}\n			else if(atom==2)\n			{\n				if(i==0) dfs_left(px,py,1,time+1);\n				else if(i==1) dfs_left(px,py,2,time+1);\n				else if(i==2) dfs_left(px,py,3,time+1);\n				else dfs_left(px,py,4,time+1);\n			}\n			else\n			{\n				if(i==0) dfs_left(px,py,4,time+1);\n				else if(i==1) dfs_left(px,py,1,time+1);\n				else if(i==2) dfs_left(px,py,2,time+1);\n				else dfs_left(px,py,3,time+1);\n			}\n			if(bl) return ;\n		}\n	}\n}\n\nvoid dfs_right(int dx,int dy,int atom,int time)\n{\n	int px,py;\n	for(int i=0;i&lt;4;i++)\n	{\n		px=dx+move_2[atom-1][i][0];\n		py=dy+move_2[atom-1][i][1];\n		if(px==ex&amp;&amp;py==ey) \n		{\n			right_=time+1;\n			br=true;\n			return ;\n		}\n		if(map[px][py]==\'#\'||px&lt;1||px&gt;x||py&lt;1||py&gt;y) continue;\n		else\n		{\n			if(atom==4)\n			{\n				if(i==0) dfs_right(px,py,1,time+1);\n				else if(i==1) dfs_right(px,py,4,time+1);\n				else if(i==2) dfs_right(px,py,3,time+1);\n				else dfs_right(px,py,2,time+1);\n			}\n			else if(atom==3)\n			{\n				if(i==0) dfs_right(px,py,4,time+1);\n				else if(i==1) dfs_right(px,py,3,time+1);\n				else if(i==2) dfs_right(px,py,2,time+1);\n				else dfs_right(px,py,1,time+1);\n			}\n			else if(atom==2)\n			{\n				if(i==0) dfs_right(px,py,3,time+1);\n				else if(i==1) dfs_right(px,py,2,time+1);\n				else if(i==2) dfs_right(px,py,1,time+1);\n				else dfs_right(px,py,4,time+1);\n			}\n			else\n			{\n				if(i==0) dfs_right(px,py,2,time+1);\n				else if(i==1) dfs_right(px,py,1,time+1);\n				else if(i==2) dfs_right(px,py,4,time+1);\n				else dfs_right(px,py,3,time+1);\n			}\n			if(br) return ;\n		}\n	}\n}\n\nvoid bfs()\n{\n	memset(book,0,sizeof(book));\n	int nn[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\n	point queue[41*41];\n	int head=1;\n	int tail=2;\n	queue[1].x=bx;\n	queue[1].y=by;\n	queue[1].step=1;\n	book[bx][by]=true;\n	while(head!=tail)\n	{\n		for(int i=0;i&lt;4;i++)\n		{\n			int dx=queue[head].x+nn[i][0];\n			int dy=queue[head].y+nn[i][1];\n			if(map[dx][dy]==\'E\')\n			{\n				minp=queue[head].step+1;\n				return ;\n			}\n			if(dx&lt;1||dx&gt;x||dy&lt;1||dy&gt;y||map[dx][dy]==\'#\'||book[dx][dy]) continue;\n			else\n			{\n				book[dx][dy]=true;\n				queue[tail].x=dx;\n				queue[tail].y=dy;\n				queue[tail].step=queue[head].step+1;\n				tail++;\n			}\n		}\n		head++;\n	}\n}\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);getchar();\n	while(t--)\n	{ \n	    bl=br=false;\n		minp=left_=right_=1;  //刚开始S也算 \n		scanf(\'%d%d\',&amp;y,&amp;x);getchar();\n		for(int i=1;i&lt;=x;i++)\n		{\n			for(int j=1;j&lt;=y;j++)\n			{\n				scanf(\'%c\',&amp;map[i][j]);\n				if(map[i][j]==\'S\') \n				{\n					bx=i,by=j;\n					if(i==1) pre_dir=2;\n					else if(i==x) pre_dir=4;\n					else if(j==1) pre_dir=1;\n					else if(j==y) pre_dir=3; \n				}\n				if(map[i][j]==\'E\') ex=i,ey=j;\n			}\n			getchar();\n		}\n		dfs_left(bx,by,pre_dir,1);\n		dfs_right(bx,by,pre_dir,1);\n		bfs();\n		printf(\'%d %d %d\n\',left_,right_,minp);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('796b9ff9c1d863eb406d735857f9b3f4','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3126 - 筛素数+BFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   输入：\n  </div>\n  <div>\n   1.n代表测试用例的个数\n  </div>\n  <div>\n   2.之后的n行，每行有两个数字，都是四位素数，现在让我输出最少的操作次数是的从第一个素数变换成第二个素数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   操作定义：\n  </div>\n  <div>\n   我们每次允许改变四位数的的一个位的数字，不能不改变，并且改变数字后的新的四位数也必须是素数，这里的前卫上的数字不允许改变成0\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   标准的BFS枚举思路，但是这里我们对于素数的判定，可以优化一下时间效率\n  </div>\n  <div>\n   首先，我们可以提前将四位的素数都筛出来，然后我们每次改变出来一个新书，直接O(1)就可以判断是不是一个素数，不用传统的思路了去判定一下这个数是不是只有自己和1这个因数，这样我们只用O(10000)筛一次就可以了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   没有什么新的思路，算是一道水题\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1970265\' name=\'code\' snippet_file_name=\'blog_20161107_1_6727389\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'cmath\'\n#define N 100000\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int step;\n}point;\n\npoint queue[N*100];\nint head;\nint tail;\nbool prime[N];\nbool book[N];\nint x,y;\n\nint bfs()\n{\n	memset(book,0,sizeof(book));\n	head=1;\n	tail=2;\n	queue[head].x=x;\n	queue[head].step=0;\n	book[x]=1;\n	while(head!=tail)\n	{\n		int atom;\n		int dx;\n		int ready;\n		for(int i=0;i&lt;4;i++)\n		{\n			int ppp=queue[head].x/pow(10,i);\n			atom=ppp%10;\n			ready=queue[head].x-pow(10,i)*atom;\n			for(int j=0;j&lt;10;j++)\n			{\n				if(atom==j||((i==3)&amp;&amp;j==0)) continue;\n				else\n				{\n					dx=ready+j*pow(10,i);\n					if(dx==y) return queue[head].step+1;   //找到 \n					if(book[dx]==1||prime[dx]==0) continue;    //出现过或者不是素数 \n					else\n					{\n						queue[tail].x=dx;\n						queue[tail].step=queue[head].step+1;\n						tail++;\n						book[dx]=1;\n					}\n				}\n			}\n		}\n		head++;\n	}\n	return 0;\n}\n\nvoid init_prime()   //筛素数 \n{\n	memset(prime,1,sizeof(prime));\n	int save[N];\n	int number=0;\n	prime[0]=prime[1]=0;\n	for(int i=2;i&lt;N;i++)\n	{\n		if(prime[i]) save[++number]=i;\n		for(int j=1;j&lt;=number&amp;&amp;i*save[j]&lt;N;j++)\n		{\n			prime[i*save[j]]=0;\n			if(i%save[j]==0) break;\n		}\n	}\n}\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);\n	init_prime();\n	while(t--)\n	{\n		scanf(\'%d%d\',&amp;x,&amp;y);\n		int p;\n		if(x==y) printf(\'0\n\');\n		else if(p=bfs()) printf(\'%d\n\',p);\n		else printf(\'Impossible\n\');\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('55210c663904f426e500fa362dda51d0','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  GCD Extends_GCD 欧几里得算法+扩展欧几里得算法详解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.欧几里得算法：\n  </h2>\n  <div>\n   我们从小学开始老师都会让我们求解一一种问题，叫做最大公约数，这里的最大公约数就叫做GCD\n  </div>\n  <div>\n   当然求解最大公约数的算法也是非常的重要，我们在这里就引入欧几里得的算法，也就是著名的辗转相除法\n  </div>\n  <div>\n   首先给出定义：\n  </div>\n  <div>\n   GCD(a,b)=GCD(b,a%b)\n  </div>\n  <div>\n   在这里有的人会问a，b到底哪个大才能使对的，其实在这里我们的a，b是没有大小之分的，要是硬说影响的话，是有那么一点影响，但是无关痛痒\n  </div>\n  <div>\n   首先这里的生命是最好a&gt;b\n  </div>\n  <div>\n   但是当a&lt;b的时候，我们会发现a%b=a，也就是说这个算法会自动调换会a&gt;b的状态，所以我们说这一点影响无关痛痒，不影响算法的本质\n  </div>\n  <div>\n   证明这里我们就不在涉及\n  </div>\n  <div>\n   但是在算法的实现方面我有一些要说的：\n  </div>\n  <div>\n   <pre class=\'python\' code_snippet_id=\'1968600\' name=\'code\' snippet_file_name=\'blog_20161105_1_5691855\'>from time import *\ndef gcd_1(a,b):\n    if b==0:\n        return a\n    else:\n        return gcd_1(b,a%b)\n\ndef gcd_2(a,b):    #一旦数据量差距过大无法应用，但是在数据量相差不多的情况下，还是很优秀的，总而言之不要用，因为不稳定\n    if a==b:\n        return a\n    elif a&gt;b:\n        return gcd_2(a-b,b)\n    else:\n        return gcd_2(b-a,a)\n\ndef gcd_3(a,b):\n    if a==b:\n        return a\n    elif a&lt;b:\n        return gcd_3(b,a)\n    elif not(a&amp;1) and not(b&amp;1):\n        return gcd_3(a&gt;&gt;1,b&gt;&gt;1)&lt;&lt;1\n    elif not(a&amp;1) and b&amp;1:\n        return gcd_3(a&gt;&gt;1,b)\n    elif not(b&amp;1) and a&amp;1:\n        return gcd_3(a,b&gt;&gt;1)\n    else:\n        return gcd_3(a-b,b)\n\ntime=clock()\na=eval(input(\'a:\'))\nb=eval(input(\'b:\'))\nprint(\'gcd_1:%d\'%gcd_1(a,b))\nprint(\'time gcd_1:%lf\'%(clock()-time))\n#time=clock()\n#print(\'gcd_2:%d\'%gcd_2(a,b))\n#print(\'time gcd_2:%lf\'%(clock()-time))\ntime=clock()\nprint(\'gcd_3:%d\'%gcd_3(a,b))\nprint(\'time gcd_3:%lf\'%(clock()-time))\n</pre>\n   实验结果：\n  </div>\n  <div>\n   <pre class=\'python\' code_snippet_id=\'1968600\' name=\'code\' snippet_file_name=\'blog_20161105_2_1297010\'>a:34567890\nb:1234567\ngcd_1:1\ntime gcd_1:2.589272\ngcd_3:1\ntime gcd_3:0.032302</pre>\n   很显然，虽然朴素的GCD写的很简洁，但是毫无疑问，朴素的GCD因为取模运算的限制太过，我们的位运算+更相孙减术（gcd_2）结合的优势最明显，在我们的工程项目中最好用gcd_3的写法\n   <br/>\n   <br/>\n   <h2>\n    2.Extends_gcd扩展欧几里得算法：\n   </h2>\n   <div>\n    我们的欧几里得算法很优秀，但是只用来求解最大公约数好像屈才了，所以这里我们对欧几里得算法进行扩展，我们引入扩展欧几里得算法\n   </div>\n   <div>\n    在讲解扩展欧几里得算法之前，我们先来讲解个很重要的知识：\n   </div>\n   <div>\n    1.贝祖定理：\n   </div>\n   <div>\n    对于任何一组不全是0的两个数x，y总是满足\n   </div>\n   <div>\n    ax+by=gcd(x,y)这是一定成立的（之后我们还要讲一下不成立的另一个中很相近的定理）\n   </div>\n   <div>\n    <strong>\n     这个解是唯一的\n    </strong>\n   </div>\n   <div>\n    但是想要求解出这个等式的整数解确实非常的麻烦，我们需要不断的尝试，这是没有办法忍受的异常繁琐的工作\n   </div>\n   <div>\n    所以说，这时候，为了快速求解出这个唯一的解，我们就需要用到扩展欧几里得算法\n   </div>\n   <div>\n    但是这里请注意，扩展欧几里得算法是基于欧几里得算法的，我们在这里只是引入了逆推 的过程\n   </div>\n   <div>\n    逆推导：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1968600\' name=\'code\' snippet_file_name=\'blog_20161105_3_2965450\'>aX0+bY0=gcd(a,b)=gcd(b,b%a)\ngcd(b,a%b)=bX1+(a%b)Y1\n....\ngcd(a,0)=aXn+0*Yn=a    上面已经提到过了，最后的状态一定是a&gt;b的\n这时候我们让Xn=1，Yn=0就可以\n逆推导开始：\naX0+bY0=gcd(a,b)=gcd(b,a%b)\ngcd(b,a%b)=bX1+(a%b)Y1\ngcd(b,a%b)=bX1+(a-b*(a/b))Y1=aY1+b*(X1-a/bY1)=gcd(a,b)\n显然，我们可以得到\nX0=Y1\nY0=X1-a/bY1</pre>\n    这就是我们的逆推导关系，我们利用C++的引用的手段，可以轻松的实现参数的时时改变，轻而易举实现这个算法\n   </div>\n   <div>\n    但是小心一点，我们的逆推导的过程是建立在\n   </div>\n   <div>\n    ax+by=gcd(a,b)上的，也就是说扩展欧几里得算法求出来的解是在等号右边是gcd(a,b)的解，这就引出了我们下面的问题\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    扩展欧几里得算法的应用：\n   </div>\n   <div>\n    <strong>\n     1.求解不定方程：\n    </strong>\n   </div>\n   <div>\n    ax+by=c\n   </div>\n   <div>\n    是不是看上去和我们上面的贝祖定理非常的相似？没错这时候我们利用扩展欧几里得求出来ax+by=gcd(a,b)的话，如果这时候c是gcd(a,b)的整数倍的话，我们扩展欧几里得算法得到的解都乘上c/gcd(a,b)得到的就是这个不定方程的解，但是，如果c不是gcd(a,b)的整数倍，说明这个不定方程没有解\n   </div>\n   <div>\n    为什么？\n   </div>\n   <div>\n    因为我们的ax+by=gcd(a,b)如果有解的条件就是gcd(a,b)是gcd(a,b)的1倍，但是如果没有说明我们没有办法分解出这个ax+by=gcd(a,b)的式子，那么自然，gcd(a,b)的倍数依旧没有解\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <strong>\n     2.求解线性同余方程：\n    </strong>\n   </div>\n   <div>\n    我们将ax=b(mod n)（ps:那个等号是三等号，代表同余）满足的解称之为a模b关于n同余，这时候我们根据同余的定义可以得到\n   </div>\n   <div>\n    n|(ax-b)-&gt;ax-b=my-&gt;ax-my=b-&gt;ax+my=b(m只是一个常数，正负无所谓)\n   </div>\n   <div>\n    是不是又觉得这个方程眼熟，没错还是扩展欧几里得的不定方程\n   </div>\n   <div>\n    这时候我们就转化成了求不定方程的问题了，注意这里的同余的结果有很多个\n   </div>\n   <div>\n    但是这些结果都有一个同性\n   </div>\n   <div>\n    <span style=\'white-space:pre\'>\n    </span>\n    1.结果总数有gcd(a,n)个\n   </div>\n   <div>\n    <span style=\'white-space:pre\'>\n    </span>\n    2.自通解以后，每个解相差b/gac(a,n)   //这里我有一个问题，按照程序角度来说，我们会不会少元素的输出？\n   </div>\n   <div>\n    <br/>\n   </div>\n   <strong>\n    3.求解模逆元：\n   </strong>\n  </div>\n  <div>\n   模拟元的定义，如果\n  </div>\n  <div>\n   ax=1(mod n)称x是a的模逆元，这里的条件是a,n必须互素\n  </div>\n  <div>\n   为什么，我们再转化一下：\n  </div>\n  <div>\n   ax+ny=1只有我们的gcd(a,n)=1的时候才有解，并且解唯一，gcd(a,n)=1的意思就是互素\n  </div>\n  <div>\n   所以模逆元存在的条件是a，n必须互素\n  </div>\n  <div>\n   性质是模逆元唯一\n  </div>\n  <div>\n   转化一下，这时候我们还是要求一个不定方程\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   综上，我们的利用欧几里得的问题始终就是求一个不定方程，只不过是不定方程的等号的右边的值不断的改变罢了，只有等号右边的值是gcd的整数倍才有解，有gcd个解，否则没有解\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1968600\' name=\'code\' snippet_file_name=\'blog_20161105_4_5124257\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nint gcd(int a,int b)   //GCD\n{\n	return b?gcd(b,a%b):a;\n}\n\nint Extends_gcd(int a,int b,int&amp; x,int&amp; y)   //扩展欧几里得算法 \n{\n	if(b==0)\n	{\n		x=1;\n		y=0;\n		return a;\n	}\n	int g=Extends_gcd(b,a%b,x,y);\n	int t=x;\n	x=y;\n	y=t-(a/b)*y;\n	return g; \n} \n\nint main()\n{\n	int x;\n	int y;\n	int a,b,c;\n	scanf(\'%d%d%d\',&amp;a,&amp;b,&amp;c);\n	int g=Extends_gcd(a,b,x,y);\n	printf(\'GCD:%d\n\',g);\n	//以下是求出解得，必须要乘倍数，是因为我们当时算的基础以gcd，但是实际上方程的右边是gcd的倍数（有解的话），所以我们要先乘上一个倍数 ，才是真正的解 \n	if(c%g) printf(\'No solution\n\');\n	else printf(\'%d*%d+%d*%d=%d\n\',a,x*(c/g),b,y*(c/g),c);\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('58484fb4edee14a71df58f0483f6740a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Miller-Rabin概率素数测试算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <p>\n    本文首先鸣谢以下资料文章：\n    <br/>\n    <a href=\'http://www.xuebuyuan.com/552593.html\'>\n     资料1\n    </a>\n    <br/>\n    <a href=\'http://www.cnblogs.com/TenosDoIt/p/3398112.html\'>\n     资料2\n    </a>\n    <br/>\n    <a href=\'http://blog.chinaunix.net/uid-21712186-id-1818141.html\'>\n     资料3\n    </a>\n    <br/>\n    下面我们开始正文，从源头开始真正的梳理一下素数测试\n   </p>\n   <h2 id=\'1素数\'>\n    1.素数\n   </h2>\n   <p>\n    我们都知道，素数在当今的数论中占有非常重要的地位，主要原因就是素数最根本的性质——\n    <strong>\n     除了1，和自身以外，不会被任何一个数整除\n    </strong>\n    <br/>\n    并且，素数现在在我们的日常生活中伴有非常重要的地位，这一点的其一主要原因就是素数已经是密码学中最重要的一点，我们当今的密码学常常要涉及到利用超大素数作为我们的密钥和核心，所以说，我们对素数的研究就变得非常的重要了\n    <br/>\n    <strong>\n     很是遗憾，现在我们并没有一套合理的算法体系去真正的获取一个绝对100%是素数的一个非常大的数\n    </strong>\n    ，这是当前做不到的，因为目前的确定性的算法朝朝大素数无外乎两种情况，耗时和空间占用，但是本文将从一种全新的角度带大家研究一种非确定性算法，\n    <strong>\n     该算法虽然并不是100%正确的\n    </strong>\n    ，但是我们如果加上限制条件，我们可以将该算法的\n    <strong>\n     错误率降低\n    </strong>\n    到几乎可以忽略的程度，这也就是我们本文即将讲述的重点——\n    <strong>\n     Miller-Rabin算法\n    </strong>\n   </p>\n   <h2 id=\'2朴素素数测试-筛法\'>\n    2.朴素素数测试  + 筛法\n   </h2>\n   <p>\n    我们从刚开始学编程的时候，大学老师都会给我们将一种非常糟糕的算法（当然这处理我们的考试已经够了）这种算法叫做\n    <strong>\n     试除法\n    </strong>\n    <br/>\n    算法描述：\n    <br/>\n    对一个已知的待测的数n，k从2开始一直到n-1，我们如果发现k|n,那么我们认为这是一个合数\n    <br/>\n    当然，这是我们从素数的定义出发的一种算法，之所以说这种算法糟糕是因为当我们的待测的数非常的大的时候，我们不得不遍历一整遍数据来保证算法的正确性，这是无法容忍的\n    <br/>\n    可能有的人还想在这个算法上搞搞优化什么的，其实都是治标不治本\n    <br/>\n    至于朴素素数测试和筛法测试我会援引我的博客作为讲解\n    <br/>\n    <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52835805\'>\n     Lantian的朴素素数测试和筛法素数生成算法讲解\n    </a>\n    <br/>\n    <strong>\n     <em>\n      在这里我先声明：\n     </em>\n    </strong>\n    <br/>\n    筛法是一种非常高效的算法，但是在这里筛法没有办法发挥他的优势，因为筛法真正强大在可以快速的生成一定范围内的所有的素数，但是我们这里强调的是对超大素数的测试，并不需要获取那么多的素数\n   </p>\n   <p>\n    以上，筛法和朴素测试的时间复杂度都是O(n)和无限接近O(n)，在这里我们确定性算法就走到了尽头，下面有请非确定性概率测试算法来施展身手\n   </p>\n   <h2 id=\'3必要数论基础知识\'>\n    3.必要数论基础知识\n   </h2>\n   <p>\n    在我们继续研究之前，我们还需要一些必备的知识来为我们打通道路\n    <br/>\n    <strong>\n     <em>\n      1.费马小定理：\n     </em>\n    </strong>\n    <br/>\n    其实在讲费马小定理之前，我们其实还需要讲解欧拉定理，飞马小丁立只是欧拉定理的特殊情况\n    <br/>\n    欧拉定理：\n    <br/>\n    <img alt=\'欧拉定理\' src=\'http://upload.wikimedia.org/math/7/e/6/7e61812b8e775a284870b88c1306d0ee.png\' title=\'\'/>\n    这里的n，a必须是互素（Gcd(n,a)=1）\n    <br/>\n    费马小定理：\n    <br/>\n    <img alt=\'费马小定理\' src=\'http://upload.wikimedia.org/math/a/5/5/a55b843317686066afd9b974bbc5aa89.png\' title=\'\'/>\n    当欧拉定理中的n是素数的时候，很显然欧拉函数的值是n-1，费马小定理成立，这里就不描述费马小定理的证明了\n    <br/>\n    2.二次探测定理：\n    <br/>\n    <a href=\'http://upload.wikimedia.org/math/f/4/7/f47f8a62f0ce933340a1b18796672474.png\'>\n     二次探测定理\n    </a>\n    <br/>\n    为了更好的了解Miller-Rabin算法，我们在这里必须需要了解二次探测定理的证明和原理，相信我，这不难\n    <br/>\n    <strong>\n     首先，先给出二次探测定理的描述：\n    </strong>\n    <br/>\n    如果p是素数，\n    <strong>\n     x是小于p的正整数\n    </strong>\n    ，且\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813195535187\' title=\'\'/>\n    ，那么要么x=1，要么x=p-1。这是显然的，因为\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813195535187\' title=\'\'/>\n    相当于p能整除\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813195644656\' title=\'\'/>\n    ，也即p能整除(x+1)(x-1)。由于p是素数，那么只可能是x-1能被p整除(此时x=1) 或 x+1能被p整除(此时x=p-1)。\n   </p>\n   <h2 id=\'4费马测试\'>\n    4.费马测试\n   </h2>\n   <p>\n    首先我们先来看看费马测试\n    <br/>\n    刚才我们的费马小定理已经说明了素数成立的必要条件，也就是说，如果一个数不满足费马小定理，那么这个数必定是合数，但是如果这个数满足我们就没有办法确定是不是合数还是素数了，因为历史上有一种非常神秘的数的存在——\n    <strong>\n     <em>\n      卡密歇尔数\n     </em>\n    </strong>\n    ，这类数我们也叫伪素数\n    <br/>\n    如果想要了解更多的话，可以百度查询，我们这里只需要了解到，因为卡米歇尔书满足费马小定理但是同时又不是素数，所以这使得我们的费马测试（费马小定理的逆定理）不是正确的，也就不能称之为算法\n    <br/>\n    但是我们还是需要知道这种测试的情况的，对于至少也是一种测试算法\n    <br/>\n    一般以2为a做测试，我们一般应用费马测试的时候都是提前利用了一张伪素数表来进行容错处理，当我们找到了满足费马测试并且又不在伪素数表（基于底数2）上的时候我们就可以断定是一个素数，但是这样有两个缺点：\n    <br/>\n    1.占用时间，我们生成伪素数需要很大的计算资源（我还真不知道有什么好的算法可以快速求伪素数）\n    <br/>\n    2.当我们内存资源不允许伪素数表的时候，我们的费马测试错误率太高，不能实际应用\n   </p>\n   <p>\n    费马小定理毕竟只是素数判定的一个必要条件.满足费马小定理条件的整数n未必全是素数.有些合数也满足费马小定理的条件\n    <em>\n     *\n    </em>\n    .这些合数被称作Carmichael数,前3个Carmichael数是561,1105,1729.\n    <br/>\n    Carmichael数是非常少的.在1~100000000范围内的整数中,只有255个Carmichael数.数据越大，之后的卡米歇尔数越稀疏\n    <br/>\n    但是在允许伪素数表的情况下对于快速计算幂取模的话（因为测试的素数非常的大）我们可以用快速幂来实现：\n    <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/53043646\'>\n     Lantian的快速幂算法详解\n    </a>\n   </p>\n   <h2 id=\'5miller-rabin素性测试\'>\n    5.Miller-Rabin素性测试\n   </h2>\n   <p>\n    Miller和Rabin两个人的工作让Fermat素性测试迈出了革命性的一步，建立了Miller-Rabin素性测试算法\n    <br/>\n    在这之前，我们为了更好的了解算法的本质，我们来看一下伪素数341是如何被Miller-Rabin的二次探测定理卡掉的\n    <br/>\n    <strong>\n     <em>\n      一下摘引自资料1：\n     </em>\n    </strong>\n    <br/>\n    我们下面来演示一下上面的定理如何应用在Fermat素性测试上。前面说过341可以通过以2为底的Fermat测试，因为2^340 mod 341=1。如果341真是素数（对于任意的x&lt;341,我们必须都要满足x=1||x=340）的话，那么2^170(2^340开方，这时候的2^340满足了)mod 341只可能是1或340；当算得2^170 mod 341确实等于1时，我们可以继续查看2^85除以341的结果。我们发现，2^85 mod 341=32，这一结果摘掉了341头上的素数皇冠\n   </p>\n   <p>\n    在这里，我们抽离一下本质，我们用Miller-Rabin做素数测试的时候将a^(n-1)\n    <br/>\n    转化成了a^(d*2^r)这里的d是一个正奇数（1也是）\n   </p>\n   <p>\n    这就是Miller-Rabin素性测试的方法。不断地提取指数n-1中的因子2，把n-1表示成\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813201811250\' title=\'\'/>\n    （其中d是一个奇数）。那么我们需要计算的东西就变成了\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813201922250\' title=\'\'/>\n    除以n的余数。于是，\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813202011515\' title=\'\'/>\n    要么等于1，要么等于n-1。如果\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813202011515\' title=\'\'/>\n    等于1，定理继续适用于\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813202042406\' title=\'\'/>\n    ，这样不断开方开下去，直到对于某个i满足\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813202108796\' title=\'\'/>\n    或者最后指数中的2用完了得到的\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813202132281\' title=\'\'/>\n    <br/>\n    在这里我们需要明确一点，当\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813202108796\' title=\'\'/>\n    这种情况出现的时候，我们没有办法继续满足二次探测定理了，我们就不对这种情况继续判断，支队等于1的情况继续用二次探测定理判断\n   </p>\n   <p>\n    所以我们的算法流程就出来了\n    <br/>\n    我们首先从先计算出\n    <br/>\n    x=\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20130813201922250\' title=\'\'/>\n    (mod n)\n    <br/>\n    然后如果x=n-1,我们返回true，是一个素数\n    <br/>\n    如果不是我们继续判断知道，我们中途发现x!=1&amp;&amp;x!=n-1我们返回false，是个合数\n    <br/>\n    知道最后，我们看看剩下的数是1还是n-1还是别的数\n   </p>\n   <p>\n    在这里我们还有一些技巧需要学习：\n    <br/>\n    1.利用数论的只是证明之后我们可以发现，只要我们的Miller-Rabin多次随机选择底数a的话，重复进行k次，我们可以将错误降低到2^(-k)，次数越多越精确，错误概率越小\n    <br/>\n    2.Miller-Rabin素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。\n    <br/>\n    Miller-Rabin算法的代码也非常简单：计算d和r的值（可以用位运算加速,即快速积,快速幂），然后二分计算的值，最后把它平方r次。\n    <br/>\n    3.对于大数的素性判断，目前Miller-Rabin算法应用最广泛。一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于4 759 123 141，\n    <strong>\n     <em>\n      那么只需要测试三个底数2, 7和61就足够了\n     </em>\n    </strong>\n    。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11, 13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用\n    <strong>\n     <em>\n      2, 3, 7, 61和24251作为底数\n     </em>\n    </strong>\n    ，那么10^16内唯一的强伪素数为46856248255981\n    <br/>\n    4.最好不要用合数作为底，出错概率太大，至少也是素数作为底，证明的话，不会\n   </p>\n   <h2 id=\'6miller-rabin-代码\'>\n    6.Miller-Rabin 代码\n   </h2>\n   <p>\n    本人用正向迭代和反向迭代都了一遍，发现正向迭代在很大的偶数的情况下比反向的速度快一点点，平均的时间都差不多\n   </p>\n   <pre class=\'prettyprint\'><code class=\' hljs cpp\'><span class=\'hljs-preprocessor\'>#include\'iostream\'</span>\n<span class=\'hljs-preprocessor\'>#include\'cstdio\'</span>\n<span class=\'hljs-preprocessor\'>#include\'cstring\'</span>\n<span class=\'hljs-preprocessor\'>#include\'cstdlib\'</span>\n<span class=\'hljs-preprocessor\'>#include\'ctime\'</span>\n<span class=\'hljs-keyword\'>using</span> <span class=\'hljs-keyword\'>namespace</span> <span class=\'hljs-built_in\'>std</span>;\n\n<span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> quicks(<span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> a,<span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> b,<span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> c)\n{\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> ans=<span class=\'hljs-number\'>1</span>;\n    a=a%c;\n    <span class=\'hljs-keyword\'>while</span>(b!=<span class=\'hljs-number\'>0</span>)\n    {\n        <span class=\'hljs-keyword\'>if</span>(b &amp; <span class=\'hljs-number\'>1</span>) ans=(ans*a)%c;\n        b&gt;&gt;=<span class=\'hljs-number\'>1</span>;\n        a=(a*a)%c;\n    }\n    <span class=\'hljs-keyword\'>return</span> ans;\n}\n\n<span class=\'hljs-keyword\'>bool</span> Miller_Rabin_1(<span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> n)   <span class=\'hljs-comment\'>//标准代码 </span>\n{\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> t=<span class=\'hljs-number\'>0</span>;\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> b=n-<span class=\'hljs-number\'>1</span>;\n    <span class=\'hljs-keyword\'>while</span>((b&amp;<span class=\'hljs-number\'>1</span>)==<span class=\'hljs-number\'>0</span>)\n    {\n        t++;\n        b&gt;&gt;=<span class=\'hljs-number\'>1</span>;\n    }\n    <span class=\'hljs-comment\'>//现在的a^(b*2^t)=1(mod n)</span>\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> a=<span class=\'hljs-number\'>11</span>;   <span class=\'hljs-comment\'>//测试</span>\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> x=quicks(a,b,n);\n    <span class=\'hljs-comment\'>//个人认为这里如果加上优先判定是不是1，n-1的话，会更快一点？是不是呢？？？？？ </span>\n    <span class=\'hljs-keyword\'>for</span>(<span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> i=<span class=\'hljs-number\'>1</span>;i&lt;=t;i++)\n    {\n        <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> y=quicks(x,<span class=\'hljs-number\'>2</span>,n);\n        <span class=\'hljs-keyword\'>if</span>(y==<span class=\'hljs-number\'>1</span>&amp;&amp;x!=<span class=\'hljs-number\'>1</span>&amp;&amp;x!=n-<span class=\'hljs-number\'>1</span>) <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>false</span>;    <span class=\'hljs-comment\'>//这里的意思是如果a^(d*2^r)是1，但是a^(d*2^(r-1))不是1也不是n-1的情况，这时候我们认为是合数 </span>\n        x=y;\n    } \n    <span class=\'hljs-keyword\'>if</span>(x!=<span class=\'hljs-number\'>1</span>) <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>false</span>;\n    <span class=\'hljs-keyword\'>else</span> <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>true</span>;\n}\n\n<span class=\'hljs-keyword\'>bool</span> Miller_Rabin_2(<span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> n)   <span class=\'hljs-comment\'>//正向迭代 </span>\n{\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> p=n-<span class=\'hljs-number\'>1</span>;\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> a=<span class=\'hljs-number\'>11</span>;\n    <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> x=quicks(a,p,n);\n    <span class=\'hljs-keyword\'>if</span>(x==n-<span class=\'hljs-number\'>1</span>) <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>true</span>;\n    <span class=\'hljs-keyword\'>else</span>\n    {\n        <span class=\'hljs-keyword\'>long</span> <span class=\'hljs-keyword\'>long</span> w;\n        <span class=\'hljs-keyword\'>do</span>\n        {\n            p&gt;&gt;=<span class=\'hljs-number\'>1</span>;\n            w=quicks(a,p,n);\n            <span class=\'hljs-keyword\'>if</span>(w==n-<span class=\'hljs-number\'>1</span>) <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>true</span>;\n            <span class=\'hljs-keyword\'>else</span> <span class=\'hljs-keyword\'>if</span>(w!=<span class=\'hljs-number\'>1</span>) <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>false</span>;\n        }\n        <span class=\'hljs-keyword\'>while</span>((p&amp;<span class=\'hljs-number\'>1</span>)!=<span class=\'hljs-number\'>1</span>);\n\n        <span class=\'hljs-keyword\'>if</span>(w==<span class=\'hljs-number\'>1</span>||w==n-<span class=\'hljs-number\'>1</span>) <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>true</span>;\n        <span class=\'hljs-keyword\'>else</span> <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>false</span>;\n    }\n}\n\n\n<span class=\'hljs-keyword\'>int</span> main()\n{\n    <span class=\'hljs-keyword\'>double</span> time=clock();\n    <span class=\'hljs-keyword\'>if</span>(Miller_Rabin_1(<span class=\'hljs-number\'>2222222222222222222222</span>)) <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'YES\n\'</span>);\n    <span class=\'hljs-keyword\'>else</span> <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'NO\n\'</span>);\n    <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'%lf\n\'</span>,clock()-time);\n    time=clock();\n    <span class=\'hljs-keyword\'>if</span>(Miller_Rabin_2(<span class=\'hljs-number\'>2222222222222222222222</span>)) <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'YES\n\'</span>);\n    <span class=\'hljs-keyword\'>else</span> <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'NO\n\'</span>);\n    <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'%lf\n\'</span>,clock()-time);\n    <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-number\'>0</span>;\n}</code></pre>\n   <h2 id=\'7thinking\'>\n    7.Thinking\n   </h2>\n   <p>\n    感谢前人的无私分享，我在匍匐前进，特以此文鸣谢资料和论文的作者\n    <br/>\n    剩余几个问题待解：\n    <br/>\n    1.算法中最后的(n-1)|x的情况为什么不考虑，只考虑x！=1的情况？\n    <br/>\n    2.在检查的过程中，如果出现了(n-1)|x我们怎么回避呢\n    <br/>\n    3.在计算出来d，b之后我们可不可以提前判断一下a^d是不是1或者n-1的倍数从而加快速度呢?\n   </p>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('113fbc3d8ac8f7b3968dc1110b2cb0b7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  快速幂取模算法详解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.大数模幂运算的缺陷：\n  </h2>\n  <div>\n   快速幂取模算法的引入是从大数的小数取模的朴素算法的局限性所提出的，在朴素的方法中我们计算一个数比如5^1003%31是非常消耗我们的计算资源的，在整个计算过程中最麻烦的就是我们的5^1003这个过程\n  </div>\n  <div>\n   缺点1：在我们在之后计算指数的过程中，计算的数字不都拿得增大，非常的占用我们的计算资源（主要是时间，还有空间）\n  </div>\n  <div>\n   缺点2：我们计算的中间过程数字大的恐怖，我们现有的计算机是没有办法记录这么长的数据的，所以说我们必须要想一个更加高效的方法来解决这个问题\n  </div>\n  <h2>\n   2.快速幂的引入：\n  </h2>\n  <div>\n   我们首先从优化的过程开始一步一步优化我们的模幂算法\n  </div>\n  <h3>\n   1.朴素模幂运算过程：\n  </h3>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_1_7253370\'>#define ans=1\nfor(int i=1;i&lt;=b;i++)\n{\n	ans*=a;\n}</pre>\n   根据我们上面说的，这种算法是非常的无法容忍的，我们在计算的过程中出现的两个缺点在这里都有体现\n  </div>\n  <div>\n   在这里我们如果要做优化的话，我肥就是每个过程中都加一次模运算，但是我们首先要记住模运算是非常的消耗内存资源的，在计算的次数非常的大的时候，我们是没有办法忍受这种时间耗费的\n  </div>\n  <h3>\n   2.快速幂引入：\n  </h3>\n  <div>\n   在讲解快速幂取模算法之前，我们先将几个必备的知识\n  </div>\n  <div>\n   1.对于取模运算：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_2_6349081\'>(a*b)%c=(a%c)*(b%c)%c</pre>\n   这个是成立的：也是我们实现快速幂的基础\n  </div>\n  <div>\n   之后我们来看看快速幂的核心本质\n  </div>\n  <div>\n   我通过离散课上的学习，将快速幂的本质差不多理解了一下，感觉还是很深刻的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在这里，我们对指数懂了一些手脚，核心思想在于\n  </div>\n  <div>\n   将大数的幂运算拆解成了相对应的乘法运算，利用上面的式子，始终将我们的运算的数据量控制在c的范围以下，这样我们可以客服朴素的算法的缺点二，我们将计算的数据量压缩了很大一部分，当指数非常大的时候这个优化是更加显著的，我们用Python来做一个实验来看看就知道我们优化的效率有多高了\n  </div>\n  <div>\n   <pre class=\'python\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_3_2902735\'>from time import *\ndef orginal_algorithm(a,b,c):  #a^b%c\n    ans=1\n    a=a%c  #预处理，防止出现a比c大的情况\n    for i in range(b):\n        ans=(ans*a)%c\n    return ans\n\ndef quick_algorithm(a,b,c):\n    a=a%c\n    ans=1\n    #这里我们不需要考虑b&lt;0，因为分数没有取模运算\n    while b!=0:\n        if b&amp;1:\n            ans=(ans*a)%c\n        b&gt;&gt;=1\n        a=(a*a)%c\n    return ans\n\ntime=clock()\na=eval(input(\'底数:\'))\nb=eval(input(\'指数:\'))\nc=eval(input(\'模:\'))\nprint(\'朴素算法结果%d\'%(orginal_algorithm(a,b,c)))\nprint(\'朴素算法耗时:%f\'%(clock()-time))\ntime=clock()\nprint(\'快速幂算法结果%d\'%(quick_algorithm(a,b,c)))\nprint(\'快速幂算法耗时:%f\'%(clock()-time))\n</pre>\n   实验结果：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_4_5552693\'>底数:5\n指数:1003\n模:12\n朴素算法结果5\n朴素算法耗时:3.289952\n快速幂算法结果5\n快速幂算法耗时:0.006706</pre>\n   我们现在知道了快速幂取模算法的强大了，我们现在来看核心原理：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_5_6250805\'>对于任何一个整数的模幂运算\na^b%c\n对于b我们可以拆成二进制的形式\nb=b0+b1*2+b2*2^2+...+bn*2^n\n这里我们的b0对应的是b二进制的第一位\n那么我们的a^b运算就可以拆解成\na^b0*a^b1*2*...*a^(bn*2^n)\n对于b来说，二进制位不是0就是1，那么对于bx为0的项我们的计算结果是1就不用考虑了，我们真正想要的其实是b的非0二进制位\n\n那么假设除去了b的0的二进制位之后我们得到的式子是\na^(bx*2^x)*...*a(bn*2^n)\n这里我们再应用我们一开始提到的公式，那么我们的a^b%c运算就可以转化为\n(a^(bx*2^x)%c）*...*(a^(bn*2^n)%c)\n这样的话，我们就很接近快速幂的本质了</pre>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_6_9424151\'>(a^(bx*2^x)%c)*...*(a^(bn*2^n)%c)\n我们会发现令\nA1=(a^(bx*2^x)%c)\n...\nAn=(a^(bn*2^n)%c)\n这样的话，An始终是A(n-1)的平方倍（当然加进去了取模匀速那），依次递推</pre>\n   </div>\n   现在，我们基本的内容都已经了解到了，现在我们来考虑实现它：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_7_4233701\'>int quick(int a,int b,int c)\n{\n	int ans=1;   //记录结果\n	a=a%c;   //预处理，使得a处于c的数据范围之下\n	while(b!=0)\n	{\n		if(b&amp;1) ans=(ans*a)%c;   //如果b的二进制位不是0，那么我们的结果是要参与运算的\n		b&gt;&gt;=1;    //二进制的移位操作，相当于每次除以2，用二进制看，就是我们不断的遍历b的二进制位\n		a=(a*a)%c;   //不断的加倍\n	}\n	return ans;\n}</pre>\n   <br/>\n   现在，我们的快速幂已经讲完了\n  </div>\n  <div>\n   我们来大致的推演一下快速幂取模算法的时间复杂度\n  </div>\n  <div>\n   首先，我们会观察到，我们每次都是将b的规模缩小了2倍\n  </div>\n  <div>\n   那么很显然，原本的朴素的时间复杂度是O(n)\n  </div>\n  <div>\n   快速幂的时间复杂度就是O(logn)无限接近常熟的时间复杂度无疑逼朴素的时间复杂度优秀很多，在数据量越大的时候，者中优化效果越明显\n  </div>\n  <div>\n   <h2>\n    3.OJ例题\n   </h2>\n  </div>\n  <div>\n   POJ1995\n  </div>\n  <div>\n   题意：\n  </div>\n  <div>\n   快速幂版题\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1967817\' name=\'code\' snippet_file_name=\'blog_20161105_8_4375405\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nint ans=0;\nint a,b;\nint c;\n\nint quick(int a,int b,int c)\n{\n	int ans=1;\n	a=a%c;\n	while(b!=0)\n	{\n		if(b&amp;1) ans=(ans*a)%c;\n		b&gt;&gt;=1;\n		a=(a*a)%c;\n	}\n	return ans;\n}\n\nint main()\n{\n	int for_;\n	int t;\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		ans=0;\n		scanf(\'%d%d\',&amp;c,&amp;for_);\n		for(int i=1;i&lt;=for_;i++)\n		{\n			scanf(\'%d%d\',&amp;a,&amp;b);\n			ans=(ans+quick(a,b,c))%c;\n		}\n		printf(\'%d\n\',ans);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('69abedfbd2207ec21e54cf274483bec5','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1840 - Hash\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   本题中有一个五元三次方程，现在让我们求解出系数都在-50-50，未知元的范围是-50-50的所有的解的个数，不计含0的解\n  </div>\n  <div>\n   PS：首先，我们首先要知道，为了简化我们的操作，题目已经限定了系数和解得的取值范围，并且解是 整数\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   首先，对于我们的朴素的算法的话，我们需要对所有的情况都进行枚举，中国需要我们枚举50^5,很显然，这种算法的思路一定会导致超时，所以说，我们利用哈希的快速存取的性质对算法进行优化\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先，我们肯定是要用枚举法的，但是怎么做我们才可以减少我们的枚举的个数？\n  </div>\n  <div>\n   我们的思路如下，我们将方程变形\n  </div>\n  <div>\n   ax^3+by^3+cz^3+dw^3+et^3=0\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    -ax^3-by^3=\n    <span style=\'font-size:13.3333px\'>\n     cz^3+dw^3+et^3\n    </span>\n   </span>\n   <br/>\n  </div>\n  <div>\n   这样的话\n  </div>\n  <div>\n   我们首先对方程左边的值进行枚举，利用哈希的思路将所有的解都保存下来，然后我们在讲等式右边的的三个变量依次进行遍历找到所有的匹配的解，存在匹配的解的话，我们计数就可以了\n  </div>\n  <div>\n   这样的话，我们的美剧的次数就变成了50^2+50^3，显然我们将美剧的次数都优化下来了，我们的哈希的核心操作在于我们利用哈希将解的性质抽离出来，然后我们就实现了快速的存取减少了不必要的枚举的次数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   PS：但是本题有一些注意点\n  </div>\n  <div>\n   首先是数据的范围：我们的等式左边的枚举的最值是50*50*50*50*2=12500000\n  </div>\n  <div>\n   但是我们需要考虑到方程是会存在负解的，所以我们开辟的空间大小是25000000\n  </div>\n  <div>\n   但是显然我们要是用int开辟这么大的内存是会MLE的，所以我们采用short\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1967002\' name=\'code\' snippet_file_name=\'blog_20161104_1_8455549\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nshort hash[25000001];\nint a,b,c,d,e;\n\nint hash_function(int i,int j)\n{\n	int sum=0;\n	sum=a*i*i*i+b*j*j*j;\n	if(sum&lt;0) sum+=25000000;\n	return sum;\n}\n\nint main()\n{\n	scanf(\'%d%d%d%d%d\',&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);\n	for(int i=-50;i&lt;=50;i++)\n	{\n		if(i==0) continue;\n		for(int j=-50;j&lt;=50;j++)\n		{\n			if(j==0) continue;\n			else\n			{\n				int key=hash_function(i,j);\n				hash[key]++;\n			}\n		}\n	}\n	int result=0;\n	for(int i=-50;i&lt;=50;i++)\n	{\n		if(i==0) continue;\n		for(int j=-50;j&lt;=50;j++)\n		{\n			if(j==0) continue;\n			for(int k=-50;k&lt;=50;k++)\n			{\n				if(!k) continue;\n				int key=c*i*i*i+d*j*j*j+e*k*k*k;\n				if(key&lt;0) key+=25000000;\n				if(key) result+=hash[key]; \n			}\n		}\n	}\n	printf(\'%d\n\',result);\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2dbfe2c4c069b6e3d0044908d6cc03c8','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ - 138 节约内存 哈希\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <dd style=\'margin:0px; padding:0px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n    在某一国度里流行着一种游戏。游戏规则为：现有一堆球中，每个球上都有一个整数编号i(0&lt;=i&lt;=100000000),编号可重复，还有一个空箱子，现在有两种动作：一种是\'ADD\'，表示向空箱子里放m(0&lt;m&lt;=100)个球，另一种是\'QUERY”，表示说出M(0&lt;M&lt;=100)个随机整数ki(0&lt;=ki&lt;=100000100),分别判断编号为ki 的球是否在这个空箱子中（存在为\'YES\',否则为\'NO\'），先答出者为胜。现在有一个人想玩玩这个游戏，但他又很懒。他希望你能帮助他取得胜利。\n    <div class=\'clr\' style=\'clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n    </div>\n    <dl class=\'others\' style=\'margin:0px; padding:0px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px\'>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      第一行有一个整数n(0&lt;n&lt;=10000);\n      <br/>\n      随后有n行;\n      <br/>\n      每行可能出现如下的任意一种形式：\n      <br/>\n      第一种：\n      <br/>\n      一个字符串\'ADD\'，接着是一个整数m，随后有m个i；\n      <br/>\n      第二种：\n      <br/>\n      一个字符串\'QUERY”，接着是一个整数M，随后有M个ki；\n      <br/>\n      <br/>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      输出每次询问的结果\'YES\'或\'NO\'.\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_input\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>2\nADD 5 34 343 54 6 2\nQUERY 4 34 54 33 66</pre>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_output\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>YES\nYES\nNO\nNO</pre>\n     </dd>\n    </dl>\n    <h2>\n     2.Solution:\n    </h2>\n   </dd>\n  </div>\n  <div>\n   本题的数据量非常的大，而且还涉及到了不断的添加和查询操作\n  </div>\n  <div>\n   所以，简单的排序加二分的思路已经是走不通了，在这里我们用哈希\n  </div>\n  <div>\n   哈希的思路世纪路节点的存在，但是本题有一点巧妙而就是本题的内存非常的节约\n  </div>\n  <div>\n   65536kb的内存，我们如果只是简简单单的开100000000的int或者short的话我们看一下内存数据的占用情况\n  </div>\n  <div>\n   首先拿short来看吧，一个short两个字节，那么总共要200000000b，约为200000kb，很显然超过内存\n  </div>\n  <div>\n   所以在这里我们的解题思路很明显就是缩小我们的哈希表长\n  </div>\n  <div>\n   我才用的是1000000的表长，对于超出表唱的部分我们采用除留取余法，\n  </div>\n  <div>\n   但是这样我哦们是没有办法避免冲突的，采用拉链法我们可以尽可能的节约我们的内存\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于我们插入的内存优化，我们可以通过找到相同的然后不插入，但是这样的优化空间可以提升但是我们每次的查询都需要耗费一定量的遍历操作的时间，如果我们的冲突的频度非常大的话，还是会提高我们的时间的复杂度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在本题的测试数据中，我对两种思路都进行了测试，发现内存并没有减少，时间还提升了，说明我们的测试数据中的所有的只都是不相同的，导致我们的第二种思路的时间效率低于第一种的时间效率\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1966352\' name=\'code\' snippet_file_name=\'blog_20161104_1_452513\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	struct node* next;\n}point;\n\npoint hash[1000000];\nint n;\nint m;\nchar atom[10];\n\nvoid init()\n{\n	for(int i=0;i&lt;1000000;i++) hash[i].next=NULL;\n}\n\nint main()\n{\n	init();\n	scanf(\'%d\',&amp;n);\n	while(n--)\n	{\n		scanf(\'%s%d\',atom,&amp;m);\n		if(strcmp(atom,\'ADD\')==0)\n		{\n			for(int i=0;i&lt;m;i++)\n			{\n				int x;\n	    		scanf(\'%d\',&amp;x);\n		    	point* w=new point;\n		    	w-&gt;x=x;\n		    	bool flag=false;\n		    	point* p=hash[x%1000000].next;\n		    	while(p!=NULL)\n		    	{\n		    		if(p-&gt;x==x)\n		    		{\n		    			flag=true;\n		    			break;\n		    		}\n		    		p=p-&gt;next;\n		    	}\n		    	if(!flag)\n				{\n					w-&gt;next=hash[x%1000000].next;\n					hash[x%1000000].next=w;\n				} \n			}\n		}\n		else\n		{\n			for(int i=0;i&lt;m;i++)\n			{\n				int x;\n				scanf(\'%d\',&amp;x);\n				bool flag=false;\n				point* w=hash[x%1000000].next;\n				while(w!=NULL)\n				{\n					if(w-&gt;x==x) \n					{\n						flag=true;\n						break;\n					}\n					w=w-&gt;next;\n				}\n				if(flag) printf(\'YES\n\');\n				else printf(\'NO\n\');\n			}\n		}\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('14ded15154a6158a649db6d86727c4e2','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3274 - 数组 + 哈希\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <img alt=\'\' src=\'http://hi.csdn.net/attachment/201107/30/0_13120337780RMP.gif\'/>\n   <br/>\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   首先我们通过范例来了解一下题意是什么：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1964733\' name=\'code\' snippet_file_name=\'blog_20161103_1_2638020\'>7 3\n1 1 1\n1 1 0\n0 1 0\n0 0 1\n1 0 0\n0 1 0</pre>\n   如代码所示，我们k代表的是二进制的位数，n代表的是奶牛个数\n   <br/>\n  </div>\n  <div>\n   注意这种排列是题目要求的唯一的，我们不能改动\n  </div>\n  <div>\n   最后，我们开始转化问题\n  </div>\n  <div>\n   首先，我们想要快速的求出差值最好的方法就是就是对数组从头到尾进行累加（这种方法也是非常的优秀）但是本题只用这一种思想是远远不够的\n  </div>\n  <div>\n   我们想要求最长的满足要求的区间长度的话，还需要对问题进行转化\n  </div>\n  <div>\n   因为如果我们用朴素的方法的话需要至少O(n^2)的比较次数，这在数据量是10w的时候是无法容忍的，所以我们想要才去跟家高效的查找方式就是哈希\n  </div>\n  <div>\n   但是我们怎么哈希呢\n  </div>\n  <div>\n   首先，我们对题意进行转化\n  </div>\n  <div>\n   sum[i][j]存储第i行的之前的累计的值\n  </div>\n  <div>\n   carray[i][j]存储每一行的sum[i][j]-sum[i][0]\n  </div>\n  <div>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    sum[i][1]-sum[i][0] = sum[j][1]-sum[j][0]\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    sum[i][2]-sum[i][0] = sum[j][2]-sum[j][0]\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    ......\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    sum[i][k-1]-sum[i][0] = sum[j][k-1]-sum[j][0]\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    令C[i][y]=sum[i][y]-sum[i][0] (0&lt;y&lt;k)\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    初始条件C[0][0~k-1]=0\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    这里我们就将查找的条件转化成看carray数组的对应位是否相同了(其实不做最后一步转化也可以只不过我们要计算罢了)\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    最后我们用哈希来高效存储提高查找效率，不断更新我们的最大值就好了\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    在这里我们总结哈希的本质就是\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    原本我们需要对每个元素都要重新遍历一遍数组找最大值，但是我们现在通过哈希省去了很大一部分的不必要的判断，我们先明确必要条件然后我们去查询减少了我们的判断的次数\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    提高时间效率\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <br/>\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    PS:这里要小心最重要的一点，carray数组的第一个元素是从0开始的，不是从1开始的，不然对于\n   </p>\n   <p align=\'left\' style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   </p>\n   <pre class=\'cpp\' code_snippet_id=\'1964733\' name=\'code\' snippet_file_name=\'blog_20161103_2_7130359\'>4 4\n1\n2\n4\n8</pre>\n   这种是会出错的，我就是WA在这里了\n   <h2 style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <br/>\n   </h2>\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1964733\' name=\'code\' snippet_file_name=\'blog_20161103_3_8068450\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cmath\'\n#include\'cstdlib\'\n#define N 1000000   //100w的散列 \n#define MAX 100005  //10w的数据量 \n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	struct node* next;\n}point;\n\nint n,k;\nint sum[MAX][32];\nint carray[MAX][32];\npoint hash[N];   //散列记录下标 \n\nint hash_function(int i)\n{\n	int p=0;\n	for(int j=0;j&lt;k;j++)\n	{\n		p=((p+(carray[i][j])&lt;&lt;2))%N;\n	}\n	return abs(p)%N;\n}\n\nvoid init()\n{\n	for(int i=0;i&lt;N;i++) hash[i].next=NULL;\n	point* w=new point;    //这里就是WA的核心 \n	w-&gt;next=hash[0].next;\n	hash[0].next=w;\n	w-&gt;x=0;\n}\n\nint main()\n{\n	init();\n	int result=0;\n	int x;\n	scanf(\'%d%d\',&amp;n,&amp;k);\n	for(int i=1;i&lt;=n;i++)\n	{\n		scanf(\'%d\',&amp;x);\n		for(int j=0;j&lt;k;j++)   //问题转化 \n		{\n			sum[i][j]=sum[i-1][j]+(x &amp; 1);\n			carray[i][j]=sum[i][j]-sum[i][0]; \n			x=x&gt;&gt;1;  //x是正数 \n		}\n    	int key=hash_function(i);   //将carray的第i行哈希,返回散列地址 \n		point* w=hash[key].next;\n		while(w!=NULL)\n		{\n			int j;\n			for(j=0;j&lt;k;j++)\n			{\n				if(carray[i][j]!=carray[w-&gt;x][j]) break;\n			}\n			if(j==k&amp;&amp;result&lt;i-w-&gt;x) result=i-w-&gt;x; \n			w=w-&gt;next;\n		} \n		point* h=new point;\n		h-&gt;x=i;\n		h-&gt;next=hash[key].next;\n		hash[key].next=h;\n	}\n	printf(\'%d\n\',result);\n	return 0;\n\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c483f05652dfed8429bb6988b7c39e74','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  快排光芒下被忽视的Partition函数\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.前言:\n  </h2>\n  <div>\n   看到这篇标题，没有学过快排的人自然是不知道Partition函数的意思和作用，这里附上学习的连接\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52145746?locationNum=3&amp;fps=1\' target=\'_blank\'>\n    Lantian的快排总结\n   </a>\n  </div>\n  <div>\n   我们现在都是被快排蒙蔽了双眼，没有意识到快最核心的划分函数Partition,当然Partition函数也就不止于快排这里，本文就从多方面来为展示Partition函数的本质和扩展作用\n  </div>\n  <h2>\n   2.快排中的Partition及其优化：\n  </h2>\n  <div>\n   在算法导论中我们对Partition函数的定义是这样的：\n  </div>\n  <div>\n   <p style=\'margin:0in 0in 10pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:18px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     PARTITION(A, p, r)\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     x\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     =\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     A[r]\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     选择最后一个元素作为比较元素\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     =\r\n p\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     –\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     这个慢速移动下标必须设定为比最小下表\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     p\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     小\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     ，否则两个元素的序列比如\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     2\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     ，\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     无法交换\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Microsoft YaHei\'; border:0px; outline:0px; font-size:13.3333px; vertical-align:baseline; background:transparent\'>\n     <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n      for\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     j\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     =\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     p\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Microsoft YaHei\'; border:0px; outline:0px; font-size:13.3333px; vertical-align:baseline; background:transparent\'>\n     <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n      to\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     r-1\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     遍历每个元素\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     {\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Microsoft YaHei\'; border:0px; outline:0px; font-size:13.3333px; vertical-align:baseline; background:transparent\'>\n     <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n      if\r\n (\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     A[j] &lt;=\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     x)\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     比较\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Microsoft YaHei\'; border:0px; outline:0px; font-size:13.3333px; vertical-align:baseline; background:transparent\'>\n     <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n      {\n     </span>\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 1in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     =\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     +\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     移动慢速下标\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 1in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     Exchange\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     A[i]\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     with\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     A[j\r\n ]\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     交换\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     }\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     }\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     Exchange\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     A[i+1]\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     with\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     A[r]\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     交换\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; border:0px; outline:0px; font-size:12px; vertical-align:baseline; color:rgb(102,102,102); line-height:26px; background:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; font-family:\'Microsoft YaHei\'; border:0px; outline:0px; font-size:13.3333px; vertical-align:baseline; background:transparent\'>\n     <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n      return\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     +\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; font-family:\'Comic Sans MS\'; border:0px; outline:0px; font-size:14pt; vertical-align:baseline; line-height:1.5; background:transparent\'>\n     返回分割点\n    </span>\n   </p>\n   这里我就不再过多的赘述算法的具体细节，我在这里强调的是对快排中的Partition的优化\n  </div>\n  <div>\n   首先，在原本的算法中，假如我们已经选定了一个枢纽元，那么对于所有的比枢纽元小的元素我们都执行了swap操作\n  </div>\n  <div>\n   这是非常的低效的\n  </div>\n  <div>\n   在这里我们引入双向的Partition算法，在双向的算法中，我们对于比枢纽院小的元素并不是都执行了swap操作，只有数组右边的一部分的比枢纽元小的元素我们才执行了swap操作，大大减少了swap操作的次数从而降低时间复杂度\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1963331\' name=\'code\' snippet_file_name=\'blog_20161102_1_3164489\'>含有Partition函数的快速排序，标准算法导论上的描述实现 \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1005\n\nusing namespace std;\n\nint data[N];\nint number;\n\nvoid init_data()\n{\n	scanf(\'%d\',&amp;number); \n	for(int i=0;i&lt;number;i++) scanf(\'%d\',&amp;data[i]);\n}\n\nvoid partition(int left,int&amp; mid,int right)\n{\n	int i=left-1;\n	int j=left;\n	int var=data[right];\n	while(j&lt;right)\n	{\n		if(data[j]&lt;var)\n		{\n			i++;\n			int temp=data[i];\n			data[i]=data[j];\n			data[j]=temp;\n		}\n		j++;\n	}\n	i++;\n	int temp=data[i];\n	data[i]=var;\n	data[right]=temp;\n	mid=i;\n	return ;\n}\n\nvoid quicksort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int mid;\n		partition(left,mid,right);\n		quicksort(left,mid-1);\n		quicksort(mid+1,right); \n		return ;\n	} \n}\n\nvoid print()\n{\n	for(int i=0;i&lt;number;i++) printf(\'%d \',data[i]);\n	printf(\'\n\');\n}\n\nint main()\n{\n	init_data();\n	quicksort(0,number-1);\n	print();\n	return 0;\n}</pre>\n   双向的Partition我在我的连接中已经写明了\n  </div>\n  <div>\n   你们可能对这一点还是有所怀疑，我们来做一做实验：\n  </div>\n  <div>\n   注意，一下的代码是Python编写的，为了方便实验\n   <br/>\n   <pre class=\'python\' code_snippet_id=\'1963331\' name=\'code\' snippet_file_name=\'blog_20161102_2_2750569\'>import random\nfrom time import *\nglobal data\ndata=[]\ndef partition_1():\n    global data\n    i=-1\n    j=0\n    var=data[len(data)-1]\n    while j&lt;len(data)-1:\n        if data[j]&lt;var:\n            i+=1\n            temp=data[i]\n            data[i]=data[j]\n            data[j]=temp\n        j+=1\n    i+=1\n    temp=data[i]\n    data[i]=var\n    data[len(data)-1]=temp\n\ndef partition_2():\n    global data\n    i=0\n    j=len(data)-1\n    temp=data[0]\n    while i!=j:\n        while i&lt;j and data[j]&gt;=temp:\n            j-=1\n        while i&lt;j and data[i]&lt;=temp:\n            i+=1\n        if i!=j:\n            t=data[i]\n            data[i]=data[j]\n            data[j]=t\n    data[0]=data[i]\n    data[i]=temp\n\ndef test_init():\n    global data\n    data=eval(input())\n\ndef init_data():\n    global data\n    for i in range(1000000):\n        data.append(random.randint(-100000,100000))\n\ninit_data()\ntime1=clock()\npartition_1()\nprint(\'单向partition耗时:%f\'%(clock()-time1))\ntime1=clock()\npartition_2()\nprint(\'双向partition耗时:%f\'%(clock()-time1))\n#test_init()\n#partition_2()\n</pre>\n   实验结果：\n  </div>\n  <div>\n   单向partition耗时:0.833947\n   <br/>\n   双向partition耗时:0.277176\n   <br/>\n   很显然，在数据量越来越大的时候，我们的双向Partition与单向的Partition比是非常的高效的\n  </div>\n  <h2>\n   3.Top-k Question:\n  </h2>\n  <div>\n   对于Top-k问题已经被问烂了，解法也是很多的\n  </div>\n  <div>\n   当然我们优秀的解法有：\n  </div>\n  <div>\n   O(n*logk)的堆排序实现\n  </div>\n  <div>\n   BST/SBT二叉查找树，自平衡二叉查找树实现:忽略建树时间的话，我们的而时间复杂度是O(logn)\n  </div>\n  <div>\n   现在我们完全可以利用Partition函数来进行实现：\n  </div>\n  <div>\n   对于Partition函数的该操作的实现，很多人又叫这种方法快速选择算法（注意选择之后得到的不是有序的数组只是一个有了划分的数组）\n  </div>\n  <div>\n   算法的本质是通过每次遍历Partition分组操作之后确定Tok-k的位置所在，然后递归查找所在的那一边区域（相当于是BST或者二分查找的思路）\n  </div>\n  <div>\n   时间复杂度是O(n)\n  </div>\n  <div>\n   时间复杂度的推导：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1963331\' name=\'code\' snippet_file_name=\'blog_20161102_3_384018\'>T(n)=O(n)+T(n/2)\n...log2n=k次迭代\nT(n)=O(n)+O(n/2)...O(1)\nT(n)=O(n*(1+1/2+...1/n))=O(2*n-2)</pre>\n   <br/>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1963331\' name=\'code\' snippet_file_name=\'blog_20161102_4_4113771\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1005\n\nusing namespace std;\n\nint data[N];\nint number;\nint k;\nint pos=-1;   //最终确定的地址 \n\nvoid print()\n{\n	for(int i=0;i&lt;=pos;i++) printf(\'%d \',data[i]);\n	printf(\'\n\');\n}\n\nvoid init_data()\n{\n	scanf(\'%d%d\',&amp;number,&amp;k);\n	for(int i=0;i&lt;number;i++) scanf(\'%d\',&amp;data[i]);\n}\n\nvoid quickfind(int left,int right,int n)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int i=left-1;\n		int j=left;\n		int var=data[right];\n		while(j&lt;right)\n		{\n			if(data[j]&lt;var)\n			{\n				i++;\n				int temp=data[i];\n				data[i]=data[j];\n				data[j]=temp;\n			}\n			j++;\n		}\n		int temp=data[i+1];\n		data[i+1]=data[j];\n		data[right]=temp;\n		if(i+1-left+1==n)\n		{\n			pos=i+1;\n			return ;\n		} \n		else if(i+1-left+1&lt;n) quickfind(i+2,right,n-(i+1-left+1));\n		else quickfind(left,i,n);\n	}\n}\n</pre>\n   <br/>\n   <h2>\n    4.Dutch national flag problem\n   </h2>\n  </div>\n  <div>\n   荷兰三色旗问题，这种问题是用Partition的典型例子\n  </div>\n  <div>\n   定义一个数组序列有红白蓝三种颜色，我们要求尽可能快的对数组进行排序，是的相同颜色的元素相邻，并且整体存在红白蓝额顺序\n  </div>\n  <div>\n   本题是Partition函数的扩展应用，时间复杂度和空间复杂度处理的非常的优秀\n  </div>\n  <div>\n   算法详见：\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/53010521\' target=\'_blank\'>\n    Leetcode-75\n   </a>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1963331\' name=\'code\' snippet_file_name=\'blog_20161102_5_2620055\'>/*\nPartiton函数的作用 \n简易模拟 Dutch national flag problem */ \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1005\n\nusing namespace std;\n\n//0&lt;1&lt;2为例 \nint data[N];\nint number;\n\nvoid init_data()\n{\n	scanf(\'%d\',&amp;number);\n	for(int i=0;i&lt;number;i++) scanf(\'%d\',&amp;data[i]);\n}\n\nvoid print()\n{\n	for(int i=0;i&lt;number;i++) printf(\'%d \',data[i]);\n	printf(\'\n\');\n}\n\nvoid swap(int x,int y,int atom)\n{\n	int temp;\n	if(atom==0)\n	{\n		temp=data[x];\n		data[x]=data[y];\n		data[y]=temp;\n	}\n	else\n	{\n		temp=data[x];\n		data[x]=data[y];\n		data[y]=temp;\n	}\n}\n\nvoid sortColors() {\n    int i=-1;\n    int j=0;\n    int k=number;\n    while(j&lt;k)\n    {\n        if(data[j]==0)\n        {\n            i++;\n            int temp=data[i];\n            data[i]=data[j];\n            data[j]=temp;\n        }\n        else if(data[j]==2)\n        {\n            k--;\n            while(j&lt;k&amp;&amp;data[k]==2) k--;\n            int temp=data[j];\n            data[j]=data[k];\n            data[k]=temp;\n            if(data[j]==0)\n            {\n                i++;\n                int temp=data[i];\n                data[i]=data[j];\n                data[j]=temp;\n            }\n        }\n        j++;\n    }\n}\n\nint main()\n{\n	init_data();\n	print();\n	sortColors();\n	print();\n	return 0;\n}</pre>\n   <h2>\n    5总结：\n   </h2>\n   <div>\n    Partition函数真的是非常的强大，我们如果只是了解快排的话真的是没有学透Partition函数的精髓，也没有学到快排的算法的本质\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('0f83981f8c807e6d7775ac507fd33680','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Leetcode - 75. Sort Colors - Dutch national flag problem - Partition\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <p style=\'margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:30px\'>\n    Given an array with\n    <span style=\'\'>\n     n\n    </span>\n    objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:30px\'>\n    Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n   </p>\n   翻译：\n  </div>\n  <div>\n   给你一个n长度的序列，序列中的元素只有红,白,蓝三种，对这个序列进行排序是的相同颜色的元素是邻近的，并且整体上有红,白,蓝的顺序\n  </div>\n  <div>\n   这里我们定义0代表红色，1代表白色，2代表蓝色\n  </div>\n  <div>\n   请用尽可能高效的解法给出解答\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题是标准的Dutch nation flag problem问题，荷兰三色旗问题我们的解决途径是很显然的\n  </div>\n  <div>\n   对于朴素的方法来说，我们可以扫描一遍然后计数最后我们对数组进行重新赋值就好，需要的时间复杂度是O(n),但是常数时间的因子不是很完美\n  </div>\n  <div>\n   本题的标准解法是利用Partition函数（详见快速排序）下设三个指针域从而实现一遍扫描O(n)解决，空间复杂度是O(1)高效的解决这个问题\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   算法的原理如下：\n  </div>\n  <div>\n   1.初始化：0指针索引是-1,1指针索引是0,2指针索引是数组的长度（注意是长度，下表从0开始）\n  </div>\n  <div>\n   2.首先，我们先给出意义：\n  </div>\n  <div>\n   0,1(开区间)指针之间的区域全部都是1\n  </div>\n  <div>\n   数组首地址到0指针之间全部都是0\n  </div>\n  <div>\n   2指针到数组的尾地址之间全都是2\n  </div>\n  <div>\n   1-2(前闭后开)指针之间都是待检查的区域\n  </div>\n  <div>\n   3.对于每次的1指针\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   如果是1，忽略\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   如果是0，我们令0指针递增并交换\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   如果是2，我们令2指针递减至第一个非2元素并交换\n  </div>\n  <div>\n   4.当1指针和2指针指向相同，程序结束，完成交换\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1963233\' name=\'code\' snippet_file_name=\'blog_20161102_1_616635\'>void sortColors(int* nums, int numsSize) {\n    int i=-1;\n    int j=0;\n    int k=numsSize;\n    while(j&lt;k)\n    {\n        if(nums[j]==0)\n        {\n            i++;\n            int temp=nums[i];\n            nums[i]=nums[j];\n            nums[j]=temp;\n        }\n        else if(nums[j]==2)\n        {\n            k--;\n            while(j&lt;k&amp;&amp;nums[k]==2) k--;\n            int temp=nums[j];\n            nums[j]=nums[k];\n            nums[k]=temp;\n            if(nums[j]==0)\n            {\n                i++;\n                int temp=nums[i];\n                nums[i]=nums[j];\n                nums[j]=temp;\n            }\n        }\n        j++;\n    }\n}</pre>\n   <h4 style=\'font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-weight:500; line-height:1.1; color:rgb(51,51,51); margin-top:10px; margin-bottom:10px; font-size:18px\'>\n    Submission Result:\n    <a class=\'ng-binding text-success\' href=\'https://leetcode.com/submissions/detail/81053387/\' id=\'result-state\' style=\'color:rgb(60,118,61); text-decoration:none; background-color:transparent\' target=\'_blank\'>\n     Accepted\n    </a>\n   </h4>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('8a22a0815cfe9ee71c17c22a1cbfa291','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3329 - 数学 + 哈希\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   平面上有一些二维点，现在我们要求输入的这些二维点最多可以构成多少个正方形，注意选择的点次序不同得到的正方形视作相同的正方向\n  </div>\n  <div>\n   输入：\n  </div>\n  <div>\n   有多组测试用例，首先每一组测试用例的第一行n表示有n个点\n  </div>\n  <div>\n   之后的n行中两个数字分别表示二维点的横纵坐标\n  </div>\n  <div>\n   输出：\n  </div>\n  <div>\n   可以组成的正方形的个数\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   首先我们来描述一下为什么朴素的枚举人以四个点地做法是不行的，首先，本题的数据量大小是1000，如果我们对1000进行选择四个的枚举来操作的话\n  </div>\n  <div>\n   我们按照排列组合来计算至少需要比较：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1962818\' name=\'code\' snippet_file_name=\'blog_20161102_1_1795836\'>C(4,1000)=1000*999*998*997/24</pre>\n   显然我们会发现要比较的次数太过庞大，二期我们判断四个点是否构成是正方形还是需要很困难的数字计算的\n  </div>\n  <div>\n   本题，我们选择采用枚举两个点来进行，我们枚举两个点，然后通过计算算出能够成的正方形的情况，然后我们对于所有的数据进行查找\n  </div>\n  <div>\n   于是我们就将这个大数量的问题转化成了查找的题目\n  </div>\n  <div>\n   对于查找的方式，本题有很多的思路\n  </div>\n  <div>\n   1.二分+快排\n  </div>\n  <div>\n   2.哈希\n  </div>\n  <div>\n   本文，我们用哈希的思路来进行高速的查找（但是我不知道为什么我的时间耗费很大\n   <span style=\'font-size:12px\'>\n    ）\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    计算公式需要很强的数学功底，我还不太会，公式如下：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n   </span>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     已知： (x1,y1)  (x2,y2)\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     则：   x3=x1+(y1-y2)   y3= y1-(x1-x2)\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     x4=x2+(y1-y2)   y4= y2-(x1-x2)\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     或\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     x3=x1-(y1-y2)   y3= y1+(x1-x2)\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     x4=x2-(y1-y2)   y4= y2+(x1-x2)\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     求两个点的思路可能是求出(x1,y1),(x3,y3)的中点，再利用(x2,y2)两个垂直的定理求解出(x3,y3)的关系，(x4,y4)同理\n    </strong>\n   </p>\n   最后通过高速查找的方法，我们只需要至少：\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1962818\' name=\'code\' snippet_file_name=\'blog_20161102_2_7782674\'>C(2,1000)=1000*999/2</pre>\n   大大缩小了我们的比较次数，从而达到优化时间的目的\n  </div>\n  <div>\n   <h2>\n    3.Code:\n   </h2>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1962818\' name=\'code\' snippet_file_name=\'blog_20161102_3_5448360\'>/*\nProblem: 2002		User: lantianheyeqi\nMemory: 1076K		Time: 3329MS\nLanguage: G++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 1000\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n	struct node* last;\n}data;\n\nint n;\ndata point[N+10];\n\nvoid init()\n{\n	for(int i=0;i&lt;N;i++) point[i].last=NULL;\n}\n\nvoid insert(int key,int x,int y)\n{\n	data* p=&amp;point[key];\n	data* w=new data;\n	w-&gt;x=x;\n	w-&gt;y=y;\n	w-&gt;last=p-&gt;last;\n	p-&gt;last=w;\n}\n\nint hash_function(int x,int y)\n{\n	return (x*x+y*y)%N;\n}\n\nbool find(int x3,int y3,int x4,int y4)\n{\n	bool ok1=false;\n	bool ok2=false;\n	int key1=hash_function(x3,y3);\n	int key2=hash_function(x4,y4);\n	data* p1=point[key1].last;\n	while(p1!=NULL)\n	{\n		if(p1-&gt;x==x3&amp;&amp;p1-&gt;y==y3)\n		{\n			ok1=true;\n			break;\n		}\n		p1=p1-&gt;last;\n	}\n	if(!ok1) return false;\n	p1=point[key2].last;\n	while(p1!=NULL)\n	{\n		if(p1-&gt;x==x4&amp;&amp;p1-&gt;y==y4)\n		{\n			ok2=true;\n			break;\n		}\n		p1=p1-&gt;last;\n	}\n	if(ok1&amp;&amp;ok2) return true;\n	else return false;\n}\n\nint main()\n{\n	data now[N+10];\n	int x,y;\n	int sum=0;\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n!=0)\n	{\n		sum=0;\n		init();\n		for(int i=1;i&lt;=n;i++)\n		{\n			scanf(\'%d%d\',&amp;x,&amp;y);\n			now[i].x=x,now[i].y=y;\n    		int key=hash_function(x,y);\n    		insert(key,x,y);\n		}\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(i==j) continue;\n				else\n				{\n					int x3,y3,x4,y4;\n					int x1,y1,x2,y2;\n					x1=now[i].x,y1=now[i].y;\n					x2=now[j].x,y2=now[j].y;\n					x3=x1+(y1-y2),y3= y1-(x1-x2);\n                    x4=x2+(y1-y2),y4= y2-(x1-x2);\n					if(find(x3,y3,x4,y4)) sum++;\n					x3=x1-(y1-y2),y3= y1+(x1-x2);\n                    x4=x2-(y1-y2),y4= y2+(x1-x2);\n					if(find(x3,y3,x4,y4)) sum++;\n				}\n			}\n		}\n		printf(\'%d\n\',sum/8);\n	}\n	return 0;\n} </pre>\n    <br/>\n    <br/>\n   </div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('36ce257e05ca20567ddcca2ded5086dc','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 3349 - 数值哈希（这辈子只服数据量）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意描述：\n  </div>\n  <div>\n   输入：n代表有多少片雪花\n  </div>\n  <div>\n   之后的n行，每行6个数字代表雪花的6个枝杈的长度（正序逆序都可以）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   输出：\n  </div>\n  <div>\n   如果以上的雪花中出现了同构的情况，那么我们认为出现了相同的雪花\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   最后如果我们认为有两种相同的雪花，输出Twin snowflakes found.\n  </div>\n  <div>\n   否则输出No two snowflakes are alike.\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题的数据量是我最想吐槽的，而不能提的思路是哈希（为了优化速度，不然铁定超时）\n  </div>\n  <div>\n   1.朴素思路：\n  </div>\n  <div>\n   如果我们采用数组直接存储的话，对于每一中的情况我们都需要进行往前的回溯判断，总共需要\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1961562\' name=\'code\' snippet_file_name=\'blog_20161101_1_5282393\'>T(n)=1+2+...+n=O(n^2)</pre>\n   的时间复杂度，本题来说的话10000^2是一定会超时的，在这里我们就要考虑优化了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.优化思路1：\n  </div>\n  <div>\n   我们这里哈希的本质思路是对雪花进行分类，我们分类的依据是六个分叉的和相同的试做一个类，这样的话，我们对雪花进行分类之后可以通过（类似邻接表的思路）快速的减少遍历的次数来进行快速的正确的判断，如果数据哈希的均匀的话，可以无限接近于O(1)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.TLE+RE的教训\n  </div>\n  <div>\n   首先我们来说说RE，在本题中因为我多次的TLE之后让我误以为是散列的范围不够大，所以我将哈希函数改成平方和对10w取模，但是在计算的过程之后发现TLE变成了RE，在这里我认为是因为本题的数据量有点大在100w的数据平方之后导致对于long型数据也溢出了，所以我们最好不要采用平方和的哈希方案\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于TLE有这么几点：\n  </div>\n  <div>\n   1.首先，我们的不要用线性探测的思路去做，因为线性探测是会出现二次聚集的情况的，我们最好的思路是采用拉链法构建哈希表\n  </div>\n  <div>\n   2.本题的用平方和的思路是可以做的，但是要求我们对结果要不断的取模控制溢出，但是这里也就引入了驱魔运算的效率的问题，我们都知道木偶运算是非常的低效的，索引说对于大数量的取模操作耗时也是让我们在本体的数据量下变得难以接受\n  </div>\n  <div>\n   3.最后，也是最重要的一点，我们千万不要为了节约内存对节点的保存数组用int*指针来代替，在用的时候我们动态分配内存的时间是非常的恐怖的，这也就是我TLE的根本所在\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   ps:本题判断雪花是不是相同的，我们采用了一点点优化，我摘引自别的大神，其他的判断方式当然也可以，但是这样写的非常的直观\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1961562\' name=\'code\' snippet_file_name=\'blog_20161101_2_6645596\'>/*\nProblem: 3349		User: lantianheyeqi\nMemory: 8908K		Time: 3485MS\nLanguage: G++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100001\n\nusing namespace std;\n\ntypedef struct node\n{\n	int data[6];\n	struct node* last;\n}point;\n\nint n;\npoint snow[N];\nint dp[6];\n\nvoid init()\n{\n	for(int i=0;i&lt;N;i++) snow[i].last=NULL;\n}\n\nbool issame(int* white)\n{\n	for(int i=0;i&lt;6;i++)    //这里为了解决同构的问题，我们必须要考虑顺时针和逆时针，在这里我们引入了如下的方法进行优化，值得学习 \n	{\n		if((dp[0]==white[i]&amp;&amp;\n		   dp[1]==white[(i+1)%6]&amp;&amp;\n		   dp[2]==white[(i+2)%6]&amp;&amp;\n		   dp[3]==white[(i+3)%6]&amp;&amp;\n		   dp[4]==white[(i+4)%6]&amp;&amp;\n		   dp[5]==white[(i+5)%6])\n		   ||\n		   (dp[0]==white[i]&amp;&amp;\n		    dp[1]==white[(i+5)%6]&amp;&amp;\n			dp[2]==white[(i+4)%6]&amp;&amp;\n			dp[3]==white[(i+3)%6]&amp;&amp;\n			dp[4]==white[(i+2)%6]&amp;&amp;\n			dp[5]==white[(i+1)%6]))\n		return true;\n	}\n	return false;\n}\n\nbool find(int key)\n{\n	point* k=snow[key].last;\n	while(k!=NULL)\n	{\n		if(issame(k-&gt;data)) return true;\n		k=k-&gt;last;\n	}\n	return false;\n}\n\nvoid insert(int key)\n{\n	point* k=new point;\n	for(int i=0;i&lt;6;i++) k-&gt;data[i]=dp[i];\n	k-&gt;last=snow[key].last;\n	snow[key].last=k;\n}\n\nint main()\n{\n	bool ok=false;\n	init();\n	scanf(\'%d\',&amp;n);\n	for(int i=1;i&lt;=n;i++)\n	{\n		int sum=0;\n		for(int j=0;j&lt;6;j++) scanf(\'%d\',&amp;dp[j]),sum+=dp[j];\n		sum=sum%N;\n		if(find(sum)) ok=true;\n		else insert(sum);\n	}\n	if(ok) printf(\'Twin snowflakes found.\n\');\n	else printf(\'No two snowflakes are alike.\n\');\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('13075d1c6b47863f4cb80a3efc718856','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2503 - 二分+快排\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   前文有\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本文采用二分+快排的模式\n  </div>\n  <div>\n   我们都知道字符串在字典序下是有严格的递增的序列的，所以我们利用字符串的字典序作为待查序列，利用二分法来查找\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   PS：二分法的时间复杂度是O(n*logn),但是字典树是接近O(n)，但是在测试中，二分比字典树还要快一点，我有些不得其解，可能库函数对排序而做了非常好的的优化我也不知道，也有可能是数据的问题\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   本方法需要的知识连接：\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52772002\' target=\'_blank\'>\n    lantian的二分讲解\n   </a>\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1959883\' name=\'code\' snippet_file_name=\'blog_20161101_1_7613441\'>/*\nProblem: 2503		User: lantianheyeqi\nMemory: 2500K		Time: 485MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'algorithm\'\n#define N 100005\n\nusing namespace std;\n\ntypedef struct node\n{\n	char english[12];\n	char foreign[12];\n}point;\n\npoint data[N];\nint number;\n\nbool cmp(point x,point y)\n{\n	int k=strcmp(x.foreign,y.foreign);\n	if(k&gt;0) return false;\n	else return true;\n}\n\nvoid find(int left,int right,char* f)\n{\n	int mid=(left+right)/2;\n	while(left&lt;=right)\n	{\n		int k=strcmp(data[mid].foreign,f);\n		if(k&gt;0) right=mid-1;\n		else if(k&lt;0) left=mid+1;\n		else \n		{\n			printf(\'%s\n\',data[mid].english);\n			return ;\n		}\n		mid=(left+right)/2;\n	}\n	printf(\'eh\n\');\n	return ;\n}\n\nint main()\n{\n	char e[12];\n	char f[12];\n	char ppp[30];\n	while(gets(ppp)&amp;&amp;ppp[0]!=\'\0\')\n	{\n		sscanf(ppp,\'%s%s\',&amp;e,&amp;f);\n		number++;\n		strcpy(data[number].english,e);\n		strcpy(data[number].foreign,f);\n	}\n	sort(data+1,data+1+number,cmp);\n	while(gets(f))\n	{\n		find(1,number,f);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b4879acfeae5796e043cb678ee5be519','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2503 - 字典树再解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意:\n  </div>\n  <div>\n   有不超过10w个字典序列，每个字典序列中都是两个字符串，第一个字符串是英文，第二个字符串是对应的一门不知道什么语言\n  </div>\n  <div>\n   现在要求我们尽可能快速的建立映射，是的我们根据输入的外语可以快速的查找到对应的英语\n  </div>\n  <div>\n   每个单词的长度不超过10，全部都是小写（简化了问题）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   输入样例和解释：\n  </div>\n  <div>\n   <pre class=\'sio\' style=\'font-family:\'Courier New\',Courier,monospace; font-size:14px\'>dog ogday\ncat atcay\npig igpay\nfroot ootfray\nloops oopslay\n\natcay\nittenkay\noopslay\n</pre>\n   <div>\n    第一个序列代表我们的字典序列\n   </div>\n  </div>\n  <div>\n   之后的一个空行之后我们开始执行查找操作，输入一直执行到文件的末尾\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题的思路很多，因为是查找类的题目：\n  </div>\n  <div>\n   通解有：字典树，快排+二分，字符串哈希\n  </div>\n  <div>\n   本文只针对字典树的解法，快排和哈希我另外再写解法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于字典树，如果还没有了解，欢迎访问我的博客：\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52727024?locationNum=1&amp;fps=1\' target=\'_blank\'>\n    lantian的字典树总结\n   </a>\n  </div>\n  <div>\n   首先对于本题来说，因为是OJ上的题目，我们对速度是要非常的小心的，所以这里我们摒弃查找速度相对较慢的双链法实现的字典树，我们采用类似B树的形式构建多键字典树\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   字典树的节点内容：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1958228\' name=\'code\' snippet_file_name=\'blog_20161031_1_9155632\'>typedef struct node\n{\n	char key;   //存储当前的键位 \n	struct node* nextp[27];   //子指针 \n	char* data;   //存储字典键值 \n	bool isleaf;   //判断域是否是叶子节点\n	bool isphrase;   //判断以当前键结束的词是否出现过 \n}point;</pre>\n   这里的isphrase是非常的有必要的，在总结中我已经提到了，我们的字典树采用的是公共前缀的压缩处理方式所以说我们真的很有必要判断当前的节点是不是一个单词的末尾\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   PS：在这里为了节约内存我稍微做了点优化，我将存储字符串的变量没有设置成数组，我设置成了字符指针，对于非叶子节点只占用一个字节的内存，只有对于叶子节点才会保存长的字符串\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   相对高效存储的（因为考虑的建树的时间，字典树的速度会稍微的慢于字符串哈希）哈希算法而言，我们的字典树是稍微，慢了的，但是还算是非常的高效\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1958228\' name=\'code\' snippet_file_name=\'blog_20161031_2_4029656\'>/*\nProblem: 2503		User: lantianheyeqi\nMemory: 20760K		Time: 516MS\nLanguage: C++		Result: Accepted\n*/\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	char key;   //存储当前的键位 \n	struct node* nextp[27];   //子指针 \n	char* data;   //存储字典键值 \n	bool isleaf;   //判断域是否是叶子节点\n	bool isphrase;   //判断以当前键结束的词是否出现过 \n}point;\n\npoint root;   //根节点,根节点没有键值 \nint number;  //节点总数\nchar english[13];\nchar foreign[13];\n\nvoid initpoint(point&amp; x,char key)    //初始化节点 \n{\n	x.key=key;\n	for(int i=0;i&lt;27;i++) x.nextp[i]=NULL;\n	x.data=NULL;\n	x.isleaf=true;\n	x.isphrase=false;\n}\n\nvoid insert()\n{\n	point* help=&amp;root; \n	char* now=foreign;\n	while(*now!=\'\0\')\n	{\n		if(help-&gt;nextp[(*now-\'a\')]!=NULL) help=help-&gt;nextp[(*now-\'a\')];\n		else\n		{\n			point* p=new point;\n			initpoint(*p,*now);\n			if(*(now+1)!=\'\0\') p-&gt;isleaf=false;   //强制转化非叶子节点 \n			else \n			{\n				p-&gt;isphrase=true;    //强制转化成单词节点\n				p-&gt;data=(char*)malloc(sizeof(char)*12);\n				strcpy(p-&gt;data,english);\n			} \n			help-&gt;nextp[(*now-\'a\')]=p;\n			help=p;\n		}\n		now++;\n	}\n}\n\nvoid find()\n{\n	point* p=&amp;root;\n	char* now=foreign;\n	while(*now!=\'\0\')\n	{\n		if(p==NULL) break;\n		p=p-&gt;nextp[(*now-\'a\')];\n		now++;\n	}\n	if(p==NULL) printf(\'eh\n\');\n	else printf(\'%s\n\',p-&gt;data);\n}\n\nint main()\n{\n	char ppp[30];\n	initpoint(root,\'#\');\n	while(gets(ppp) &amp;&amp; ppp[0]!=\'\0\')\n	{\n		sscanf(ppp,\'%s %s\',&amp;english,foreign);\n		insert();   //插入操作\n		number++; \n		memset(english,0,sizeof(english));\n		memset(foreign,0,sizeof(foreign));\n	}\n	\n	while(gets(foreign))\n	{\n		find();\n		memset(foreign,0,sizeof(foreign));\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('251bddab31c2f3083c00169d4ffe44d4','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2503 - 字符串哈希\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   简单的字符串哈希的题目\n  </div>\n  <div>\n   引用拉链法处理冲突\n  </div>\n  <h2>\n   2.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1956497\' name=\'code\' snippet_file_name=\'blog_20161030_1_3035440\'>#include\'iostream\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cstdio\'\n#define N 100003\n\nusing namespace std;\n\ntypedef struct node\n{\n	char english[15];\n	char foreign[15];\n	struct node* next;\n}point;\n\npoint data[N];\n\nint elfhash(char* str)\n{\n	unsigned long hash=0;\n	unsigned long x=0;\n	while(*str)\n	{\n		hash=(hash&lt;&lt;4)+(*str++);\n		if((x=hash&amp;0xF0000000L)!=0)\n		{\n			hash^=(x&gt;&gt;24);\n		}\n		hash&amp;=~x;\n	}\n	return hash%N;\n}\n\nint main()\n{\n	char ppp[30];\n	char s1[12];\n	char s2[12];\n	memset(s1,0,sizeof(s1));\n	memset(s2,0,sizeof(s2));\n	while(gets(ppp) &amp;&amp; ppp[0]!=\'\0\')\n	{\n		sscanf(ppp,\'%s %s\',s1,s2);\n		int key=elfhash(s2);\n		point* k=new point;\n		memset(k,0,sizeof(k));\n		strcpy(k-&gt;english,s1);\n		strcpy(k-&gt;foreign,s2);\n		k-&gt;next=data[key].next;\n		data[key].next=k;\n		\n		memset(s1,0,sizeof(s1));\n		memset(s2,0,sizeof(s2));\n	}\n	\n	while(gets(ppp))\n	{\n		int key=elfhash(ppp);\n		point* k=data[key].next;\n		if(k==NULL) printf(\'eh\n\');\n		else\n		{\n			while(k!=NULL)\n			{\n				if(strcmp(k-&gt;foreign,ppp)==0)\n				{\n					//while(1);\n					printf(\'%s\n\',k-&gt;english);\n					break;\n				} \n				k=k-&gt;next;\n			} \n		}\n		memset(ppp,0,sizeof(ppp));\n	}\n	return 0;\n}</pre>\n   <h2>\n    3.怪异：\n   </h2>\n   <div>\n    本题中，我们引用拉链法去处理冲突，但是我和网上大部分的代码都是一样的用ELFhash去做，但是很是奇怪，我一直是WA，求解WA的原因\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1b2285c1780faebb68ef9c5b02eb9357','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  ELFhash - 优秀的字符串哈希算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.字符串哈希：\n  </h2>\n  <div>\n   我们先从字符串哈希说起\n  </div>\n  <div>\n   在很多的情况下，我们有可能会获得大量的字符串，每个字符串有可能重复也有可能不重复\n  </div>\n  <div>\n   C不像Python有字典类型的数据结构，我们没有办法吧字符串当做是键值来保存，所以说我们需要一种hash函数将每个字符串都尽可能减少冲突的情况下去应设一个唯一的整形数据，方便我们的保存，这里我们就引入了字符串hash算法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   现在，有非常多的字符串hash算法都很优秀，本文主要面对ELFhash算法来表述，相对来说比较的清晰\n  </div>\n  <h2>\n   2.ELFhash\n  </h2>\n  <div>\n   首先我需要声明，字符串hash算法ELFhash的算法的形成的三列的均匀性我不会证明\n  </div>\n  <div>\n   根据其他的大牛的描述，ELFhash算法对于长字符串和短字符串都有优良的效率，以下的数据援引刘爱贵大神的实验数据：\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    Hash应用中，字符串是最为常见的关键字，应用非常普通，现在的程序设计语言中基本上都提供了字符串hash表的支持。字符串hash函数非常多，常见的主要有Simple_hash, RS_hash, JS_hash, PJW_hash, ELF_hash, BKDR_hash, SDBM_hash, DJB_hash, AP_hash, CRC_hash等。它们的C语言实现见后面附录代码: hash.h, hash.c。那么这么些字符串hash函数，谁好熟非呢？评估hash函数优劣的基准主要有以下两个指标：\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    (1) 散列分布性\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    即桶的使用率backet_usage = (已使用桶数) / (总的桶数)，这个比例越高，说明分布性良好，是好的hash设计。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    (2) 平均桶长\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    即avg_backet_len，所有已使用桶的平均长度。理想状态下这个值应该=1，越小说明冲突发生地越少，是好的hash设计。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    hash函数计算一般都非常简洁，因此在耗费计算时间复杂性方面判别甚微，这里不作对比。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    评估方案设计是这样的：\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    (1) 以200M的视频文件作为输入源，以4KB的块为大小计算MD5值，并以此作为hash关键字;\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    (2) 分别应用上面提到的各种字符串hash函数，进行hash散列模拟；\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    (3) 统计结果，用散列分布性和平均桶长两个指标进行评估分析。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n    测试程序见附录代码hashtest.c，测试结果如下表所示。从这个结果我们也可以看出，这些字符串hash函数真是不相仲伯，难以决出高低，所以实际应用中可以根据喜好选择。当然，最好实际测试一下，毕竟应用特点不大相同。其他几组测试结果也类似，这里不再给出。\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   </p>\n   <table border=\'0\' cellpadding=\'0\' cellspacing=\'0\' style=\'color:rgb(0,0,0); font-family:Arial; font-size:14px; line-height:26px; width:680px; border-collapse:collapse\'>\n    <colgroup span=\'1\'>\n     <col span=\'1\' style=\'width:89pt\' width=\'118\'>\n     </col>\n     <col span=\'1\' style=\'width:77pt\' width=\'102\'>\n     </col>\n     <col span=\'1\' style=\'width:102pt\' width=\'136\'>\n     </col>\n     <col span=\'1\' style=\'width:85pt\' width=\'113\'>\n     </col>\n     <col span=\'1\' style=\'width:77pt\' width=\'103\'>\n     </col>\n     <col span=\'1\' style=\'width:81pt\' width=\'108\'>\n     </col>\n    </colgroup>\n    <tbody>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td class=\'xl63\' height=\'24\' style=\'width:89pt; height:18pt; border:rgb(236,233,216); background-color:transparent\' width=\'118\'>\n       <strong>\n        <span style=\'font-size:12px\'>\n         Hash函数\n        </span>\n       </strong>\n      </td>\n      <td class=\'xl63\' style=\'width:77pt; border:rgb(236,233,216); background-color:transparent\' width=\'102\'>\n       <strong>\n        <span style=\'font-size:12px\'>\n         桶数\n        </span>\n       </strong>\n      </td>\n      <td class=\'xl63\' style=\'width:102pt; border:rgb(236,233,216); background-color:transparent\' width=\'136\'>\n       <strong>\n        <span style=\'font-size:12px\'>\n         Hash调用总数\n        </span>\n       </strong>\n      </td>\n      <td class=\'xl63\' style=\'width:85pt; border:rgb(236,233,216); background-color:transparent\' width=\'113\'>\n       <strong>\n        <span style=\'font-size:12px\'>\n         最大桶长\n        </span>\n       </strong>\n      </td>\n      <td class=\'xl63\' style=\'width:77pt; border:rgb(236,233,216); background-color:transparent\' width=\'103\'>\n       <strong>\n        <span style=\'font-size:12px\'>\n         平均桶长\n        </span>\n       </strong>\n      </td>\n      <td class=\'xl63\' style=\'width:81pt; border:rgb(236,233,216); background-color:transparent\' width=\'108\'>\n       <strong>\n        <span style=\'font-size:12px\'>\n         桶使用率%\n        </span>\n       </strong>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        simple_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.63\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        99.00%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        RS_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.63\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        98.91%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        JS_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        15\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.64\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        98.87%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        PJW_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.63\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        99.00%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        ELF_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.63\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        99.00%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        BKDR_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.63\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        99.00%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        SDBM_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.63\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        98.90%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        DJB_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        15\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.64\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        98.85%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        AP_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.63\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        98.96%\n       </span>\n      </td>\n     </tr>\n     <tr height=\'24\' style=\'height:18pt\'>\n      <td height=\'24\' style=\'height:18pt; border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        CRC_hash\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        10240\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        47198\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        16\n       </span>\n      </td>\n      <td align=\'right\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        4.64\n       </span>\n      </td>\n      <td align=\'right\' class=\'xl64\' style=\'border:rgb(236,233,216); background-color:transparent\'>\n       <span style=\'font-size:12px\'>\n        98.77%\n        <br/>\n        <br/>\n       </span>\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   所以实际应用中我们可以随便的选取，本文针对ELFhash\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.原理：\n  </h2>\n  <div>\n   首先，我们在开始之前需要明确几点\n  </div>\n  <div>\n   1.unsigned int有4个字节，32个比特位\n  </div>\n  <div>\n   2.异或操作中0是单位元，任何数与1异或相当于取反\n  </div>\n  <div>\n   3.unsigned无符号类型的数据右移操作均是执行逻辑右移（左高位自动补0）\n  </div>\n  <div>\n   4.ELFhash算法的核心在于“影响“\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   先附上代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1956231\' name=\'code\' snippet_file_name=\'blog_20161029_1_5499817\'>unsigned int ELFhash(char *str)\n{\n	unsigned int hash=0;\n	unsigned int x=0;\n	while(*str)\n	{\n		hash=(hash&lt;&lt;4)+*str;     //1\n		if((x=hash &amp; 0xf0000000)!=0)         //2\n		{\n			hash^=(x&gt;&gt;24);   //影响5-8位，杂糅一次   3\n			hash&amp;=~x;   //清空高四位    4\n		}\n		str++;   //5\n	}\n	return (hash &amp; 0x7fffffff);    //6 \n}</pre>\n   <br/>\n   解释：\n  </div>\n  <div>\n   首先我们的hash结果是一个unsigned int类型的数据：\n  </div>\n  <div>\n   0000 0000 0000 0000\n  </div>\n  <div>\n   1.hash左移4位，将str插入（一个char有八位）这里我开始也一直是怀疑的态度，那么第一个字节的高四位不就乱了吗\n  </div>\n  <div>\n   实际上这也是我们的第一次杂糅，我们是故意这么做的，这里我们需要注意标记一下，我们在第一个字节的高四位做了第一次杂糅\n  </div>\n  <div>\n   2.x这里用0xf0000000获取了hash的第四个字节的高四位，并用高四位作为掩码做第二次杂糅\n  </div>\n  <div>\n   在这里我们首先声明一下，因为我们的ELFhash强调的是每个字符都要对最后的结构有影响，所以说我们左移到一定程度是会吞掉最高的四位的，所以说我们要将最高的四位先对串产生影响，再让他被吞掉，之后的所有的影响都是叠加的，这就是多次的杂糅保证散列均匀，防止出现冲突的大量出现\n  </div>\n  <div>\n   3.x掩码右移24位移动到刚才的5-8位哪里在对5-8位进行第二次杂糅\n  </div>\n  <div>\n   4.我们定时清空高四位，实际上这部操作我们完全没有必要，但是算法要求，因为我们下一次的左移会自动吞掉这四位//这里存疑，不会减少我们的hash的范围？\n  </div>\n  <div>\n   5.str递增，引入下一个字符进行杂糅\n  </div>\n  <div>\n   6.返回一个缺失了最高符号位的无符号数（为了之后防止用到了有符号的时候造成的溢出）作为最后的hash值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   4.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1956231\' name=\'code\' snippet_file_name=\'blog_20161029_2_8388973\'>/*#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n\nusing namespace std;\n\nunsigned int a=0x80;\n\nint main()\n{\n	printf(\'%d\n\',a&gt;&gt;1);   //无符号数实行逻辑右移 \n	return 0;\n} */\n\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n\nusing namespace std;\n\nunsigned int ELFhash(char *str)\n{\n	unsigned int hash=0;\n	unsigned int x=0;\n	while(*str)\n	{\n		hash=(hash&lt;&lt;4)+*str;\n		if((x=hash &amp; 0xf0000000)!=0)\n		{\n			hash^=(x&gt;&gt;24);   //影响5-8位，杂糅一次 \n			hash&amp;=~x;   //清空高四位 \n		}\n		str++;\n	}\n	return (hash &amp; 0x7fffffff); \n}\n\nint main()\n{\n	char data[100];\n	memset(data,0,sizeof(data));\n	scanf(\'%s\',data);\n	printf(\'%d\n\',ELFhash(data));\n	return 0;\n} </pre>\n   <br/>\n   最后，按照我的思路来看的话，ELFhash最多可以散列的空间的大小是几个亿的数据？如果去掉hash&amp;=~x这一句的话会不会扩大我们hash的范围，尽可能利用空间，我下星期问问数据结构老师好了！\n  </div>\n  <h2>\n   5.应用：\n  </h2>\n  <div>\n   我们在对内存地址的进行的操作的时候，可以将数据的内存地址进行哈希\n  </div>\n  <div>\n   因为每个数据的内存地址都是唯一的，所以我们只需要一步获取内存地址的十六进制的表示就可以了\n  </div>\n  <div>\n   语句是\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1956231\' name=\'code\' snippet_file_name=\'blog_20161124_3_2489263\'>sprintf(data,\'%0x\',&amp;now_data);</pre>\n   第一个data保存我们的保留字符串的内存空间（字符串数组）\n  </div>\n  <div>\n   中间的是保存的进制的形式\n  </div>\n  <div>\n   最后是我们的要取地址的内存空间\n   <br/>\n   利用这种思路，我们可以很清晰明了的对链表相交的问题构建一种新的解法，我们采用哈希我们的内存空间就可以了，可以再O(n)中完成查找\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9c2b79a615bff58c45e9f51f7f9aba7e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Lantian和Tianqi的移动开发之旅 - 003 OOP\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  1.面向对象程序设计的基本概念\n  <br/>\n  面向对象程序设计 - OOP程序设计模式\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  将程序看成是一系列的对象组成的，而非一些列的动作组成的，对象是程序设计的基本单元\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  对象：包含状态（数据）和行为（状态）的程序设计实体 - 类的实例化\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  状态：我们将保存在对象中的保存对象的信息称之为状态\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  行为：一些对象可以完成的动作，常常有\'报告\'和\'修改\'状态\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  首先我们需要明确的是，对象本省并不能构成完整的程序，对象之时具有不同角色和功能的程序组件，对象可以作为解决更为复杂的程序设计的一部分，创建并适用对象的代码称之为客户\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  客户：与该类和该类的对象进行交互的代码\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  eg讲解：Point（Java.awt包）\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  状态：横坐标，纵坐标（整数）\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  行为：syso - Point 打印坐标\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  translate(x,y)移动x,y距离\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:我们话可以直接对横坐标和纵坐标进行操作\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  setLocation(x,y)设置坐标值\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  distance(Point X)计算该点到x的距离，并返回\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  对象的状态：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  只包含信息没有行为的我们也可以叫他结构体\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  对象的行为：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  对象中类的方法，用来操作类中（对象中的）数据元素，这里我们要小心对数据元素进行操作的时候有作用域的问题，因为我们的变量定义是在数据的操作的作用于是定义在第一个大括号之内的，对于类的数据元素来说也是一样的，类中的状态数据元素的作用于就是整个类\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  隐含的参数：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  市里的方法可以通过摸个隐蔽的渠道来指导我们当前操作的对象（隐含参数，我们调用的时候就知道我们的示例函数操作的对象），每个对象都有自己的行为函数的副本\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  修改器+访问器：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  前者修改对象的内存信息，后置不做任何修改，我们只是访问我们的对象的内存数据\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  toString方法:Java语言的设计者认为Java应当与String类型良好的配合工作，在syso中我们已经可以对字符串直接进行拼接操作\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  当Java需要我们利用syso标准输出一段字符串或者实现字符串的连接操作的时候，会自动调用相应的字符串toString方法，返回的是表示对象实例的字符串，toString方法不存在调用的参数，但是返回一个字符串\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  但是一旦加入我们要输出的东西并不存在相应的toString方法的话，Java会自动在类的名称后面添加一个@之后跟上一段的乱码（通常和你存的地址有关），但是一旦我们定义了相关的toString方法的话，我们实惠自定调用的自己的toString方法\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  建议位字节写的每一个类都加上toString方法\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  对象的初始化 - 构造函数：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  构造函数用public修饰，后面是雷鸣和我们所需要的参数，构造函数也是针对摸一个特定的对象，函数的名字和类的名字是相同的，并且构造函数没有返回值\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  我们经常说的new操作的实质：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  1.创建新的对象，并未对象开辟相应的内存区域\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  2.对对象调用相应的显示构造函数\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  3.在站区域中我们创建相应的对象的引用变量，并将我们新开辟的UI想的内存地址分配到我们到我们的引用变量上\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  如果我们没有定义构造函数的话，其实是并不会出现错误的，因为Java自动为没有显示设定构造函数的类设定缺省 默认的构造函数\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  但是缺省的构造函数会自动的将为类中的相应的状态变量设定0和相应的空值\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  关键字this：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  在类的内部我们可以访问到相应的隐含参数，注意this只有一个内存区域，当我们制定不同的对象的时候，我们的this是指向不同的对象的，该方法一个重要的作用就是避免函数的名字的重复\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  构造函数的重载：一个类是允许存在多个不同的构造函数的，为了方便我们在建立对象的时候的多重的情况的选择\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  封装性：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  封装的概念：讲一个对象的内部事项的方法隐藏起来，不让他的客户代码看到\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  抽象：我么只关注问题的本身属性而不关注我们的内存的实现的细节\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  抽象是封装的表现，二良好的封装也是我们设计需要的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  私有成员：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  我们需要对垒中的成员进行封装的话，我们至少要在状态的开头用private关键字声明其为私有的属性\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  私有的变量对于类内部的代码来说是可见的，但是对于我们的外部的客户代码来说是不可见的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  我们为了可以读取对象的相应的状态可以增设set或者get方法，目的是返回一个类内部成员的副本，相当于我们对外部的客户代码只有访问权限，没有修改的权限\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  类的不变式：在类的对象的生命周期之内，我们对于一个状态的永真断言\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  2.继承和接口：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  继承：允许我们的代码的复用，代码共享\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口：允许我们的用统一的行为取处理不同的对象，不需要这些对象之间共享代码\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  代码的复用：我们抽象出代码的普遍的结构之后抽象出来相同的部分从而实现的代码的重复使用\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  在多个程序中相同使用一段代码，我们引入集成的概念是的哦我们呢可以在一个类的基础上对类进行相应的扩充使得我们的逻辑更加的清晰\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  继承：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  1.相同，共用\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  2.不同，对于不同的类我们制定不同的规范\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Java允许我们通过继承的方法，避免在定义一个相似的类的时候重复的产生冗余的代码，如果已经有一个类包含了我们需要的所有的信息，我们完全可以继承这个类，共用相同的部分，至于特殊的部分我们在添加修改即可\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  派生出来的类叫做 - 子类，子类继承自 - 父类的全部的状态和行为\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  我们一般都说是子类扩展了父类，因为子类不仅可以介绍了父类的状态和行为，还可以添加自己特有的性质  ？？？？控制子类访问的protected\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  在Java中，我们只是提倡单继承，一个类可以扩展成多个类，但是一个类智能是有一个父类扩展来的\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  关键字引入：extends\n  <br/>\n  <br/>\n  <br/>\n  方法的重写：咋子类中我们可以通过重写父类的函数方法改变我们的子类的行为\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  重写：在子类中提供给父类的默写行为的一些新的实现的函数版本，替换我们之前的父类的函数\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  与父类的交互：super\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  调用重写的方法，super关键字可以再子类中调用到父类的构造函数和方法\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  注意子类不能说会用父类中的私有字段，Java限制类子类直接的访问从父类继承来的字段\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  构造函数是不会被子类继承的，子类的够早的时候是默认我们会调用父类的狗在函数的，如果我们没有制定相应的构造函数说明，我们编译器会自动的生成一个没有参数的默认的父类的构造函数\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  所以说，我们我们在子类中显示调用父类的构造函数的方法就是调用我们super方法，调用父类的构造函数，并且该super语句必须在构造函数的第一行\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  super还允许我们调用已经被冲写的父类函数，super只会调用上次的一个父类\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Object类：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Java中有一个Object类是所有的类的父类，没有extends额类，系统自动的默认添加上extends Object\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Object的主要的方法：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  1.clone()创建对象的副本\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  2.equals()判断当前对象是否相等，值\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  3.finalize()对象被销毁的时候自动调用\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  4.getClass()返回对象的类型的信息\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  5.hashCode()返回与对象相关的一个数字，在默写数据结构中游泳\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  6.toString()字符创的形式返回对象的信息\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  7.多线程相关的方法\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  如果我们希望摸个方法可以接受任何类型的对象作为参数，我们可以将形参设置为Object，返回值是Object也是合法的，使用的时候记住先强制类型转换\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  equals()方法：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ==运算符不能用在对象的身上，因为对于不同的对象也可能具有相同的内容\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ==表示我们判断两个被比较的引用是否引用了相同的对象，而不是比较我们的要比较的引用对象的对象的状态是否是相同的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  equals()方法不一样，equals()方法比较两个对象的状态是否是相同的（比较我们的两个变量的内容是否相同），如果我们没有对equals()方法进行重载的话，那么equals()方法实际上就是==，只有我们自己重写这个这个方法才会有用处\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  instanceof关键字：注意，如果我们使用通用的Object来进行比较，我们只是将当前的对象的引用类型表示成父亲级别的变量，但是我们instanceof比较的时候还是使用原来的对象的本身来进行比较\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  instanceof关键字用来判断检测一个变量是否是某个类型的对象，返回值是boolean类型\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  eg:如果是同一个类型的我们就先强制类型转换然后进行某种操作，不是的话我们就返回一个false的boolean\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public boolean equals(Object x)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(x instancof point) x=(point)x,return 判断;   *****instanceof判断当前的引用变量指向什么类型的对象*****\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else return false;\n  <br/>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  上面的代码是大多数的equals函数的判断的副本，我们可以当做模板来记忆\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  多态性：继承的好处就是我们通过继承实现了代码的复用，就像我们上面对于继承中的方法重写中哪里说的一样，我们在大量的一批的数组中同时保存一个继承链中的类的对象的时候，因为不同的集成的子类对于相同的父类函数进行了重写\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  所以说我们可以在不同的对象中调用相同的函数来实现不同的行为反应，我们成这种代码的能力叫做多态\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  定义：允许一段代码作用于几种不同的类型的对象中，而且代码会根据对象的不同自动的执行相应的不用的动作\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  在C++中，我们通过父类的指针指向不同的子类的对象从而实现调用不同的子类中的相同的方法实现不同的动作\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  在Java中，我们已经没有了指针的概念，但是我们还是有引用的概念，我们的引用可以指向不同的对象，从而实现和上述一样的效果\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  /*eg:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public class class_in_java {\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public static void test(Object x)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x=(data)x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(x);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(\'\n\');\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public static Object test2(data x)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public static void main(String[] args) {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  // TODO 自动生成的方法存根\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //data a=new data(1,2);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //test(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //System.out.println((data)test2(a));\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  data a=new data(1,2);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //a.change()   这里的调用就是错的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=new pdata(2,2);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <br/>\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  class data\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  protected int a;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  protected int b;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public data(int x,int y)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  b=y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public String toString()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return Integer.toString(a)+Integer.toString(b);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  class pdata extends data\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public pdata(int x,int y)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  super(x,y);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public void change()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  syso - 输出\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public String toString()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return Integer.toString(a*b);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }/*\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  **************多态的基础就是引用型变量(Java)没有必要和所引用的对象的类型完全匹配，这是最重要的************\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  **************我们确切的来说，一开始我们声明城市父类的引用类型我们完全之后可以用来直接指向子类的对象示例*********这一点同C++\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  在基本数据类型的时候我们知道我们可以将精度小的数据类型强制转化成精度高的数据类型，但是在Java的对象的中，我们用父类（精度低的结构）的引用指向子类的对象（精度高的结构）的时候，不会发生强制转化\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  但是确实，我们这是后的变量的类型是父类，大师指向确实是子类，用instanceof完全可以验证\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  一个多态的经典的例子就是，我们可以将父类类型的引用作为函数的参数或者返回值，这时候，我们虽然我们结果是父类类型的引用变量，但是实际上我们指向的对象是动态的，是不同的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  也正因为我们的子类都重写了父类的方法，所以说我们完全可以用一段相同的代码实现不同的动作，这就是多态的核心本质\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  但是有一个注意点，我们的父类的引用类型如果引用的是子类的对象的时候，我们只可以调用父类的已知的方法，不能直接调用出子类的方法（虽然这时候对象确实是子类）\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  /*eg:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public class class_in_java {\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public static void test(Object x)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x=(data)x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(x);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(\'\n\');\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public static Object test2(data x)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public static void main(String[] args) {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  // TODO 自动生成的方法存根\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //data a=new data(1,2);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //test(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //System.out.println((data)test2(a));\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  data a=new data(1,2);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //a.change()   这里的调用就是错的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=new pdata(2,2);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  System.out.println(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <br/>\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  class data\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  protected int a;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  protected int b;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public data(int x,int y)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  b=y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public String toString()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return Integer.toString(a)+Integer.toString(b);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  class pdata extends data\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public pdata(int x,int y)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  super(x,y);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public void change()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  syso - 输出\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public String toString()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return Integer.toString(a*b);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }/*\n  <span style=\'white-space:pre\'>\n  </span>\n  因为这个时候我们编译器是只看父类的引用的，默认父类没有子类独有的方法\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  一句话，我们的多态性中，父类只能调用被重写的方法，但是父类引用不能直接调用子类的独有的方法\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  解决这种问题我们可以通过对象之间的强制类型转换来实现，但是我们必须要保证强制转换的两个对象的之间实在同一颗继承树上的，否则我们会造成运行时错误\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  在继承的时候我们非常要注意OOP的可替换性，在面向对象的程序过程当中，我们必须要明确所有的包括equals()等方法都会有对称的性质，造成这种现象出现的原因是我们的错误的继承的滥用导致向下和向上转型的部队称，父类引用的instanceof识别子类，但是子类的instanceof不识别父类\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  为了避免继承的麻烦的问题，我们可以使用组合类的思路来实现，没有了继承的向上向下转型造成的麻烦了\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口：interface关键字引用就好\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Java的局限性显而易见，Java只支持单继承，一个类智能从一个父类继承而来，Java为了弥补这样的缺陷，使用了接口这个性质，我们可以用接口作为多各类的共同父类型，而且不会涉及代码共享\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口定义：某些类承诺会实现一组方法（注意是方法），这样的话我们可以用类似的代码来处理这些类\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口和类很类似，但是接口之表示方法的声明，不包括方法的实现，一个类承诺实现某一个接口，说明该类会实现接口中声明的那些方法，从而实现了多继承，结合多态的特性，我们完全可以通过上面描述的多态的特性去处理所有的实现了该接口的代码\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  当我们不需要共享代码的时候，我们就用借口来实现相应的过程\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  抽象方法：一个只具有声明但是没有实现的行为，当一个类实现一个抽象方法的\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口的抽象的特性代表接口不能被实例化\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  引用接口的时候我们需要用到implements关键字，一个类声明了实现了接口，那么我们在该类中就必须要实现接口的抽象方法，否则我们的编译就会不通过，多态也可以应用\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口的优点：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  实现了某一个接口的一组类和具有能继承关系的一组类之剑一样都已明确的层次关系，接口充当了这些类的父类的角色，其实接口和上面的父类的堕胎一样，也可以指向子类（实现了接口的类）\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口的作用本人有自己的理解，接口是对动作的抽象，有的一些类没有集成的关系，但是他们都可以由一些相同的动作（飞机，鸟），但是我们不能让飞机和鸟都从一个类里面继承下来（这样很怪异）\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  所以说，对于不是一个继承树上的一些类来说，我们将的共同的行为进行抽象，我们只需要事项这些行为就可以啦，并且，我们还可以将接口的类型作为引用类型产生更广泛意义上的多态\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  摘引网上的一段解释：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  你只要记得接口就是一个特殊的抽象类。实现它的类它必须对其所有方法进行重写。\n  <br/>\n  接口是个比较抽象的东西。它一般来说可看作是1个功能扩展的类。比如你已经写好了1个类。而且也已经写好了所有的方法通俗点说就是实现了所有的功能。但现在如果又要多增加个功能。而又不想修改源代码的情况下。你就可以考虑实现接口。接口里写要增加的方法（功能）。让你这个类实现它。你就必须重写了这个方法。\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  /*Madai的理解是：\n  <br/>\n  java接口的用处主要体现在下面几个方面：\n  <br/>\n  <br/>\n  （1）通过接口可以实现不相关类的相同行为，而不需要了解对象所对应的类。\n  <br/>\n  <br/>\n  （2）通过接口可以指明多个类需要实现的方法。\n  <br/>\n  <br/>\n  （3）通过接口可以了解对象的交互界面，而不需了解对象所对应的类。\n  <br/>\n  <br/>\n  <br/>\n  Clkrst给出了更详细的解释：\n  <br/>\n  类描述了一个实体，包括实体的状态，也包括实体可能发出的动作。\n  <br/>\n  <br/>\n  接口定义了一个实体可能发出的动作。但是只是定义了这些动作的原型，没有实现，也没有任何状态信息。\n  <br/>\n  <br/>\n  所以接口有点象一个规范、一个协议，是一个抽象的概念；而类则是实现了这个协议，满足了这个规范的具体实体，是一个具体的概念。\n  <br/>\n  <br/>\n  从程序角度，简单理解，接口就是函数声明，类就是函数实现。需要注意的是同一个声明可能有很多种实现。\n  <br/>\n  <br/>\n  所以就你的问题：\n  <br/>\n  1、接口中定义类方法的原型，但是不能说是空方法，因为空方法的意思是有实现体，只不过实现体是空操作。实际上接口没有定义任何实现体。具体的实现体都是在实现接口的类中，接口只是定义了这些方法的调用方式。\n  <br/>\n  <br/>\n  你当然也可以不用接口，直接在类里面写方法，但是如果你的一组方法需要在很多类里实现，那么把它们抽象出来，做成一个接口规范，不是更好么？\n  <br/>\n  <br/>\n  2、一个类描述了一个实体，这个实体可能是一个复杂的对象，它的动作很多，如果把这些动作分类，用接口a定义其中的某一组动作，接口b定义其中的另外一组动作，这样的结构，比较清楚。\n  <br/>\n  <br/>\n  这种方式具备了多继承的优点，避免了多继承的缺陷。实际上在历史上，接口在很大程度上，是为了解决多继承带来的种种问题而设计出来的。\n  <br/>\n  <br/>\n  3、包中那些已定义的接口，怎么知道那里面定义了什么方法。\n  <br/>\n  <br/>\n  接口里定义了方法的输入输出，这些都是协议，具体的实现都在每个类中。对于很多只需要抽象接口的地方，不需要知道具体的类是什么，只要这个类实现了这个接口就可以了。*/\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  3.抽象类：abstract关键字\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  java中的特殊的类，这种类不能被实例化\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  抽象类也可以实现摸一个接口，我们可以直接在抽象类中直接实现接口，使得我们之后的抽象类的子类都不用去频繁的都去声明实现一个接口，但是我们可以声明要实现，抽象类中不一定要去实现接口的方法，我们交给子类去完成\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  因此在这里有一个编程的技巧就是，我们可以再抽象类中自己调用自己的方法，这是可以成功的，因为编辑器知道这些抽象的方法一定会被实现\n  <br/>\n  <br/>\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  总结：\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  接口可以实现的功能，抽象类都可以实现，而且抽象类还可以是实现其他的功能，但是并不能说抽象类比接口号，因为接口是允许多继承的，但是一个类只能继承一个类\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('bb96ebc2a8afc57269ffdac3cbb5b724','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2586 - 贪心 or DP\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   有一个公司，12个月份，所有的连续的5个月都是亏损的，请求出在此情况下的一年最大的盈利数目，如果没有输出Defict\n  </div>\n  <div>\n   输入:n,d分别代表每个月的固定的收入和固定的亏损\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   相比较而言，DP的思路更快：DP 0ms   贪心16ms\n  </div>\n  <div>\n   本题我用了两种思路去做：\n  </div>\n  <div>\n   1.贪心：\n  </div>\n  <div>\n   网上的大神的讲解：\n  </div>\n  <div>\n   我们从1月开始贪心，每次将亏损的月份放在最后面才可以得到最优的结果\n  </div>\n  <div>\n   因为如果我们并没有把亏损的月份放在最后面的话，有可能会出现下一次的亏损月份没有考虑这个亏损的月份导致考虑更多的情况出现，所以说我们的贪心思路就是从后往前贪心\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.DP：\n  </div>\n  <div>\n   我的思路是这样的，在5月之前，我们的弦乐处理一下，然后在之后的几个月利用DP递推公式O(n)求解，不需要贪心的回溯了，可以加快速度\n  </div>\n  <div>\n   每次利用前四个月推到第五个月\n  </div>\n  <div>\n   定义状态：\n  </div>\n  <div>\n   保证最优的情况下的每个月的收入或者亏损\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1953388\' name=\'code\' snippet_file_name=\'blog_20161028_1_6618318\'>if(sum(前4个月+本月盈利)&gt;=0) dp[i]=-d\nelse dp[i]=s</pre>\n   <br/>\n   <h2>\n    3.Code:\n   </h2>\n  </div>\n  <div>\n   1.贪心：16ms\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1953388\' name=\'code\' snippet_file_name=\'blog_20161028_2_1907045\'>#include&lt;iostream&gt; \n#include\'cstdio\'\nusing namespace std; \n \n \nint add(int m[],int n) //从第n个月开始，5个月的盈亏总和  \n{ \n  int sum=0; \n   for(int i=n;i&lt;n+5;i++)  sum+=m[i];\n   return sum; \n} \n \nint main() \n{ \n  int s,d; \n  int month[12]; \n  while(scanf(\'%d%d\',&amp;s,&amp;d)!=EOF)   //这里不要随便用for(;;),除非有终止条件让他break掉  \n   { \n       \n      d=-d; \n       \n      for(int i=0;i&lt;12;i++) month[i]=s; \n          \n      for(int i=0;i&lt;8;i++) \n      { \n         for(int j=1;j&lt;=5;j++)  //这里要有=号，就是有可能一个月的盈利大于4个月的亏损情况，那只能是全亏了  \n         { \n            int tmp = add(month,i); \n            if(tmp&gt;=0) month[i+5-j]=d;\n            else break; \n         } \n      }  \n       \n      int sum=0; \n      for(int i=0;i&lt;12;i++)  sum+=month[i]; \n       \n       \n      if(sum&gt;0)  cout&lt;&lt;sum&lt;&lt;endl; \n      else cout&lt;&lt;\'Deficit\'&lt;&lt;endl; \n   }  \n   return 0; \n} </pre>\n   2.DP 0ms\n   <br/>\n   <pre class=\'cpp\' code_snippet_id=\'1953388\' name=\'code\' snippet_file_name=\'blog_20161028_3_6781851\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nint dp[13];\nint s,d;\nint sum;\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;s,&amp;d)!=EOF)\n	{\n		for(int i=1;i&lt;=12;i++)\n		{\n			if(i&lt;=5)\n			{\n				if((5-i)*(-d)+i*s&gt;=0) \n				{\n				for(int j=i;j&lt;=5;j++) dp[j]=-d;	\n					i=5; \n				}\n				else dp[i]=s;\n			}\n			else\n			{\n				if(dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]+s&gt;=0) dp[i]=-d;\n				else dp[i]=s;\n			}\n		}\n		sum=0;\n		for(int i=1;i&lt;=12;i++) sum+=dp[i];\n		if(sum&lt;0) printf(\'Deficit\n\');\n		else printf(\'%d\n\',sum);\n	}\n	return 0;\n}</pre>\n   <h2>\n    4.问题抽象\n   </h2>\n   <div>\n    假设现在有一个数组有n个元素，每个元素只有a,b两种选择，现在让每个数组元素的连续k个数字之和必小于0，求满足条件的序列中\n   </div>\n   <div>\n    序列和最大的一个，并输出序列的满足条件的情况\n   </div>\n   <div>\n    本问题我们可以利用DP（O(n\n    <span style=\'font-size:12px\'>\n     )解决）\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:12px\'>\n     我们首先预处理前k个元素，利用贪心的思路O(k)求出满足第一个连续5个元素的情况\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:12px\'>\n     然后之后利用上面的思路不断地递推求出整个序列的所有的情况\n    </span>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('08001296ed7349c1fc96f28462f054b8','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2109 - double\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   本题的正解是高精度+二分法\n  </div>\n  <div>\n   但是题目的bug导致我们直接一行用double也可作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   二分+高精度我之后会补上\n  </div>\n  <div>\n   这里的blog相当于是插了个flag吧\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1953196\' name=\'code\' snippet_file_name=\'blog_20161027_1_8519577\'>#include\'iostream\'\n#include\'cstring\'\n#include\'cstdio\'\n#include\'cmath\'\n\nusing namespace std;\n\ndouble n,p;\n\nint main()\n{\n	while(scanf(\'%lf%lf\',&amp;n,&amp;p)!=EOF)\n	{\n		cout&lt;&lt;pow(p,1/n)&lt;&lt;endl;\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('8bc440fbc155d5d28aba81774b1ed45f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1328 &amp;&amp; NYOJ 891 - 贪心 区间选点问题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题意：\n  </div>\n  <div>\n   题目中抽象了一个俯视图，以x轴为海岸线，y的负半轴一下是陆地，y的正半轴是海洋，在海洋上有很多岛屿\n  </div>\n  <div>\n   我们有一中雷达，雷达的侦测半径是d，现在要我们输出可以将所有的岛屿全部都侦测到的最少的雷达的个数\n  </div>\n  <div>\n   我们定义输入：\n  </div>\n  <div>\n   n，d分别代表岛屿的个数和我们的雷达的半径\n  </div>\n  <div>\n   之后的n行两个数据代表了岛屿的坐标（小心坐标的值可以使负数，也可以d大）\n  </div>\n  <div>\n   本题有多组输入，当遇到输入n，d都是0的时候终止输出并返回\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   本题是 区间选点问题 的一种很典型的变体\n  </div>\n  <div>\n   我们解决区间选点问题标准是贪心的思路\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   贪心的描述如下：\n  </div>\n  <div>\n   以所有的区间的右端点升序排列，右端相同按左端的降序排列\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们从头开始，一旦遇到下一个区间的左端比上一个选定的区间的右端大，说明我们至少需要再增加一个雷达来满足所有的区间覆盖，然后我们将选定的区间在移动至当前的区间\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   证明很麻烦（好吧我不会）：我还是太渣了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   为了弥补过失我将 &lt;algorithm&gt;下的qsort和sort函数大致的讲解一下\n  </div>\n  <div>\n   这两个函数一直是算法考试的常考点，并且两者还有一些区别（总的来说sort比qsort更优秀一些）\n  </div>\n  <div>\n   qsort(数组的首地址，数组待排的长度，数组中的单元的字节大小，cmp)cmp比较函数\n  </div>\n  <div>\n   比较函数算是最难的一点：\n  </div>\n  <div>\n   cmp只能返回int类型，所以说对于其他数据类型进行排序的时候，我们一般都用三元运算符表达层次关系\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1950951\' name=\'code\' snippet_file_name=\'blog_20161026_1_5024268\'>int cmp(const void* a,const void* b)   //注意这里是void类型的含义是我们之后要对void类型进行强制转换，转换成对应的类型进行比较\n{\n    return *(type*)a &gt; *(type*)b ? 1:-1;\n}\n我们需要注意，在qsort的cmp中，返回正数表示a,b要交换位置，0表示无所谓交不交换，负数代表a,b不交换位置</pre>\n   <div>\n    <br/>\n   </div>\n   sort(首地址，尾地址，cmp)\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1950951\' name=\'code\' snippet_file_name=\'blog_20161026_2_1545685\'>bool cmp(type a,type b,cmp)\n{\n    return true;   //返回true代表不用交换为止\n    return false;   //返回false代表需要交换位置 \n}</pre>\n   本题的话，利用sort或者qsort都可以实现\n  </div>\n  <div>\n   <h2>\n    3.Code:\n   </h2>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1950951\' name=\'code\' snippet_file_name=\'blog_20161026_3_7227286\'>#include\'iostream\'\n#include\'cstdlib\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'algorithm\'\n#include\'cmath\'\n#define N 1005\n\nusing namespace std;\n\ntypedef struct node\n{\n	double x;\n	double y;\n}point;\n\npoint line[N];\nint n,d;\nint coun;\nint sum=0;\n\nbool cmp(point a,point b)\n{\n	if(a.y&lt;b.y) return true;\n	else if(a.y==b.y)\n	{\n		if(a.x&gt;b.x) return true;\n		else return false;\n	}\n	else return false;\n}\n\nint main()\n{\n	int t=1;\n	while(scanf(\'%d%d\',&amp;n,&amp;d)&amp;&amp;(n||d))\n	{\n		sum=0;\n		int x;\n		int y;\n		coun=0;\n		bool ok=true;\n		for(int i=1;i&lt;=n;i++)\n		{\n			scanf(\'%d%d\',&amp;x,&amp;y);\n			if(d*d-y*y*1.0&lt;0||d&lt;0) ok=0;\n			else\n			{\n				line[coun+1].x=x*1.0-sqrt(d*d*1.0-y*y*1.0);\n				line[++coun].y=x*1.0+sqrt(d*d*1.0-y*y*1.0);\n			}\n		}\n		if(ok==false)\n		{\n			printf(\'Case %d: -1\n\',t++);\n			continue;\n		}\n		sort(line+1,line+1+coun,cmp);\n		sum=1;\n		point temp=line[1];\n		for(int i=2;i&lt;=coun;i++)\n		{\n			if(line[i].x&gt;temp.y) sum++,temp=line[i];\n		} \n		printf(\'Case %d: %d\n\',t++,sum);\n	}\n	return 0;\n}</pre>\n    <br/>\n    <br/>\n   </div>\n   <h2>\n    NYOJ 891\n   </h2>\n   <div>\n    同一个思路，不说什么了\n   </div>\n   <h2>\n    Code:\n   </h2>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1950951\' name=\'code\' snippet_file_name=\'blog_20161026_4_2488468\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'algorithm\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n}point;\n\nint n;\npoint line[105];\n\nbool cmp(point a,point b)\n{\n	if(a.y&lt;b.y) return true;\n	else if(a.y==b.y)\n	{\n		if(a.x&gt;b.x) return true;\n		else return false;\n	}\n	else return false;\n}\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)!=EOF)\n	{\n		int x,y;\n		for(int i=1;i&lt;=n;i++)\n		{\n			scanf(\'%d%d\',&amp;x,&amp;y);\n			line[i].x=x;\n			line[i].y=y;\n		}\n		sort(line+1,line+1+n,cmp);\n		int sum=1;\n		point temp=line[1];\n		for(int i=2;i&lt;=n;i++)\n		{\n			if(line[i].x&gt;temp.y) sum++,temp=line[i];\n		}\n		printf(\'%d\n\',sum);\n	}\n	return 0;\n}</pre>\n    <br/>\n    <br/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('6b04ae0d5f526b4b60f4af48b5842704','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2965 - 状态压缩 + BFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   和上次的1753是一个思路\n  </div>\n  <div>\n   题意：\n  </div>\n  <div>\n   有一个4*4的表格，+代表关，-代表开，请输出让整个图都是开的状态所需要的最小操作次数\n  </div>\n  <div>\n   定义操作：\n  </div>\n  <div>\n   我们每次可以翻转一个按钮，同时同一行和同一列的元素都会执行相同的反转操作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   和1753一样，我们同样用位运算压缩状态\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   状态压缩+BFS\n  </div>\n  <div>\n   总共只有2^16个状态需要枚举，所以说本题还是可以做到很快的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   最后输出的时候我们用到了栈\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   小心空图的时候直接输出0\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   队列结构体定义注意加上回溯的标记，保存父节点在队列中的物理地址，方便我们的回溯访问用栈来输出路径\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   本题还有更加高效的算法，我之后会补上\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1947318\' name=\'code\' snippet_file_name=\'blog_20161025_1_9416098\'>#include\'iostream\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cstdio\'\n#define N 70000   //反转公有65536种情况 \n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;    //上次操作的坐标 \n	int y;\n    int data;\n    int step;\n    int save;\n}point; \n\ntypedef struct pnode\n{\n	int x;\n	int y;\n}kkk;\n\nint number;\nkkk s[N];\nint head;\nint tail;\npoint queue[N];\nchar map[4][4];\nint pre;\nint flag[N];\nint sum;\n\nvoid print()\n{\n	printf(\'%d\n\',number);\n	for(int i=number;i&gt;=1;i--) printf(\'%d %d\n\',s[i].x+1,s[i].y+1);\n}\n\nvoid make_stack()\n{\n	for(int i=tail-1;;)\n	{\n		if(i==1) break;\n		s[number+1].x=queue[i].x;\n		s[number+1].y=queue[i].y;\n		i=queue[i].save;\n		number++;\n	}\n} \n\nint trans_bit(int atom,int k)\n{\n	int mask=0;\n	int rows=k/4;\n	for(int i=0;i&lt;4;i++) mask|=(1&lt;&lt;(4*rows+i));\n	int cols=k%4;\n	for(int i=0;i&lt;4;i++) mask|=(1&lt;&lt;(cols+4*i));\n	mask|=(1&lt;&lt;k);\n	return mask^queue[atom].data;\n}\n\nvoid bfs()\n{\n	int px,py;\n	memset(flag,0,sizeof(flag));\n	flag[pre]=1;\n	while(head!=tail)\n	{\n		for(int i=0;i&lt;16;i++)\n		{\n			int dx=trans_bit(head,i);\n			if(dx==0) \n			{\n				queue[tail].x=i/4;\n				queue[tail].y=i%4;\n				queue[tail].save=head;\n				tail++;\n                sum=queue[head].step+1; \n				make_stack();\n				head=tail-1;\n				break;\n			}\n			else if(flag[dx]==1) continue;\n			else\n			{\n				flag[dx]=1;\n				queue[tail].x=i/4;\n				queue[tail].y=i%4;\n				queue[tail].data=dx;\n				queue[tail].step=queue[head].step+1;\n				queue[tail].save=head;   //记录前驱 \n				tail++;\n			} \n		}\n		head++;\n	}\n} \n\nint main()\n{\n	pre=0;\n	memset(queue,0,sizeof(queue));\n	head=1;\n	tail=2;\n	memset(s,0,sizeof(s));\n	number=0;\n	for(int i=0;i&lt;4;i++)\n	{\n		for(int j=0;j&lt;4;j++) \n		{\n			scanf(\'%c\',&amp;map[i][j]);\n			if(map[i][j]==\'+\') pre|=(1&lt;&lt;(4*i+j));   //抽取初始状态 \n		}\n		getchar();\n	}\n	\n	if(pre==0)\n	{\n		printf(\'0\n\');\n		exit(0);\n	}\n	queue[1].save=-1;   //记录前驱 \n	queue[1].data=pre;\n	queue[1].step=0;\n	bfs();\n	print();\n    return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('fc0566579ca8e1f202a7ce694da3880a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 1753 - 位运算(异或)+BFS / DFS+枚举\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   题目大意:\n  </div>\n  <div>\n   有一个4*4的棋盘，棋盘上有黑白子，我们对棋盘进行如下操作：\n  </div>\n  <div>\n   操作的定义：我们每次可以反转一个棋子，即黑变白，白变黑，之后上下左右四个方向的棋子都会跟着进行翻转操作\n  </div>\n  <div>\n   题目中让我们求可以使得整个棋盘变成纯色的\n   <span style=\'font-size:13.3333px\'>\n    最少的操作次数\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <h2>\n   2.Solution1:\n  </h2>\n  <div>\n   本题的解法思路有很多，之后的枚举+DFS的思路我会更新补上，这里我们着重讲解位运算+BFS的思路求解\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先，我们都很清楚，BFS对于求解最优解的搜索问题是一种很高效的查找解的方式，但是我们又清楚的意识到\n  </div>\n  <div>\n   BFS的算法本质在于维护一个动态的 队列以及一个记录数组（非必须，看题意），队列保存的是，每一次搜索完之后的状态，但是通过题意描述我们会发现期盼这种二维状态真的不好描述\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   所以说，本题就引入了一种处理的思路，因为棋盘限定为4*4（为了降低难度）我们将棋盘这样考虑\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1945394\' name=\'code\' snippet_file_name=\'blog_20161024_1_5748591\'># # # #    //0 1 2 3\n# # # #    //4 5 6 7\n# # # #    //8 9 10 11 \n# # # #    //12 13 14 15\n我们将每一个棋盘的格子是做一个二进制位的话，整个棋盘的所有的操作位数是16位，也就是说，最多会有2^16=65536种棋盘状态\n那么我们将其用位运算压缩存储，一个int(或者unsigned short)就可以表示出一种状态</pre>\n   <br/>\n   很显然，对于本题，我们还要尽量避免会出现重复搜索，v比如如果我们搜索到了之前的一个状态就要立即终止更换搜索的方式（防止无限循环）\n  </div>\n  <div>\n   刚好这种位压缩的思路对于我们记录来说也是很方便的\n  </div>\n  <div>\n   毕竟65536的存储单元内存消耗也不大\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   最后一个要点就是异或操作(^)，本题中因为我们是要反转，我是用1记录黑棋，0记录白棋，那么这样的话对于我们的异或操作也是很方便的，其实我们的翻转操作就是一个异或操作\n  </div>\n  <div>\n   <strong>\n    1和任何数的异或是取反，0很任何数的异或操作是不变\n   </strong>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   最后要注意一个坑，对于一开始就是纯色的棋盘不要搜索，直接输出0\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   附上AC代码\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1945394\' name=\'code\' snippet_file_name=\'blog_20161024_2_1397956\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 70000\n\nusing namespace std;\n\n//黑1白0 \n\ntypedef struct node\n{\n    int data;\n	int step;	\n}kkk;\n\nchar map[4][4];\nint judge[N];\nkkk queue[N];\nint head;\nint tail;\n\nint bit_trans(int atom,int data)\n{\n	int mask=0;\n	mask|=(1&lt;&lt;atom);\n	if(atom%4!=0) mask|=(1&lt;&lt;(atom-1));   //左边\n	if(atom%4!=3) mask|=(1&lt;&lt;(atom+1));   //右边\n	if(atom&gt;=4) mask|=(1&lt;&lt;(atom-4));    //上边\n	if(atom&lt;=11) mask|=(1&lt;&lt;(atom+4));   //下边\n	\n	return data^mask; \n}\n\nint bfs()\n{\n	bool flag=0;   //是否成功\n	int s=0;\n	while(head!=tail)\n	{\n		for(int i=0;i&lt;16;i++)\n		{\n			int dmove=bit_trans(i,queue[head].data);\n			if(dmove==0||dmove==65535)\n			{\n				s=queue[head].step+1;\n				flag=true;\n				break;\n			}\n			else if(judge[dmove]==1) continue;\n			else\n			{\n				judge[dmove]=1;\n				queue[tail].data=dmove;\n				queue[tail].step=queue[head].step+1;\n				tail++;\n			} \n		} \n		if(flag==true) break;\n		head++;\n	}\n	if(flag==1) return s;\n	else return -1;\n}\n\nint main()\n{\n	memset(queue,0,sizeof(queue));\n	head=1;\n	tail=2;\n	for(int i=0;i&lt;4;i++)\n	{\n		for(int j=0;j&lt;4;j++) scanf(\'%c\',&amp;map[i][j]);\n		getchar();\n	}\n	\n	for(int i=0;i&lt;4;i++)\n	{\n		for(int j=0;j&lt;4;j++)\n		{\n			if(map[i][j]==\'b\')\n			{\n				queue[head].data|=(1&lt;&lt;(4*j+i));\n			}\n		}\n	}\n	\n	if(queue[head].data==0||queue[head].data==65535) printf(\'0\n\');\n	else\n	{\n    	int number=bfs();\n    	if(number==-1) printf(\'Impossible\n\');\n    	else printf(\'%d\n\',number);\n    }\n	return 0;\n} </pre>\n   <div>\n    <br/>\n   </div>\n   <h2>\n    4.Solution2:\n   </h2>\n   <div>\n    对于整个棋盘\n   </div>\n   <div>\n    我们的操作次数只有1，2，3，4.....16\n   </div>\n   <div>\n    我们每次只用摘出一个子序列，对于子序列中的元素进行反转操作\n   </div>\n   <div>\n    从小到大枚举可以保证我们找到最优解\n   </div>\n   <div>\n    核心在于抽取子序列：\n   </div>\n   <div>\n    为了方便描述，我用Python写了一下代码，思路很清晰，用了有序的DFS生产子序列排列，实际上，DFS不仅可以用来生成所有的子序列，DFS还可以生成全排列，详情搜索我额的全排列的代码\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    Python:\n   </div>\n   <div>\n    <pre class=\'python\' code_snippet_id=\'1945394\' name=\'code\' snippet_file_name=\'blog_20161024_3_1137286\'>global count    #全局变量声明的时候不能初始化\ncount=0\nglobal Exp\n\ndef initdata():\n    global Exp\n    list=[]   #数据域\n    data=eval(input(\'键入数据(列表)\'))\n    Exp=eval(input(\'请输入抽取的元素的个数\'))\n    grasp(data,list,0,0)\n    print(\'抽取的种类的个数%d\'%count)\n\ndef print_tuple(list):\n    print(list)\n\ndef grasp(data,list,Now,index):   #index代表最末索引\n    global count    #哪里需要全局变量哪里声明一次\n    global Exp\n    if Now==Exp :\n        count+=1\n        print_tuple(list)\n        return\n    else:\n        for var in data[index:]:\n            list.append(var)\n            grasp(data,list,Now+1,index+1)\n            list.remove(var)\n            index=index+1\n\ninitdata()\n</pre>\n    <br/>\n    <h2>\n     5.Code:\n    </h2>\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1945394\' name=\'code\' snippet_file_name=\'blog_20161024_4_9883549\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nchar map[4][4];\nint pre;\nbool flag=false;\nint count[16];\nint number;\nbool back=false;\n\nint trans()\n{\n	int k=pre;\n	int mask=0;\n	int dx;\n	for(int i=0;i&lt;number;i++)\n	{\n		mask=0;\n		mask|=(1&lt;&lt;count[i]);\n		dx=count[i];\n		if(dx%4!=0) mask|=(1&lt;&lt;(count[i]-1));\n		if(dx%4!=3) mask|=(1&lt;&lt;(count[i]+1));\n		if(dx&gt;=4) mask|=(1&lt;&lt;(count[i]-4)); \n		if(dx&lt;=11) mask|=(1&lt;&lt;(count[i]+4));\n		k=k^mask;\n	}\n	return k;\n}\n\nvoid grasp(int exp,int now,int index)\n{\n	if(now==exp)\n	{\n		int w=trans();\n		if(w==0||w==65535) flag=1;\n		if(flag==1) return ;\n		else return ;\n	}\n	else\n	{\n		for(int i=index;i&lt;16;i++)\n		{\n			count[number++]=i;\n			grasp(exp,now+1,index+1);\n			if(flag==1) return ;\n			index++;\n			number--;\n		}\n	}\n}\n\nvoid move(int step)\n{\n	memset(count,0,sizeof(count));\n	number=0;\n	grasp(step,0,0);\n}\n\nint main()\n{\n	pre=0;\n	for(int i=0;i&lt;4;i++)\n	{\n		for(int j=0;j&lt;4;j++) \n		{\n			scanf(\'%c\',&amp;map[i][j]);\n			if(map[i][j]==\'b\') pre|=(1&lt;&lt;(i*4+j)); \n		}\n		getchar();\n	}\n	if(pre==0||pre==65535) printf(\'0\n\');\n	else\n	{\n		int i;\n		for(i=1;i&lt;=16;i++)\n		{\n			move(i);\n			if(flag==1) break;\n		}\n		if(flag==1) printf(\'%d\',i);\n		else printf(\'Impossible\n\');\n	}\n	return 0;\n}</pre>\n    <br/>\n    <br/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('6484768ed9aa38231f0eae47f83ac2d7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  位运算全解(含位段)\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.位运算操作符\n  </h2>\n  <div>\n   <table border=\'1\' cellpadding=\'0\' cellspacing=\'0\' style=\'\'>\n    <tbody>\n     <tr>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         符号\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         描述\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         运算规则                        by MoreWindows\n        </span>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         &amp;\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         与\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         两个位都为1时，结果才为1\n        </span>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         |\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         或\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         两个位都为0时，结果才为0\n        </span>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         ^\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         异或\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         两个位相同为0，相异为1\n        </span>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         ~\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         取反\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         0变1，1变0\n        </span>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         &lt;&lt;\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         左移\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         各二进位全部左移若干位，高位丢弃，低位补0\n        </span>\n       </p>\n      </td>\n     </tr>\n     <tr>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         &gt;&gt;\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         <span style=\'font-size:18px\'>\n          右移\n         </span>\n        </span>\n       </p>\n      </td>\n      <td valign=\'top\'>\n       <p>\n        <span style=\'font-size:18px\'>\n         各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）\n        </span>\n       </p>\n      </td>\n     </tr>\n    </tbody>\n   </table>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   位运算的主要操作都在上面以经济中的描述过了\n  </div>\n  <div>\n   下面我阐述一点自己的理解\n  </div>\n  <div>\n   1.首先位运算的二元操作符返回值都是同一个数据类型的一个数据，参与运算的数是不会发生变化的，这和正常的运算符是一样的\n  </div>\n  <div>\n   2.位运算操作只针对整形，浮点型是没有位运算的\n  </div>\n  <div>\n   3.对于右移的情况，不同的环境下处理的方式不同，但是我们应该要了解到，很多常用的机器都是采用算数右移的，也就是说对于最高位（符号位）是1的话（负数）算数右移的结果是高位用1，但是对于逻辑右移来说，不论符号位是0，1我们的高位都是用0来补齐的\n  </div>\n  <div>\n   4.小心位运算的优先级比四则运算的优先级要低，所以说我们一般保险起见用括号对优先运算顺序进行明确的界定\n  </div>\n  <div>\n   5.运算符可以合并：&amp;=,|=,&gt;&gt;=,&lt;&lt;=,^=\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.位段\n  </h2>\n  <div>\n   位段大致上可以说是一种针对位操作方便的结构体\n  </div>\n  <div>\n   定义如下\n  </div>\n  <pre class=\'html\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_1_6118305\'>struct\n{\n    unsigned var:length;  //length是变量的存储的字节宽度\n    unsigned ：length;   //无名的位段不可访问但是可以用来占空间\n};\n</pre>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于位段与几点说明很重要：\n  </div>\n  <div>\n   1.位域中的每一个位段字节大小不能超过定义的长度（对于unsigned来说是8）\n  </div>\n  <p>\n   2.对于位段中没有名字的部分我们不能访问，但是可以办证过户我们完成一些特殊的占位的需要\n  </p>\n  <p>\n   3.如果1个字节剩余的字段的长度不能刚好匹配下该位段的话，系统会重新的分配相应的内存空间，扩展一个字节\n  </p>\n  <p>\n   4.位段的引入大大的方便了我们对位运算的需求，并且还可以协助节省大量的内存空间\n  </p>\n  <p>\n   以《编程珠玑》将帅问题为例：（利用位段，压缩一个字节的空间复杂度）\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_2_1723459\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	unsigned a:4;\n	unsigned b:4; \n}point;   //一个字节(实际上半个字节，但是对于位域的分配都是整个的) \n\nint main()\n{\n	point use;\n	int count=0;\n	for(use.a=1;use.a&lt;=9;use.a++)\n	{\n		for(use.b=1;use.b&lt;=9;use.b++)\n		{\n			if(use.a%3==use.b%3) continue;\n			else printf(\'%d %d\n\',use.a,use.b),count++;\n		}\n	}\n	printf(\'\n%d\n\',count);\n	return 0;\n}</pre>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.位运算的技巧\n  </h2>\n  <h3>\n   1.判断奇偶\n  </h3>\n  <p>\n   对于奇数偶数我们一般采用的判断方法都是对2进行取余来进行判断的\n  </p>\n  <p>\n   但是我们都知道，取余运算是非常的低效的，但是计算机是二进制的机器，所以说对于取余2，我们完全可以利用二进制的一些特点快速的完成\n   <br/>\n   首先我们需要了解到对于任何一个数转化成二进制的话，如果是偶数那么最低位一定是0，是奇数最低位一定是1\n  </p>\n  <p>\n   那么根据这一点我们的优化就有了\n  </p>\n  <pre class=\'html\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_3_1025348\'>if(a&amp;1) printf(\'奇数\');\nelse printf(\'偶数\');</pre>\n  <h3>\n   2.交换两个数\n  </h3>\n  <div>\n   通常的swap操作我们价换两个数的值都是用引入了第三个变量来进行交换的，但是我们其实可以通过异或来快速的进行不引入变量的快速交换（利用了整数异或运算群的逆元的性质），但是我们要注意\n   <strong>\n    该方法仅限于整数\n   </strong>\n  </div>\n  <div>\n   首先，我们要知道一个数和自己异或的话，结果是0，但是0和任何数异或的结果是都是原数本身，并且异或操作可以结合\n  </div>\n  <div>\n   示例代码如下：\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_4_8375389\'>void swap(int x,int y)\n{\n    x=x^y;\n    y=y^x;\n    x=y^x;\n}</pre>\n  <div>\n   该性质很简单也很好记\n  </div>\n  <h3>\n   3.变换符号\n  </h3>\n  <div>\n   负数变正数以及正数变负数一直是我们可能会常用到的一种运算，对于这种的方式我们通常会用到二进制存储的一点知识来进行解决\n  </div>\n  <div>\n   我先给出结论：\n  </div>\n  <div>\n   不论是正数还是负数，只要我们取反再加一就可以实现变换符号\n  </div>\n  <div>\n   比如8\n  </div>\n  <div>\n   0000 1000  -&gt; 1111 0111（取反）-&gt;1111 1000（-8）\n  </div>\n  <div>\n   1111 1000  -&gt; 0000 0111（取反）-&gt;0000 1000（8）\n  </div>\n  <div>\n   注意这里说的取反是整个联通符号位一起取反\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么对于变换符号我们的程序大致如下：（~优先级允许我们可以不用加括号）\n  </div>\n  <pre class=\'html\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_5_5725430\'>void change(int x)\n{\n    x=~x+1;\n}</pre>\n  <h3>\n   4.求绝对值\n  </h3>\n  <div>\n   我们求取绝对值的思路和上面的变换符号的实录大致是一样的\n  </div>\n  <div>\n   在这里有两种思路\n  </div>\n  <div>\n   但是我们判断数的正负还有一种方法\n  </div>\n  <div>\n   如果数是int类型的，我们知道最高位只有32位，那么显然对于最高位我们右移31位之后就会取到最高位的数据\n  </div>\n  <div>\n   显然，如果是整数的话，右移31位之后我们只会得到0\n  </div>\n  <div>\n   但是如果最高位是1，不论是算数右移还是逻辑右移，我们得到的至少是1，不会是0\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_6_9487421\'>int abs(int x)\n{\n    return (a&gt;&gt;31)==0 ? a : (~a+1); \n}</pre>\n  <div>\n   但是我们换一种角度来看的话，其实作为算数右移的话，x&gt;&gt;31得到的结果只能是-1，0\n  </div>\n  <div>\n   任何数与-1异或的结果是取反(-1的二进制位全部是1)\n  </div>\n  <pre class=\'html\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_7_5965410\'>int abs(int x)\n{\n    int i=x&gt;&gt;31;\n    return (x^i)+i;\n}</pre>\n  <div>\n   我们就可以如此简化了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   4.位运算的应用优化\n  </h2>\n  <h3>\n   1.优化筛素数算法\n  </h3>\n  <div>\n   我们在这里和大神的讲解一样，我们引入筛素数的例子\n  </div>\n  <div>\n   众所周知，筛素数算法的由埃拉托色尼和快速线性筛\n  </div>\n  <div>\n   我们常用的筛法都是快速线性筛，但是因为算法本身的需要我们需要一个判断数组来进行判断，但是我们标记需要的位数只有0，1用一个bool或者char存储太浪费空间，所以这里我们引入位运算，个努努存储的类型不同，我们可以选择8位压缩，或者32位一压缩\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_8_5267299\'>/*\n位数组优化空间复杂度，时间复杂度降低 \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\' \n#include\'ctime\'\n#define N 10000\n\nusing namespace std;\n\nunsigned char BITGET(unsigned char&amp;x,int y) \n{\n    return (x&gt;&gt;y)&amp;1;\n}\n\nvoid BITSET(unsigned char&amp;x,int y) \n{\n    x=(1&lt;&lt;y)|x;\n}\n\nvoid BITZERO(unsigned char&amp;x,int y) \n{\n    x=(~(1&lt;&lt;y))&amp;x;\n}\n\nint prime[N];\nint count=0;\nunsigned char judge[N/8];\n\nint main()\n{\n	double w=clock();\n	memset(judge,0,sizeof(judge));\n	for(int i=0;i&lt;N;i++) BITSET(judge[i/8],i%8);\n	BITZERO(judge[0],0);\n	for(int i=2;i&lt;N;i++)\n	{\n		int k;\n		k=BITGET(judge[i/8],i%8);\n		if(k&amp;1) prime[++count]=i;\n		for(int j=1;j&lt;=count&amp;&amp;prime[j]*i&lt;N;j++)\n		{\n			BITZERO(judge[i*prime[j]/8],i*prime[j]%8);\n			if(i%prime[j]==0) break;\n		}\n	}\n	for(int i=1;i&lt;=count;i++) printf(\'%d \',prime[i]);\n	printf(\'\n%d\n耗时:%lf\n\',count,clock()-w);\n	return 0;\n}*/\n\n/*\n朴素的快速线性筛法 \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'ctime\'\n#define N 10000\n\nusing namespace std;\n\nint prime[N];\nint count;\nbool judge[N];\n\nint main()\n{\n	double w=clock();\n	memset(judge,1,sizeof(judge));\n	count=0;\n	judge[1]=judge[0]=0;\n	for(int i=2;i&lt;N;i++)\n	{\n		if(judge[i]==1) prime[++count]=i;\n		for(int j=1;j&lt;=count&amp;&amp;i*prime[j]&lt;N;j++)\n		{\n			judge[i*prime[j]]=0;\n			if(i%prime[j]==0) break;\n		}\n	}\n	for(int i=1;i&lt;=count;i++) printf(\'%d \',prime[i]);\n	printf(\'%d\n%lf\n\',count,clock()-w);\n	return 0;\n}*/\n</pre>\n  <div>\n   通过对两种算法的时间效率的比较我们会发现\n  </div>\n  <div>\n   虽然在时间复杂度上，位运算优化过的时间效率明显低于朴素的时间效率（因为大量的位运算的操作）\n  </div>\n  <div>\n   但是我们可以发现，我们实际上已经空间优化了8倍不止，在内存吃紧的情况下，该优化还是很有必要的\n  </div>\n  <h3>\n   2.内存反转（位运算+手摇算法）\n  </h3>\n  <pre class=\'cpp\' code_snippet_id=\'1942546\' name=\'code\' snippet_file_name=\'blog_20161021_9_3489392\'>/*手摇算法的位运算实现 \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nunsigned char data;\n\nvoid BIT_REVERSE(int atom)   //atom代表作用操作符，表示替代我们的操作位置 \n{\n	for(int i=0;i&lt;2;i++)\n	{\n		int a=(data&gt;&gt;(atom+i))&amp;1;\n    	int b=(data&gt;&gt;(atom+3-i))&amp;1;\n    	if(a) data=(a&lt;&lt;(atom+3-i))|data;\n    	else data=(~(1&lt;&lt;(atom+3-i)))&amp;data;\n    	if(b) data=(b&lt;&lt;(atom+i))|data;\n    	else data=(~(1&lt;&lt;(atom+i)))&amp;data;\n	}\n}\n\nvoid bit_reverse()\n{\n	for(int i=0;i&lt;4;i++)\n	{\n		int a=(data&gt;&gt;(i))&amp;1;\n    	int b=(data&gt;&gt;(7-i))&amp;1;\n    	if(a) data=(a&lt;&lt;(7-i))|data;\n    	else data=(~(1&lt;&lt;(7-i)))&amp;data;\n    	if(b) data=(b&lt;&lt;(i))|data;\n    	else data=(~(1&lt;&lt;(i)))&amp;data;\n	}\n}\n\nint main()\n{\n	data=7;   //测试数据 \n	BIT_REVERSE(0);\n	//printf(\'%d\n\',data);\n	BIT_REVERSE(4);\n	//printf(\'%d\n\',data);\n	bit_reverse();\n	printf(\'%d\n\',data);\n	return 0;\n}*/ </pre>\n  <h3>\n   3.缺失的数（经典面试题）\n  </h3>\n  <div>\n   大致题意：\n  </div>\n  <div>\n   1.由原本是一对成对的数，但是现在有一个数缺失了一个，求出缺失的那一个\n  </div>\n  <div>\n   通常的做法，我们都是从头到位遍历保存出现次数，但是额外开辟的空间实在是不理想\n  </div>\n  <div>\n   但是我们可以知道，异或运算\n  </div>\n  <div>\n   两个相同的数异或的结果是0，0和任何数的抑或结果都是原数，所以说只要我们将所有的数据一次异或，剩下的结果就是那个缺失的数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.题目拓展：如果有两个数都存在缺失的话，怎么办\n  </div>\n  <div>\n   因为两个数是不相同的，所以说所有的数一次异或之后我们得到的结果就是这两个答案的异或，并且我们知道这个结果一定不是0，因为两个数是不相同的\n  </div>\n  <div>\n   这是候，我们就可以利用分治法来考虑，我们将最后的结果中找到任意一个是1的二进制位，我们可以肯定这两个数的该二进制位是绝对不相同的\n  </div>\n  <div>\n   我们可以将整个数根据这个二进制位来进行分类（分成两类）然后，我们每组再利用1中的异或的方法，最后就可以轻松地得到两个结果，时间复杂度还是O(n),空间复杂度还是0\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   5.参考资料\n  </h2>\n  <h2>\n   <a href=\'http://www.jb51.net/article/40555.htm\' target=\'_blank\'>\n    点击打开链接\n   </a>\n  </h2>\n  <h2>\n   <a href=\'http://blog.csdn.net/MoreWindows/article/details/7354571?locationNum=1&amp;fps=1\' target=\'_blank\'>\n    点击打开链接\n   </a>\n   <br/>\n   <br/>\n   <br/>\n  </h2>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('98540dd299f8123e697ac26c937a6eef','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  1102 面积最大的矩形(简单DP)\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   <div style=\'margin:0px; padding:0px; color:rgb(48,48,48); font-family:\'Bookman Old Style\',Constantia,微软雅黑,宋体; font-size:16px; line-height:25px\'>\n    有一个正整数的数组，化为直方图，求此直方图包含的最大矩形面积。例如 2,1,5,6,2,3，对应的直方图如下：\n   </div>\n   <div style=\'margin:0px; padding:0px; color:rgb(48,48,48); font-family:\'Bookman Old Style\',Constantia,微软雅黑,宋体; font-size:16px; line-height:25px\'>\n    <br/>\n   </div>\n   <div style=\'margin:0px; padding:0px; color:rgb(48,48,48); font-family:\'Bookman Old Style\',Constantia,微软雅黑,宋体; font-size:16px; line-height:25px\'>\n    <img alt=\'\' src=\'http://img.51nod.com/upfile/000fbce2/08d164337bdb2808000000000027de17.png\'/>\n   </div>\n   <div style=\'margin:0px; padding:0px; color:rgb(48,48,48); font-family:\'Bookman Old Style\',Constantia,微软雅黑,宋体; font-size:16px; line-height:25px\'>\n    <br/>\n   </div>\n   <div style=\'margin:0px; padding:0px; color:rgb(48,48,48); font-family:\'Bookman Old Style\',Constantia,微软雅黑,宋体; font-size:16px; line-height:25px\'>\n    面积最大的矩形为5,6组成的宽度为2的矩形，面积为10\n   </div>\n   <h2>\n    2.Solution:\n   </h2>\n  </div>\n  <div>\n   DP思想，和小学期做的编程珠玑那道题基本上是一个套路\n  </div>\n  <div>\n   定义状态：\n  </div>\n  <div>\n   left[i]:i矩形的左边界\n  </div>\n  <div>\n   right[i]:i举行的右边界\n  </div>\n  <div>\n   状态转移方程:\n  </div>\n  <div>\n   right和left是对称的，这里只说left\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>if(data[i]&gt;data[i-1]) left[i]=i;\nelse \n{\n    for(j=left[i-1];j&gt;=1&amp;&amp;data[j]&lt;data[i];j--);\n    left[i]=j+1;\n}</pre>\n   在上面的状态转移的过程中，虽然我们加快了回溯左边界的过程，但是并没有找到，还是要我们回去继续查找的，但是已经加快了速度了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <h2>\n    3.Code:\n   </h2>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1940421\' name=\'code\' snippet_file_name=\'blog_20161020_2_8791318\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define ll long long\n#define N 50005\n\nusing namespace std;\n\nint n;\nll data[N];\nint leftp[N];\nint rightp[N];\nint j; \n\nint main()\n{\n	memset(rightp,0,sizeof(rightp));\n	memset(leftp,0,sizeof(leftp));\n	scanf(\'%d\',&amp;n);\n	for(int i=1;i&lt;=n;i++) scanf(\'%lld\',&amp;data[i]);\n	leftp[1]=1;\n	for(int i=2;i&lt;=n;i++)\n	{\n		if(data[i]&gt;data[i-1]) leftp[i]=i;\n		else\n		{\n			for(j=leftp[i-1]-1;j&gt;=1;j--) if(data[j]&lt;data[i]) break;\n			leftp[i]=j+1;\n		}\n	}\n	rightp[n]=n;\n	for(int i=n-1;i&gt;=1;i--)\n	{\n		if(data[i]&gt;data[i+1]) rightp[i]=i;\n		else\n		{\n			for(j=rightp[i+1]+1;j&lt;=n;j++) if(data[j]&lt;data[i]) break;\n			rightp[i]=j-1;\n		}\n	}\n	ll maxp=0;\n	for(int i=1;i&lt;=n;i++)\n	{\n		ll k=(rightp[i]-leftp[i]+1)*data[i];\n		maxp=maxp&gt;k?maxp:k;\n	}\n	printf(\'%lld\n\',maxp);\n	return 0;\n} </pre>\n    <br/>\n    <br/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c045f73b5b9c9d152db30b839bb58d16','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  埃拉托色尼素数筛法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.算法原理\n  </h2>\n  <div>\n   埃拉托色尼素数筛法是有古希腊数学家发明的一种快速求解范围内所有的素数的算法\n  </div>\n  <div>\n   在我们讲解埃拉托色尼素数筛法之前，我们需要了解一下朴素的求素数的算法的工作原理\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   首先：\n  </h3>\n  <div>\n   对于朴素的求素数的算法我们有过编程基础的人都会知道算法的原理很简单，首先从定义出发，一个数既然是素数那么就说明这个数除了1和本身以外不存在任何一个因子，所以朴素的算法就很直接的遍历一遍整个范围，我们对范围内的所有的数都进行判断，如果该数可以被整除说明不满足素数的条件，这样的话，对整个范围都进行一次比那里我们就可以判断\n   <strong>\n    一个数\n   </strong>\n   是不是素数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   优化一下我们的朴素的求解思路，对于数来说，如果一个数的有因子的话（至少因子都是成对的），那么我们很显然会知道两个因子至少有一个会是小于等于sqrt(n)的，这一点是显然的，换个说法来看的话，如果一个数我们只要对他的sqrt(n)范围内进行遍历的话，只要在这个范围内是满足我们没有银子的条件，很显然这个数我们就可以认为是素数了，这么做可以减少我们的遍历的循环的次数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   好了我们来总结一下，对于朴素的求素数的方法判断每个数是不是素数我们至少需要O(sqrt(n))即O(n)的时间复杂度，但是如果我们要是想要判断一整个范围内的所有的素数或者求范围内的素数的个数的话，我们朴素的方法就至少需要O(sqrt(n)*n)即O(n^2)的时间复杂度来做了，很显然当数据量非常大的时候这么做是有一些低效的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <pre class=\'html\' code_snippet_id=\'1932942\' name=\'code\' snippet_file_name=\'blog_20161017_1_8928070\'>for(int i=2;i*i&lt;N;i++)\n{\n    if(d%i==0) break;\n}\n</pre>\n  </div>\n  <h3>\n   导入：\n  </h3>\n  <div>\n   <img alt=\'\' src=\'\'/>\n  </div>\n  <div>\n   下面我们来解释一下著名的素数筛法，即\n   <strong>\n    埃拉托色尼素数筛法\n   </strong>\n   ，本算法由著名的希腊数学家发明，算法的原理也是非常的简单，但是我们要求的不仅仅是初步的优化，之后我会讲解一系列的对埃拉托色尼算法的优化\n  </div>\n  <div>\n   首先在开始之前，我们需要了解到，埃拉托色尼素数筛法实际上是一种空间换时间的算法优化，对于判断单个数的素数性质来说，相对于朴素的算法没有优化，但是在求解范围素数问题的时候，埃拉托色尼素数筛法可以很快的打印一份范围内的素数表（该思路的时间复杂度我之后讲解）\n  </div>\n  <div>\n   首先，我们需要来了解一下\n  </div>\n  <div>\n   埃拉托色尼算法工作原理：\n  </div>\n  <div>\n   1.假定范围内的所有的数都是素数\n  </div>\n  <div>\n   2.我们从2开始，只要是2的倍数我们就认为该数不是素数，打标处理\n  </div>\n  <div>\n   3.直到判断到n为止我们就可以将所有的非素数打上标记，从而确定了所有的非素数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   简单证明：反证法\n  </div>\n  <div>\n   假设应用算法流程之后我们得到了一组序列，如果该序列中存在一个非素数，说明该数必定存在因子d，那么对于在算法流程中我们对d的所有的倍数全部都打标处理了，所以说出现矛盾，埃拉托色尼素数筛法是正确的，可以得到正确的素数序列\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   附上代码直观一些:\n  </div>\n  <div>\n   <pre class=\'html\' code_snippet_id=\'1932942\' name=\'code\' snippet_file_name=\'blog_20161017_2_6354559\'>	memset(prime,1,sizeof(prime));   //初始假设所有的数都是素数 \n	\n	prime[0]=prime[1]=0;   //初始确认0,1不是 \n	for(int i=2;i*i&lt;N;i++)\n	{\n		if(prime[i])\n		{\n			for(int j=2;i*j&lt;N;j++) prime[i*j]=0;\n		}\n	}</pre>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于朴素的埃拉托色尼素数筛法的时间复杂度我们来判断一下\n  </div>\n  <div>\n   <pre class=\'html\' code_snippet_id=\'1932942\' name=\'code\' snippet_file_name=\'blog_20161017_3_6704006\'>n:扫描遍历次数\n从2开始直到n我们进行倍数打标处理，每个循环到的数我们记为k\n单次扫描的时间复杂度是O(n/k)\n那么总的时间复杂度就是\nT(n)=n/2+n/3+n/4+.....n/n(因为在算法的过程中我们是不断地筛掉的，所以说实际的时间复杂度是远远要比这个小的)\nO(n)&lt;T(n)\n对于T(n)的求解,我们应用调和奇数的公式可以得到大致约为Ln(n)\n所以说O(n)&lt;O(n*logn)</pre>\n   <br/>\n   <div>\n    当然你们可能会觉得算法比朴素的求素数的有点慢，但是注意我们的算法求解出来了整个范围的所有的素数，还算是相对来说比较高效的\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    优化1:\n    <br/>\n    先陈述我们的优化，在这里我们还是没有必要遍历整个范围，我们只需要遍历到sqrt(n)就可以了\n    <br/>\n    证明，我先说明这个证明确实废了我一些功夫\n    <br/>\n    首先回顾埃拉托色尼素数筛法，我们进行的操作是打标处理，如果我们在sqrt(n)停止了打标处理，会错误吗\n    <br/>\n    反证法：\n    <br/>\n    假设我们操作之后还是存在非素数d没有被打标，那么该素数的sqrt(d)&lt;sqrt(n)显然，那么就说明d还存在一个因子k&lt;sqrt(d)&lt;sqrt(n),但是按照埃拉托色尼算法，这个k的所有的倍数我们全部都打标了，所以说矛盾\n    <br/>\n    证明成功\n    <br/>\n    对于优化1来说我们明显降低了遍历次数\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    2016/10/29\n   </div>\n   <div>\n    优化1再优化，今天又得到了一种新的优化思路\n   </div>\n   <div>\n    因为在埃式筛法中我们都是从2倍开始一次的筛但是仔细注意我们会发现，实际上我们只用从i*i开始筛就好了，因为i*2,i*3....i*i-1都曾经被筛过了，我们只用从i*i开始就好，实际上在压力测试100000000（1亿）的时候我们会发现这样子我们可以优化一些时间，优化1的时间是4951，本次优化的时间压缩到了4321\n   </div>\n   <div>\n    还是很有用处的\n   </div>\n   <div>\n    附上代码：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1932942\' name=\'code\' snippet_file_name=\'blog_20161029_4_7410791\'>	for(int i=2;i&lt;N;i++)\n	{\n		if(prime[i])\n		{\n			long long int j;\n			save[++count]=i;\n			for(j=pow(i,2);j&lt;N;j+=i) prime[j]=0;\n		}\n	}</pre>\n    <br/>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    优化2:导入快速线性筛法\n    <br/>\n    从上面的埃拉托色尼算法的流程来看，我们对于某些数其实进行了重复筛选的结果\n    <br/>\n    比如12，我们分别在2,3,的时候重复了筛选，为了优化重复筛选的弊端，我们引入快速线性筛法\n   </div>\n   <div>\n    为了解释方便首先我们先引入代码段，之哦后我们对代码段进行解释\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1932942\' name=\'code\' snippet_file_name=\'blog_20161017_4_5450270\'>memset(judge, 1, sizeof(judge));\n	judge[1] = judge[0] = 0;\n	for (int i=2;i&lt;N;i++)\n	{\n		if (judge[i]) prime[++countp] = i;   //0\n		for (int j=1;j&lt;=countp&amp;&amp;i*prime[j]&lt;N;j++)    //1\n		{\n			judge[i*prime[j]] = 0;\n			if (!(i%prime[j])) break;   //2\n		}\n	}</pre>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    线性素数筛法的解释：\n   </div>\n   <div>\n    对于埃拉托色你素数筛法，我们会发现有的素数我们会重复删除，比如12会被2，3判断两次，这样会大幅度的降低我们算法的时间复杂度，针对一些素数的基本性质和反证法，我来对快速线性筛法做一下简单的我证明和解释\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <strong>\n     首先：\n    </strong>\n   </div>\n   <div>\n    <strong>\n     1.任何一个合数都有唯一的素因子分解式（这也是我们唯一删除一次的应用原理）\n    </strong>\n   </div>\n   <div>\n    <strong>\n     对于任何一个合数，始终都在这个范围内\n    </strong>\n   </div>\n   <div>\n    <strong>\n     a.合数=素数*素数\n    </strong>\n   </div>\n   <div>\n    <strong>\n     b.合数=素数*合数\n    </strong>\n   </div>\n   <strong>\n   </strong>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先从代码的角度我来解释一下，快速先行筛法的思路如下：\n  </div>\n  <div>\n   1.从2开始\n  </div>\n  <div>\n   如果当前的i是素数的话对于1的内层循环我们始终是不会中途跳出的，也就是将当前i和i之前的所有的素数相乘得到的合数全部打标判负（对于合数=素数*素数的情况来看的话这样的删除效果是唯一的，不会重复删除，很容易可以判断出来）\n  </div>\n  <div>\n   如果当前的i是合数的话对于1的内层循环我们绝对会中途跳出（因为一个合数必定会表示成至少有一个素数参与的分解式）这样子的操作的目的是为了保证该情况下的删除是唯一的，不会重复删除\n   <br/>\n  </div>\n  <div>\n   2.当整个数组遍历完之后，我们就会得到一个完整的素数表（这一点在下面我会用反证法证明）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    证明：\n   </strong>\n  </div>\n  <div>\n   <strong>\n    1.证明该方案是不会漏筛合数的\n   </strong>\n  </div>\n  <div>\n   反证法：\n  </div>\n  <div>\n   假设该方案我们会漏掉合数，假设合数是d\n  </div>\n  <div>\n   显然该合数d可以表示成：\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'1932942\' name=\'code\' snippet_file_name=\'blog_20161017_5_1131872\'>d=d的最小素因子*w(该书可素可和，不考虑)\nd的最小素因子必定小于等于w的最小素因子\n（该结论应用反证法，如果d的最小素因子大于w最小素因子，那么对于d的最小素因子就不是一开始确定的值，所以说成立）\n那么显然按照我们算法的流程来看的话在我们遍历到w的那个时候我们已经将d打标了，所以说和题设相矛盾\n说明该算法对于筛素数是完全正确的，是不会漏筛的</pre>\n  <div>\n   <strong>\n    2.证明该方案是不会重复删除合数的(也就是证明如果注释2处不跳出是会重复删除的)\n   </strong>\n  </div>\n  <div>\n   假设合数k=p*w(p是素数，w是另一个k的因子)\n  </div>\n  <div>\n   如果p&gt;w的最小素因子\n  </div>\n  <div>\n   对于k之后的素数h\n  </div>\n  <div>\n   我们就也要执行删除操作\n  </div>\n  <div>\n   因为h=pk*w(pk是p的下一个素数)=pw*ww(pw*ww的式子在ww遍历的时候会h会被打标，ww&lt;w说明h之前被标记了，所以重复标记)\n  </div>\n  <div>\n   证明完成\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    综上我们可以总结出快速线性素数筛法在是正确的\n   </strong>\n  </div>\n  <div>\n   <strong>\n    因为快速线性素数筛法是不会出现对一个素数重复删除标记的情况，所以说对于埃拉托色尼素数筛法该速发的时间效率更高\n   </strong>\n  </div>\n  <div>\n   <strong>\n    <br/>\n   </strong>\n  </div>\n  <div>\n   为了验证算法的高效性，我对两种算法在压力测试100000000（1亿）的时候的耗时情况进行了大致的测试\n  </div>\n  <div>\n   实际显示快速先行筛法在大数据量的时候比埃拉托色你筛法要高效很多\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   附上压力测试代码：\n  </div>\n  <pre class=\'cpp\' code_snippet_id=\'1932942\' name=\'code\' snippet_file_name=\'blog_20161017_6_4653882\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'time.h\'\n#define N 100000000\n\nusing namespace std;\n\nint prime[N];\nbool judge[N];\nint countp = 0;\n\nint main()\n{\n	double w = clock();\n	memset(judge, 1, sizeof(judge));\n	judge[1] = judge[0] = 0;\n	for (int i=2;i&lt;N;i++)\n	{\n		if (judge[i]) prime[++countp] = i;\n		for (int j=1;j&lt;=countp&amp;&amp;i*prime[j]&lt;N;j++)\n		{\n			judge[i*prime[j]] = 0;\n			if (!(i%prime[j])) break;\n		}\n	}\n	//for (int i = 1;i &lt;= countp;i++) printf(\'%d \', prime[i]);\n	printf(\'耗时:%lf\n%d\',(double) (clock() - w),countp);\n	return 0;\n}\n/*\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'time.h\'\n#define N 100000000\n\nusing namespace std;\n\nbool judge[N];\n\nint main()\n{\n	int count = 0;\n	double w = clock();\n	memset(judge, 1, sizeof(judge));\n	judge[1] = judge[0] = 0;\n	for (int i=2;i*i&lt;N;i++)\n	{\n		if (judge[i])\n		{\n			for (int j = 2;i*j &lt; N;j++) judge[i*j] = 0;\n		}\n	}\n	for (int i = 2;i &lt; N;i++) if (judge[i]) count++;\n	printf(\'%lf\n%d\n\', clock() - w,count);\n	return 0;\n}*/\n</pre>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.Last question\n   <br/>\n  </h2>\n  <div>\n   1.对于线性素数筛法还催你在什么好的优化\n  </div>\n  <div>\n   2.对于欧拉筛法和莫比乌斯筛法的学习算法原理\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b8a70e672566aa45fe1c8bc1573504c1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Lantian和Tianqi的移动开发之旅 - 002\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   Java面向对象\n  </h1>\n  <h2>\n   1.java类成员\n  </h2>\n  <div>\n   在这里该问题太过简单，不在多余赘述，但是需要强调一点\n  </div>\n  <div>\n   <strong>\n    <em>\n     类的组成成分：\n    </em>\n   </strong>\n  </div>\n  <div>\n   <strong>\n    成员变量：\n   </strong>\n  </div>\n  <div>\n   作为类的属性参数，有四种访问权限，可以被类中的所有的函数调用（注意静态函数只能调用静态的方法，想要在静态成员函数中调用非静态成员必须要先new一个对象出来之后继续才能调用）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    局部变量：\n   </strong>\n  </div>\n  <div>\n   方法体里面定义的变量，作用域仅限于该方法体内，注意函数的形参也属于我们的局部变量\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    类变量（静态变量）：\n   </strong>\n  </div>\n  <div>\n   类变量是一个类共有的变量，类变量对于一个类来说只有一份模板，在类声明的初期我们确定下来的类变量我们可以直接通过类名通过.运算直接访问也可以正规的通过初始化的对象直接访问（注意有访问的权限）\n  </div>\n  <div>\n   一般来说，如果我们的勒种我的对象需要我们共享一段数据的时候，我们往往将该数据声明为静态的变量，这样子往往我们可以节约内存\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    非静态方法：\n   </strong>\n  </div>\n  <div>\n   非静态方法就是我们的类中的普通的方法，首先我们需要注意一点，如果该类作为一个源文件的接口的话（带有主方法的类），那么我们的主方法因为是static的，我们不能再主方法中直接调用我们的费静态方法，因为我们的类只是一个模板，我们的在没有创建对象的时候，遮羞费静态函数是没有任何实际意义的，我们需要在主方法中创建类的实例化对象之后才可以根据我们的翻个万全县来访问我们的非静态方法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    静态方法：\n   </strong>\n  </div>\n  <div>\n   静态方法在一个类中只有一个区域，静态的方法只能调用静态的方法和成员，并且在类的声明的方法只有一块内存的模板，我们的静态的方法其实就是类的方法，我们可以直接通过类名.运算符直接调用我们的静态成员方法，也可以通过我们的实例化的对象来直接调用我们的静态方法，都是一样的\n  </div>\n  <div>\n   一般情况下，如果我们的一个类中有少数几个类代表一个类的性质取实现摸个操作的时候，我们就可以将函数设定成静态的函数这样我们无需实例化对象我们就可以实现相应的功能，但是一个类中所有的成员函数如果都是静态的话反而没有必要，因为这样的话这个类就没有创建出对象的必要了\n  </div>\n  <div>\n   因为静态方法实际上还有一份的内存，那么我们类中的大部分的变量都是静态的，实例化的对象实际上就只有费静态的对象了，这样反而没有必要，还会占内存\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    静态初始化块：\n   </strong>\n  </div>\n  <div>\n   在类中我们往往会见到这样的初始化块\n  </div>\n  <div>\n   首先我们要知道，在java中类的成员变量可以不用进行初始化，java会自动的附上默认值，但是我们自己进行的显示的初始化也是可以的\n  </div>\n  <div>\n   但是局部变量必须要初始化，这是定义\n  </div>\n  <div>\n   在java中我们往往会将这三者进行比较\n  </div>\n  <div>\n   1.静态初始化块\n  </div>\n  <div>\n   2.非静态初始化块\n  </div>\n  <div>\n   3.构造函数\n  </div>\n  <div>\n   实际上，有的人可能会问了，我们既然可以自己显示的给类的变量进行初始化赋值，为什么还需要初始化块来初始化呢，实际上初始化块的作用不仅仅在于初始化，初始化块还可以运行语句，如果\n  </div>\n  <div>\n   上面的三个比较的执行优先级如下：\n  </div>\n  <div>\n   静态&gt;非静态&gt;构造函数（实际上语句运行的顺序也是如此，在调用构造函数之前我们必须要先初始化所有的变量然后才去调用构造函数）\n  </div>\n  <div>\n   静态初始化块我们只可以初始化静态的成员变量\n  </div>\n  <h3>\n   非静态初始化块：\n  </h3>\n  <div>\n   在上面已经大致的说明了，非静态初始化块可以初始化静态成员但是不提倡\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   创建对象的方法语句大致为\n  </div>\n  <div>\n   classname varname=new classname(形参表);\n  </div>\n  <div>\n   调用静态成员或者方法：\n  </div>\n  <div>\n   classname.function()    classname.var    varname.function()    varname.var\n  </div>\n  <h2>\n   2.访问权限控制\n  </h2>\n  <div>\n   <img alt=\'\' src=\'http://img.ph.126.net/AYLKMqOoxAgGVZPtqyEAFQ==/2552696563805717290.jpg\'/>\n   <br/>\n  </div>\n  <h2>\n   3.this\n  </h2>\n  <div>\n   this说白了和C++中的this指针的作用是一样的，都是代表了当前的对象的本身，java已经将this帮顶到了当前的对象上了，所以亦可以说this是对象的一个引用名\n  </div>\n  <div>\n   this在java中的使用有以下几点：\n  </div>\n  <div>\n   1.区分同名变量\n  </div>\n  <div>\n   2.作为方法名来初始化对象，相当于是在构造函数中调用 另一个构造函数\n  </div>\n  <div>\n   调用动作必须在构造函数的起始位置（构造函数的重载）\n  </div>\n  <div>\n   一个构造函数只能调用一个构造函数\n  </div>\n  <div>\n   3.作为参数传递，将对象本身作为参数传递给另一个函数，实现某种功能\n  </div>\n  <h2>\n   4.重载\n  </h2>\n  <div>\n   简单一句话：\n  </div>\n  <div>\n   只要只要方法名相同，形参表中参数的个数，顺序，类型不同就可以构成重载\n  </div>\n  <div>\n   final，static成员函数不能重载\n  </div>\n  <h2>\n   5.拆箱装箱\n  </h2>\n  <div>\n   在java中基本数据类型是可以封装成一个类的，我们管这种类叫做包装类\n  </div>\n  <div>\n   包装类我们可以理解为是封装了基本数据类型变量的数值以及对相应的数据类型的一系列操作\n  </div>\n  <div>\n   在转化方面是非常的高效的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   包装类总览:\n  </div>\n  <div>\n   <table style=\'border-collapse:collapse; margin:auto; color:rgb(51,51,51); font-family:\'Microsoft Yahei\',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.4px; background-color:rgb(238,238,238)\'>\n    <caption>\n     基本数据类型及对应的包装类\n    </caption>\n    <tbody>\n     <tr>\n      <th style=\'padding:7px 5px; border:1px solid rgb(204,204,204); color:rgb(68,68,68); background-color:rgb(237,237,237)\'>\n       基本数据类型\n      </th>\n      <th style=\'padding:7px 5px; border:1px solid rgb(204,204,204); color:rgb(68,68,68); background-color:rgb(237,237,237)\'>\n       对应的包装类\n      </th>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       byte\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Byte\n      </td>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       short\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Short\n      </td>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       int\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Integer\n      </td>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       long\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Long\n      </td>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       char\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Character\n      </td>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       float\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Float\n      </td>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       double\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Double\n      </td>\n     </tr>\n     <tr>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       boolean\n      </td>\n      <td style=\'padding:5px; border:1px solid rgb(204,204,204)\'>\n       Boolean\n       <br/>\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   包装类一旦创建就不可修改\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   1.装箱\n  </div>\n  <div>\n   我们将基本数据类型封装到包装类中的过程叫做装箱\n  </div>\n  <div>\n   装箱有手动装箱和自动装箱之分\n  </div>\n  <div>\n   手动装箱：\n  </div>\n  <div>\n   <span class=\'sh_usertype\' style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    Integer\n   </span>\n   <span class=\'sh_normal\' style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    obj\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    =\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n   </span>\n   <span class=\'sh_keyword\' style=\'color:rgb(255,48,48); font-weight:bold; font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    new\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n   </span>\n   <span class=\'sh_function\' style=\'color:rgb(209,28,237); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    Integer\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    (\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    m\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    );\n   </span>\n   <span class=\'sh_symbol\' style=\'font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    <span style=\'color:#333333\'>\n    </span>\n   </span>\n  </div>\n  <div>\n   自动装箱：\n  </div>\n  <div>\n   <span style=\'font-family:monospace; color:#333333\'>\n    <span style=\'font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n     <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n     </span>\n     <span class=\'sh_usertype\' style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n      Integer\n     </span>\n     <span class=\'sh_normal\' style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n     </span>\n     <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n      obj\n     </span>\n     <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n      =\n     </span>\n     <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n      m\n     </span>\n     <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n      ;\n     </span>\n     <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n     </span>\n     <br/>\n    </span>\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.拆箱（借助包装类的相应方法进行拆箱）\n  </div>\n  <div>\n   手动拆箱：\n  </div>\n  <div>\n   <span class=\'sh_type\' style=\'color:rgb(207,149,17); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    int\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    n\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    =\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    obj\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    .\n   </span>\n   <span class=\'sh_function\' style=\'color:rgb(209,28,237); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    intValue\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    ();\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n   </span>\n   <span class=\'sh_comment\' style=\'color:rgb(56,173,36); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    // 手动拆箱\n   </span>\n   <br/>\n  </div>\n  <div>\n   自动拆箱：\n  </div>\n  <div>\n   <span class=\'sh_type\' style=\'color:rgb(207,149,17); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    int\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    n\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    =\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    obj\n   </span>\n   <span class=\'sh_symbol\' style=\'color:rgb(48,48,238); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    ;\n   </span>\n   <span style=\'color:rgb(51,51,51); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n   </span>\n   <span class=\'sh_comment\' style=\'color:rgb(56,173,36); font-family:monospace; font-size:14px; line-height:22.4px; white-space:pre; background-color:rgb(249,249,249)\'>\n    // 自动拆箱\n   </span>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.静态方法：\n  </div>\n  <div>\n   每个包装类都有所谓的静态方法，可以直接通过类名直接的访问，从而调用事项相应的功能\n  </div>\n  <div>\n   例如：\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:\'Microsoft Yahei\',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.4px; background-color:rgb(238,238,238)\'>\n    Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：\n   </span>\n   <div class=\'snippet-container\' style=\'color:rgb(51,51,51); font-family:\'Microsoft Yahei\',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.4px; background-color:rgb(238,238,238)\'>\n    <div class=\'sh_bright snippet-wrap\' style=\'position:relative; margin:5px auto; border:1px solid rgb(204,204,204); background-color:rgb(249,249,249)\'>\n     <pre class=\'java sh_java snippet-formatted sh_sourceCode\' style=\'margin-top:0px; margin-bottom:0px; word-wrap:break-word; word-break:normal\'><ol class=\'snippet-num\' style=\'margin-top:0px; margin-bottom:0px; margin-left:0px; padding-left:20px; padding-top:3px!important; padding-right:8px!important; padding-bottom:3px!important\'><li style=\'padding-left:8px; list-style:decimal-leading-zero outside none\'><span class=\'sh_function\' style=\'color:rgb(209,28,237)\'>parseInt</span><span class=\'sh_symbol\' style=\'color:rgb(48,48,238)\'>(</span><span class=\'sh_usertype\'>String</span><span class=\'sh_normal\'> </span>s<span class=\'sh_symbol\' style=\'color:rgb(48,48,238)\'>,</span> <span class=\'sh_type\' style=\'color:rgb(207,149,17)\'>int</span> radix<span class=\'sh_symbol\' style=\'color:rgb(48,48,238)\'>);</span></li></ol></pre>\n    </div>\n   </div>\n   <span style=\'color:rgb(51,51,51); font-family:\'Microsoft Yahei\',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.4px; background-color:rgb(238,238,238)\'>\n    s 为要转换的字符串，radix 为进制，可选，默认为十进制。\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:\'Microsoft Yahei\',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.4px; background-color:rgb(238,238,238)\'>\n    <br/>\n   </span>\n  </div>\n  <h2>\n   6.Java代码层次结构\n  </h2>\n  <div>\n   1.最底层：源文件\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:\'Microsoft Yahei\',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.4px; background-color:rgb(238,238,238)\'>\n    当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则：\n   </span>\n   <ul style=\'margin-top:0px; margin-bottom:0px; margin-left:0px; padding-left:20px; color:rgb(51,51,51); font-family:\'Microsoft Yahei\',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.4px; background-color:rgb(238,238,238)\'>\n    <li>\n     一个源文件中只能有一个public类。\n    </li>\n    <li>\n     一个源文件可以有多个非public类。\n    </li>\n    <li>\n     源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。\n    </li>\n    <li>\n     如果一个类定义在某个包中，那么package语句应该在源文件的首行。\n    </li>\n    <li>\n     如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。\n    </li>\n    <li>\n     import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n    </li>\n    <li>\n     类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在后续章节介绍。\n    </li>\n    <li>\n     除了上面提到的几种类型，Java还有一些特殊的类，如内部类、匿名类。\n    </li>\n   </ul>\n   源文件中可以有多个类，但只能有一个类作为公共接口调用\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.包：\n  </div>\n  <div>\n   包中含有其他的包或者接口，在程序开发中我们常常将功能相似的类放进同一个包中\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.src文件夹\n  </div>\n  <div>\n   主要存放我们的java的源代码\n  </div>\n  <div>\n   4.java文件夹\n  </div>\n  <div>\n   下属包括src文件夹或者也可以加入其他的文件夹，比如我们的测试代码，要和我们的源代码分开来这样才能很好的实现软件工程\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('20f2f5ffe5e0038e1a298261cc14c6cd','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Lantian和tianqi的移动开发之旅 - 001\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   Java基础语法\n  </h1>\n  <h2>\n   1.java的数据类型\n  </h2>\n  <div>\n   <table border=\'1\' cellpadding=\'1\' cellspacing=\'1\' width=\'200\'>\n    <tbody>\n     <tr>\n      <td>\n       byte\n      </td>\n      <td>\n       1b 127\n      </td>\n     </tr>\n     <tr>\n      <td>\n       short\n      </td>\n      <td>\n       2b 32767\n      </td>\n     </tr>\n     <tr>\n      <td>\n       int\n      </td>\n      <td>\n       4b 2^31-1\n      </td>\n     </tr>\n     <tr>\n      <td>\n       long\n      </td>\n      <td>\n       8b 92233720368\n      </td>\n     </tr>\n     <tr>\n      <td>\n       float\n      </td>\n      <td>\n       4b\n      </td>\n     </tr>\n     <tr>\n      <td>\n       double\n      </td>\n      <td>\n       8b\n      </td>\n     </tr>\n     <tr>\n      <td>\n       char\n      </td>\n      <td>\n       2b\n      </td>\n     </tr>\n     <tr>\n      <td>\n       boolean\n      </td>\n      <td>\n       1b\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <span style=\'font-size:12px\'>\n    数据类型：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    1.整形：byte，short，int，long\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    2.浮点型：float，double\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    3.字符型：char\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    4.布尔型：boolean\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    java不存在无符号类型\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   java7 支持\n  </div>\n  <div>\n   0b二进制\n  </div>\n  <div>\n   0八进制\n  </div>\n  <div>\n   0x十六进制\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于浮点数的一些易错点：\n  </div>\n  <div>\n   double 之后最好加d/D\n  </div>\n  <div>\n   float 之后必须要加f/F\n  </div>\n  <div>\n   因为在java中，所有的浮点型的默认类型都是double\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   自动转换（低-&gt;高）\n  </div>\n  <div>\n   强制转换：数据域前附加()\n  </div>\n  <div>\n   精度丢失(高-&gt;低)\n  </div>\n  <div>\n   精度增加(低-&gt;高)\n  </div>\n  <div>\n   根据上面的判断附上转化表：\n  </div>\n  <div>\n   byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   数据类型支持的操作：\n  </div>\n  <div>\n   +,-,*,/,%,++,--,&gt;,&gt;=,&lt;,&lt;=,==,!=,&amp;&amp;,||,!,&amp;,|,^,~,&gt;&gt;,&lt;&lt;\n  </div>\n  <div>\n   三目运算符 ?:\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.数组\n  </h2>\n  <div>\n   数组的定义：\n  </div>\n  <div>\n   <pre class=\'java\' code_snippet_id=\'1929719\' name=\'code\' snippet_file_name=\'blog_20161014_1_4049431\'>typename arrayname[];  //注意此两种初始化之后是没有内存的\ntypename[] arrayname;</pre>\n   数组的初始化分为两种，一种是静态初始化，一种是动态初始化\n  </div>\n  <div>\n   静态初始化我们在声明声明了空的字符串之后，我们可以直接的初始化，初始化的时候我们自动的给数组分配相应大小的内存空间\n  </div>\n  <div>\n   动态初始化我们需要用到new语句，new语句在队中为我们设置内存空间（大小自己指定）动态分配之后我们就只能一个一个去赋值了\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    注意，每个数组都有一个length引用的属性，代表我们的数组的大小\n   </span>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   二维数组的声明和一维数组大致上类似的\n  </div>\n  <div>\n   但是在java中没有c那种的固定的内存空间的大小限制，我们的二维数组的大小的每一层都是可以动态的指定的\n  </div>\n  <div>\n   画个图我们可以清晰地看出来：\n  </div>\n  <div>\n   |||||||||||||\n  </div>\n  <div>\n   ||||||\n  </div>\n  <div>\n   |||||||||\n  </div>\n  <div>\n   |||||||||||||||||\n  </div>\n  <div>\n   每一位我们都可以动态的分配大小\n  </div>\n  <div>\n   但是我们需要注意，数组的大小一旦我们是声明之后就会不变，所以说我们需要改变数组的大小需要重新的考虑另一种方案\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于数组的循环遍历操作我们可以采用C原本的语法采用for循环语句我们还可以使用加强版你的java\n  </div>\n  <div>\n   也就是我们的foreach语句，我们的foreach语句格式如下\n  </div>\n  <div>\n   for( var : array)  var存储变量，每一次我们从array数组中获取相应的变量然后加入到我们的var变量中\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   因为数组一旦声明之后就无法随意的改动，所以说我们完全在平常的应用的时候大多时候应用的都是Arraylist类\n  </div>\n  <div>\n   其实原理相当于一个链表，有很多的方法，remove，get，clear，add方法来实现\n  </div>\n  <h2>\n   3.字符串\n  </h2>\n  <div>\n   1.定义在“”内的都是字符串\n  </div>\n  <div>\n   2.字符串一旦声明之后的长度和内容都不会变化已经固定了\n  </div>\n  <div>\n   3.在system输出语句中我们的字符串拼接的操作其实就是对其他的数据类型调用toString方法拼接成一个整个字符串\n  </div>\n  <div>\n   4.正因为定义声明之后的长度是不会变化的，所以说我们只要的字符串的加法操作实际上是在声明一块内存然后我们将原来的内容拷贝到新的内存中，这样的效率其实非常的低下\n  </div>\n  <div>\n   ps:String str=new String;的写法其实是错误的，因为其实我们相当于动摇开辟了一块内存然后让str这个已经有了的字符串对象去指向他，完全没有必要，实际上我们直接就已经有了str这个对象\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   操作：\n  </div>\n  <div>\n   length()返还字符串的长度\n  </div>\n  <div>\n   charAt()根据索引返还字符串的相应的元素\n  </div>\n  <div>\n   contains()检查有没有子串,返回boolean型\n  </div>\n  <div>\n   replace(,)将原串的中的子串重新的修改，返回一个字符串类型，原本的额内存不变，我们只是返还了一个新的内存\n  </div>\n  <div>\n   split()用指定的 字符串 分割字符串，返回一个字符串数组，分割字符串我们吃掉了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   StringBuffer字符串缓冲区\n  </div>\n  <div>\n   我们如果对一个字符串进行大量的频繁的操作的时候，只用string的话我们是不断地生成新的类然后返还保存，按时这样的效率太过低下，所以说我们这里引入stringbuffer类，方便的对字符串进行各种操作\n  </div>\n  <div>\n   append()追加字符串，相当于之前的+\n  </div>\n  <div>\n   deleteCharAt()删除指定的字符\n  </div>\n  <div>\n   delete(,)删除区间子字符串，前闭后开\n  </div>\n  <div>\n   insert(,)插入制定位置之后插入相应的的字符串，相当于我们的加强版的append方法\n  </div>\n  <div>\n   setCharAt()指定位置我们修改字符\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('a84af7a5470d479c208fe66b7613ba27','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  哈希+位运算实现差错控制编码([7:4]线性分组码-离散数学)\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   今天上完离散课，老师上课讲解了线性分组码\n  </p>\n  <p>\n   通过陪集的思路，我算是大致理解了线性分组码的原理\n  </p>\n  <p>\n   因为目前只会了[7:4]线性分组码，其他更高数据量的线性分组码需要线性代数的知识，而且有些晦涩难懂，我就没仔细看\n  </p>\n  <p>\n   本文主要目的是通过哈希+位运算成功实现[7:4]线性分组码的纠错功能\n  </p>\n  <p>\n   首先我们来介绍一下[7:4]线性分组码，前4位是有效数字位，后三位是校验位\n  </p>\n  <p>\n   首先定义7维向量群\n  </p>\n  <p>\n   G={x1x2x3x4x5x6x7}为一个字串，群的运算为模2加法\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   前四位使我们传递信息的信息位，后三位的运算规则是\n  </p>\n  <p>\n   x5=x1+x2+x3(模2加法)\n  </p>\n  <p>\n   x6=x1+x2+x4\n  </p>\n  <p>\n   x7=x1+x3+x4\n  </p>\n  <p>\n   后三位作为一个校验单元用来判断我们的（是校验单元的原因是这三位是随着前四位变化的，一旦前四位出现错误，后三位的逆运算可以判断是哪里出现的错误）\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   其实本人的理解在这里，线性分组码是将错误码最小还原为最接近的源码，但是这里有可能还有错误的出现，一旦多次出现错误的话，显然我们还是有将其判断为正确的可能性，但是在这里我们不考虑这种可能性\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   在实际的实现中：\n  </p>\n  <p>\n   1.数据结构：\n  </p>\n  <p>\n   哈希表将所有的分组码经过哈希映射到一个标记地址（标记地址的含义是最相近的源码的存储的位置）\n  </p>\n  <p>\n   再开辟一个一维的16个码字的源码类数组\n  </p>\n  <p>\n   2.通过位运算将压缩的unsigned变量不断更新，也就会说我在实现的过程中为了节约内存利用unsigned char变量压缩存储在一个字节以内\n  </p>\n  <p>\n   <br/>\n  </p>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1925373\' name=\'code\' snippet_file_name=\'blog_20161012_1_6102427\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define GETPOS(x,y,k) k=((1&lt;&lt;y)&amp;x)&gt;&gt;y\n#define PUTPOS(x,y) x=((1&lt;&lt;y)|x)  \n\nusing namespace std;\n\nint hashmap[130];   //建立哈希映射 \n\nclass point\n{\n	public:\n		point()\n		{\n			data=\'\0\';\n		}\n		point(char k[])\n		{\n			data=\'\0\';\n			for(int i=0;i&lt;=6;i++) if(k[i]!=\'0\') PUTPOS(data,6-i);\n		}\n		inline void set(int x)\n		{\n			data=\'\0\';\n			data=(unsigned char)x;\n			data&lt;&lt;=3;    //右移运算三位，有效位，空余校验位 \n		}\n		inline void setfalse(int x)\n		{\n			data=\'\0\';\n			data=(unsigned char)x;\n		}\n		void creatafter()\n		{\n			//x5校验位 \n			int a=0;\n			int b=0;\n			int c=0;\n			GETPOS(data,6,a);\n			GETPOS(data,5,b);\n			GETPOS(data,4,c);\n			if((a+b+c)%2!=0) PUTPOS(data,2);\n			//x6校验位\n			GETPOS(data,3,c);\n			if((a+b+c)%2!=0) PUTPOS(data,1);\n			//x7校验位\n			GETPOS(data,4,b);\n			if((a+b+c)%2!=0) PUTPOS(data,0); \n		}\n		point operator+(point b)\n		{\n			point k;\n			k.data=data^b.data;\n			return k;\n		}\n		int returndata()\n		{\n			return (int)data;\n		}\n		friend ostream&amp; operator&lt;&lt;(ostream&amp; out,point&amp; x)\n		{\n			int h=0;\n			for(int i=6;i&gt;=0;i--)\n			{\n				GETPOS(x.data,i,h);\n				if(h!=0) printf(\'1\');\n				else printf(\'0\');\n			}\n			return out; \n		}\n	private:\n		unsigned char data;\n};\n\nint main()\n{\n	point map[16];\n	for(int i=0;i&lt;16;i++) map[i].set(i),map[i].creatafter();   //生成16个线性分组码\n	//建立正确映射\n	for(int i=0;i&lt;16;i++) hashmap[map[i].returndata()]=-1;\n	for(int i=0;i&lt;7;i++)   //建立映错误射 \n	{\n		for(int j=0;j&lt;16;j++)\n		{\n			point k;\n			k.setfalse(1&lt;&lt;i);\n			k=k+map[j];\n			hashmap[k.returndata()]=j;\n		}\n	}\n	char number[8];\n	memset(number,0,sizeof(number));\n	while(1)\n	{\n		memset(number,0,sizeof(number));\n		scanf(\'%s\',number);\n    	point h(number);   //重载的构造函数\n    	int p=h.returndata();\n     	if(hashmap[p]==-1) \n	    {\n	    	cout&lt;&lt;\'译码结果显示没有错误出现\'&lt;&lt;endl;\n	    	cout&lt;&lt;\'译码是:\';\n	    	cout&lt;&lt;h&lt;&lt;endl; \n    	}\n    	else\n     	{\n   	     	cout&lt;&lt;\'译码结果显示出现传输错误\'&lt;&lt;endl;\n     		cout&lt;&lt;\'源代码是:\';cout&lt;&lt;h&lt;&lt;endl;\n	    	cout&lt;&lt;\'纠错码是:\';cout&lt;&lt;map[hashmap[p]]&lt;&lt;endl;\n	    }\n	}\n 	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('04c3ef30e7df96dd7bb29a997c8f6b3a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  蒙特卡洛算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.何为蒙特卡洛算法\n  </h2>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:sans-serif; font-size:13.92px; line-height:19.488px\'>\n    蒙特卡罗方法于20世纪40年代美国在第二次世界大战中研制原子弹的“曼哈顿计划”计划的成员\n   </span>\n   <a class=\'new\' href=\'http://wiki.mbalib.com/w/index.php?title=S.M.%E4%B9%8C%E6%8B%89%E5%A7%86&amp;action=edit\' style=\'margin:0px; color:red; text-decoration:none; font-family:sans-serif; font-size:13.92px; line-height:19.488px\' target=\'_blank\' title=\'S.M.乌拉姆\'>\n    S.M.乌拉姆\n   </a>\n   <span style=\'color:rgb(51,51,51); font-family:sans-serif; font-size:13.92px; line-height:19.488px\'>\n    和\n   </span>\n   <a href=\'http://wiki.mbalib.com/wiki/J.%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC\' style=\'margin:0px; color:rgb(23,58,189); text-decoration:none; font-family:sans-serif; font-size:13.92px; line-height:19.488px\' target=\'_blank\' title=\'J.冯·诺伊曼\'>\n    J.冯·诺伊曼\n   </a>\n   <span style=\'color:rgb(51,51,51); font-family:sans-serif; font-size:13.92px; line-height:19.488px\'>\n    首先提出。数学家\n   </span>\n   <a href=\'http://wiki.mbalib.com/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC\' style=\'margin:0px; color:rgb(23,58,189); text-decoration:none; font-family:sans-serif; font-size:13.92px; line-height:19.488px\' target=\'_blank\' title=\'冯·诺伊曼\'>\n    冯·诺伊曼\n   </a>\n   <span style=\'color:rgb(51,51,51); font-family:sans-serif; font-size:13.92px; line-height:19.488px\'>\n    用驰名世界的赌城—摩纳哥的Monte\r\n Carlo—来命名这种方法，为它蒙上了一层神秘色彩。在这之前，蒙特卡罗方法就已经存在。1777年，法国Buffon提出用投针实验的方法求圆周率∏。这被认为是蒙特卡罗方法的起源。\n   </span>\n   <br/>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:sans-serif; font-size:13.92px; line-height:19.488px\'>\n    <br/>\n   </span>\n  </div>\n  <h2>\n   2.蒙特卡罗算法的思想\n  </h2>\n  <div>\n   根据概率论中的伯努利大数定理和中心极限定理我们可以知道当一个问题被重复了无限多次之后我们可以得到最接近正确结果的次优解\n  </div>\n  <div>\n   简单的说就使用时间发生的频率来替代事件发生的概率\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.算法思路\n  </h2>\n  <div>\n   根据问题描述的事件，我们在合理的数据范围内大量模拟随机事件，对所有的结果进行统计得到我们的需要的数据的范围\n  </div>\n  <div>\n   距离说明：\n  </div>\n  <div>\n   求解π：\n  </div>\n  <div>\n   对π的求解我们有两种思路\n  </div>\n  <div>\n   1.\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n    在一个边长为a的正方形内一均匀概率随机投点，该点落在此正方形的内切圆中的概率即为内切圆与正方形的面积比值，即：Pi * (a / 2)^2 : a^2 = Pi / 4\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n    <img alt=\'\' src=\'http://www.ruanyifeng.com/blogimg/asset/2015/bg2015072604.jpg\'/>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n    最后附上Python源程序\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1924184\' name=\'code\' snippet_file_name=\'blog_20161011_1_8424895\'>from random import *\nfrom math import *\nfrom time import * \ndef MC(number):   #定义运算数目，控制精度\n    m=0;\n    for i in range(number):\n        x=random()\n        y=random()\n        if(pow(x,2)+pow(y,2)&lt;=1): m=m+1\n    return float(m)/number*4\n\ndef main():\n    print(\'开始蒙特卡洛模拟π的大小\')\n    num=input(\'模拟次数\')\n    num=int(num)\n    print(\'Python数学库中的π的数值,保留小数点之后15位\')\n    print(\'%.15f\'%pi)\n    t0=clock()\n    print(\'%.15f\'%MC(num))\n    t1=clock()\n    print(\'程序处理时间%.2fs\'%(t1-t0))\n\nmain()\n</pre>\n   对于结果我进行一亿次重复试验得到圆周率的试验结果是\n   <br/>\n   3.14164816很接近了，但是我们测试的次数越多其实越不是很趋近于精确解，因为计算机产生的随机数列是伪随机数列，所以说，我们的圆周率的求解不是很正确的\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     2.布冯投针试验\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     以下摘自百度百科\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n    </span>\n   </span>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    18世纪，法国数学家\n    <a href=\'http://baike.baidu.com/view/60776.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     布丰\n    </a>\n    和勒可莱尔提出的“投针问题”，记载于布丰1777年出版的著作中：“在平面上画有一组间距为a的\n    <a href=\'http://baike.baidu.com/view/67614.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     平行线\n    </a>\n    ，将一根长度为l（l=a/2）的针任意掷在这个平面上，求此针与平行线中任一条相交的\n    <a href=\'http://baike.baidu.com/view/45320.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     概率\n    </a>\n    。”\n   </div>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    布丰本人证明了，这个概率是：\n   </div>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    <div class=\'layoutinline formula\' style=\'width:49px; display:inline\'>\n     <img align=\'absmiddle\' alt=\'\' height=\'37\' src=\'http://f.hiphotos.baidu.com/baike/s%3D49/sign=f67ef59a0e23dd542573a661d0090871/b64543a98226cffc237a364cbe014a90f703eaf8.jpg\' style=\'border:0px\' title=\'\' width=\'49\'/>\n    </div>\n    (其中π为\n    <a href=\'http://baike.baidu.com/view/3287.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     圆周率\n    </a>\n    ）\n   </div>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    由于它与π有关，于是人们想到利用投针试验来估计圆周率的值。\n   </div>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    布丰惊奇地发现：有利的扔出与不利的扔出两者次数的比，是一个包含π的表示式．如果针的长度等于a/2，那么有利扔出的\n    <a href=\'http://baike.baidu.com/view/45320.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     概率\n    </a>\n    为1/π．扔的次数越多，由此能求出越为精确的π的值。\n   </div>\n   <div class=\'anchor-list\' style=\'position:relative; color:rgb(51,51,51); font-family:arial,宋体,sans-serif; font-size:12px; line-height:16.3636px\'>\n    <a class=\'lemma-anchor para-title \' name=\'1_1\' style=\'color:rgb(19,110,194); position:absolute; top:-50px\' target=\'_blank\'>\n    </a>\n    <a class=\'lemma-anchor \' name=\'sub640668_1_1\' style=\'color:rgb(19,110,194); position:absolute; top:-50px\' target=\'_blank\'>\n    </a>\n    <a class=\'lemma-anchor \' name=\'实验数据\' style=\'color:rgb(19,110,194); position:absolute; top:-50px\' target=\'_blank\'>\n    </a>\n   </div>\n   <div class=\'para-title level-3\' style=\'clear:both; zoom:1; margin:20px 0px 12px; line-height:20px; font-size:18px; font-family:\'Microsoft YaHei\',SimHei,Verdana; color:rgb(51,51,51)\'>\n    <h3 class=\'title-text\' style=\'margin:0px; padding:0px; font-size:18px; font-weight:400\'>\n     实验数据\n    </h3>\n   </div>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    下面是利用这个公式，用概率的方法得到圆周率的近似值的一些资料。\n   </div>\n   <table class=\'table-view log-set-param \' style=\'border-spacing:0px; border-collapse:collapse; margin:5px 0px; word-wrap:break-word; word-break:break-all; font-size:12px; line-height:22px; color:rgb(0,0,0); font-family:arial,宋体,sans-serif\'>\n    <tbody>\n     <tr>\n      <th style=\'padding:2px 10px; height:23px; border:1px solid rgb(230,230,230); background-color:rgb(249,249,249)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        试验者\n       </div>\n      </th>\n      <th style=\'padding:2px 10px; height:23px; border:1px solid rgb(230,230,230); background-color:rgb(249,249,249)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        时间\n       </div>\n      </th>\n      <th style=\'padding:2px 10px; height:23px; border:1px solid rgb(230,230,230); background-color:rgb(249,249,249)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        投掷次数\n       </div>\n      </th>\n      <th style=\'padding:2px 10px; height:23px; border:1px solid rgb(230,230,230); background-color:rgb(249,249,249)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        相交次数\n       </div>\n      </th>\n      <th style=\'padding:2px 10px; height:23px; border:1px solid rgb(230,230,230); background-color:rgb(249,249,249)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        圆周率估计值\n       </div>\n      </th>\n     </tr>\n     <tr>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        Wolf\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1850年\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        5000\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        2532\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3.1596\n       </div>\n      </td>\n     </tr>\n     <tr>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        Smith\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1855年\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3204\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1218.5\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3.1554\n       </div>\n      </td>\n     </tr>\n     <tr>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        C.De Morgan\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       1860年\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        600\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        382.5\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3.137\n       </div>\n      </td>\n     </tr>\n     <tr>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        <a href=\'http://baike.baidu.com/view/46445.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n         Fox\n        </a>\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1884年\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1030\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        489\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3.1595\n       </div>\n      </td>\n     </tr>\n     <tr>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        Lazzerini\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1901年\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3408\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1808\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3.1415929\n       </div>\n      </td>\n     </tr>\n     <tr>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        Reina\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        1925年\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        2520\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        859\n       </div>\n      </td>\n      <td style=\'margin:0px; padding:2px 10px; height:22px; border:1px solid rgb(230,230,230)\'>\n       <div class=\'para\' style=\'font-size:12px; word-wrap:break-word; color:rgb(51,51,51); margin:0px; line-height:24px; zoom:1; height:auto\'>\n        3.1795\n       </div>\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    公元1901年，意大利数学家拉兹瑞尼作了3408次投针，给出π的值为3．1415929——准确到\n    <a href=\'http://baike.baidu.com/view/120346.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     小数\n    </a>\n    后6位．不过，不管拉兹瑞尼是否实际上投过针，他的实验还是受到了美国犹他州奥格登的国立韦伯大学的L·巴杰的质疑．通过几何、\n    <a href=\'http://baike.baidu.com/view/3139.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     微积分\n    </a>\n    、概率等广泛的范围和渠道发现π，这是着实令人惊讶的！\n   </div>\n   <div class=\'para\' style=\'font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,宋体,sans-serif\'>\n    <a href=\'http://baike.baidu.com/view/60776.htm\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n     布丰\n    </a>\n    投针实验是第一个用几何形式表达概率问题的例子，他首次使用随机实验处理确定性数学问题，为概率论的发展起到一定的推动作用。\n    <span style=\'font-size:10.9091px; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; white-space:nowrap; margin-left:2px; color:rgb(51,102,204); padding:0px 2px\'>\n     [1]\n    </span>\n    <a class=\'sup-anchor \' name=\'ref_[1]_640668\' style=\'color:rgb(19,110,194); position:relative; top:-50px; font-size:0px; line-height:0\' target=\'_blank\'>\n    </a>\n   </div>\n   <h2>\n    4.应用\n   </h2>\n  </div>\n  <div>\n   目前对于我们来说（青涩的学生）\n  </div>\n  <div>\n   我们可以根据蒙特卡罗算法\n  </div>\n  <div>\n   1.大量的随机试验求解函数的最值\n  </div>\n  <div>\n   2.大量的随机试验求解多重积分（类似求圆周率的方法一的思路）\n  </div>\n  <div>\n   相应源码我会及时的附到我的snippts上\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('5eee68084652e5ff7bbafe419560879b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  巧用循环不变式书写正确的二分查找算法(看不懂我撞墙)\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.二分查找介绍\n  </h2>\n  <div>\n   在进行开始之前，我们县要来正确的认识一下什么是二分查找算法\n  </div>\n  <div>\n   上过数值分析这门课的同学一定在迭代那一刻里面清楚的了解过一个名词叫做对分法\n  </div>\n  <div>\n   实际上，对分法的本质就是二分查找\n  </div>\n  <div>\n   下面我们来介绍一下二分查找算法\n  </div>\n  <div>\n   Binary-Search\n  </div>\n  <div>\n   是不同于顺序扫描的一种极其高效的查找算法\n  </div>\n  <div>\n   首先我们县要来了解一下二分查找算法相对于朴素的顺序查找算法的优劣\n  </div>\n  <div>\n   对于朴素的顺序查找算法（不局限于数据的逻辑存储方式，链式或者顺序都可以），我们从顺序表的头开始一直遍历到顺序表的尾知道找到我们需要查找的元素即可跳出，时间复杂度是O(n)，对于数据量一旦过于庞大的话，该算法会显得力不从心\n  </div>\n  <div>\n   二分查找算法（受限制与数据的逻辑存储方式，仅限制于顺序存储结构），前提是被查找的内存区域数据域必须是有序的，这是二分法开始的先决条件（对于交换式排序的O(n*logn)的时间复杂度可能大家会觉得还不如朴素的算法，但是实际中我们常常会遇到类似插入排序那样的情况，我们的二分查找开始就没必要进行排序，所以说仅从查找的角度来看的话，二分还是非常高效的）\n  </div>\n  <div>\n   每一次，我们以中点作为分界点，明确我们的待插元素的位置，舍弃另一半区域从而将我们的算法的查找区域大大缩小\n  </div>\n  <div>\n   计算其时间复杂度的话\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_1_3117054\'>T(n)=T(n/2)+O(C)\n...一共进行了k=logn次迭代\nT(n)=T(1)+O(C)*logn=O(logn)</pre>\n   因为是对数的原因，在数据两大的情况下，我们的比较次数依然会变的无限趋近于常数阶，所以说，二分查找是非常的高效的\n  </div>\n  <h2>\n   2.二分查找为什么难\n  </h2>\n  <div>\n   虽然我们看着二分查找非常的简单，但是实际上，二分查找的正确书写需要一个非常精细的数学和逻辑推导过程（我在下面会用几个例题来模拟一下思考的思路）\n  </div>\n  <div>\n   <p>\n    <span style=\'font-family:宋体\'>\n     《编程珠玑》第四章提到：\n    </span>\n    <span style=\'color:rgb(255,0,0)\'>\n     <span style=\'font-family:宋体\'>\n      提供充足的时间，仅有约\n     </span>\n     10%\n     <span style=\'font-family:宋体\'>\n      的专业程序员能够完成一个正确的二分查找。\n     </span>\n    </span>\n   </p>\n   <p>\n    为什么难在于这么几点：\n   </p>\n   <p>\n    1.终止条件不清晰\n   </p>\n   <p>\n    2.不正确的转换边界容易导致死循环\n   </p>\n   <p>\n    3.二分查找的变体相当庞杂，死记硬背绝对不可能\n   </p>\n   <p>\n    <br/>\n   </p>\n   <p>\n    既然二分查找这么难写，有没有好一点的方法可以帮助我们理解\n   </p>\n   <p>\n    下面我引入一种思路叫做循环不变式\n   </p>\n   <h2>\n    3.循环不变式\n   </h2>\n  </div>\n  <div>\n   什么是循环不变式，在《算法导论》和《编程之美》中大神都有队循环不变式进行了详细的讲解\n  </div>\n  <div>\n   个人在这里只是描述个人的见解，如有纰漏和误解，还烦请大神指出\n  </div>\n  <div>\n   循环不变式相当于是严谨的附加了终止条件的数学归纳法\n  </div>\n  <div>\n   学过数学归纳法的同学应该都知道，数学归纳法处理的问题往往都是没有上界的，但是作为一个算法，我们的第一根本原则就是有穷性\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   定义如下：\n  </div>\n  <div>\n   初始：循环第一次迭代开始之前，我们的描述和假设必须正确\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   维护（也有的叫保持）：在某次迭代是正确的，在下次迭代还是正确的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   终止：循环可以终止，并返回正确的结果\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   循环不变式其实不仅仅在本问题中可以大显身手，其实在 循环不变式 是一种思想，在以后的很多问题中，我们要证明算法的正确性等等都需要用到这个强有力的工具\n  </div>\n  <h2>\n   4.若干变体描述以及代码示例\n  </h2>\n  <div>\n   我们二分查找描述操作的区域设定为1-right的数组区域\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   循环不变式的初始是left-right\n  </div>\n  <h3>\n   1.二分查找值为key的下标不存在则返回-1\n  </h3>\n  <div>\n   初始：待查数组范围是left(1)-right(n)，待查元素key如果存在必定在该范围内\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   保持：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_2_2703133\'>if(data[mid]&gt;key) right=mid-1;   //1\nelse if(data[mid]&lt;key) left=mid-1;    //2\nelse if(data[mid]==key) return mid;    //3</pre>\n   解释：1.当data[mid]&gt;key说明mid-right中必定没有key，那么我们的超照范围就变成了left-(mid-1)，该判断语句是查找范围缩小了right-mid+1\n  </div>\n  <div>\n   2.同理，查找范围缩小了mid-left+1\n  </div>\n  <div>\n   3.超找到了位置，直接返回\n  </div>\n  <div>\n   在保持环节中，显然，我们每次都确保了key必定在我们的查找范围内，保持性证明完成\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    我们始终保证了待插元素落在left-right区域范围内\n   </span>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   终止：\n  </div>\n  <div>\n   本例题中，因为每次只要没有找到的话我们的待查区域是必定会至少减少1个长度的，所以说，我们的程序必定会正确的终止，不会出现死循环的情况\n  </div>\n  <div>\n   在最后，如果left&gt;right的话,我们返回-1就好\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   示例代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_3_3052580\'>int Binary_Search(int left,int right)\n{\n	int mid=left+(right-left)/2;\n	while(left&lt;=right)\n	{\n		if(data[mid]&lt;key) left=mid+1;\n		else if(data[mid]&gt;key) right=mid-1;\n		else return mid;\n	} \n	return -1;\n}</pre>\n   <h3>\n    2.二分查找key第一次出现的下标（可能有重复），不存在返回-1\n   </h3>\n   <div>\n    初始：\n    <span style=\'font-size:13.3333px\'>\n     待查数组范围是left(1)-right(n)，待查元素key如果存在必定在该范围内\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <br/>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     保持：\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n    </span>\n    <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_4_8701162\'>if(data[mid]&gt;key) right=mid-1;   //1\nelse if(data[mid]&lt;key) left=mid+1;   //2\nelse right=mid;   //3</pre>\n    解释：\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     1.data[mid]&gt;key,说明必然第一次出现的下标在left-（mid-1）范围内，该轮判断查找区域缩小了right-mid+1\n    </span>\n   </div>\n   <div>\n    2.同理，盖伦判断的查找区域缩小了mid-left+1\n   </div>\n   <div>\n    3.当相同的时候，我们会发现我们要找第一次出现的下表，显然第一次出现的下表必然在left-mid之间，该轮判断查找区域缩小了right-mid\n   </div>\n   <div>\n    其实1,3是可以合并的，合并起来我们可以减小我们的代码量和分支语句，提高判断效率，并且合并之后是不会出现错误的，毕竟按照1来说合并之后right=mid,我们的待插元素key还在left-mid范围内，只不过是收缩的精确度的问题，这个不影响结果\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     我们始终保证了待插元素落在left-right区域范围内\n    </span>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    终止：\n   </div>\n   <div>\n    在该例题中，我们会发现，第1,3,的分支检查的区域缩小的范围是right-mid，也就是说，我们有可能会存在一次判断之后，待查区域大小没有变化的情况，即当left=right的时候，我们的待查区域缩小量始终是right-mid=right-right=0\n   </div>\n   <div>\n    这种情况下，会造成死循环，满足不了我们的循环不变式种植的要求，这时候，我们就要对循环的控制进入的条件进行巧妙地修改了\n   </div>\n   <div>\n    <span style=\'font-size:12px\'>\n     先来看：\n    </span>\n   </div>\n   <div>\n    left=right-1:mid始终等于left，会1,3情况缩小范围，可以正确运行\n   </div>\n   <div>\n    left=right:mid始终等于left和right，1,3情况缩小范围是0，回不正确终止\n   </div>\n   <div>\n    这时候，我们只要让终止条件是left&lt;right就可以了\n   </div>\n   <div>\n    之后，我们对data[left]进行判断，等于key，返回left，否则返回-1\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    示例代码：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_5_7065742\'>int Binary_Search(int left,int right)\n{\n	int mid=left+(right-left)/2;\n	while(left&lt;right)\n	{\n		if(data[mid]&lt;key) left=mid+1;\n		else right=mid;\n	} \n	if(data[left]==key) return left;\n	else return -1;\n}</pre>\n    <h3>\n     3.二分查找key（有可能重复）的最后一次出现的下表，没有返回-1\n    </h3>\n   </div>\n   1.初始：\n   <span style=\'font-size:13.3333px\'>\n    待查数组范围是left(1)-right(n)，待查元素key如果存在必定在该范围内\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    2.保持：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_6_9890424\'>if(data[mid]&gt;key) right=mid-1;   //1\nelse if(data[mid]&lt;key) left=mid+1;   //2\nelse left=mid;   //3</pre>\n   解释：\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    1.显然，我们的待查范围缩小了right-mid+1\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    2.同理，我们的待查范围缩小了mid-left+1\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    3.相同的时候，我们发现我们要查找最后一个元素，那么显然最后一个key的下表必然在mid-right之间，该轮缩小待查区域为mid-right\n   </span>\n  </div>\n  <div>\n   同上2,3可以合并，减少代码量\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    我们始终保证了待插元素落在left-right区域范围内\n   </span>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.终止\n  </div>\n  <div>\n   我们发现left=right-1，或者left=right的时候，我们的mid始终等于left，那么对于判断3,很容易出现死循环\n  </div>\n  <div>\n   我们对终止条件进行修正left&lt;right-1\n  </div>\n  <div>\n   最后我们对left，right进行判断就好了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   代码示例：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_7_1111924\'>int Binary_Search(int left,int right)\n{\n	int mid=left+(right-left)/2;\n	while(left&lt;right-1)\n	{\n		if(data[mid]&gt;key) right=mid-1;\n		else left=mid;\n	} \n	if(data[right]==key) return right;\n	else if(data[left]==key) return left;\n	else return -1;\n}</pre>\n   <br/>\n   <h3>\n    4.二分查找刚好小于key的元素的下表，不存在返回-1\n   </h3>\n  </div>\n  <div>\n   1.初始：\n   <span style=\'font-size:13.3333px\'>\n    待查数组范围是left(1)-right(n)，待查元素key如果存在必定在该范围内\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    2.保持：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_8_5681493\'>if(data[mid]&lt;key) left=mid;    //1\nelse if(data[mid]&gt;=key) right=mid-1;    //2</pre>\n   对于1来说，显然小于的话，我们的待插元素必定在mid-right中间，那么缩小的区域大小就是mid-left\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    对于2，显然缩小范围是right-mid+1\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    我们始终保证了待插元素落在left-right区域范围内\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    3.终止：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    对于情况一来说，如果left=right-1/left=right的话，显然会出现死循环的情况，所以说我们就需要修改终止情况left&lt;right-1\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    最后判断一下就好了\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    代码示例：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_9_6902992\'>int Binary_Search(int left,int right)\n{\n	int mid=left+(right-left)/2;\n	while(left&lt;right-1)\n	{\n		if(data[mid]&gt;=key) right=mid-1;\n		else left=mid;\n	} \n	if(data[right]&lt;key) return right;\n	else if(data[left]&lt;key) return left;\n	else return -1;\n}</pre>\n   <br/>\n   <h3>\n    <span style=\'font-size:13.3333px\'>\n     5.二分查找干好大于key的元素的下表不存在返回-1\n    </span>\n   </h3>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     1.初始：\n     <span style=\'font-size:13.3333px\'>\n      待查数组范围是left(1)-right(n)，待查元素key如果存在必定在该范围内\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      2.维护：\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n     </span>\n    </span>\n    <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_10_6172643\'>if(data[mid]&gt;key) right=mid;\nelse left=mid+1;</pre>\n    <div>\n     <span style=\'font-size:13.3333px\'>\n      <span style=\'font-size:13.3333px\'>\n       <br/>\n      </span>\n     </span>\n    </div>\n    3.终止：\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      对于情况left=right来说，容易出现死循环的情况，我们left&lt;right就可以了\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      最后判断\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      代码示例：\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n     </span>\n    </span>\n    <pre class=\'cpp\' code_snippet_id=\'1920720\' name=\'code\' snippet_file_name=\'blog_20161010_11_218043\'>int Binary_Search(int left,int right)\n{\n	int mid=left+(right-left)/2;\n	while(left&lt;right)\n	{\n		if(data[mid]&gt;key) right=mid;\n		else left=mid+1;\n	} \n	if(data[left]&lt;key) return left;\n	else return -1;\n}</pre>\n    <h2>\n     5.总结：\n    </h2>\n    <div>\n     思路，利用循环不变式不断的缩小我们的待查区域\n    </div>\n    <div>\n     最后我们需要对left=right和left=right-1等特殊情况进行考虑，避免因为缩小的区域大小可能为0导致的死循环的情况出现，修改终止条件\n    </div>\n    <div>\n     最后额外判断就好了\n    </div>\n    <span style=\'font-size:13.3333px\'>\n     <span style=\'font-size:13.3333px\'>\n      <br/>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b8cbdec366ed2d6f1183146a007f4f16','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Segment Tree 线段树总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.何为线段树\n  </h2>\n  <div>\n   准确的来说，线段树是一种平衡二叉树，当我们的要换分的区间大小是2的幂的话，刚好我们的线段树就是一颗满二叉树，但是如果不是的话，我们最多只能叫他是平衡二叉树\n  </div>\n  <div>\n   正因为是一颗平衡二叉树，所以说，线段树的划分是均匀的，树高也稳定在logn上(这也就是我们的优化的源泉)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   上面只是个人的一点小理解，下面我们步入正题\n  </div>\n  <div>\n   线段树Segment Tree，是BST二叉搜索树而一种应用，是一种应用广泛的高级数据结构\n  </div>\n  <div>\n   主要用来查找区间的覆盖问题等\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   定义：\n  </div>\n  <div>\n   线段树并不是如字面意思上来的说，我们每一个树中结点都保留一串数据，那样的话我们的空间复杂度就会变得难以想象了，在这里我们数据只有一份，但是我们的线段树中的节点保存的是\n   <strong>\n    <em>\n     区间的范围\n    </em>\n   </strong>\n  </div>\n  <div>\n   另外我们还会保存一些其他的数据域，这些都是看具体的题目的要求了\n  </div>\n  <h2>\n   2.操作\n  </h2>\n  <div>\n   作为一种数据结构，我们对线段树有以下几个基本操作的描述\n  </div>\n  <div>\n   1.建树\n  </div>\n  <div>\n   2.插入\n  </div>\n  <div>\n   3.修改\n  </div>\n  <div>\n   4.查询\n  </div>\n  <div>\n   5.先上维护数据域\n  </div>\n  <div>\n   6.向下继承lazy-tag（这个我们之后会讲解）\n  </div>\n  <h2>\n   3.数据结构的选择\n  </h2>\n  <div>\n   1.链式\n  </div>\n  <div>\n   我们一开始首先可以联想到线段树的链式存储方式，链式存储的优势在于我们可以动态分配内存，从而我们能够最大限度的利用的我们的空间，不会出现我们无法确定线段户的内存的大小的问题（之后会讲解为什么至少需要4倍内存空间）\n  </div>\n  <div>\n   但是对于链式存储来说，我们还需要额外开辟内存来保存指针变量，但是在数量很大并且捉摸不透的时候，采用链式存储是一个明智的选择\n  </div>\n  <div>\n   2.数组\n  </div>\n  <div>\n   在这里，我们的数组的存储方式是有些类似于二叉堆的存储的方式结构的\n  </div>\n  <div>\n   因为线段树和堆一样是一颗平衡二叉树，所以说对于节点的标号为n的话，n*2必定代表的是左儿子，n*2+1必定代表的是右儿子\n  </div>\n  <div>\n   这样的话，相对于链式存储我们可以节约出来两个指针域的内存空间，但是这样的话，我们就需要开辟至少4倍的内存空间的大小\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在本文中，为了方便叙述，我们采用的是数组的形式\n  </div>\n  <h2>\n   4.操作解析及复杂度：\n  </h2>\n  <div>\n   数据\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1916029\' name=\'code\' snippet_file_name=\'blog_20161007_1_7970577\'>typedef struct node\n{\n	int left;   //区间左端 \n	int right;   //区间右端 \n	int val;   //区间数据域，按照题目要求可以修改\n	int lazy;   //延迟标记 ，基本上是我们的对区间更新的数据，一般都会乘上我们的区间的长度饭换成我们的区间的数据域，我们一会可以解释 \n}point;</pre>\n  </div>\n  <h3>\n   PS:小心为预算的优先级小于+，-\n  </h3>\n  <div>\n   <br/>\n  </div>\n  <div>\n   空间复杂度是O(4*n)：\n  </div>\n  <div>\n   首先我们需要认识到\n   <br/>\n   线段树作为一种平衡二叉树，当我们的最终的区间长度是n的时候，我们的线段树最少需要2*n-1的节点内存\n   <br/>\n   但是，因为上述情况只有在我们的n是2的幂的时候才成立，但是当n不是2的幂的时候，我们因为在存储的时候，不是满二叉树\n   <br/>\n   所以说实际上会存在内存的浪费，极限的情况下会需要远远比2*n-1大的内存\n   <br/>\n   这时候，我们进行粗略的估计操作，我们找到比n大的最小的2的幂k，大致需要2*k-1的内存大小\n   <br/>\n   但是在最糟糕的情况下，k的值可能几乎就是n的2倍\n   <br/>\n   所以说，大致上我们开辟4*n的内存就完全够我们 的线段树的存储需要了\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   1.建树\n  </h3>\n  <div>\n   建树操作，相当于我们前序遍历二叉树\n  </div>\n  <div>\n   我们对当前的节点进行初始化，然后依次的向下递归至我们的叶子节点\n  </div>\n  <div>\n   递归的终止是在于我们递归到的节点的区间为1，代表我们递归到了叶子节点，直接返回初始化并且更新就可以返回了\n  </div>\n  <div>\n   大致代码如下：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1916029\' name=\'code\' snippet_file_name=\'blog_20161007_2_9018136\'>//建树操作    O(n)\nvoid build(int left,int right,int pox)    //pox代表的是线段树种的节点存储的物理顺序地址 ,初始的时候是1 \n{\n	tree[pox].left=left;\n	tree[pox].right=right;\n	tree[pox].lazy=0;\n	tree[pox].val=0;   //数据域初始化，这一句可以根据题目要求随时来改变\n	if(left==right)   //找到最底层叶子结点，我们更新fa访问数组强制返回 \n	{\n		fa[left]=pox;\n		return ;\n	} \n	//递归操作，位运算加速 \n	build(left,(left+right)/2,pox&lt;&lt;1);   \n	build((left+right)/2+1,right,(pox&lt;&lt;1)+1); \n} \n</pre>\n   时间复杂度是O(n),因为我们需要建立所有的叶子节点，故是O(n)的时间复杂度\n  </div>\n  <div>\n   <h3>\n    2.查询\n   </h3>\n   <div>\n    在这里，我们需要引入一个叫做完全覆盖的概念，这也是我们线段树优化的核心所在\n   </div>\n   <div>\n    如果我们将树中结点的信息都完全的保留在当前的树中结点的话，我们就完全没必要一直访问到叶子节点，我们找到完全福该节点的话，就可以直接的获取我们的需要的值然后退出就好了\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1916029\' name=\'code\' snippet_file_name=\'blog_20161007_3_5779533\'>//查询区间的数据域   O(logn)\nint find(int left,int right,int pox)\n{\n	int sum=0;\n	if(tree[pox].left==left&amp;&amp;tree[pox].right==right) return tree[pox].val;   //找到了完全覆盖区间，直接返回,该句本身也是一个递归中值判断语句 \n	pox&lt;&lt;=1;\n	if(tree[pox].right&gt;=left) \n	{\n		if(right&lt;=tree[pox].right) sum+=find(left,right,pox);\n		else sum+=find(left,tree[pox].right,pox);\n	}\n	pox+=1;\n	if(tree[pox].left&lt;=right)\n	{\n		if(left&gt;=tree[pox].left) sum+=find(left,right,pox);\n		else sum+=find(tree[pox].left,right,pox); \n	} \n	return sum;\n}</pre>\n    因为查询的深度就是我们的线段树的额深度，所以说我们的时间复杂度就是 O(logn)\n   </div>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   3.lazy-tag\n  </h3>\n  <div>\n   之后的lazy-tag等问题就要牵扯到区间更新了\n  </div>\n  <div>\n   如果是区间更新的话，我们的朴素做法无非就是将区间整个的遍历一遍然后统一进行修改操作，时间复杂度是O(n)\n   <br/>\n   但是对于线段树来说，如果我们每次都是一直递归到所有的叶子结点的话，我们也会发现，我们需要将所有的叶子结点\n   <br/>\n   都要修改覆盖，时间复杂度也是O(n)，这样我们就并没有实现复杂度上的优化，在这里我们就要引入lazy变量\n   <br/>\n   可以就其本质上来说的话，父节点的区间是完全的包含我们的子节点的区间的，所以说，我们就只用父节点区间来代表子节点区间就好了\n   <br/>\n   在这里，我们的引入的lazy变量就是这样的，我们将更新操作进行到完全覆盖的树中的节点的时候我们就退出，不对之后的叶子结点进行操作\n   <br/>\n   但是我会对该节点是加一个lazy标记，代表我们的更新只进行到这里，该节点之后的子节点并没有执行更新操作\n   <br/>\n   只有我们再次进行访问该节点额子节点的区间的时候，我们才会往下继续执行我们的更新操作，这样的话，通过完全覆盖的父区间，我们可以减少操作\n   <br/>\n   的复杂度，降低到 O(logn)，也就是最多我们也就执行到树的深度为止\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   所以说，我们的lazy-tag是非常有必要的\n  </div>\n  <div>\n   为了直白额表示我们上述的过程，附上一段代码\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1916029\' name=\'code\' snippet_file_name=\'blog_20161007_4_7001032\'>void pushdown_lazy(int pox)    //传递lazy标记，并更新子区间的val，注意我们的pox节点已经将val域更新了 \n{\n	if(tree[pox].lazy)   //该节点的lazy变量存在 \n	{\n		tree[pox&lt;&lt;1].lazy+=tree[pox].lazy;\n		tree[pox&lt;&lt;1].val=tree[pox&lt;&lt;1].lazy*(tree[pox&lt;&lt;1].right-tree[pox&lt;&lt;1].left+1);   //根据我们lazy的值修改我们的数据域，lazy的值代表我们扽区间修改的基\n		tree[(pox&lt;&lt;1)+1].lazy+=tree[pox].lazy;\n		tree[(pox&lt;&lt;1)+1].val=tree[(pox&lt;&lt;1)+1].lazy*(tree[(pox&lt;&lt;1)+1].right-tree[(pox&lt;&lt;1)+1].left+1);\n		tree[pox].lazy=0;   //lazy标记清除 \n	}\n} \n\nvoid pushup_val(int pox)   //数据域的向上更新函数，一会在update_segment函数我再解释该函数以及上一个函数的额具体作用 \n{\n	tree[pox].val=tree[pox&lt;&lt;1].val+tree[(pox&lt;&lt;1)+1].val;   //将左右区间的值合并生成该父区间的值 \n} \n\nvoid update_segment(int left,int right,int pox,int k)   //k代表区间更新的值，left和right代表的是当前需要更新的区间的范围，pox代表当前的树中节点的物理下标 \n{\n	if(tree[pox].left==left&amp;&amp;tree[pox].right==right)    //完全覆盖的时候，我们就直接退出，这就是上面的叙述中的优化的本质，对lazy标记的应用 \n	{\n		tree[pox].lazy+=k;   //lazy打标成功\n		tree[pox].val=tree[pox].lazy*(tree[pox].right-tree[pox].left+1);   //更新该节点的数据域 \n		return ; \n	}  \n	if(tree[pox].left==tree[pox].right) return ;    //更新到了叶子结点，进行递归终止\n	//以下代码的运行的原因是还没有找到完全覆盖的树中节点，所以继续向下更新树 \n	pushdown_lazy(pox);   //没有找到完全覆盖的节点，向下查找完全覆盖的节点，并将我们的lazy标记传递下去，但是这里我们需要注意，pox节点的val域没有更新维护，还是空的\n    if(right&lt;=tree[pox&lt;&lt;1].right) update_segment(left,right,pox&lt;&lt;1,k);\n	else if(left&gt;=tree[(pox&lt;&lt;1)+1].left) update_segment(left,right,(pox&lt;&lt;1)+1,k);\n	else\n	{\n		update_segment(left,tree[pox&lt;&lt;1].right,pox&lt;&lt;1,k);\n		update_segment(tree[(pox&lt;&lt;1)+1].left,right,(pox&lt;&lt;1)+1,k);\n	} \n	pushup_val(pox);   //上面已经说了，pox节点并没有更新维护，所以说，我们在回溯的时候必须要将我们的数据域更新，一直返还到我们的你根结点处，但是我们只要更新了，就必须要回溯的时候，对数据域必须要进行同步的更新\n    //当然该函数也可以封装在pushdown函数里面，这都无所谓了 \n} \n </pre>\n   上面一段的代码的作用是将一段子区间同时加上一个数的操作，主要的解释都已经注释了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('3d8be14bf788253396c52edaa6a87d0b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU1754 - 线段树 Water~\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   本题是标准的线段树求区间最大值的版题\n  </div>\n  <div>\n   题目描述如下：\n  </div>\n  <div>\n   1.输入直到文件末尾截止\n  </div>\n  <div>\n   2.n,m其中n代表元素的的个数，m代表m次操作\n  </div>\n  <div>\n   3.一行输入n个数字表示所有的数组元素\n  </div>\n  <div>\n   4.接下来m行输入，Q操作代表询问，U操作代表替换\n  </div>\n  <div>\n   5.针对每次的Q操作输出区间最大值\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   线段树求解区间最大值\n  </div>\n  <div>\n   给树上节点附上权值max标记该节点覆盖的区间内的最大值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   ps：本题千万小心，max函数式进行宏展开的，所以说千万不要在max函数里面嵌套递归函数，否则，我们的函数就会被展开成四个\n  </div>\n  <div>\n   类似于 a&gt;b?a:b\n  </div>\n  <div>\n   展开四次，肯定就慢下来了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   主要的思路就是，每次我们的替换操作的时候，从底向上进行更新（在本题中，我引入了和堆中一样的快速访问函数，加快一般的递归时间，算是一种时间上的优化吧，毕竟是消耗了O(n)的空间复杂度了）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   神修改的内容在代码中有详细解释\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1915913\' name=\'code\' snippet_file_name=\'blog_20161007_1_2389937\'>/*\nHDU 1754  \n826ms    12536K    1924B\nBy BIT/CS LT\n*/ \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'math.h\'\n#define N 200005\n\nusing namespace std;\n\ntypedef struct node\n{\n	int max;\n	int left;\n	int right;\n}point;\n\nint fa[N];   //快速访问数组 \npoint tree[N*4];   //开辟四倍的线段树的含义在我的博客中有详细的描述 \nint data[N];   //记录数据域 \nint n,m;\nchar atom;\nint leftp;\nint rightp;\n\nint max(int x,int y)\n{\n	return x&gt;y?x:y;\n}\n\nvoid build(int left,int right,int pox)   //建立线段树 \n{\n	tree[pox].left=left;\n	tree[pox].right=right;\n	tree[pox].max=0;\n	if(left==right)    //递归至叶子节点，完成初始化之后递归终止 \n	{\n		tree[pox].max=data[left];\n		fa[left]=pox;\n		return ;\n	}\n	build(left,(left+right)/2,pox&lt;&lt;1);\n	build((left+right)/2+1,right,(pox&lt;&lt;1)+1);\n	tree[pox].max=max(tree[pox&lt;&lt;1].max,tree[(pox&lt;&lt;1)+1].max);    //建立的过程中回溯构建max域 \n}\n\nvoid change(int pox)   //自底向上更新 \n{\n	tree[pox].max=max(tree[pox&lt;&lt;1].max,tree[(pox&lt;&lt;1)+1].max);   //更新操作 \n	if(pox==1) return ;   //终止 \n	pox&gt;&gt;=1;\n	change(pox);\n}\n\nint find(int left,int right,int pox)\n{\n	int sum=-1;   //初始化sum \n	if(tree[pox].left==tree[pox].right) return tree[pox].max;    //访问到叶子节点，直接返回max \n	if(left==tree[pox].left&amp;&amp;right==tree[pox].right) return tree[pox].max;    //访问到完全覆盖的节点，直接返回 \n	else   //下面的小心，一定不要写在max函数里面，会拖慢速度 \n	{\n		 if(right&lt;=tree[pox&lt;&lt;1].right) \n		 {\n		 	int a=find(left,right,pox&lt;&lt;1);\n		 	sum=sum&gt;a?sum:a;\n		 }\n		 else if(left&gt;=tree[(pox&lt;&lt;1)+1].left) \n		 {\n		 	 int a=find(left,right,(pox&lt;&lt;1)+1);\n		 	 sum=sum&gt;a?sum:a;\n		 }\n		 else \n		 {\n		 	int a=find(left,tree[pox&lt;&lt;1].right,pox&lt;&lt;1);\n			int b=find(tree[(pox&lt;&lt;1)+1].left,right,(pox&lt;&lt;1)+1);\n			sum=max(a,b);\n		 }\n	}\n	return sum;\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)!=EOF)\n	{\n		memset(data,0,sizeof(data));\n		memset(tree,0,sizeof(tree));\n		memset(fa,0,sizeof(fa));\n		for(int i=1;i&lt;=n;i++) scanf(\'%d\',&amp;data[i]);\n		build(1,n,1);\n		while(m--)\n		{\n			getchar();\n			scanf(\'%c%d%d\',&amp;atom,&amp;leftp,&amp;rightp);\n			if(atom==\'Q\') printf(\'%d\n\',find(leftp,rightp,1));\n     		else if(atom==\'U\') \n	     	{\n	     		data[leftp]=rightp;\n		    	tree[fa[leftp]].max=rightp;\n		    	change(fa[leftp]&gt;&gt;1);\n	    	}\n		}\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('47308dafde2fa3209ecfeb951489ba40','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU1556 - 线段树基础\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   给出一个序列，我们每次都可以给一段子序列进行一次操作\n  </div>\n  <div>\n   序列的数据量是n(n&lt;=1e5),我们每次进行n次操作在这个序列上，最后输出每个序列中的元素被操作的次数\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   首先，为了更好的理解我们的线段树的优化措施\n  </div>\n  <div>\n   我们先来考虑一下我们的朴素的做法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于这道题，我们的做法无非就是开辟一个一维数组，每次对那个区间进行操作，我们就对区间范围呢你的所有的数据都统一进行累加操作\n  </div>\n  <div>\n   最后，我们将以为数组的值全部输出就好了\n  </div>\n  <div>\n   该算法的时间复杂度是 O(n^2)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   现在我们再来考虑线段树的做法，线段树的做法，在本体中应用了lazy标记的优化措施\n  </div>\n  <div>\n   我们的一旦发现了完全覆盖的区间就直接强行的退出这样我们就应用父区间完全代表子区间的方式成功的将算法单次操作的复杂度优化到O(logn)\n  </div>\n  <div>\n   总共有n此操作，所以说，insert操作的时间复杂度是就是O(n*logn)\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    之后我们还需要对结果继续累计\n   </span>\n  </div>\n  <div>\n   因为我们应用了lazy的思路，所以我们从根节点开始从上往下进行扫描，只要扫描到区间的计数器不是0，说明该区间范围内的所有节点曾经被至少共同操作过一次，我们累加\n  </div>\n  <div>\n   一层的该操作的时间复杂度是O(n)\n  </div>\n  <div>\n   总共有logn层，所以该操作的时间复杂度也是O(n*logn)\n  </div>\n  <div>\n   最后，线段树的操作的时间复杂度就是O(n*logn)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们最后直观的来看一下，假如说计算机1s计算量为10^9\n  </div>\n  <div>\n   最坏的情况下，所有的操作都是对全部的区间进行的，\n  </div>\n  <div>\n   算法1的时间复杂度就是 1e5^2=10^10 &gt; 10^9  超时显而易见\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    算法2的时间复杂度就是 1e5*lg1e5*2*c ~1e6  在大数据量的操作下，线段树的优势显而易见\n   </span>\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1915652\' name=\'code\' snippet_file_name=\'blog_20161007_1_5266198\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100005\n\nusing namespace std;\n\ntypedef struct node\n{\n	int left;\n	int right;\n	int n;\n}point;\n\nint ans[N];\npoint tree[N*4];\nint n;\n\nvoid build(int left,int right,int i)\n{\n	tree[i].left=left;\n	tree[i].right=right;\n	tree[i].n=0;\n	if(left==right) return ;\n	build(left,(left+right)&gt;&gt;1,i*2);\n	build(((left+right)&gt;&gt;1)+1,right,i*2+1);\n} \n\nvoid insert(int left,int right,int i)\n{\n	if(tree[i].left==left&amp;&amp;tree[i].right==right)\n	{\n		tree[i].n++;\n		return ;\n	}\n	else\n	{\n		if(right&lt;=tree[i*2].right) insert(left,right,i*2);\n		else if(left&gt;=tree[i*2+1].left) insert(left,right,i*2+1);\n		else\n		{\n			insert(left,tree[i*2].right,i*2);\n			insert(tree[i*2+1].left,right,i*2+1); \n		} \n	}\n}\n\nvoid add(int i)\n{\n	if(tree[i].n) for(int j=tree[i].left;j&lt;=tree[i].right;j++) ans[j]+=tree[i].n;\n	if(tree[i].left==tree[i].right) return ;\n	add(i*2);\n	add(i*2+1);\n}\n\nint main()\n{\n	int x,y;\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n!=0)\n	{\n		memset(ans,0,sizeof(ans));\n		build(1,n,1);\n		for(int i=1;i&lt;=n;i++)\n		{\n			scanf(\'%d%d\',&amp;x,&amp;y);\n    		insert(x,y,1);\n		}\n		add(1);\n		for(int i=1;i&lt;n;i++) printf(\'%d \',ans[i]);\n		printf(\'%d\n\',ans[n]);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('570ad6d8683bd0db5476502faca23c6a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU 1711 KMP Water~\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   没什么可说的，数字版本的KMP\n  </div>\n  <h2>\n   2.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1911455\' name=\'code\' snippet_file_name=\'blog_20161003_1_7374351\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 10005\n\nusing namespace std;\n\nint data[N*100];\nint pattern[N];\nint nextp[N];\nint n,m;\n\nvoid getnext()\n{\n	int k=-1;\n	int j=0;\n	nextp[0]=-1;\n	while(j&lt;m)\n	{\n		if(k==-1||pattern[j]==pattern[k])\n		{\n			k++;\n			j++;\n			nextp[j]=k;\n		}\n		else k=nextp[k];\n	}\n}\n\nint count()\n{\n	int i=0;\n	int j=0;\n	while(i&lt;n&amp;&amp;j&lt;m)\n	{\n		if(j==-1||data[i]==pattern[j]) i++,j++;\n		else j=nextp[j];\n	}\n	if(j==m) return i-j+1;\n	else return -1;\n}\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		scanf(\'%d%d\',&amp;n,&amp;m);\n		for(int i=0;i&lt;n;i++) scanf(\'%d\',&amp;data[i]);\n		for(int i=0;i&lt;m;i++) scanf(\'%d\',&amp;pattern[i]);\n		getnext();\n		cout&lt;&lt;count()&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('eaceef9143e36f2061ce6b97f59878d6','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU-1686 KMP\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.Question:\n  </h2>\n  <div>\n   t个测试用例\n  </div>\n  <div>\n   先输入模板串\n  </div>\n  <div>\n   后输入母串\n  </div>\n  <div>\n   求母串中有多少个子串\n  </div>\n  <h2>\n   2.Solution:\n  </h2>\n  <div>\n   标准的KMP算法模板\n  </div>\n  <div>\n   我们只需要进行小一点的改动就可以了\n  </div>\n  <div>\n   首先，我们现在来复习一下next数组的作用\n  </div>\n  <div>\n   next数组作为一个跳转表，在我们适配的时候，next数组直接可以将模式串的位置重新定位\n  </div>\n  <div>\n   但是在本题中有一点小小的改动在于\n  </div>\n  <div>\n   eg：\n  </div>\n  <div>\n   aza\n  </div>\n  <div>\n   azazazazaza\n  </div>\n  <div>\n   这样的用例中，很显然，我们的模式串要小心在一次匹配成功之后，不能直接让i调到匹配成功的下一个位置去，那样会造成遗漏\n  </div>\n  <div>\n   我们也不能一次匹配成功之后，就果断的让i重新回溯之前的状态的下一个去避免遗漏，因为这样的话，我们KMP所避免的回溯问题就又出来了\n  </div>\n  <div>\n   那我们该怎么解决这个问题呢？\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们可以这么来考虑：\n  </div>\n  <div>\n   当 j=patternlength 的时候，显然，我们已经按成了一次匹配\n  </div>\n  <div>\n   我们先计数\n  </div>\n  <div>\n   然后，我们令 j=next[j]\n  </div>\n  <div>\n   这样做的目的是，我们假设最后一个字母没有匹配成功，然后重新进行匹配操作\n  </div>\n  <h2>\n   3.Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1911428\' name=\'code\' snippet_file_name=\'blog_20161003_1_1886462\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 10005\n\nusing namespace std;\n\nchar data[N*100];\nchar pattern[N];\nint nextp[N];\n\nvoid getnext()\n{\n	int k=-1;\n	int j=0;\n	nextp[0]=-1;\n	int len=strlen(pattern);\n	while(j&lt;len)\n	{\n		if(k==-1||pattern[j]==pattern[k])\n		{\n			k++;\n			j++;\n			if(pattern[j]!=pattern[k]) nextp[j]=k;\n			else nextp[j]=nextp[k];\n		}\n		else k=nextp[k];\n	}\n}\n\nint count()\n{\n	int sum=0;\n	int i=0;\n	int j=0;\n	int dl=strlen(data);\n	int pl=strlen(pattern);\n	while(i&lt;dl)\n	{\n		if(j==-1||data[i]==pattern[j]) i++,j++;\n		else j=nextp[j];\n		if(j==pl)\n		{\n			sum++;\n			j=nextp[j];\n		}\n	}\n	return sum;\n}\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);getchar();\n	while(t--)\n	{\n		memset(nextp,0,sizeof(nextp));\n		memset(data,0,sizeof(data));\n		memset(pattern,0,sizeof(pattern));\n		gets(pattern);\n		gets(data);\n		getnext();\n		cout&lt;&lt;count()&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4df03da5d71ef098daedb9758aa4ce6e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  字典树 Trie\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.什么是字典树\n  </h2>\n  <div>\n   字典树，又称单词查找树或者键树，或者前缀树，是哈希树的一种变种，典型的应用就是保存大量的字符串的信息，统计和排序大规模字符串，因为采用了前缀的概念，压缩存储了部分的字符串，所以说，查询和查找效率都非常的高，接近于哈希\n  </div>\n  <div>\n   主要思想就是，利用了空间换时间的思路，将多个字符串的最大公共前缀压缩存储\n  </div>\n  <div>\n   示例图：\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.my.csdn.net/uploads/201210/31/1351652182_4860.png\'/>\n   <br/>\n  </div>\n  <h2>\n   2.字典树的ADT\n  </h2>\n  <div>\n   描述如下：\n  </div>\n  <div>\n   1.根节点不含有键值\n  </div>\n  <div>\n   2.每个节点之下有多个指针指向下一个待查键位\n  </div>\n  <div>\n   3.每个节点的子节点各不相同\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   主要的核心数据域\n  </div>\n  <div>\n   1.键值（该节点的键值保存）\n  </div>\n  <div>\n   2.子指针（如果是孩子兄弟树存储方式还有兄弟指针，子指针还可以作为叶子节点和树节点的区分标志）-如果采用孩子兄弟表示法，我们又称其为双链树\n  </div>\n  <div>\n   3.标记域（记录该单词是否出现过，因为我们采取了压缩存储公共前缀的方式，所以说，我们有必要对标记域进行声明）\n  </div>\n  <div>\n   4.kind标记域，标记该节点是叶子节点还是树节点\n  </div>\n  <div>\n   5.其他（根据题目的具体要求，我们还可以加设其他的结构，方便问题的解决）\n  </div>\n  <h2>\n   <br/>\n  </h2>\n  <div>\n   操作：\n  </div>\n  <div>\n   1.插入单词\n  </div>\n  <div>\n   2.查询单词\n  </div>\n  <div>\n   3.建树\n  </div>\n  <div>\n   4.销毁树\n  </div>\n  <div>\n   5.DFS（深度优先遍历）-如果本树建立之时就已经采用了语序的状态，那么我们深度优先的前序遍历该子树就会得到字典序排列\n  </div>\n  <h2>\n   3.复杂度以及比较\n  </h2>\n  <div>\n   假设双链树的查找基（关键字的基就是我们关键字的键的最大种类数，有点类似于我们的基数排序里面的基）是d\n  </div>\n  <div>\n   双链树的平均树深是h\n  </div>\n  <div>\n   1.在双链树中每一位的平均查找长度是\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1911157\' name=\'code\' snippet_file_name=\'blog_20161003_1_7497130\'>sum(p+p*2+p*3+...+p*d)=sum((1+d)*d*p/2)\np=1/d\nsum=(1+d)/2</pre>\n   2.在双链树中查找单词的平均查找长度是\n  </div>\n  <div>\n   <pre class=\'html\' code_snippet_id=\'1911157\' name=\'code\' snippet_file_name=\'blog_20161003_2_9591464\'>(1+d)*h/2</pre>\n   <div>\n    <br/>\n   </div>\n   比较：\n  </div>\n  <div>\n   相对于哈希表的查找来说，我们每次的时间耗费大多都是浪费存在遍历单词上了，哈希表可以做到O(1)的查询，但是还是需要遍历，所以说是O(h)\n  </div>\n  <div>\n   但是哈希的建树操作时间复杂度其实和字典树是一样的，但是我们完全可以在字典树中实现，查询+建树同时进行，但是哈希表就不行了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    采用双链树的话，我们虽然可以节省内存，但是在查询的时候，我们必须对下一层的子指针进行相应的遍历，会比较耗时，但是对于稀疏的状态来说还是非常的优秀的\n   </strong>\n  </div>\n  <div>\n   <h2>\n    4.操作解析\n   </h2>\n   <div>\n    为了降低内存的消耗，本文中描述中全部采用双链树的形式\n   </div>\n   <h3>\n    1.查询操作\n   </h3>\n   首先，我们在对单词便利的过程中完成对树的遍历操作，从根节点开始，对于单词的每一位我们在子指针中查找有没有匹配节点\n  </div>\n  <div>\n   1.没有匹配节点，返回失败\n  </div>\n  <div>\n   2.有匹配节点继续开始步骤，知道我们单词查询遍历完毕\n  </div>\n  <div>\n   1.如果单词查询完，标记域是否，代表我们这个单词只是作为其他单词的前缀出现过，之前没有出现过这个单词，我们对单词标记域进行修改，返回失败\n  </div>\n  <div>\n   2.如果标记域是是，我们进行其他的操作（比如计数什么的）返回成功\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   2.插入操作（建树）\n  </h3>\n  <div>\n   同上，我们首先从根节点开始\n  </div>\n  <div>\n   1.子指针中如果对当前的关键字的位有相应的指针，那么继续遍历\n  </div>\n  <div>\n   2.如果不存在相应的指针，我们开始怼该单词的每一位进行建树操作，对每一次便利的单词的位扩展构建子节点，并在最后的时候，对叶子节点的标记域进行修改\n  </div>\n  <h3>\n   3.销毁\n  </h3>\n  <div>\n   销毁一颗字典树我们需要对数进行后序遍历，这是很简单的\n  </div>\n  <h3>\n   4.有序输出\n  </h3>\n  <div>\n   前序遍历Trie\n  </div>\n  <h2>\n   5.封装代码\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1911157\' name=\'code\' snippet_file_name=\'blog_20161003_3_1685016\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	char key;   //键值\n	struct node* son[26];   //以英文字母为例 \n	bool flag;   //标记是否存在过	\n	bool lort;   //标记是叶子节点还是树节点 \n}point;\n\nclass Trie\n{\n	public:\n		Trie()\n		{\n			root=new point;\n			root-&gt;flag=false;\n			root-&gt;key=\'#\';  //空标记 \n			root-&gt;lort=true;   //开始是空树，必然是叶子节点 \n			memset(data,0,sizeof(data));\n			for(int i=0;i&lt;26;i++) root-&gt;son[i]=NULL;\n		}\n		~Trie()\n		{\n			clear(root);\n		}\n		friend istream&amp; operator&gt;&gt;(istream&amp;,Trie&amp;); \n		void clear(point*);   //后序遍历清空Trie\n		void insert(point*,int);   //建树+插入\n		bool find(point*,int);   //查询\n		void scan(point*,int);   //前序遍历输出字典序 \n		inline void initdata()\n		{\n			memset(data,0,sizeof(data));\n		}\n		inline point* returnroot()   //返回根节点指针 \n		{\n			return root;\n		}\n	private:\n		point* root;   //空表头指针 \n		char data[20];   //不超过20个字母的单词 \n		char a[20];\n};\n\nistream&amp; operator&gt;&gt;(istream&amp; in,Trie&amp; p)\n{\n	cout&lt;&lt;\'&gt;&gt;&gt; \';\n	in&gt;&gt;p.data;\n	return in;\n}\n\nvoid Trie::insert(point* now,int i)\n{\n	if(data[i]==\'\0\') return ;\n	if(now-&gt;son[data[i]-\'a\']==NULL)\n	{\n		now-&gt;lort=false;   //不是叶子节点了 \n		now-&gt;son[data[i]-\'a\']=new point;\n		now-&gt;son[data[i]-\'a\']-&gt;key=data[i];\n		if(data[i+1]==\'\0\') now-&gt;son[data[i]-\'a\']-&gt;flag=true;\n		else now-&gt;son[data[i]-\'a\']-&gt;flag=false;\n		for(int j=0;j&lt;26;j++) now-&gt;son[data[i]-\'a\']-&gt;son[j]=NULL;\n		insert(now-&gt;son[data[i]-\'a\'],i+1);\n	}\n	else insert(now-&gt;son[data[i]-\'a\'],i+1);\n}\n\nbool Trie::find(point* p,int i)\n{\n	if(data[i]==\'\0\'&amp;&amp;p-&gt;flag==true) return true;\n	else\n	{\n		if(data[i]==\'\0\'&amp;&amp;p-&gt;flag==false) return false;\n		else\n		{\n			if(p-&gt;son[data[i]-\'a\']==NULL) return false;\n			else return find(p-&gt;son[data[i]-\'a\'],i+1);\n		} \n	} \n}\n\nvoid Trie::scan(point* p,int i)\n{\n	 if(p-&gt;lort==true) \n	 {\n	 	a[i]=p-&gt;key;\n	 	for(int j=1;j&lt;=i;j++) cout&lt;&lt;a[j];\n	 	cout&lt;&lt;endl;\n	 	return ;\n	 }\n	 else\n	 {\n	 	for(int j=0;j&lt;26;j++)\n	 	{\n	 		if(p-&gt;son[j]!=NULL) \n	 		{\n	 			a[i]=p-&gt;key;\n				scan(p-&gt;son[j],i+1); \n	 		}\n	 	}\n	 }\n}\n\nvoid Trie::clear(point* p)\n{\n	if(p-&gt;lort==true) free(p);\n	else \n	{\n		for(int i=0;i&lt;26;i++)\n		{\n			if(p-&gt;son[i]!=NULL) clear(p-&gt;son[i]);\n		}\n	}\n}\n\nint main()\n{\n	Trie my;\n	int t=10;\n	while(t--)\n	{\n		cin&gt;&gt;my;\n		my.insert(my.returnroot(),0);\n		my.initdata();\n	}\n	t=5;\n	while(t--)\n	{\n		cin&gt;&gt;my;\n		if(my.find(my.returnroot(),0)) cout&lt;&lt;\'Yes!\'&lt;&lt;endl;\n		else cout&lt;&lt;\'No!\'&lt;&lt;endl; \n	}\n	my.scan(my.returnroot(),0);\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <h2>\n   6.待解\n  </h2>\n  <div>\n   1.DFA（有限状态机）\n  </div>\n  <div>\n   2.Double-Array Trie / Tripple-Array Trie(对空间的压缩，基于DFA)\n  </div>\n  <div>\n   3.叶子节点真的要保存整个剩余的字段吗？\n  </div>\n  <h2>\n   7.OJ例题及解析\n  </h2>\n  <div>\n   1.HDU 1251\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1911157\' name=\'code\' snippet_file_name=\'blog_20161003_4_4542718\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	char key;\n	struct node* son[26];\n	int count;   //记录以该字符为后缀的前缀单词的个数 \n}point;\n\npoint* root;\nchar data[12];\n\nvoid insert()\n{\n	point* p=root;\n	int j=0;\n	while(data[j]!=\'\0\')\n	{\n		int k=data[j]-\'a\';\n		if(p-&gt;son[k]!=NULL) p=p-&gt;son[k],p-&gt;count++;\n		else\n		{\n			p-&gt;son[k]=new point;\n			p-&gt;son[k]-&gt;key=data[j];\n			p-&gt;son[k]-&gt;count=1;\n			for(int i=0;i&lt;26;i++) p-&gt;son[k]-&gt;son[i]=NULL; \n			p=p-&gt;son[k];\n		}\n		j++;\n	}\n	memset(data,0,sizeof(data));\n}\n\nint dosomething()\n{\n	point* p=root;\n	int j=0;\n	while(data[j]!=\'\0\')\n	{\n		int k=data[j]-\'a\';\n		if(p-&gt;son[k]!=NULL) p=p-&gt;son[k];\n		else return 0;\n		j++;\n	}\n	return p-&gt;count; \n} \n\nint main()\n{\n	root=new point;\n	for(int i=0;i&lt;26;i++) root-&gt;son[i]=NULL;\n	while(gets(data)&amp;&amp;data[0]!=\'\0\') insert();\n	while(gets(data)!=NULL) cout&lt;&lt;dosomething()&lt;&lt;endl; \n	return 0;\n}\n </pre>\n   <br/>\n   2.1671\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1911157\' name=\'code\' snippet_file_name=\'blog_20161003_5_3604627\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int key;  //键\n	struct node* son[10];   //英文字母，如果是其他情况，调整就好\n	bool flag;  //判断是否出现过\n	bool fornext;\n//	int count;   前缀的数目等其他的信息 \n}point;\n\npoint* root;\nchar data[12];\nbool ok;   //记录当前号码是否存在过 \n\nbool insert()\n{\n	bool youxinjiedianshengcheng=false;\n	int j=0;\n	point* p=root;\n	while(data[j]!=\'\0\')\n	{\n		int k=data[j]-\'0\';\n		if(p-&gt;son[k]==NULL) \n		{\n			youxinjiedianshengcheng=true;\n			p-&gt;son[k]=new point;\n			p-&gt;fornext=false;\n			p-&gt;son[k]-&gt;key=k;\n			for(int i=0;i&lt;=9;i++) p-&gt;son[k]-&gt;son[i]=NULL;\n			p-&gt;son[k]-&gt;flag=false;\n			p=p-&gt;son[k];\n		}\n		else\n		{\n			if(p-&gt;son[k]-&gt;flag==true) ok=true;\n			p-&gt;fornext=false;\n			p=p-&gt;son[k];\n		}\n		j++;\n	}\n	p-&gt;flag=true;\n	p-&gt;fornext=true;\n	if(ok==true||youxinjiedianshengcheng==false) return false;\n	else return true;\n}\n\nvoid dfs(point* gen)\n{\n	if(gen-&gt;fornext==true) \n	{\n		delete gen;\n		return ;\n	}\n	else\n	{\n		for(int i=0;i&lt;=9;i++)\n		{\n			if(gen-&gt;son[i]!=NULL) \n			{\n				dfs(gen-&gt;son[i]);\n				gen-&gt;son[i]=NULL;\n			}\n		}\n		delete gen;\n	}\n}\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;getchar();\n	root=new point;\n	root-&gt;flag=false;\n	for(int i=0;i&lt;10;i++) root-&gt;son[i]=NULL;\n	root-&gt;key=-1;\n	while(t--)\n	{\n		bool yes=false;\n		int k;\n		cin&gt;&gt;k;getchar();\n		while(k--)\n		{\n			ok=false; \n			gets(data);\n			if(insert()==false) yes=true; \n		}\n		if(yes==false) cout&lt;&lt;\'YES\'&lt;&lt;endl;\n		else cout&lt;&lt;\'NO\'&lt;&lt;endl;\n		\n		dfs(root);\n		root=new point;\n    	root-&gt;flag=false;\n		for(int i=0;i&lt;10;i++) root-&gt;son[i]=NULL;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('f6991b304d495950cd16010d04ea334e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Radix-Sorting(线性阶 多关键字排序算法 基数排序)\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.引入：\n  </h2>\n  <div>\n   我们发现也经过证实，交换式的排序的算法的时间复杂度的下界是O(n*lgn),但是这真的就是我们的排序算法的极限了吗，事实并不是这样的，我们的多关键字的分配式排序--本文的基数排序就是如此却是打破了这样的瓶颈\n  </div>\n  <div>\n   分配式的Radix-Sorting算法成功的将我们的算法的复杂度优化到无限接近线性阶的完美的O(n)，下面，我们就来一一道来\n  </div>\n  <h2>\n   2.前身：\n  </h2>\n  <div>\n   桶式排序：\n  </div>\n  <div>\n   我们先假定排序这样的一个数组\n  </div>\n  <div>\n   1,9,4,8,2,7,5,6,3,10\n  </div>\n  <div>\n   很显然，你们都会说出什么快排啊，归并排序，插入排序啊，堆排序啊什么的，但是我们就题目本身来看的话，可不可以这么来考虑\n  </div>\n  <div>\n   我们现在假设这里有10个桶，每个桶用来存放权值是相应的标号的数字的个数\n  </div>\n  <div>\n   那么很显然初始的状态应该是\n  </div>\n  <div>\n   0 0 0 0 0 0 0 0 0 0\n  </div>\n  <div>\n   按照题目来看的话，我们扫描一遍，将相应的数组入桶，结果为\n  </div>\n  <div>\n   1 1 1 1 1 1 1 1 1 1\n  </div>\n  <div>\n   最后我们从桶1开始一直输出到桶10\n  </div>\n  <div>\n   很明显就会得到\n  </div>\n  <div>\n   1 2 3 4 5 6 7 8 9 10\n  </div>\n  <div>\n   很显然，这样的算法我们的时间耗费完全只是在扫描和输出上了，完全接近我们的O(n)的线性阶时间复杂度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   但是我们需要明确一点，这里的桶式排序有一些明显的缺陷\n  </div>\n  <div>\n   1.无法排序负数\n  </div>\n  <div>\n   2.需要消耗大量的额外空间，对于极限情况1,2000来说，显然会造成力不从心的情况\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   于是，这里就引出了我们的基数排序\n  </div>\n  <h2>\n   3.基数排序概念\n  </h2>\n  <div>\n   基数排序的专业说法应该是：对单逻辑关键字的多关键字排序，也就是说，我们将待排对象分类城多种关键字，我们对不同的关键字都进行一趟桶式排序，然后我们对结果进行收集（这里的描述有一些偏向LSD，但是会方便我们的理解，这里我们不要过深究就这一点）\n  </div>\n  <div>\n   定义：\n  </div>\n  <div>\n   对有n个关键字的记录序列\n  </div>\n  <div>\n   {r1,r2,r3,r4,r5...rn\n   <span style=\'font-size:12px\'>\n    }\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    每个记录中都含有d个关键字{k0,k1,k2,k3,k4,...kd}\n   </span>\n  </div>\n  <div>\n   我们的基数排序要求对于任意的两个r之间我们都要满足前者的k关键字必须全部大于或者小于后者的全部关键字\n  </div>\n  <h2>\n   4.思路分类：\n  </h2>\n  <div>\n   对于基数排序，我们这里存在着两种不同的排序思路\n  </div>\n  <h3>\n   1.LSD（最低位优先）\n  </h3>\n  <div>\n   这里的最低位优先的意思是，我们从最次为的关键字进行开始，每一次进行一趟基数排序然后收集，当所有的关键字全部都匹配完全之后，我们得到的就是有序的序列\n  </div>\n  <div>\n   这里的限制的终止情况是，我们必须要对所有的关键字全部都进行匹配，但是一旦在出现数字（待排对象）之间的位数差距比较大的情况，我们有可能做大量的无用功\n  </div>\n  <h3>\n   2.MSD（最高位优先）\n  </h3>\n  <div>\n   这里的MSD法参透了一些递归的思想，在这里，我们首先从高位开始匹配，每一次入桶之后，我们对每一个桶的序列也分别进行一次MSD递归调用，直到最后最后我们发现每个子桶中的元素的个数都只是&lt;=1的情况的话，很明显，这时候我们就该强行终止了递归调用，返回我们的有序序列\n  </div>\n  <div>\n   MSD对于上述的位数差距比较大的情况来看的话，可以大幅度减少我们的排序次数\n  </div>\n  <h2>\n   5.复杂度的优化想法思路\n  </h2>\n  <div>\n   1.参照网上的大神的描述，在整数排序的额时候，我们可以将基数设置的大一些\n  </div>\n  <div>\n   2.在对证书进行基数排序的时候，那面会出现pow函数的调用，这时候我们的时间耗费就会出现一些提升，在这里，我们的优化思路是采用位运算的想法，将基数设定成2的幂，那么我们在进行反馈映射的过程的时候，利用位运算可以大幅度降低我们pow函数和我们的触发造成的恐怖的时间耗费，毕竟计算机还是一个二进制机器\n  </div>\n  <div>\n   3.如果我们只是单纯地对数组进行基数排序的话\n  </div>\n  <div>\n   我们的时间耗费大致是O(d*(3*n+radix)),空间耗费是n+radix\n  </div>\n  <div>\n   但是如果我们在这里利用链表的话\n  </div>\n  <div>\n   时间复杂度大致是O(d*(n+radix)),空间耗费是radix\n  </div>\n  <div>\n   为什么呢\n  </div>\n  <div>\n   <strong>\n    <u>\n     <em>\n      ps：以下的思路是LSD\n     </em>\n    </u>\n   </strong>\n  </div>\n  <h3>\n   1.数组法\n  </h3>\n  <div>\n   我们的工具：bucket桶数组，count记录每个桶的数目\n  </div>\n  <div>\n   我们先来看简单的数组的操作过程\n  </div>\n  <div>\n   1.初始化count\n  </div>\n  <div>\n   2.扫描一遍数组O(n),将count更新维护\n  </div>\n  <div>\n   5.扫描一遍count，确定每个桶的右边界，方便我们的插入操作\n  </div>\n  <div>\n   4.扫描一遍数组O(n),建立映射，数组元素入桶\n  </div>\n  <div>\n   5.将bucket中的元素返还（倒进）原数组中，O(n)\n  </div>\n  <div>\n   以上是一趟桶式排序，对于我们的数字的范围d（如果用十进制的例子来看的话，那就是d是位数）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   2.链式基数排序（\n   <span style=\'font-size:12px\'>\n    在这里，我们用链表还是静态量表的实现原理都是一样的，我们这里随便举个例子，用静态链表来描述好了）\n   </span>\n  </h3>\n  <div>\n   我们的工具radix个&lt;head,tail&gt;链队列的头尾指针O(2*radix)的空间复杂度\n  </div>\n  <div>\n   1.扫描一遍，根据映射我们将链的节点插入相应的链队列O(n)\n  </div>\n  <div>\n   2.遍历所有的radix链队列，将链队列的头尾指针相互串接，构成新的链O(radix)\n  </div>\n  <div>\n   3.重复d次\n  </div>\n  <div>\n   时间复杂度是O(d*(n+radix)),空间复杂度是O(2*radix+n),n是链节点的指针域\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   通过上述比较，我们来看一下\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <table border=\'1\' cellpadding=\'1\' cellspacing=\'1\' width=\'200\'>\n    <tbody>\n     <tr>\n      <td>\n      </td>\n      <td>\n       空间复杂度\n      </td>\n      <td>\n       时间复杂度\n      </td>\n     </tr>\n     <tr>\n      <td>\n       数组法\n      </td>\n      <td>\n       O(n+ra)\n      </td>\n      <td>\n       O(d*(3*n+ra))\n      </td>\n     </tr>\n     <tr>\n      <td>\n       链表法\n      </td>\n      <td>\n       O(n+2*ra)\n      </td>\n      <td>\n       O(d*(n+ra))\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   显然从上述表格来看，我们的链式的结构更具有优越性\n  </div>\n  <div>\n   当然，我所有的情况都会用代码示例一遍\n  </div>\n  <h2>\n   6.优缺点限制以及特殊情况的处理\n  </h2>\n  <div>\n   <strong>\n    <u>\n     优点：排序稳定性：\n    </u>\n   </strong>\n  </div>\n  <div>\n   <strong>\n    <u>\n     无论是从上面的链式还是数组的方式，我们都可以清楚地的看到，通过特殊的处理（链队列，数组count的利用）都是的我们的基数排序是稳定的\n    </u>\n   </strong>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   1.从上面的情况，我们已经看到了，桶式排序不能处理负数，不能处理浮点数，也不能处理字符串\n  </div>\n  <div>\n   但是对于基数排序，并不是这样的\n  </div>\n  <div>\n   负数的话，我们可以将负数和整数进行分类考虑最后将结果合并就好\n  </div>\n  <div>\n   浮点数的话，我们可以将浮点数承上一个较大的整数将其装花城整数来进行操作\n  </div>\n  <div>\n   字符串的话，我们将字符串的每个字符都当成是一个关键字，从而更加方便的实现基数排序\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   优点：基数排序不是交换式的，而是分配式的排序，所以说，我们的时间复杂度可以轻而易举的达到线性阶\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20140404103637593\'/>\n   <br/>\n  </div>\n  <div>\n   缺点：基数排序的内存占用和归并排序一样，非常的大，在我们的内存吃紧的情况下，基数排序不要进行考虑，但是对于我们的内存宽松，时间要求搞笑的时候，基数排序旺旺可以达到比快排更好的效果\n  </div>\n  <div>\n   基数排序的LSD进行之前，我们必须要了解到所有的数组的最大的上限\n  </div>\n  <h2>\n   7.相应的核心代码段\n  </h2>\n  <div>\n   附上我的CSDN snippts连接：\n  </div>\n  <div>\n   <a href=\'https://code.csdn.net/snippets_manage\' target=\'_blank\'>\n    基数排序相关代码段\n   </a>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('7fe9d4d601c5edf7b833235f57e5efb3','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  数据结构和算法绪论下\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.算法分析的要点\n  </h2>\n  <div>\n   1.正确性\n  </div>\n  <div>\n   2.复杂度的分析\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   基础知识：\n  </div>\n  <div>\n   级数：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1900010\' name=\'code\' snippet_file_name=\'blog_20160925_1_7208789\'>T(n)=1+2+3+...+n=O(n^2)\nT(n)=1^2+2^2+...+n^2=n*(n+1)*(2*n+1)/6=O(n^3)\nT(n)=1^3+...+n^3=O(n^4)</pre>\n   可以很明显的看出来，几何级数的复杂度呈现出来的规律就是始终是我们的幂数的+1次幂的复杂度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.注意事项：\n  </h2>\n  <div>\n   无论n多大，都有可能会出现时间复杂度和n没有任何关系的情况\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.算法正确性的证明：\n  </h2>\n  <div>\n   1.循环不变式的利用\n  </div>\n  <div>\n   2.单调性（减而知之，规模缩减）\n  </div>\n  <div>\n   3.正确性（算法必须可以终止）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   4.分析举例：\n  </h2>\n  <div>\n   Max2问题的算法分析：查找数列中的最大的两个元素的问题\n  </div>\n  <div>\n   当然，该问题在我们采用了堆这种高效的数据结构之后，时间复杂度可以优化到无限的接近O(n)\n  </div>\n  <div>\n   1.迭代：\n  </div>\n  <div>\n   思路：扫描两遍，分别查找当前最大的元素并标记（避免重复访问）\n  </div>\n  <div>\n   算法的复杂度分析：O(2n)显然\n  </div>\n  <div>\n   2.递归：\n  </div>\n  <div>\n   二分递归查找：我们将数据简化为两部分，左边有最大和次大，右边有最大和次大，之后我们在讲左边的最大和右边的最大进行比较，选择最优，然后让第一次比较的败者和左边的次大作比较选出次大\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   边界的判断：\n  </div>\n  <div>\n   在问题的规模缩小到2,或者3的时候，我们特殊的判断一下就好了\n  </div>\n  <div>\n   其余的情况下，我们都可以按照上面的策略来进行比较\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1900010\' name=\'code\' snippet_file_name=\'blog_20160925_2_4111890\' style=\'font-size: 13.3333px;\'>T(n)=(n/3)T(3)+2(n/3-1)\nT(n)=5/3T(n)-2</pre>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('bf0ae593723c282ce17b0cb55e3cf869','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  数据结构与算法 - 绪论上\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.计算机\n  </h2>\n  <h3>\n   1.引言\n  </h3>\n  <div>\n   Dijstra原话摘引，计算机无非就是计算工具而已\n  </div>\n  <div>\n   使我们使用的可以重复的，机械的，为了完成目的而使用的工具（当然每个工具都有自己的能力范围）\n  </div>\n  <h3>\n   2.算法\n  </h3>\n  <div>\n   所谓计算机算法，无非就是我们的计算过程：某种工具按照某种一定的规则，明确机械的重复某一些过程，即我们认为的解决问题的一些指令序列（特定的计算模型）\n  </div>\n  <div>\n   大致分为以下几个步骤：\n  </div>\n  <div>\n   1.输入（问题实际描述）\n  </div>\n  <div>\n   2.输出（对问题的解释）\n  </div>\n  <div>\n   3.正确性：一个算法我们只有认可了正确性的条件下，我们才可以正确的使用\n  </div>\n  <div>\n   4.可行性：对于每个基础操作，我们必须要认定其每个操作在常数时间内完成，并且整个算法必须可以兑现，可以有有限多个操作步骤组合而成\n  </div>\n  <div>\n   5.有穷性：整个算法中包含有穷个步骤\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于有穷性而言，我们引出Hailstone问题\n  </div>\n  <div>\n   Hailstone(n):\n  </div>\n  <div>\n   {1}  n&lt;=1\n  </div>\n  <div>\n   {n} &amp; Hailstone(n/2)   n为偶数\n  </div>\n  <div>\n   {n} &amp; Hailstone(3*n+1)    n为奇数\n  </div>\n  <div>\n   很遗憾，我们目前还不能证明Hailstone是一个算法，因为我们我发证明对于任意的输入，我们都可以在有限地步骤内完成\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   所以说，我们这里引出了  Programm ！= Algorithm 的概念，因为我们可以随随便便的设计出不满足算法条件的程序来，但是对我们来说，有时候还是有用的\n  </div>\n  <h3>\n   3.好的算法\n  </h3>\n  <div>\n   一个好的算法：\n  </div>\n  <div>\n   1.输入：简单，大规模，一般性或者任意的合法输入我们都可以给出正确的结果\n  </div>\n  <div>\n   2.健壮性：对于不正确的输入，我们依然可以给出提示并正确退出\n  </div>\n  <div>\n   3.效率：我们要求我们的算法便携的程序有速度快，占用空间少的特性\n  </div>\n  <h2>\n   2.计算模型\n  </h2>\n  <div>\n   对于一个特定的算法我们一般只会考虑两部分：正确性，算法的成本\n  </div>\n  <div>\n   在这里，算法的成本只有两点，时间成本和空间成本，但是实际上，我们一般都不会考虑算法的空间成本，我们都重点关注算法的时间成本，也就是我们的 算法运行的效率\n  </div>\n  <div>\n   这里我们定义：\n  </div>\n  <div>\n   T\n   <span style=\'font-size:12px\'>\n    a(p):算法A求解问题示例p的计算成本  = 》T(n)求解问题的所需要的成本\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    为了稳妥起见，我们一般只关注成本提高的最坏的情况T(n) = max{T(p) | p = n}\n   </span>\n  </div>\n  <h3>\n   <span style=\'font-size:12px\'>\n    1.Turing Machine\n   </span>\n  </h3>\n  <div>\n   <span style=\'font-size:12px\'>\n    1.tape：无限长的纸袋，纸袋上有大量的格子，每个格子初始字符自己约定，比如我们约定为\'#\'\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    2.Alphabet：字符表，有限的字符表我们来修饰tape纸袋\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    3.head：读写头\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    4.state：TM总是处在悠闲中的状态中，读写头的每一次移动和读写都会造成我们的状态的转移\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    5.转移函数：包含但浅的状态，指向的格子的状态，即将读写的字符，移动的方向，以及下一次我们要转移的状态（特定的状态用来表示停机）\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <h3>\n   <span style=\'font-size:12px\'>\n    2.RAM（Random Access Machine）\n   </span>\n  </h3>\n  <div>\n   <span style=\'font-size:12px\'>\n    顺序存储寄存器，无限的空间\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    包含大量的基本操作，例如：赋值，间接取值，简单的+，-运算，条件判断语句，终止语句\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    通过上述的两种计算模型，我们可以大致的将算法的运行时间抽象成我们算法的基本的操作次数，也就转化成了我们对基本的操作此时的求和的估算\n   </span>\n  </div>\n  <h2>\n   3.Big-O and other charater for our analyse\n  </h2>\n  <div>\n   算法的分析忽略常系数，忽略低阶项，保留高阶项\n  </div>\n  <h3>\n   1.Big-O标记\n  </h3>\n  <div>\n   基本上，随着问题的规模的上升我们的计算的成本也是不断的成正比上升（通常的情况下）\n  </div>\n  <div>\n   渐进分析 n&gt;&gt;2,算法的基本的操作次数T(n),算法的占用内存的存储单元S(n)\n  </div>\n  <div>\n   T(n) = O(f(n))\n  </div>\n  <div>\n   <strong>\n    <em>\n     该含义是：存在c&gt;0,当n&gt;&gt;2时，T(n)&lt;c*f(n)\n    </em>\n   </strong>\n  </div>\n  <div>\n   从函数的定义来看，我们发现，实际上O标记也就是我们的悲观的估计，但是他给出了我们算法的upper bound，也就是确定了我们算法最坏的情况，从而方便我们进行判断\n  </div>\n  <h3>\n   2.Big-omega标记\n  </h3>\n  <div>\n   定义：存在c&gt;0,当n&gt;&gt;2,T(n)&gt;c*f(n)\n  </div>\n  <div>\n   和上面的对应来看，其实omega标记实际上是我们的最乐观的估计，我们给出了我们算法的low bound，也就是说我们确定了我们算法的最低效率\n  </div>\n  <h3>\n   3.Big-Sita标记\n  </h3>\n  <div>\n   简而言之，就是上面的联众标记的综合，我们用确定的形式确定了我们的算法的实际的准确的运行增长\n  </div>\n  <h2>\n   4.常见的复杂度\n  </h2>\n  <div>\n   1.O(1)：最理想的时间复杂度。此类算法的效率是最高的，只要程序中没有显示或者隐式的出现循环分支调用，递归的程序我们都可以认为是理想的时间复杂度，当然，也并不是说，出现了就不是O(1)是啊金复杂度的算法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.O(lgn)：对数或者对数的多项式的时间复杂度，其实我们在这里也是只考虑常系数和高阶项\n  </div>\n  <div>\n   此类算法的复杂度无限的接近于常数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.O(n^c)：多项式时间复杂度，我们在估算的时候，我们只去最高阶项，其中的O(n)表示我们的线性的时间复杂度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   下面的复杂度算法称之为无效的算法，因为算法的时间成本增长的速度我们无法忍受\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    4.O(2^n)\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    n^c=O(2^n)(不可忍受的时间成本)\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    对于我们已经确定的NP问题，是不存在多项式时间复杂度的解的，但是只有在我们施加了约束条件之后，才有可能我们对问题进行合理的优化\n   </span>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('e52dee5e50a48a9e7de044296cad9dcc','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  背包问题九讲02-完全背包问题总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述：\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   假设有n件物品，每件物品都有value，和cost属性，现有一个容量为v的背包，现在每件物品都有无限件可以选择，请问为了使背包的总价值最大，我们该怎么挑选放入背包的物品，输出我们的最大总价值\n  </div>\n  <h2>\n   2.思路：\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   不同于01背包问题的完全背包问题，和01背包问题有所不同，完全背包问题强调了，每种物品都有无限件可以选取，那么我们最终要检查的状态就不在是01背包问题中的O(V*N)而是扩展成O(V*SUM(\n   <span style=\'white-space:pre\'>\n   </span>\n   V/cost[i]))件物品，显然因为扩展了可能选择的情况，我们的时间复杂度激素飙升，在背包容量非常大，并且物品的耗费很小的时候，这种算法的时间复杂度有些显得力不从心\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   但是我们还是来写一下还方法的状态和状态专业方程，位我们接下来的优化提供契机\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   定义状态：\n   <br/>\n   <pre class=\'cpp\' code_snippet_id=\'1883816\' name=\'code\' snippet_file_name=\'blog_20160918_1_8160002\'>dp[i][j]:在背包容量为j的情况下，我们在放入前i件物品的时候（最大选择上线是V/cost[i]）可以获得的最大价值</pre>\n   状态转移方程：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'1883816\' name=\'code\' snippet_file_name=\'blog_20160918_2_603002\'>dp[i][j]=max(dp[i][j-k*cost[i]]+k*value[i])  //K从0~V/cost[i](选择下界)</pre>\n   <h2>\n    3.简单优化：\n   </h2>\n  </div>\n  <h3>\n   1.思路上的优化：\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   我们不好理解哇暖背包问题的话，其实不妨把完全背包问题转化成01背包问题，我们这样来看待我们的完全背包，既然每一个物品都有V/cost[i]中选择方式，那么我们就不妨从01背包的思路入手，我们将物品机体扩充，每件物品都有V/cost[i]件，那么我们就将问题装化成了有n*sum(V/cost[i])件物品的01背包问题了，但是这种想法上的优化对于我们优化时间复杂度没有任何实际上的作用，我们需要扫描的状态的数目仍然是O(V*\n   <span style=\'font-size:13.3333px\'>\n    n*sum(V/cost[i])\n   </span>\n   )中状态，但是，这种事路其实给我们提供了一种01背包和完全背包之间的联系\n  </div>\n  <h3>\n   2.01背包思路的进一步优化：\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   我们可以发现，每一件物品既然都要拆成n*sum(V/cost[i])件物品，我们是选择每件物品单独来作为一种情况来进行组装，但是我们仔细想想就会发现，实际上，我们为了找过所有的情况，没有必要拆除那么多的物品，想一下二进制的原理，任何一个数我们都可以由二进制数目进行组合来得到，那我们同样的，如果我们将每个物品最多拆成二进制个话，我们完全就可以实现我们需要的所有的状态了\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   比如，为了实现表示我们二进制的100（4），我们没必要拆出4个状态：1,10,11,100，我们只需要2^k=4,k=2种状态就可以了，也就是说，我们最多只需要1和10就能够高速的实现我们的所有的状态的组合\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   这样的话，我们来回到正题上，对于完全背包的话，我们每个物品只需要cost[i]*2^k&lt;=V,也就是说log(V/cost[i])个状态就好了\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   那么我们01背包需要的扫描的状态数目就是\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   O(V*n*log(V/cost[i]))\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   我们现在来比较一下两个状态：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'1883816\' name=\'code\' snippet_file_name=\'blog_20160918_3_6251583\'>O(V*n*log(V/cost[i]))\nO(V*n*V/cost[i])</pre>\n   显而易见，我们在01背包的思路之上，成功的优化了我们的时间复杂度\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   PS：这里我们选择了2^k来拆，其实根据个人喜好3^k,4^k都是可以的，但是在计算时间复杂度的时候我们统一是用2^k来作为标准的\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <h3>\n    3.O(V*N)优化思路：\n   </h3>\n   <div>\n    其实我们的O(V*N)的思路其实很好得到，但是这里面我们的额优化思路和我们的01背包的思路是不一样的，我们还是从前往后扫，一会我来解释一下这一点的额含义是什么\n   </div>\n   <div>\n    先上核心代码：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1883816\' name=\'code\' snippet_file_name=\'blog_20160918_4_2664316\'>for(int i=1;i&lt;=n;i++)\n{\n	for(int j=0;j&lt;=v;j++)  //可以黑箱优化 \n	{\n		dp[i][j]=max(dp[i][j],dp[i][j-cost[i]]+value[i]);\n	}\n} </pre>\n    PS:所谓的常数优化，就是我们每次起点都是cost[I]，在我们的物品的cost比较高的时候，该优化的效果是很可观的\n   </div>\n   <div>\n    我们这样优化的思路其实很简单\n   </div>\n   <div>\n    首先，我们这样优化是建立在内层循环是从前往后进行的，每一次，我们之前的状态都是已经计算过的\n   </div>\n   <div>\n    那么我们再来考虑我们原先的没有优化的时候的状态\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1883816\' name=\'code\' snippet_file_name=\'blog_20160918_5_4757867\' style=\'font-size: 13.3333px;\'>dp[i][j]=max(dp[i][j-k*cost[i]]+k*value[i])  //K从0~V/cost[i](选择下界)</pre>\n    在这里我们发现，我们的k次优化是不断递增的，也就是说我们下一次的k可以通过k-1已经计算出来的值（这个计算出来的值已经是前一段的k是最优的），我们直接拿这个最优解和我们的当前的解进行比较就可以了\n   </div>\n   <h3>\n    4.空间复杂度的优化：\n   </h3>\n   <div>\n    我们其实没必要开辟那么多的，我们只需要之前计算的数值和当前位置的数据（当前的数据是一个都不取）\n   </div>\n   <div>\n    黑箱优化：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1883816\' name=\'code\' snippet_file_name=\'blog_20160918_6_4899570\'>void absolutepackage(int cost,int value)\n{\n	for(int i=cost;i&lt;=v;i++) dp[i]=max(dp[i],dp[i-cost]+value);\n}\n\nvoid test()\n{\n	for(int i=1;i&lt;=n;i++) absolutepackage(cost[i],value[i]);\n}</pre>\n    <br/>\n    <br/>\n   </div>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9cf9a00aa46b1fe0b1b84704cfe4348a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  背包九讲01-01背包问题阅读笔记\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   背包问题：\n  </div>\n  <div>\n   给出n件物品以及我们的背包的总容量v，以及n件物品的价值value和耗费cost，每件物品只有两种选择，装或者不装，请问如何选择装填的物品才可以使我们的最后获得价值最大\n  </div>\n  <h2>\n   2.求解思路：\n  </h2>\n  <div>\n   这我就不阐明记忆化搜索的思路了，既然是背包问题的专题，我就只讲动态规划的方法\n  </div>\n  <div>\n   <strong>\n    定义状态：\n   </strong>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    dp[i][j]:在容量为j的时候我们选择\n    <strong>\n     前i件物品\n    </strong>\n    可以获得的最大的价值\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <strong>\n     状态转移方程：\n    </strong>\n   </span>\n  </div>\n  <div>\n   <em>\n    if j&gt;=cost[i]   dp[i][j]=max(dp[i-1][j],dp[i-1][j-cost[i]]+value[i])\n   </em>\n  </div>\n  <div>\n   <em>\n    else dp[i][j] = dp[i-1][j]\n   </em>\n  </div>\n  <div>\n   <em>\n    <br/>\n   </em>\n  </div>\n  <div>\n   核心代码段：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1882815\' name=\'code\' snippet_file_name=\'blog_20160917_1_3280298\'>for(int i=1;i&lt;=n;i++)   //遍历所有的i件物品\n{\n	for(int j=0;j&lt;=v;j++)   //遍历背包的所有的状态，从0开始是为了考虑进去耗费是0的物品的状态 \n	{\n		if(j&gt;=cost[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-cost[i]]+value[i]); \n	}\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   上述的状态转移方程的含义是这样的：\n  </div>\n  <div>\n   当我们的目前的背包的容量大于我们当前第i件物品的时候，我们就存在两种决策，取或者不取，作为动态规划来说，我们每次都是选取最优的解，由最优的解推导出下一个状态的最优的解，所以说，这里我们就要选取两种情况的额最优的情况dp[i-1][j]代表本次该物品不取，dp[i-1][j-cost[i]]+value[i]代表本次该物品取\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   但是当我们的背包的容量不足以容许我们选取第i件物品的时候，我们就只有不取这一种选择，显而易见，也是当前最优的一种选择\n  </div>\n  <h2>\n   3.优化空间复杂度：\n  </h2>\n  <div>\n   如果采用搜索算法来解决这道题的话，时间复杂度会是2^n，毕竟有\n   <span style=\'font-size:13.3333px\'>\n    2^n这么多的选择，但是我们利用动态规划成功 的将指数时间复杂度优化到了n*v\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    时间复杂度上，我们已经无法在优化了，但是我们对于空间复杂度却是可以考虑进行优化调整\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们来考虑一下我们的空间耗费和我们的01背包问题的算法步骤\n  </div>\n  <div>\n   首先：空间耗费是O(n*v)\n  </div>\n  <div>\n   其次：我们的算法过程：\n  </div>\n  <div>\n   我们每次都是从之前的记录下来的状态作为我们的表的记录值，通过O(1)的时间复杂度从而完成我们的优化工作\n  </div>\n  <div>\n   但是，我们可以清楚地发现，我们并不需要之前所有的状态，我们需要的仅仅只是上一次的状态，即i只需要第i-1的状态值\n  </div>\n  <div>\n   所以说，我们的优化思路已经出具眉目了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们可以将状态压缩到一维状态下，然后我们通过不断的覆盖从而使下将大的我们实际上不需要的过早记录的值忽略掉\n  </div>\n  <div>\n   但是这里面牵扯到我们要保存好我们的状态的方法：\n  </div>\n  <div>\n   之前我们的内层循环是从0循环到v   。\n   <span style=\'font-size:12px\'>\n    但是在这里我们必须要装换思路，因为我们始终利用之前的状态\n   </span>\n  </div>\n  <div>\n   如果我们的内层循环还是从0循环到v的话，那么我们会发现我们之前的值已经被新的计算的值覆盖了，也就是说，我们之后的计算如果要利用之前的额记录，这个记录是个错误的值，因为正确的记录应经被我们覆盖了\n  </div>\n  <div>\n   所以说，我们的小技巧就是从v循环到0，保证我们每次的状态转移的时候都可以利用到我们的争取的dp记录状态\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   核心代码如下：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1882815\' name=\'code\' snippet_file_name=\'blog_20160917_2_8362064\'>for(int i=1;i&lt;=n;i++)   //遍历所有的i件物品\n{\n	for(int j=v;j&gt;=0;j--)   //遍历背包的所有的状态，从0开始是为了考虑进去耗费是0的物品的状态 \n	{\n		if(j&gt;=cost[i]) dp[j]=max(dp[j],dp[j-cost[i]]+value[i]); //dp[j]代表的含义是原先的dp[i-1][j]，我们将i状态和i-1状态合并到了以为数组中 \n	}\n} </pre>\n  </div>\n  <h2>\n   4.进一步优化：\n  </h2>\n  <div>\n   首先我们会发现，对于每一次的循环，因为每一件物品的cost值是不一样的，但是我们都是统一从状态v遍历到0（目的是不会遗漏掉所有的记录的状态）\n  </div>\n  <div>\n   但是我们如果发现，对于任一个状态i来说，我们的背包容量在小于cost[i]的时候是不会发生改变的，我们直接从v循环到cost[i]就可以了，但是每一个物品的cost都不一样，我们该怎么解决这个问题呢\n  </div>\n  <div>\n   位了进一步优化，我们就引进了函数调用——在原背包九讲中，称之为黑箱状态\n  </div>\n  <div>\n   不说了，上代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1882815\' name=\'code\' snippet_file_name=\'blog_20160917_3_520873\'>void pack01(int cost,int value)  //当然这里也就自然而然的考虑了cost位0的特殊情况 \n{\n	for(int i=v;i&gt;=cost;i--) dp[i]=max(dp[i],dp[i-cost]+value);\n} \n\nvoid algorithm(int cost[],int value[])\n{\n	for(int i=1;i&lt;=n;i++) pack01(cost[i],value[i]); \n}</pre>\n   <div>\n    <br/>\n   </div>\n   <h2>\n    5.初始化的问题：（变体问题的好的解决思路）\n   </h2>\n   <div>\n    在我们做01背包问题的时候，我们经常会遇见题目变了一些花样，比如说，恰好装满的最大价值这类的问题\n   </div>\n   <div>\n    面对这些问题的时候，我们只需要对我们的初始化的时候做一些必要的处理就好了\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    1.在朴素的问题中，我们全部都初始化位0，这其实代表了一种合法的状态，该合法状态（针对题目的要求限制下的合法状态）的含义就是背包中选择不装任何的东西，那么价值为0，也代表合法\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    2.在恰好装满的问题中，我们dp[0]=0，代表我们的容量是0的时候恰好装满了，价值是0，合法状态也是0，但是其他的dp状态我们赋予\n    <strong>\n     <em>\n      -inf\n     </em>\n    </strong>\n    的状态，表示不合法（在恰好装满的约束条件下，只要有空间但是没有装满的话就是不和题意的不合法状态）\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    这里面的思想就是，如果子问题合法并且当前的的装填也属于合法（恰好的完全装填）才是合法的状态\n   </div>\n   <div>\n    否则我们都处理成非法的状态（这里的inf可以参与运算，反正是无穷小，再怎么运算都一样，只是为了让代码更加简洁）\n   </div>\n   <h2>\n    6.最优方案记录：\n   </h2>\n   <div>\n    我们如果要输出最优的额方案的话，有这么两种思路\n   </div>\n   <div>\n    1.直接利用我们的二位dp矩阵，从头开始往前推\n   </div>\n   <div>\n    2.额外开辟新的path数组记录路径，其实主要的思路和上面的是一样的，都是逆推回去，每次如果出现了当前第i行的最优解，我们标记一次，然后从后向前遍历，找到第一个标记点然后逐层向前推（推回去点不一定是标记为1的点，我们再以该点为基础向前推找最先出现的标记点，知道找到第1行为止）\n   </div>\n   <div>\n    <br/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('fa3f0b698f83ef8c9f9ae2670b694717','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU4508-完全背包\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   标准的完全背包水题\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1882756\' name=\'code\' snippet_file_name=\'blog_20160917_1_7365867\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 105 \n\nusing namespace std;\n\nint n;\nint v;\nint weight[N];\nint value[N];\nint dp[100005];\n\nint maxp(int x,int y)\n{\n	if(x&gt;y) return x;\n	else return y;\n}\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)!=EOF)\n	{\n		for(int i=1;i&lt;=n;i++) scanf(\'%d%d\',&amp;value[i],&amp;weight[i]);\n		scanf(\'%d\',&amp;v);\n		memset(dp,0,sizeof(dp));\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=0;j&lt;=v;j++)\n			{\n				if(j&gt;=weight[i]) dp[j]=maxp(dp[j],dp[j-weight[i]]+value[i]);\n			}\n		}\n		printf(\'%d\n\',dp[v]);\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2bd642ffa77be3d17dfb4fcb139eb41b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ983-首尾相连的最大子数组和（升级版子数组和）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   本体是最大子数组和的升级版，我们这里允许数组首尾相接，那么这里面就会涉及到更多地知识点\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   首先，我们定义的状态和状态转移方程不变\n  </div>\n  <div>\n   <strong>\n    定义状态：\n   </strong>\n  </div>\n  <div>\n   dp[i]:以第i位作为结尾的最大子数组和（连续的子数组）\n  </div>\n  <div>\n   <strong>\n    状态转移方程：\n   </strong>\n  </div>\n  <div>\n   if dp[i-1]&lt;0  dp[i]=data[i]\n  </div>\n  <div>\n   else dp[i]=dp[i-1]+data[i]\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在本题中我们加入了一些处理的技巧，首先，既然是连续的，我们不妨开辟而被的连续空间形成循环的假象\n  </div>\n  <div>\n   那么在dp前n段的时候，就和我们的正常的情况一样，但是在我们dp后n段的时候，就涉及到了循环的额本质，我们可以访问之前n段的dp结果，所以就可以形成了循环的求解思路\n  </div>\n  <div>\n   在这里，我们哈需要额外开辟两个变量\n  </div>\n  <div>\n   head记录当前子数组的出发点\n  </div>\n  <div>\n   s记录当前最大子数组的长度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们在出现s&gt;=n的情况的时候，就要开始中断，然后让head右移在次计算，千万注意，这里不能以为找齐了就中断退出循环然后输出值\n  </div>\n  <div>\n   因为会出现这种情况\n  </div>\n  <div>\n   7\n  </div>\n  <div>\n   2 2 2 2 -1 2 2\n  </div>\n  <div>\n   我们在上面的情况的 时候，必须要计算所有的s为n的情况，挑选最大值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   ps:TLE的时候，记得用scanf输入不要用cin，流输入很慢\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1882124\' name=\'code\' snippet_file_name=\'blog_20160916_1_3731891\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100005\n\nusing namespace std;\n\nint n;\nint data[N*2];\nint dp[N*2];\nint s;\nint maxp=0;\nint head;\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)!=EOF)\n	{\n		for(int i=1;i&lt;=n;i++) scanf(\'%d\',&amp;data[i]);\n		for(int i=n+1;i&lt;=2*n;i++) data[i]=data[i-n];\n		\n		s=1;\n		head=1;\n		maxp=0;\n		dp[1]=data[1];\n		for(int i=2;i&lt;=2*n;i++)\n		{\n			if(s&gt;=n)\n			{\n				i=head+1;\n				head=i;\n				dp[i]=data[i];\n				s=1;\n				continue;\n			}\n			if(dp[i-1]&lt;=0) \n			{\n				dp[i]=data[i];\n				s=1;\n				head=i;\n				if(head&gt;=n+1) break;\n			}\n			else \n			{\n				dp[i]=dp[i-1]+data[i];\n				s++;\n			}\n			maxp=max(maxp,dp[i]);\n		}\n		cout&lt;&lt;maxp&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1d78cdbe4c8e63af43ad88b7bfe789c8','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ3069-贪心水\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   本体摘自《挑战程序设计2.2.4》，详情见书\n  </div>\n  <div>\n   求最少的标记点覆盖所有的点\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   我们这里采用的贪心思路是每次从起点开始贪半径，找到我们的原点之后，在贪右边，找到下一次的起点\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1882073\' name=\'code\' snippet_file_name=\'blog_20160916_1_3105110\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'algorithm\'\n#define N 1005 \n\nusing namespace std;\n\nint r,n;\nint data[N];\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;r,&amp;n)&amp;&amp;(r+n)!=-2)\n	{\n		int sum=0;\n		for(int i=1;i&lt;=n;i++) cin&gt;&gt;data[i];\n		sort(data+1,data+1+n);\n		int s=1;  //起点\n		while(s&lt;=n)\n		{\n			int i;\n			int flag;\n			for(i=s;i&lt;=n;i++)\n			{\n				if(data[s]+r&gt;=data[i]);\n				else \n				{\n					flag=i-1;\n					break;\n				}\n			}\n			sum++;\n			if(i==n+1) break; \n			for(i=flag;i&lt;=n;i++)\n			{\n				if(data[flag]+r&lt;data[i])\n				{\n					s=i;\n					break;\n				}\n			}\n			if(i==n+1) break;\n		} \n		cout&lt;&lt;sum&lt;&lt;endl;\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4d9cde1d54b5bdaa9dfdacac4267f181','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ3278-BFS容易出现思维漏洞\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   本体是标准的三个入口的BFS水题，但是细节问题太多\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   1.数组没必要太大，一旦RE了，是因为出现了这么几种情况，出现负数，因为题中声明不会有负数的出现，把负数的情况短路掉\n  </div>\n  <div>\n   还有就是我们一不小心越界，这时候，我们和上一种一样，我们需要先预判短路，再进行下标访问\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.记录数组是很有必要的，防止TLE\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.小心n，k相同点额情况，此时输出结果为0，不用BFS\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881980\' name=\'code\' snippet_file_name=\'blog_20160916_1_5503359\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1000000\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int s;\n}point;\n\nint n,k;\nint sum;\npoint queue[N];\nint head;\nint tail;\nint book[N];\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;k;\n	if(n==k) cout&lt;&lt;0&lt;&lt;endl;\n	else{\n	head=tail=1;\n	queue[1].x=n;\n	queue[1].s=0;\n	tail++;\n	memset(book,0,sizeof(book));\n	book[n]=1;\n	while(head!=tail)\n	{\n		int dx=queue[head].x+1;\n		int dy=queue[head].x-1;\n		int dz=queue[head].x*2;\n		if(dx==k||dy==k||dz==k)\n		{\n			sum=queue[head].s+1;\n			break;\n		}\n		if(dx&lt;N&amp;&amp;dx&gt;=0&amp;&amp;book[dx]==0)\n		{\n			book[dx]=1;\n			queue[tail].x=dx;\n			queue[tail++].s=queue[head].s+1;\n		}\n		if(dy&lt;N&amp;&amp;dy&gt;=0&amp;&amp;book[dy]==0)\n		{\n			book[dy]=1;\n			queue[tail].x=dy;\n			queue[tail++].s=queue[head].s+1;\n		}\n		if(dz&lt;N&amp;&amp;dz&gt;=0&amp;&amp;book[dz]==0)\n		{\n			book[dz]=1;\n			queue[tail].x=dz;\n			queue[tail++].s=queue[head].s+1;\n		}\n		head++;\n	}\n	cout&lt;&lt;sum&lt;&lt;endl;\n}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('68579480461afd9e410b96cd724c2262','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ3009-DFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   本体算是比较难的DFS搜索题目了，首先本体不能用BFS来进行搜索，因为我们每次的状态导致的地图都是不一样的改变，我们只能利用DFS来穷举，但是有的同学可能会害怕DFS在该地图自由度非常高的情况下会超时，其实大家不要担心，因为题目中已经给了我们10者个限制，这个10就是来帮助我们进行剪枝的\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   DFS穷举每一种情况，每一次碰撞记得改变地图，此外及时标准的 搜索了，DFS找最短路，还是第一次做这种题，很新颖\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881966\' name=\'code\' snippet_file_name=\'blog_20160916_1_3131176\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 22\n\nusing namespace std;\n\nint n,m;\nint map[N][N];\nint sum;\nint bx,by;\nint nn[4][2]={{1,0},{0,-1},{0,1},{-1,0}};\nint hx,hy;\n\nvoid dfs(int x,int y,int step)\n{\n	if(step&gt;10) return ;\n	for(int i=0;i&lt;4;i++)\n	{\n		int flag=0;\n		int dx=x;\n		int dy=y;\n		while(1)\n		{\n			hx=dx;\n			hy=dy;\n			dx+=nn[i][0];\n			dy+=nn[i][1];\n			if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy]==1) break;\n			if(map[dx][dy]==3)\n			{\n				sum=sum&gt;step+1?step+1:sum;\n				return ;\n			}\n			flag++;\n		}\n		if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||(flag==0&amp;&amp;map[dx][dy]==1)) continue;\n		else \n		{\n			map[dx][dy]=0;\n			dfs(hx,hy,step+1);\n			map[dx][dy]=1;\n		}\n	}\n} \n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;m,&amp;n)&amp;&amp;(n+m)!=0)\n	{\n		sum=11;\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				cin&gt;&gt;map[i][j];\n				if(map[i][j]==2) bx=i,by=j;\n			}\n		}\n	\n		map[bx][by]=0;\n		dfs(bx,by,0);\n		if(sum==11) cout&lt;&lt;-1&lt;&lt;endl;\n		else cout&lt;&lt;sum&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('470cb502a07dcdaee785823dabc6b6e7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ1321-DFS八皇后变种\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   本体是八皇后的变种题目，改为不规则的棋盘，但是还是要求每个妻子不能同行同列\n  </div>\n  <div>\n   求对于对应的棋盘和妻子个数输出所有的和法的摆放的个数\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   我们这里利用一个小技巧，我们开辟行数组和列数组，用来记录那些行和那些列别占用过\n  </div>\n  <div>\n   剩下的就是标准的DFS了\n  </div>\n  <div>\n   这里我第一次T是因为行数加错了，我们下一次直接从上一次的旗子的下一行开始摆放，这样节省时间\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881926\' name=\'code\' snippet_file_name=\'blog_20160916_1_3337241\'>#include\'iostream\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint n,k;\nchar map[10][10];\nint row[10];\nint col[10];\nint sum;\n\nvoid init()\n{\n	memset(map,0,sizeof(map));\n	memset(row,0,sizeof(row));\n	memset(col,0,sizeof(col));\n	sum=0;\n}\n\nvoid dfs(int step,int hang)\n{\n	if(step==k) \n	{\n		sum++;\n		return ;\n	}\n	for(int i=hang+1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(row[i]==1||col[j]==1||map[i][j]!=\'#\') continue;\n			else\n			{\n				row[i]=col[j]=1;\n				dfs(step+1,i); \n				row[i]=col[j]=0;\n			}\n		}\n	}\n} \n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;k)&amp;&amp;(n+k)!=-2)\n	{\n		init();\n		getchar();\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				scanf(\'%c\',&amp;map[i][j]);\n			}\n			getchar();\n		}\n		dfs(0,0);   //第0步\n		cout&lt;&lt;sum&lt;&lt;endl; \n	} \n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9a0d085d234baf4b9a58b88725bf30b1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2251-简单三维BFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   不解释三维的地图，S是起点，E是终点，如果可以逃出，输出最短路径\n  </div>\n  <div>\n   如果不能逃出，输出Trapped\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   因为是要查找最短路径，所以说，这里我们采用BFS作为我们的搜索策略，本体水，没什么难度，记得开一个六个方向的移动数组就OK了\n  </div>\n  <h2>\n   Code:32MS\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881914\' name=\'code\' snippet_file_name=\'blog_20160916_1_9730470\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 32\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n	int z;\n	int s;\n}point;\n\npoint queue[N*N*N];\nint head;\nint tail;\nint l,r,c;\nchar map[N][N][N];\nint book[N][N][N];\nint nn[6][3]={{1,0,0},{-1,0,0},{0,0,-1},{0,0,1},{0,-1,0},{0,1,0}};\nint bx,by,bz;\nint sum;\n\nbool bfs()\n{\n	memset(book,0,sizeof(book));\n	head=tail=1;\n	queue[head].x=bx;\n	queue[head].y=by;\n	queue[head].z=bz;\n	queue[head].s=0;\n	book[bz][bx][by]=1;\n	tail++;\n	while(head!=tail)\n	{\n		for(int i=0;i&lt;6;i++)\n		{\n			int dx=queue[head].x+nn[i][1];\n			int dy=queue[head].y+nn[i][2];\n			int dz=queue[head].z+nn[i][0];\n			if(dx&lt;1||dy&lt;1||dz&lt;1||dx&gt;r||dy&gt;c||dz&gt;l||book[dz][dx][dy]==1||map[dz][dx][dy]==\'#\') continue;\n			else\n			{\n				if(map[dz][dx][dy]==\'E\') \n				{\n					sum=queue[head].s+1;\n					return 1;\n				}\n				else\n				{\n					book[dz][dx][dy]=1;\n					queue[tail].x=dx;\n					queue[tail].y=dy;\n					queue[tail].z=dz;\n					queue[tail].s=queue[head].s+1;\n					tail++;\n				}\n			}\n		}\n		head++;\n	}\n	return 0;\n}\n\nint main()\n{\n	while(scanf(\'%d%d%d\',&amp;l,&amp;r,&amp;c)&amp;&amp;(l+r+c)!=0)\n	{\n		memset(map,0,sizeof(map));\n		getchar();\n		for(int i=1;i&lt;=l;i++)\n		{\n			for(int j=1;j&lt;=r;j++)\n			{\n				for(int k=1;k&lt;=c;k++)\n				{\n					scanf(\'%c\',&amp;map[i][j][k]);\n					if(map[i][j][k]==\'S\') bz=i,bx=j,by=k;\n				}\n				getchar();\n			}\n			getchar();\n		}\n		\n		if(bfs()) cout&lt;&lt;\'Escaped in \'&lt;&lt;sum&lt;&lt;\' minute(s).\'&lt;&lt;endl;\n		else cout&lt;&lt;\'Trapped!\'&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('48320f183b9fe17a517e9e53a5460fbf','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Java基础1-基本数据类型与操作\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.基本数据类型：\n  </h2>\n  <div>\n   <table align=\'center\' border=\'1\' cellpadding=\'1\' cellspacing=\'1\' height=\'600\' width=\'600\'>\n    <caption>\n     基本数据类型\n    </caption>\n    <tbody>\n     <tr>\n      <td>\n       关键字\n      </td>\n      <td>\n       位数\n      </td>\n      <td>\n       范围\n      </td>\n      <td>\n       默认值\n      </td>\n     </tr>\n     <tr>\n      <td>\n       Byte\n      </td>\n      <td>\n       8\n      </td>\n      <td>\n       -27~27+1\n      </td>\n      <td>\n       0\n      </td>\n     </tr>\n     <tr>\n      <td>\n       short\n      </td>\n      <td>\n       16\n      </td>\n      <td>\n       -215~215-1\n      </td>\n      <td>\n       0\n      </td>\n     </tr>\n     <tr>\n      <td>\n       int\n      </td>\n      <td>\n       32\n      </td>\n      <td>\n       -231~231-1\n      </td>\n      <td>\n       0\n      </td>\n     </tr>\n     <tr>\n      <td>\n       long\n      </td>\n      <td>\n       64\n      </td>\n      <td>\n       -263~263-1\n      </td>\n      <td>\n       0\n      </td>\n     </tr>\n     <tr>\n      <td>\n       float\n      </td>\n      <td>\n       32\n      </td>\n      <td>\n       3.4e-038~3.4e+038\n      </td>\n      <td>\n       0.0f\n      </td>\n     </tr>\n     <tr>\n      <td>\n       double\n      </td>\n      <td>\n       64\n      </td>\n      <td>\n       1.7e-308~1.7e+308\n      </td>\n      <td>\n       0.0d\n      </td>\n     </tr>\n     <tr>\n      <td>\n       char\n      </td>\n      <td>\n       8\n      </td>\n      <td>\n       u0000~uffff\n      </td>\n      <td>\n       u0000\n      </td>\n     </tr>\n     <tr>\n      <td>\n       boolean\n      </td>\n      <td>\n       8\n      </td>\n      <td>\n       truefalse\n      </td>\n      <td>\n       false\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <br/>\n   <br/>\n   <br/>\n   注意点：在java语言中浮点类型的变量有float和double，浮点型用来表示数据，但是float和double还是有区别的，在数据标记的时候，float后面要加上f，double数据后面要加上d\n  </div>\n  <div>\n   我们在java中要选择不溢出的情况下合适的数据类型来解决问题，开的过大不仅浪费还会增加计算的时间，开的小了有会有溢出的风险\n  </div>\n  <div>\n   对字符型变量进行复制的时候，我们常用的方法有单引号赋值，或者按照Unicode编码方式用数字进行赋值\n  </div>\n  <div>\n   <h2>\n    2.基本操作运算符：\n   </h2>\n   <div>\n    1.自增自减运算符：\n   </div>\n   <div>\n    自增自减运算符有很高的优先级，但是使用起来容易出现错误\n   </div>\n   <div>\n    自增自减运算符我们有两种模式\n   </div>\n   <div>\n   </div>\n   1.x++，x--，该表达式的含义是，我们先取x的值作为表达式的返回值然后在进行自增自减运算\n  </div>\n  <div>\n   2.++x，--x，该表达式的含义是，我们先取计算表达式，然后将计算结果作为表达式的返回值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.逻辑运算符的要点：\n  </div>\n  <div>\n   &amp;，&amp;&amp;     |，||\n  </div>\n  <div>\n   者四个运算符其实是有区别的\n  </div>\n  <div>\n   首先&amp;&amp;和||运算符具有短路的性质，只要前式计算结果满足判断情况，后者我们可以不用参与计算，直接短路掉\n  </div>\n  <div>\n   但是&amp;和|运算符会全部计算两个表达式的值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.位运算符要点：\n  </div>\n  <div>\n   移位运算符：&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;\n  </div>\n  <div>\n   前两者的移位不疑符号位，但是后者连同符号位一起位移\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   4.对象型数据类型：\n  </div>\n  <div>\n   Boolean——Boolean\n  </div>\n  <div>\n   Char——Character\n  </div>\n  <div>\n   Byte——Byte\n  </div>\n  <div>\n   Short——Short\n  </div>\n  <div>\n   Int——Integer\n  </div>\n  <div>\n   Long——Long\n  </div>\n  <div>\n   Double——Double\n  </div>\n  <div>\n   Float——Float\n  </div>\n  <div>\n   对象型的数据类型不仅存储数据还封装了相应的操作函数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   这里有个小的易混点：\n  </div>\n  <div>\n   ==运算符比较的是我们的内存的引用地址，并不是判断内容是否相同，我们要判断内容是否相同，只能用equals()方法来判断\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('f6e204f60f822e582a9b43389749744e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ3617-贪心字典序 水\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   字典序贪心，大水题，注意一下题目的输出格式就好了\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881568\' name=\'code\' snippet_file_name=\'blog_20160915_1_7842334\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 2001\n\nusing namespace std;\n\nint n;\nchar data[N];\n\nint main()\n{\n	cin&gt;&gt;n;\n	for(int i=1;i&lt;=n;i++) cin&gt;&gt;data[i];\n	int left=1;\n	int right=n;\n	int k=1;\n	while(left&lt;=right)\n	{\n		bool l=0;\n		bool r=0;\n		for(int i=1;left+i-1&lt;=right-i+1;i++)\n		{\n			if(data[left+i-1]&gt;data[right-i+1])\n			{\n				r=1;\n				break;\n			} \n			else\n			{\n				if(data[left+i-1]&lt;data[right-i+1])\n				{\n					l=1;\n					break;\n				}\n			}\n		}\n		if(l==0&amp;&amp;r==0) cout&lt;&lt;data[left++];\n		else if(l==1) cout&lt;&lt;data[left++];\n		else if(r==1) cout&lt;&lt;data[right--];\n		if(k%80==0) cout&lt;&lt;endl;\n		k++;\n	}\n	if(k%80==0) cout&lt;&lt;endl;\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c94dad4538421d140b6678605749812f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ 44 &amp; 104 - 最大连续子串和（矩阵最大子矩阵和）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.NYOJ44-最大连续子串和\n  </h2>\n  <div>\n   两种解法：\n  </div>\n  <div>\n   1.归并：（运行时间比DP长O(n*lgn),但是耗用内存小，好吧，其实dp不用开很大内存，O(1)的dp也可以解决，总体来说，dp更好一些）\n  </div>\n  <div>\n   无非三种情况，最大连续子串在mid左边，最大连续子串在mid右边，最大连续子串横跨左边和右边\n  </div>\n  <div>\n   递归调用即可\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   Code：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881495\' name=\'code\' snippet_file_name=\'blog_20160915_1_6341143\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1000005\n\nusing namespace std;\n\nint t;\nint n;\nint data[N];\nint sum;\n\nint mergesort(int left,int mid,int right)\n{\n	int leftsum=0;\n	int rightsum=0;\n	int sum=0;\n	for(int i=mid;i&gt;=left;i--)\n	{\n		sum+=data[i];\n		leftsum=max(leftsum,sum);\n	} \n	sum=0;\n	for(int i=mid+1;i&lt;=right;i++)\n	{\n		sum+=data[i];\n		rightsum=max(rightsum,sum);\n	}\n	return leftsum+rightsum;\n}\n\nint merge(int left,int right)\n{\n	int leftsum=0;\n	int rightsum=0;\n	int crosssum=0;\n	int mid=(left+right)/2;\n	if(left==right) return data[left];\n 	leftsum=merge(left,mid);\n 	rightsum=merge(mid+1,right);\n 	crosssum=mergesort(left,mid,right);\n 	if(leftsum&gt;=rightsum&amp;&amp;leftsum&gt;=crosssum) return leftsum;\n 	else if(rightsum&gt;=leftsum&amp;&amp;rightsum&gt;=crosssum) return rightsum;\n 	else return crosssum;\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		scanf(\'%d\',&amp;n);\n		for(int i=1;i&lt;=n;i++) scanf(\'%d\',&amp;data[i]);\n		printf(\'%d\n\',merge(1,n));\n	}\n	return 0;\n} </pre>\n   <br/>\n   2.DP：\n  </div>\n  <div>\n   定义状态:\n  </div>\n  <div>\n   dp[i]表示以i结尾的最大连续子串的和\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   if dp[i-1] &lt; 0   dp[i]=data[i]   //含义是，如果前面的最大连续子串和是负的，我们没必要让负值拉低我们的最大值，我们直接选取当前的元素即可\n  </div>\n  <div>\n   else  dp[i]=dp[i-1]+data[i]\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   Code：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881495\' name=\'code\' snippet_file_name=\'blog_20160915_2_6406399\'> \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1000005\n\nusing namespace std;\n\nint n;\nint data[N];\nint dp[N];\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		int m=-99999999;\n		dp[0]=0;\n		scanf(\'%d\',&amp;n);\n		for(int i=1;i&lt;=n;i++) scanf(\'%d\',&amp;data[i]);\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(dp[i-1]&gt;0) dp[i]=dp[i-1]+data[i];\n			else dp[i]=data[i];\n			m=max(m,dp[i]);\n		}\n		printf(\'%d\n\',m);\n	}\n	return 0;\n}        </pre>\n   这里我们可以优化一下，没必要开那么大的内存空间，我们直接记录前一个的数据就可以O(1)的空间复杂度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <h2>\n    NYOJ 104 矩阵最大子矩阵和\n   </h2>\n   <div>\n    Solution：\n   </div>\n   <div>\n    本题其实是上述问题的一个升级版本的变体\n   </div>\n   <div>\n    我们实际上可以将矩阵问题转化成以为问题\n   </div>\n   <div>\n    我们这样来转化，在这里我们开辟二维数组temp记录一直到每行下的每列的元素的和，那么我们只要用相应的temp减去上面的temp便可以枚举出二维矩阵的行的所有的情况，这时候，我们把行的数值当作上面NYOJ44问题的data域进行最大子列和的求解就可以了\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    Code：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1881495\' name=\'code\' snippet_file_name=\'blog_20160915_3_6264696\'> \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 105\n\nusing namespace std;\n\nint t;\nint n,m;\nint data[N][N];\nint temp[N][N];\nint dp[N];\n\nint main()\n{\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		memset(temp,0,sizeof(temp));\n		memset(dp,0,sizeof(dp));\n		int maxp=-99999999; \n		cin&gt;&gt;n&gt;&gt;m;\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				cin&gt;&gt;data[i][j];\n			}\n		}\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				temp[i][j]=temp[i-1][j]+data[i][j];\n			}\n		}\n		for(int i=1;i&lt;=n;i++)   //外层的两个循环遍历所有的行的情况 \n		{\n			for(int j=i;j&lt;=n;j++)\n			{\n				for(int k=1;k&lt;=m;k++)   //求最大连续子段和 \n				{\n					if(dp[k-1]&gt;0) dp[k]=temp[j][k]-temp[i-1][k]+dp[k-1];\n					else dp[k]=temp[j][k]-temp[i-1][k];\n					maxp=max(maxp,dp[k]);\n				}\n			}\n		}\n		cout&lt;&lt;maxp&lt;&lt;endl;\n	} \n	return 0;\n}        </pre>\n    <br/>\n    <br/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2184772f27396a64001c440b4e3f38c1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ17-LIS优化\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   求单调递增的LIS的优化方法，不要朴素的，会超时\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   定义状态：\n  </div>\n  <div>\n   dp[i]：长度为i的最长单调递增子序列的最后一个元素（保证这个元素是最小的，贪心的思路）\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   这个比较难写，我从原理的角度出发，解释一下\n  </div>\n  <div>\n   我们这里会发现，定义的这个状态一定是一个递增的序列，也就是说，我们在查找的额时候完全可以利用二分查找来优化我们的时间复杂度，二分查找最后返回的是我们第一个大于待查元素的坐标的位置，如果没有，返回总长度的加1的数值大小\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881414\' name=\'code\' snippet_file_name=\'blog_20160915_1_5950815\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 10005\n\nusing namespace std;\n\nchar dp[N];\nint len;\nint n;\nchar data[N];\n\nint bs(char k)\n{\n	int left=0;\n	int right=len-1;\n	while(left&lt;=right)\n	{\n		int mid=(left+right)/2;\n		if(dp[mid]&gt;k) right=mid-1;\n		else if(dp[mid]&lt;k) left=mid+1;\n		else return mid;\n	}\n	return left;\n}\n\nint main()\n{\n	cin&gt;&gt;n;\n	while(n--)\n	{\n		memset(data,0,sizeof(data));\n		scanf(\'%s\',data);\n		dp[0]=data[0];\n		len=1;\n		for(int i=1;i&lt;strlen(data);i++)\n		{\n			int j=bs(data[i]);\n			dp[j]=data[i];\n			if(j+1&gt;len) len=j+1;\n		}\n		cout&lt;&lt;len&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ab3aa8ddb84d04cb9ad08a5a4b99bf3a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2386-简单BFS/DFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question：\n  </h2>\n  <div>\n   对于一个图，八个方向代表相邻，求出相邻的块的个数\n  </div>\n  <h2>\n   Solution：\n  </h2>\n  <div>\n   BFS/DFS搜索，我们对图整个进行扫描，一旦发现了\'W‘，我们进入搜索函数，对周边的额八个方向整体进行扫描，并同步修改图，当我们扫描完整个图的时候，我们也就计算出来了块的个数\n  </div>\n  <h2>\n   Code：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881368\' name=\'code\' snippet_file_name=\'blog_20160915_1_3051971\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define N 105\n\nusing namespace std;\n\nint n,m;\nchar map[N][N];\nint count=0;\nint dir[8][2]={{1,0},{-1,0},{0,1},{0,-1},{-1,-1},{-1,1},{1,-1},{1,1}};\n\nvoid bfs(int x,int y)\n{\n	for(int i=0;i&lt;8;i++)\n	{\n		int dx=x+dir[i][0];\n		int dy=y+dir[i][1];\n		if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy]==\'.\') continue;\n		else\n		{\n			map[dx][dy]=\'.\';\n			bfs(dx,dy);\n		}\n	}\n}\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=m;j++)\n		{\n			cin&gt;&gt;map[i][j];\n		}\n	}\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=m;j++)\n		{\n			if(map[i][j]==\'W\')\n			{\n				map[i][j]=\'.\';\n				count++;\n				bfs(i,j);\n			}\n		}\n	}\n	cout&lt;&lt;count&lt;&lt;endl;\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('df83d3b34f7c58eeb7193f7b8db27dde','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  挑战程序设计 1.6.1\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question：\n  </h2>\n  <div>\n   给出几段长度，请将这些长度拼接成周长最大的三角形，并输出最大的周长\n  </div>\n  <h2>\n   Solution：\n  </h2>\n  <h3>\n   1.朴素解法\n  </h3>\n  <div>\n   O(n^3)时间复杂度的枚举方法，枚举所有的情况进行判断，从而选择出最优秀的那种方案\n  </div>\n  <div>\n   核心代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881335\' name=\'code\' snippet_file_name=\'blog_20160915_1_708838\'>for(int i=1;i&lt;=n;i++)\n{\n	for(int j=1;j&lt;=n;j++)\n	{\n		if(j==i) continue;\n		for(int k=1;k&lt;=n;k++)\n		{\n			if(k==i||k==j) continue;\n			else\n			{\n				count...\n			}\n		}\n	}\n}</pre>\n   <br/>\n   <h3>\n    2.优化：\n   </h3>\n  </div>\n  <div>\n   O(n*lgn)解法：\n  </div>\n  <div>\n   我们利用排序在O(n*lgn)时间复杂度内完成排序（逆序），然后从头开始取最大的三个，直到我们找不到为止\n  </div>\n  <div>\n   在这里有的同学可能要怀疑了，取最大的三个的话，不一定保证构成三角形啊\n  </div>\n  <div>\n   仔细想想就可以知道，取最大的三个就是为了保证上述的条件\n  </div>\n  <div>\n   核心代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1881335\' name=\'code\' snippet_file_name=\'blog_20160915_2_2803172\'>sort(a+1,a+n+1);\nfor(int i=1;i&lt;=n;i++)\n{\n	if(a[i]&lt;a[i+1]+a[i+2]) max=a[i]+a[i+1]+a[i+2];\n	else continue;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9cd7c0c3deb2b66eb328f935825356d7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  LCS问题求解-动态规划\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.何为LCS问题：\n  </h2>\n  <div>\n   在求解LCS问题之前，我们需要先了解一下什么叫做最长公共子序列\n  </div>\n  <div>\n   最长公共子序列：用我们最容易通俗理解的话语来解释的话，最长公共子序列就是两个或者多个串中，最长的相同的子序列\n  </div>\n  <div>\n   ps：子序列可以不连续，但是有先后的次序关系\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   LCS问题应用非常的广泛\n  </div>\n  <h2>\n   2.如何求解LCS问题：\n  </h2>\n  <div>\n   1.暴力搜索\n  </div>\n  <div>\n   LCS问题如果我们只仅限于两个的=字符串的话，我们的首先的思考的策略是暴力搜索，那么暴力搜索的复杂性到底有多大呢，我们稍微来计算一下，假设题目只让我们求两个序列的LCS，那么假设a串长是n，b串的长是m\n  </div>\n  <div>\n   那么很容易求得，a串的子序列的个数有2^n，b串的子序列的个数有2^m，那么我们对于每一种情况进行匹配的话，时间复杂度就会变成绝对无法容忍的O(2^n*2^m)指数的爆炸式增长，这是最恐怖的一点\n  </div>\n  <div>\n   那么如果我们要在k个串中查找LCS，那么这个指数式的时间是绝对无法容忍的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.动态规划：\n  </div>\n  <div>\n   动态规划对于这类求解最优解的问题，往往都可以给出多项式时间的优化算法\n  </div>\n  <div>\n   那么问题来了，LCS的DP思路是什么呢：\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   定义状态：（这里还是假设求的是两个串的LCS）\n  </div>\n  <div>\n   dp[i][j]:定义为a串第i位置b串第j位置以前的两个序列的最大的LCS，那么显而易见，dp[0][0]=0,dp[n][m]就是我们要求的最大值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   1.a[i]=b[j]   dp[i][j]=dp[i-1][j-1]+1\n  </div>\n  <div>\n   2.a[i]!=b[j]   dp[i][j]=max(dp[i-1][j],dp[i][j-1])\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   对于上面的状态转移方程的解释：\n  </div>\n  <div>\n   当i，j位置的字符匹配的时候，我们i，j位置以前的LCS就是i-1，j-1位置以前的LCS的长度+1\n  </div>\n  <div>\n   当i，j位置的字符不匹配的时候，那么LCS的长度是不会增加的，但是我们有两种选择，就是i，j-1位置以前的和i，j-1位置以前的，我们选取最大的LCS作为当前的LCS即可\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   附图好理解：\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://blog.chinaunix.net/attachment/201301/22/27767798_1358843808C4xG.png\'/>\n   <br/>\n  </div>\n  <div>\n   如上，其实使LCS长度增加的只是图上的额矩阵的对角线路径而已\n  </div>\n  <div>\n  </div>\n  <div>\n   核心代码示例：\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>for(int i=1;i&lt;=n;i++)\n{\n	for(int j=1;j&lt;=m;j++)\n	{\n		if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;\n		else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n	}\n} \n\nprint dp[n][m]</pre>\n   <br/>\n   <h2>\n    3.LCS的优化：\n   </h2>\n  </div>\n  <div>\n   我们会发现动态规划虽然可以将我们求解的指数时间复杂度问题转化成O(n*n)的多项式时间复杂度，但是我们不能沪铝的是，DP的求解速录为了能够快速得到结果，开辟了大量的空间用来保存中间结果，是的我们的空间复杂度变的很臃肿O(n*m)的空间复杂度一旦我们限制内存的大小或者我们给出的额数据的范围过于巨大的话，我们就必须考虑对LCS的DP求解思路进行空间上的优化\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   优化策略:\n  </div>\n  <div>\n   我们发现，实际上，我们在计算下一个位置之前的时候，我们最多只用到了这么一些数据dp[i-1][j],dp[i-1][j-1],dp[i][j-1],也就是说，我们最多也就只用到了i-1行和之前的dp[i][j-]的计算结果，那么我们很明显的可以发现，我们完全可以通过\n   <strong>\n    <em>\n     <u>\n      O(min(strlen(a),strlen(b)))\n     </u>\n    </em>\n   </strong>\n   的空间复杂度就可以完成整个DP的所有的操作，也就是说，我们把我们的状态压缩到一维数组\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   操作方案：\n  </div>\n  <div>\n   因为我们每次都会将新的结果覆盖到之前的一维数组之上，所以说，我们在进行计算当前的dp[i]的时候，必须提前将我们的dp[i-1](dp[i]的对角线的元素)记录下来（save）,我们最后要计算的就是这么几个情况：\n  </div>\n  <div>\n   1.当前匹配：dp[i]=save+1;\n  </div>\n  <div>\n   2.当前不匹配：dp[i-1]（刚计算完的）和dp[i]取最大值即可\n  </div>\n  <div>\n   所以说，我们这里的最核心的要点就是保存save变量\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   核心代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>for(int i=1;i&lt;=la;i++)\n		{\n			save=dp[0];\n			for(int j=1;j&lt;=lb;j++)\n			{\n				int k=dp[j];   //提取当前值 \n				if(a[i]==b[j]) dp[j]=save+1;\n				else dp[j]=max(dp[j-1],dp[j]);\n				save=k;     //save记录 \n			}\n		}\n		cout&lt;&lt;dp[lb]&lt;&lt;endl;  //注意这里要对应好 </pre>\n   <br/>\n   <h2>\n    4.例题解析：NYOJ36\n   </h2>\n  </div>\n  <div>\n   LCS版题：\n  </div>\n  <div>\n   朴素LCS dp：\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'> \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1002\n\nusing namespace std;\n\nint dp[N];\nchar a[N];\nchar b[N];\nint la;\nint lb;\nint save;\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		memset(a,0,sizeof(a));\n		memset(b,0,sizeof(b));\n		memset(dp,0,sizeof(dp));\n		scanf(\'%s\',a+1);\n		scanf(\'%s\',b+1);\n		la=strlen(a+1);\n		lb=strlen(b+1);\n		for(int i=1;i&lt;=la;i++)\n		{\n			save=dp[0];\n			for(int j=1;j&lt;=lb;j++)\n			{\n				int k=dp[j];   //提取当前值 \n				if(a[i]==b[j]) dp[j]=save+1;\n				else dp[j]=max(dp[j-1],dp[j]);\n				save=k;     //save记录 \n			}\n		}\n		cout&lt;&lt;dp[lb]&lt;&lt;endl;  //注意这里要对应好 \n	}\n	return 0;\n}        </pre>\n   <br/>\n   优化后LCS：空间复杂度O(min(a,b))\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'> \n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1002\n\nusing namespace std;\n\nint dp[N];\nchar a[N];\nchar b[N];\nint la;\nint lb;\nint save;\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		memset(a,0,sizeof(a));\n		memset(b,0,sizeof(b));\n		memset(dp,0,sizeof(dp));\n		scanf(\'%s\',a+1);\n		scanf(\'%s\',b+1);\n		la=strlen(a+1);\n		lb=strlen(b+1);\n		for(int i=1;i&lt;=la;i++)\n		{\n			save=dp[0];\n			for(int j=1;j&lt;=lb;j++)\n			{\n				int k=dp[j];   //提取当前值 \n				if(a[i]==b[j]) dp[j]=save+1;\n				else dp[j]=max(dp[j-1],dp[j]);\n				save=k;     //save记录 \n			}\n		}\n		cout&lt;&lt;dp[lb]&lt;&lt;endl;  //注意这里要对应好 \n	}\n	return 0;\n}        </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ee682def12293be7dcb77a80a60abe99','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  高精度总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Copy from others:\n  </h2>\n  <div>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     我们都知道\n     <span style=\'font-family:Arial\'>\n      int\n     </span>\n     <span style=\'font-family:宋体\'>\n      类型占\n     </span>\n     <span style=\'font-family:Arial\'>\n      32bit\n     </span>\n     <span style=\'font-family:宋体\'>\n      可表示范围：\n     </span>\n     <span style=\'font-family:Arial\'>\n      [-2147483648\n     </span>\n     <span style=\'font-family:宋体\'>\n      ，\n     </span>\n     <span style=\'font-family:Arial\'>\n      2147483647] long long\n     </span>\n     <span style=\'font-family:宋体\'>\n      类型\n     </span>\n     <span style=\'font-family:Arial\'>\n      64bit\n     </span>\n     <span style=\'font-family:宋体\'>\n      可表示范围：\n     </span>\n     <span style=\'font-family:Arial\'>\n      [-9223372036854775808\n     </span>\n     <span style=\'font-family:宋体\'>\n      ，\n     </span>\n     <span style=\'font-family:Arial\'>\n      9223372036854775807]\n     </span>\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     int\n    </span>\n    <span style=\'font-size:14px; font-family:宋体\'>\n     可以\n    </span>\n    <span style=\'font-size:14px\'>\n     完整表达\n    </span>\n    <span style=\'font-size:14px; font-family:Arial\'>\n     9\n    </span>\n    <span style=\'font-size:14px; font-family:宋体\'>\n     位数字，\n    </span>\n    <span style=\'font-size:14px; font-family:Arial\'>\n     long long\n    </span>\n    <span style=\'font-size:14px; font-family:宋体\'>\n     可以\n    </span>\n    <span style=\'font-size:14px\'>\n     完整表达\n    </span>\n    <span style=\'font-size:14px; font-family:Arial\'>\n     18\n    </span>\n    <span style=\'font-size:14px; font-family:宋体\'>\n     位。（\n    </span>\n    <span style=\'font-size:14px\'>\n     完整表达的意思是能表示到该位的任意数字）\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     当我们想表达到成千上万位的数时，\n     <span style=\'font-family:Arial\'>\n      int\n     </span>\n     <span style=\'font-family:宋体\'>\n      、\n     </span>\n     <span style=\'font-family:Arial\'>\n      long long\n     </span>\n     <span style=\'font-family:宋体\'>\n      都不再适合。所以我们便引入高精度的概念。\n     </span>\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     <strong>\n      <span style=\'white-space:pre\'>\n      </span>\n      所谓高精度就是用数组来充当数字的容器。开辟若干个空间，每个单元内存放固定数目的数据。\n     </strong>\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     <span style=\'white-space:pre\'>\n     </span>\n     高精度常用的方法主要有：不压缩法、压缩\n     <span style=\'font-family:Arial\'>\n      4\n     </span>\n     <span style=\'font-family:宋体\'>\n      位法、和压缩\n     </span>\n     <span style=\'font-family:Arial\'>\n      9\n     </span>\n     <span style=\'font-family:宋体\'>\n      位的方法。\n     </span>\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <strong>\n      不压缩法：\n     </strong>\n     主要是用\n     <span style=\'font-family:Arial\'>\n      char\n     </span>\n     <span style=\'font-family:宋体\'>\n      类型开辟的数组，每个元素内存放一位数字。\n     </span>\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <strong>\n     <span style=\'font-size:14px\'>\n      例如：\n     </span>\n    </strong>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     <span style=\'white-space:pre\'>\n     </span>\n     2156897546\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     用普通不压缩方法存储，其数据结构为：\n    </span>\n   </p>\n   <table align=\'center\' border=\'1\' cellpadding=\'1\' cellspacing=\'1\' style=\'color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\' width=\'200\'>\n    <tbody>\n     <tr>\n      <td style=\'text-align:center\'>\n       6\n      </td>\n      <td style=\'text-align:center\'>\n       4\n      </td>\n      <td style=\'text-align:center\'>\n       5\n      </td>\n      <td style=\'text-align:center\'>\n       7\n      </td>\n      <td style=\'text-align:center\'>\n       9\n      </td>\n      <td style=\'text-align:center\'>\n       8\n      </td>\n      <td style=\'text-align:center\'>\n       6\n      </td>\n      <td style=\'text-align:center\'>\n       5\n      </td>\n      <td style=\'text-align:center\'>\n       1\n      </td>\n      <td style=\'text-align:center\'>\n       2\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <br/>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <strong>\n      注意：\n     </strong>\n     此时数组中存放的是数值并不是ASCll对应的字符！之所以倒序存放是为了便于以后进行运算时溢位的情况。\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <strong>\n      压缩4位法：\n     </strong>\n     用int类型开辟的数组，每个元素内存放四位数字。\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     ps：为什么是四位呢？因为int类型能完整表达9位以内的任何数字。而存储四位数字是因为在进行乘法运算时，很可能会存在四位×四位的情况，而其结果不会超过八位。int类型完全可以存储。如果存放四位以上的数字的时候，int不能完整的存放其结果，因而无法正确计算。\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     例如：\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     <span style=\'white-space:pre\'>\n     </span>\n     2156897546\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     用压缩4方法存储，其数据结构为：\n    </span>\n   </p>\n   <table align=\'center\' border=\'1\' cellpadding=\'1\' cellspacing=\'1\' style=\'color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\' width=\'200\'>\n    <tbody>\n     <tr>\n      <td style=\'text-align:center\'>\n       7546\n      </td>\n      <td style=\'text-align:center\'>\n       5689\n      </td>\n      <td style=\'text-align:center\'>\n       21\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <br/>\n    <span style=\'font-size:14px\'>\n     <strong>\n      特点：\n     </strong>\n     自右向左每选取4位存放至数组一个单元内。最后不够的单独放一个空间。（四位内部还是正序的，总体是逆序的）\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <strong>\n      压缩9位法：\n     </strong>\n     与压缩4位法大致相同，区别在于存放的数组是用long long类型开辟的，每个元素内存放9位数字。\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     例如：\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     <span style=\'white-space:pre\'>\n     </span>\n     2156897546\n    </span>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\'>\n    <span style=\'font-size:14px\'>\n     用压缩9方法存储，其数据结构为：\n    </span>\n   </p>\n   <table align=\'center\' border=\'1\' cellpadding=\'1\' cellspacing=\'1\' style=\'color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:15px; line-height:35px\' width=\'200\'>\n    <tbody>\n     <tr>\n      <td style=\'text-align:center\'>\n       156897546\n      </td>\n      <td style=\'text-align:center\'>\n       21\n      </td>\n     </tr>\n    </tbody>\n   </table>\n   <br/>\n  </div>\n  <h2>\n   My C++ Code for the Big Number Class:(ready for fix it)\n  </h2>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'math.h\'\n\nusing namespace std;\n\n/*\n常用的压缩系数是4位压缩：4*4位数不会爆过int型的范围\n还有9*9位数压缩使用long long来进行压缩存储的，因为9*9位数不会爆过long long的18位 \n\n这里有个知识点就是，我们压缩存储的时候虽然整体上是逆序的，但是在每个元素块内我们正序表示\n该位上的数字 \n*/\n\nclass errorfull{};\n\nvoid reverse(char des[])   //功能函数，反转字符串\n{\n	int i=0;\n	int j=strlen(des)-1;\n	while(i&lt;j)\n	{\n		char t=des[i];\n		des[i]=des[j];\n		des[j]=t;\n		i++;\n		j--;\n	} \n} \n\nclass Big_Number   //类采用4位压缩的方式进行存储，所以是int型，本例通过，修改为模板类，任意控制压缩类型 \n{\n	public:\n    	Big_Number()\n    	{\n	    	memset(data,0,sizeof(data));\n		    length=0;\n    	} \n    	Big_Number(char[]);   //重载构造函数，用字符串构造大数 \n    	Big_Number(int);      //重载大整形构造大数 \n    	void clear()\n    	{\n    		memset(data,0,sizeof(data));\n		    length=0;\n    	}\n    	friend ostream&amp; operator&lt;&lt;(ostream&amp;,Big_Number&amp;);   //重载流输出，大数的输出\n    	bool operator &gt; (Big_Number&amp;);\n		bool operator &lt; (Big_Number&amp;);\n        bool operator == (Big_Number&amp;);\n        Big_Number operator = (Big_Number&amp;);\n		Big_Number Big_Add(Big_Number&amp;,Big_Number&amp;);     //大数相加，这里没有用const修饰，封装性被破坏 \n		Big_Number Big_Del(Big_Number&amp;,Big_Number&amp;);     //大数相减，默认大数在前小数在后\n		Big_Number Big_Mul(Big_Number&amp;,Big_Number&amp;);     //大数想乘\n		//大数乘以小整数可以转化为重新构造大数进行上面的大数想乘的操作\n		Big_Number Big_Power(int,int);    //快速幂实现数据量的的幂次的加速计算 \n		//Big_Number Big_\n	private:\n		static const int max_volume = 100;   //设置最大容量，可以调节 \n		static const int power = 4;   //压缩系数\n		static const int base = 10000;   //进制，随压缩系数 \n		int data[max_volume];    //这里设置大数的容量是100*4=400位，可以调节 \n		int length;   //大数的长度，因为涉及到压缩存储，所以长度在不同的压缩系数下是不一样的\n};\n\nostream&amp; operator&lt;&lt;(ostream&amp; out,Big_Number&amp; des)\n{\n	cout&lt;&lt;\'该大数数据结构有如下描述:\'&lt;&lt;endl;\n	cout&lt;&lt;\'大数的存储位数\'&lt;&lt;des.length&lt;&lt;endl;\n	cout&lt;&lt;\'该大数如下:\'&lt;&lt;endl;\n	for(int i=des.length-1;i&gt;=0;i--) \n	{\n		if(i!=des.length-1)\n		{\n			for(int k=10;k&lt;=pow(10,des.power);k*=10)\n			{\n				if(des.data[i]&lt;k) \n				{\n					for(int j=pow(10,des.power-1);j&gt;=k;j/=10) cout&lt;&lt;\'0\';\n					cout&lt;&lt;des.data[i];\n					break;\n				}\n			}\n		} \n		else cout&lt;&lt;des.data[i];\n	}\n	cout&lt;&lt;endl;\n	return out;\n} \n\nBig_Number::Big_Number(char des[])   //这里有个知识点，C++的流输出支持反转之后的识别正确，strlen函数也支持 \n{\n	memset(data,0,sizeof(data));\n	length=0;\n	reverse(des);\n	int length=strlen(des);\n	\n	int forpower=1;\n	for(int i=0;i&lt;strlen(des);i++)\n	{\n		if(forpower%base==0) this-&gt;length++,forpower=1;   //按照压缩的位数进行相应的存储，和初始化操作 \n		this-&gt;data[this-&gt;length]+=(des[i]-\'0\')*forpower;\n		forpower*=10;\n	}\n	this-&gt;length++;\n}\n\nBig_Number::Big_Number(int des)\n{\n	memset(data,0,sizeof(data));\n	length=0;\n	int forpower=1;    //和上面的思路是差不多一致的 \n	while(des!=0)\n	{\n		int x=des%10;\n		if(forpower%base==0) this-&gt;length++,forpower=1;\n		this-&gt;data[this-&gt;length]+=forpower*x;\n		forpower*=10;\n		des/=10;\n	}\n	this-&gt;length++;   //位数和长度是不一样的 \n} \n\nBig_Number 	Big_Number::Big_Add(Big_Number&amp; x,Big_Number&amp; y)\n{\n	Big_Number result;\n	int max_len = x.length &gt; y.length ? x.length : y.length;\n	for(int i=0;i &lt; max_len;i++)\n	{\n		result.data[i]+=x.data[i]+y.data[i];\n		try\n		{\n			int k=result.data[i]/base;\n			int w=result.data[i]%base;\n			if(k!=0 &amp;&amp; i==max_volume) throw errorfull();\n			else result.data[i+1] = k,result.data[i] = w;\n		}\n		catch(errorfull p)\n		{\n			cout&lt;&lt;\'加和结果上界溢出，请修改最大容量max_volume\'&lt;&lt;endl; \n			result.clear();\n			return result;\n		}\n	}\n	if(result.data[max_len] !=0 ) result.length=max_len+1;    //判断最终的假发是否进位 \n	else result.length=max_len;\n	return result; \n}\n\nBig_Number Big_Number::Big_Del(Big_Number&amp; x,Big_Number&amp; y)    //默认x比y大来进行计算 ,如果不够了，我们向前借位，最终我们整体判断一下有没有附属的情况出现，如果出现了我们修正就好 \n{\n    Big_Number result;\n	for(int i=0;i &lt; x.length;i++) result.data[i]=x.data[i]-y.data[i];\n	for(int i=0;i &lt; x.length;i++)\n	{\n		if(result.data[i] &lt; 0)\n		{\n			result.data[i+1]--;\n			result.data[i]+=base;   //加上进制弥补复负差 \n		} \n	}\n	int k=x.length-1;\n	while(result.data[k]==0 &amp;&amp; k &gt;= 0) k--;    //从头开始查找，防止出现减位的情况 \n	if(k &lt; 0) result.length=0;\n	else result.length=k+1;   //长度和位长不是等价的，这一点要小心 \n	\n	return result;\n}\n\nBig_Number Big_Number::Big_Mul(Big_Number&amp; x,Big_Number&amp; y)\n{\n	Big_Number result;\n	for(int i=0;i&lt;x.length;i++)\n	{\n		for(int j=0;j &lt; y.length;j++)\n		{\n			result.data[i+j] += x.data[i] * y.data[j];   //important \n			result.data[i+j+1] += result.data[i+j] / base;\n			result.data[i+j] = result.data[i+j] % base;\n		}\n	}\n	result.length=x.length+y.length-1;\n	if(result.data[result.length]) result.length++;\n	return result;\n}\n\nBig_Number Big_Number::Big_Power(int x,int y)   //x为底数，y是指数 \n{\n	Big_Number result;\n	Big_Number a(x);\n	Big_Number b(y);\n	Big_Number ans(1);\n	while(y != 0) \n	{\n		if( y &amp; 1 ) ans = Big_Mul(ans,a);   //n是奇数，此时按照快速幂的定义先乘上 \n		a = Big_Mul(a,a);\n		y = y &gt;&gt; 1;\n	}\n	return ans; \n}\n\nbool Big_Number::operator &gt; (Big_Number&amp; x)\n{\n	if(length&gt;x.length) return true;\n	else if(length&lt;x.length) return false;\n	else \n	{\n		for(int i=length-1;i&gt;=0;i--)\n		{\n			if(data[i]&gt;x.data[i]) return true;\n			else if(data[i]&lt;x.data[i]) return false;\n			else continue;\n		}\n	}\n	return false;\n}\n\nbool Big_Number::operator &lt; (Big_Number&amp; x)\n{\n	if(length&gt;x.length) return false;\n	else if(length&lt;x.length) return true;\n	else \n	{\n		for(int i=length-1;i&gt;=0;i--)\n		{\n			if(data[i]&gt;x.data[i]) return false;\n			else if(data[i]&lt;x.data[i]) return true;\n			else continue;\n		}\n	}\n	return false;\n}\n\nbool Big_Number::operator == (Big_Number&amp; x)\n{\n	if(length&gt;x.length) return false;\n	else if(length&lt;x.length) return false;\n	else \n	{\n		for(int i=length-1;i&gt;=0;i--)\n		{\n			if(data[i]&gt;x.data[i]) return false;\n			else if(data[i]&lt;x.data[i]) return false;\n			else continue;\n		}\n	}\n	return true;\n}\n\nBig_Number Big_Number::operator = (Big_Number&amp; x)\n{\n	Big_Number a;\n	for(int i=0;i&lt;x.length;i++) a.data[i]=x.data[i];\n	a.length=x.length;\n	return a;\n}\n\nint main()\n{\n	char dadamrx[1005];\n	scanf(\'%s\',dadamrx);\n	Big_Number lantian(dadamrx);\n	Big_Number wanggeyuan(2376347);\n	Big_Number guojianan;\n	\n	cout&lt;&lt;guojianan&lt;&lt;endl;\n	guojianan = guojianan.Big_Add(lantian,wanggeyuan);\n	//guojianan = guojianan.Big_Mul(lantian,wanggeyuan);\n	//guojianan=guojianan.Big_Power(9,15);\n	bool xuhengda=lantian&gt;wanggeyuan;\n	cout&lt;&lt;xuhengda&lt;&lt;endl;\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('5ca2146b550ba69b1bfa2bb652edbcc1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ995-经典DP\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   输入：\n  </div>\n  <div>\n   n，v分别代表硬币系统中的面值的种类数目和要凑的零钱的总数\n  </div>\n  <div>\n   之后n个数字代表硬币系统\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   输出：\n  </div>\n  <div>\n   如果可以通过该硬币系统找零，请求出最少需要的硬币个数，否则输出最好的情况下，我们还剩下多少的硬币没有找（最小值）\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   经典的动态规划思想\n  </div>\n  <div>\n   定义状态：\n  </div>\n  <div>\n   DP[i]代表找i零钱需要的最少的硬币的个数，如果不能找的话，DP[i]就是-1\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   DP[i]=min(DP[i-count[j]])+1\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   PS:本题的难点在于我们如何处理不存在的情况，其实我们加上判断语句就好\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1877190\' name=\'code\' snippet_file_name=\'blog_20160912_1_3753531\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdio\'\n#define N 100005\n\nusing namespace std;\n\nint count[60];\nint dp[N];\nint n,v;\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;v)&amp;&amp;(n+v)!=0)\n	{\n		for(int i=1;i&lt;=n;i++) \n		{\n			cin&gt;&gt;count[i];\n		}\n		memset(dp,0,sizeof(dp));\n		for(int i=1;i&lt;=v;i++)\n		{\n			int temp=99999999;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(i-count[j]&gt;= 0&amp;&amp;dp[i-count[j]]!=-1)\n				temp=min(temp,dp[i-count[j]]);\n			}\n			if(temp!=99999999) dp[i]=temp+1;\n			else dp[i]=-1;\n		}\n		int i=v;\n		while(dp[i]==-1&amp;&amp;i&gt;1) i--;\n		if(i==1) cout&lt;&lt;n&lt;&lt;endl;\n		else cout&lt;&lt;dp[i]&lt;&lt;endl;\n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1a774fa11cbcf4e6aaa04c0e27064bac','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ214-LIS优化\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   标准的LIS问题，最长公共子序列求最长的子序列的长度\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   本题考得不是我们朴素的O(n*2)的动态规划的思路，本题考查的是LIS的O(n*lgn)的优化思路\n  </div>\n  <div>\n   在大数据10 0000的数据量下，朴素的动态规划明显超时\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Code1:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1876874\' name=\'code\' snippet_file_name=\'blog_20160912_1_5290009\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 100005\n\nusing namespace std;\n\nint n;\nint data[N];\nint dp[N];\nint maxp;\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)!=EOF)\n	{\n		maxp=1;\n		for(int i=1;i&lt;=n;i++) cin&gt;&gt;data[i];\n		for(int i=1;i&lt;=n;i++) dp[i]=1;\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=i-1;j&gt;=1;j--)\n			{\n				if(data[i]&gt;data[j]) \n				{\n					dp[i]=max(dp[i],dp[j]+1);\n					maxp=max(maxp,dp[i]);\n					break;\n				} \n			}\n		}\n        cout&lt;&lt;maxp&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <div>\n    <br/>\n   </div>\n   优化的思路在于有序的DP数组创造了二分查找的良好条件\n  </div>\n  <div>\n   首先我们重新定义\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   定义状态：\n  </div>\n  <div>\n   DP[i]:以i为长度的公共子序列的最后一个元素（也就是该子序列的最大的元素），这里有个注意点，我们二分查找的是下界，也就是说，我们最后是要找到的位置的DP元素是小于等于我们的待查元素的，这一点的目的是为了尽可能的将我们的DP数组的变动追踪到最开始的位置，优点贪心的思路，目的是为了让我们下一次找到的子序列是最优的\n  </div>\n  <div>\n   通过该方法，我么发现，这样的定义的DP数组元素是递增的，也就很好的满足了我们的二分查找的有序条件，从而优化我们回溯的时间复杂度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   每次查找相对应的位置，然后对元素进行更新\n  </div>\n  <h2>\n   Code2:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1876874\' name=\'code\' snippet_file_name=\'blog_20160912_2_7688797\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 100015\n\nusing namespace std;\n\nint n;\nint dp[N];\nint data[N];\nint len;\n\nint binarysearch(int p)\n{\n	int left=1;\n	int right=len;\n	while(left&lt;=right)\n	{\n		int mid=(right+left)/2;\n		if(p&gt;dp[mid]) left=mid+1;\n		else if(p&lt;dp[mid]) right=mid-1;\n		else return left;\n	} \n	return left;\n}\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)!=EOF)\n	{\n		memset(dp,0,sizeof(dp));\n		for(int i=1;i&lt;=n;i++) cin&gt;&gt;data[i];\n		dp[1]=data[1];\n		len=1;\n		for(int i=2;i&lt;=n;i++)\n		{\n			int k=binarysearch(data[i]);\n			dp[k]=data[i];\n			if(k&gt;len) len=k;\n		}\n		cout&lt;&lt;len&lt;&lt;endl;\n	} \n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('dfee847ead718245d5fcb3711d2313b4','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ18-动态规划水\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   经典的数塔问题，我们经典的额dp求解思路\n  </div>\n  <h2>\n   Solution1:\n  </h2>\n  <div>\n   从上往下\n  </div>\n  <div>\n   定义状态：DP[I][j]在第i层的第j位置处，我们的路径上的最优的价值\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   DP[i][j]=max(DP[i-1][j],DP[i-1][j-1])+map[i][j]\n  </div>\n  <h2>\n   Code1:\n  </h2>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 105\n \nusing namespace std;\n \nint dp[N][N];\nint map[N][N];\nint n;\nint maxk;\n \nint main()\n{\ncin&gt;&gt;n;\nfor(int i=1;i&lt;=n;i++)\n{\nfor(int j=1;j&lt;=i;j++)\n{\ncin&gt;&gt;map[i][j];\n}\n}\nmemset(dp,0,sizeof(dp));\ndp[1][1]=map[1][1];\nfor(int i=1;i&lt;=n;i++)\n{\nfor(int j=1;j&lt;=i;j++)\n{\nif(j!=i&amp;&amp;j!=1) dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+map[i][j];\nelse if(j==i) dp[i][j]=dp[i-1][i-1]+map[i][j];\nelse dp[i][j]=dp[i-1][j]+map[i][j];\n}\n}\nmaxk=0;\nfor(int i=1;i&lt;=n;i++) maxk=max(maxk,dp[n][i]);\nprintf(\'%d\n\',maxk);\nreturn 0;\n}</pre>\n   <br/>\n   <h2>\n    Solution2:\n   </h2>\n  </div>\n  <div>\n   从下到上：\n  </div>\n  <div>\n   改思路明显优于上一点的就是，我们最后不需要遍历一遍最底层，因为我们的从下到上的最优的解就在DP[1][1]中\n  </div>\n  <h2>\n   Code2：\n  </h2>\n  <div>\n   基础方法4Ms，优化后0Ms\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1876640\' name=\'code\' snippet_file_name=\'blog_20160911_2_3152159\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n\nusing namespace std;\n\nint n;\nint map[105][105];\nint dp[105][105];\n\nint main()\n{\n	cin&gt;&gt;n;\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=i;j++)\n		{\n			cin&gt;&gt;map[i][j];\n		}\n	}\n	for(int i=1;i&lt;=n;i++)\n	{\n		dp[n][i]=map[n][i];\n	}\n	for(int i=n-1;i&gt;=1;i--)\n	{\n		for(int j=1;j&lt;=i;j++)\n		{\n			dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+map[i][j];\n		}\n	}\n	cout&lt;&lt;dp[1][1]&lt;&lt;endl;\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('02bea7215c3728317068fe911def129b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ252-动态规划水\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   给出定义01串，01串中不存在11这种子串，求长度为n的01串中满足定义的要求的01串的个数是多少\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   思考之后，发现其实是标准的斐波那契数列\n  </div>\n  <div>\n   首先定义状态：\n  </div>\n  <div>\n   DP[i]:长度为i的01串中满足条件的01串的个数是多少\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态转移方程:\n  </div>\n  <div>\n   DP[i]=DP[i-1]+DP[i-2]\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   这么理解：\n  </div>\n  <div>\n   1.当前的第i位是1的时候，为了不出现11的情况，那么我们就必须保证第i-1位是0，那么我们最大就要开始从i-2为进行计算\n  </div>\n  <div>\n   2.当前的第i为是0的时候，为了考虑所有的情况，我们开始从i-1为进行计算\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1876595\' name=\'code\' snippet_file_name=\'blog_20160911_1_9096293\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 105\nusing namespace std;\n\nint dp[N];\nint n;\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	dp[1]=2;\n	dp[2]=3;\n	for(int i=3;i&lt;=40;i++) dp[i]=dp[i-1]+dp[i-2];\n	while(t--)\n	{\n		cin&gt;&gt;n;\n		cout&lt;&lt;dp[n]&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('cd6d50cd369e7c03be1b37bbe08c8516','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU2602-01背包基础\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   输入：首先输入测试用例的个数\n  </div>\n  <div>\n   其次一次输入物品的个数N和背包容量V\n  </div>\n  <div>\n   随后输入的n个数代表每个物品价值\n  </div>\n  <div>\n   最后的输入的n个数代表每个物品的体积\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   要求输出背包最多可以携带多大价值的物品\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Solution1:\n  </h2>\n  <div>\n   01背包的思想：\n  </div>\n  <div>\n   定义状态：\n  </div>\n  <div>\n   DP[i][j]：代表在背包的容量为j的情况下，在取第i个物品的时候，我们最大可以携带的物品的总价值\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态转移方程：\n  </div>\n  <div>\n   if  j&gt;volume[i](代表目前的容量可以装进去)   DP[i][j]=max(DP[i-1][j],DP[i-1][j-volume[i]]+value[i])\n  </div>\n  <div>\n   else DP[i][j]=DP[i-1][j](代表如果目前装不进去物品i，那么我们的最大容量和上一级相同)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   PS：本题需要注意，因为本题中的物品可能会存在体积为0的情况，这时候我们是无条件会选择装填的，小心着个用例就好\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Code1:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1876505\' name=\'code\' snippet_file_name=\'blog_20160911_1_121495\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'math.h\'\n#define N 1005\n\nusing namespace std;\n\nint t;\nint n,v;\nint dp[N][N];\nint value[N];\nint volume[N];\n\nint maxp(int x,int y)\n{\n    if(x&gt;y) return x;\n    else return y;\n}\n\nint main()\n{\n    cin&gt;&gt;t;\n    while(t--)\n    {\n        cin&gt;&gt;n&gt;&gt;v;\n        for(int i=1;i&lt;=n;i++) cin&gt;&gt;value[i];\n        for(int i=1;i&lt;=n;i++) cin&gt;&gt;volume[i];\n        memset(dp,0,sizeof(dp));\n        for(int i=1;i&lt;=n;i++)\n        {\n            for(int j=0;j&lt;=v;j++)\n            {\n                if(j&gt;=volume[i]) dp[i][j]=maxp(dp[i-1][j],dp[i-1][j-volume[i]]+value[i]);\n                else dp[i][j]=dp[i-1][j];\n            }\n        }\n        cout&lt;&lt;dp[n][v]&lt;&lt;endl;\n    }\n    return 0;\n}</pre>\n   <br/>\n   <h2>\n    Solution2:\n   </h2>\n  </div>\n  <div>\n   同为背包的思想，但是我们在进行背包的思路步骤的同时我们会发现，我们开辟的背包是二维的，但是我们的数组再从物品1耿总导物品n的过程中会发现，我们本级的总价值相对于相对于上一级是会只增不减的，那么这就意味着，我们对于该二维DP是可以优化的，也就是说，我们完全可以用以为的DP数组来公董模拟二维的数组的情况，大大的优化我们的空间复杂度\n  </div>\n  <div>\n   另外，我们在进行计算的时候没必要对背包的容量从0开始跑到最大容量V，我们直接从volume[i]开始跑就可以了，因为在volume[i]之前我们始终是跟从上一级的背包价值的，只有从volume[i]开始我们才开始更新优化的判断，这样的话，我们还可以优化时间复杂度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   最后根据HDU上的实战测试，上一种基本的方法耗时126Ms，而优化之后我们的不仅小号了更少的内存，并且运行时间优化到96Ms\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Code2：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1876505\' name=\'code\' snippet_file_name=\'blog_20160911_2_9881514\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'math.h\'\n#define N 1005\n\nusing namespace std;\n\nint t;\nint n,v;\nint dp[N];\nint value[N];\nint volume[N];\n\nint maxp(int x,int y)\n{\n	if(x&gt;y) return x;\n	else return y;\n}\n\nint main()\n{\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		cin&gt;&gt;n&gt;&gt;v;\n		for(int i=1;i&lt;=n;i++) cin&gt;&gt;value[i];\n		for(int i=1;i&lt;=n;i++) cin&gt;&gt;volume[i];\n		memset(dp,0,sizeof(dp));\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=v;j&gt;=volume[i];j--)\n			{\n 				if(j&gt;=volume[i]) dp[j]=maxp(dp[j],dp[j-volume[i]]+value[i]);\n			}\n		}\n		cout&lt;&lt;dp[v]&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ac1342f5c978ecefeb2b2c1723e480f6','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2488——简单DFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question:\n  </h2>\n  <div>\n   题目中给出了国际象棋的地图，要求我们将马按照他的走子方式进行移动，能够将整个棋盘走遍则我们将走姿方式按照字典序进行输出，否则输出impossible\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   <img alt=\'\' src=\'http://hi.csdn.net/attachment/201107/30/0_1312045975wCTo.gif\'/>\n   <br/>\n  </div>\n  <div>\n   本题主要考察的是方向数组的顺序，首先，我们需要明确一点，如果我们要按照字典序进行输出的话并且还要踩遍整个棋盘，我们那必定会经过A1点，所以说我们的顺序必定是开头是A1的一组字典序顺序\n  </div>\n  <div>\n   按照上图的方向数组的选择方式我们可以轻松的是实现个路径记录的DFS\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n}point;\n\npoint queue[30*30];\nint nownum;\nint p,q;\nint book[30][30];\nint move[8][2]={{-1,-2},{1,-2},{-2,-1},{2,-1},{-2,1},{2,1},{-1,2},{1,2}};\n\nbool dfs(int x,int y)\n{\n	if(nownum==p*q) return true;\n	for(int i=0;i&lt;8;i++)\n	{\n		int dx=x+move[i][0];\n		int dy=y+move[i][1];\n		if(dx&lt;1||dx&gt;p||dy&lt;1||dy&gt;q||book[dx][dy]==1) continue;\n		else\n		{\n			book[dx][dy]=1;\n			queue[++nownum].x=dx;\n			queue[nownum].y=dy;\n			if(dfs(dx,dy)) return true;\n			else\n			{\n				nownum--;\n				book[dx][dy]=0;\n			}\n		} \n	}\n	return false;\n}\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	int j=1;\n	while(t--)\n	{\n		memset(book,0,sizeof(book));\n		memset(queue,0,sizeof(queue));\n		nownum=0;\n		cin&gt;&gt;p&gt;&gt;q;\n		cout&lt;&lt;\'Scenario #\'&lt;&lt;j&lt;&lt;\':\'&lt;&lt;endl;\n		j++;\n		book[1][1]=1;\n		queue[1].x=queue[1].y=1;\n		nownum++;\n		if(dfs(1,1))\n		{\n			for(int i=1;i&lt;=p*q;i++) printf(\'%c%d\',(char)(queue[i].y+64),queue[i].x);\n			cout&lt;&lt;endl;\n		}\n		else cout&lt;&lt;\'impossible\'&lt;&lt;endl;\n		if(t!=0) cout&lt;&lt;endl; \n	}\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2d55a7fd609f58667330bfad4ef552b5','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ3253——哈夫曼思想的优先队列\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   Question：\n  </h2>\n  <div>\n   给一串数，求出哈夫曼树的总代价\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Solution:\n  </h2>\n  <div>\n   贪心的哈夫曼思想，我们利用对来进行优先队列的维护\n  </div>\n  <div>\n   ps:本题中因为虽然限定了每个木块的长度在int型范围内，但是随着我们不断的加和，该数值会超过int的范围，所以说我们用long long 来八寸最后的统计结果，不然会爆掉\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   Code:\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1875875\' name=\'code\' snippet_file_name=\'blog_20160911_1_7329077\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define N 21010\nusing namespace std;\n\nlong long heap[N];\nlong long n,heapnum,sum;\n\nvoid swapk(long long x,long long y)\n{\n	long long k=heap[x];\n	heap[x]=heap[y];\n	heap[y]=k;\n}\n\nvoid siftdown(int i)\n{\n	int t=i;\n	while(i*2&lt;=heapnum)\n	{\n		if(heap[i]&gt;heap[i*2]) t=i*2;\n		else t=i;\n		if(i*2+1&lt;=heapnum&amp;&amp;heap[i*2+1]&lt;heap[t]) t=i*2+1;\n		if(i!=t)\n		{\n			swapk(i,t);\n			i=t;\n		} \n		else break;\n 	}\n}\n\nint main()\n{\n	scanf(\'%I64d\',&amp;n);\n	for(int i=1;i&lt;=n;i++) scanf(\'%I64d\',&amp;heap[i]);\n	heapnum=n;\n	for(int i=n/2;i&gt;=1;i--) siftdown(i);\n	sum=0;\n    	while(heapnum&gt;1)\n    	{\n	    	long long k=heap[1];\n	    	heap[1]=heap[heapnum];\n	    	heapnum--;\n	    	siftdown(1);\n	    	k+=heap[1];\n	    	heap[1]=k;\n	    	siftdown(1); \n	    	sum+=k;\n    	}\n    	printf(\'%I64d\n\',sum);\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('d00a87a06b466c626d073a017b9fee3a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  2016BIT小学期——博弈DP（污神Alice和Bob）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述：\n  </h2>\n  <div>\n   <h1>\n    <strong>\n     <br/>\n    </strong>\n   </h1>\n   <div>\n    <strong>\n    </strong>\n    <div class=\'box intro\' id=\'yui_3_17_2_1_1473520886849_103\'>\n     <div class=\'no-overflow\' id=\'yui_3_17_2_1_1473520886849_102\'>\n      <p>\n       Alice: 上课好无聊啊！！！\n      </p>\n      <p>\n       Bob：那你想干嘛？\n      </p>\n      <p>\n       Alice：我们来玩游戏好伐？\n      </p>\n      <p>\n       Bob：好哇！咋玩？\n      </p>\n      <p>\n       Alice：我们写n个正整数，然后轮流拿数字，每次可以拿任意多个，每次的得分是这次拿的数字中的最小值，我们俩每次拿数都要让自己的得分与对方的得分差值最大化，我俩试着拿一拿看看最后我比你高多少分吧~\n      </p>\n      <p>\n       Bob：我拒绝，这明明O(瞬间)就知道答案了为啥还要玩儿\n      </p>\n      <p>\n       Alice：哇你好厉害，那我写n个数你说按刚才的策略，我先拿，最后比你高多少分，你要是答对了我就嘻嘻嘻\n      </p>\n      <p>\n       Bob：好，你等着，嘿嘿嘿\n      </p>\n      <p>\n       <strong>\n        输入\n       </strong>\n      </p>\n      <p>\n       第一行输入一个整数T表示用例组数，每组用例第一行输入一个整数n表示要拿的正整数个数，之后输入n个正整数ai\n      </p>\n      <p>\n       <strong>\n        输出\n       </strong>\n      </p>\n      <p>\n       每组用例输出一个整数占一行，表示两人按游戏策略拿完所有数字后Alice比Bob高多少分\n      </p>\n      <p>\n       <strong>\n        数据范围\n       </strong>\n      </p>\n      <p>\n       1&lt;=T&lt;=10,1&lt;=n&lt;=50000,1&lt;=ai&lt;=10^9\n      </p>\n      <p>\n       <strong>\n        样例输入\n       </strong>\n      </p>\n      <p>\n       1\n      </p>\n      <p>\n       3\n      </p>\n      <p>\n       1 3 1\n      </p>\n      <p>\n       <strong>\n        样例输出\n       </strong>\n      </p>\n      <p>\n       2\n      </p>\n      <p>\n       <strong>\n        样例解释\n       </strong>\n      </p>\n      <p>\n       Alice拿3，Bob拿1 1，最后两者得分差值是3-1=2\n      </p>\n     </div>\n    </div>\n    <div class=\'box testcase-table\'>\n     <table class=\'generaltable \'>\n      <thead>\n       <tr>\n        <th class=\'header c0\' scope=\'col\'>\n        </th>\n        <th class=\'header c1 programming-io\' scope=\'col\'>\n         测试输入\n         <span class=\'helptooltip\'>\n          <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=input&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“测试输入”的帮助\'>\n           <img alt=\'关于“测试输入”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n          </a>\n         </span>\n        </th>\n        <th class=\'header c2 programming-io\' scope=\'col\'>\n         期待的输出\n         <span class=\'helptooltip\'>\n          <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=expectedoutput&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“期待的输出”的帮助\'>\n           <img alt=\'关于“期待的输出”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n          </a>\n         </span>\n        </th>\n        <th class=\'header c3\' scope=\'col\'>\n         时间限制\n         <span class=\'helptooltip\'>\n          <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=timelimit&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“时间限制”的帮助\'>\n           <img alt=\'关于“时间限制”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n          </a>\n         </span>\n        </th>\n        <th class=\'header c4\' scope=\'col\'>\n         内存限制\n         <span class=\'helptooltip\'>\n          <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=memlimit&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“内存限制”的帮助\'>\n           <img alt=\'关于“内存限制”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n          </a>\n         </span>\n        </th>\n        <th class=\'header c5 lastcol\' scope=\'col\'>\n         额外进程\n         <span class=\'helptooltip\'>\n          <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=nproc&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“{$a} 个额外进程”的帮助\'>\n           <img alt=\'关于“{$a} 个额外进程”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n          </a>\n         </span>\n        </th>\n       </tr>\n      </thead>\n      <tbody>\n       <tr class=\'lastrow\'>\n        <td class=\'cell c0\'>\n         测试用例 1\n        </td>\n        <td class=\'programming-io cell c1\'>\n         <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=53653&amp;test=65361&amp;type=in&amp;download=0\' id=\'action_link57d424f2ac3d05\' target=\'_blank\'>\n          以文本方式显示\n         </a>\n         <div>\n          <ol>\n           <li>\n            1↵\n           </li>\n           <li>\n            3↵\n           </li>\n           <li>\n            1 3 1↵\n           </li>\n          </ol>\n         </div>\n        </td>\n        <td class=\'programming-io cell c2\'>\n         <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=53653&amp;test=65361&amp;type=out&amp;download=0\' id=\'action_link57d424f2ac3d06\' target=\'_blank\'>\n          以文本方式显示\n         </a>\n         <div>\n          <ol>\n           <li>\n            2↵\n           </li>\n          </ol>\n         </div>\n        </td>\n        <td class=\'cell c3\'>\n         1秒\n        </td>\n        <td class=\'cell c4\'>\n         64M\n        </td>\n        <td class=\'cell c5 lastcol\'>\n         0\n        </td>\n       </tr>\n      </tbody>\n     </table>\n    </div>\n    <br/>\n   </div>\n   <h2>\n    <strong>\n     2.思路\n    </strong>\n   </h2>\n   <h1>\n    <strong>\n     题意：\n    </strong>\n   </h1>\n   <p>\n    两个人博弈，每次取任意多的数，但是每次取的数都只以当前取的最小的数来计分，每一轮取完之后记录该轮分差并计入总分，最后输出总分，但是每个人都想让自己与对方的分差是最大的（这句话其实是最有歧义也是最容易理解错的一句话）\n   </p>\n   <p>\n    下面我对上面那句最有歧义的话来进行以下分析\n   </p>\n   <p>\n    出题人其实是真的想通过这句话来给我们传达正确的意思，但是可能我们想问题的时候存在思维定式了\n   </p>\n   <p>\n    首先，注意，整个过程中实际上是不存在一轮一轮的概念的，我们每次都想要，也就是说，我们是不考虑之前的决策的\n   </p>\n   <p>\n    我们都是以当前为起点开始考虑取数来让自己与下一次对方取的时候的分差最大化\n   </p>\n   <p>\n    有的同学可能理解成当前A取完了，B想要让分差与A最小（这就是我们的思维定式和自以为是了）\n   </p>\n   <p>\n    实际上A取完了，我们B才不管上一次A取的是什么，B只关心为了下一次我能让下一次A取完之后与我的分差最大，我该怎么选\n   </p>\n   <h1>\n    错误的想法：贪心\n   </h1>\n   <p>\n    这种错误的想法是建立在我们之前说的自以为是的观点上（我在这上面WA了快10发了），我们每次都是取尽量大的元素为止，（我但是还专门找了两数之间分差最大的两个数的位置）然后我就只取最大的元素或者很多相同的最大的元素（当前有多个相同的最大元素）\n   </p>\n   <p>\n    但是我在测试用例的时候无意中发现一组用例出现了问题：\n   </p>\n   <p>\n    1 1 2 2 5 5 7 7 10 10\n   </p>\n   <p>\n    如果我们按照贪心的思想来做的话：答案应该是sum=10-7+5-2+1=7（这里我们就把题意理解错了）\n   </p>\n   <br/>\n  </div>\n  <div>\n   <div class=\'left\' id=\'yui_3_17_2_1_1473520826624_108\'>\n    <div class=\'grouppictures\'>\n    </div>\n   </div>\n   <div class=\'no-overflow\'>\n    <div class=\'content\'>\n     <div class=\'posting fullpost\'>\n      <p>\n       接着上面的来讲\n      </p>\n      <p>\n       上面我们说了贪心的答案是7,我们贪心的取法是这样的\n      </p>\n      <p>\n       Alice-&gt;10,10\n      </p>\n      <p>\n       Bob-&gt;7,7\n      </p>\n      <p>\n       Alice-&gt;5,5\n      </p>\n      <p>\n       Bob-&gt;2,2\n      </p>\n      <p>\n       Alice-&gt;1,1\n      </p>\n      <p>\n       但是题意不是这样子的，题意的是我们每次只关心当前的决策\n      </p>\n      <p>\n       所以说，正确的理解思路下的选取方案应该是\n      </p>\n      <p>\n       Alice-&gt;10,10为了让下一次分差最大（10-7&gt;7-5&gt;=5-2）\n      </p>\n      <p>\n       Bob-&gt;7,7,5,5(计分只记5)为了让下一次分差最大(5-2&gt;7-5)\n      </p>\n      <p>\n       Alice-&gt;2,2\n      </p>\n      <p>\n       Bob-&gt;1,1\n      </p>\n      <p>\n       正确的答案是sum=10-5+2-1=6\n      </p>\n      <p>\n       所以说，贪心的思路实在错误的理解了题目那句核心的话之下做出的错误的答案\n      </p>\n      <p>\n       很是揪心，我WA在这上面这么多次却浑然不知\n      </p>\n      <h1>\n       正解思路：动态规划\n      </h1>\n      <p>\n       孟义超大神的一句话点醒了我，本题的DP的递归性质\n      </p>\n      <p>\n       因为本题中我们每次所做的决策都无后效性，和最优子结构很相像，我在孟义超大神的指引下走上了DP这条正确的求解答道路上\n      </p>\n      <p>\n       首先，在这里，要想真的清楚的理解DP的性质，我们必须尽力抛开所谓的Alice和Bob两个只知道嘿嘿嘿的污神\n      </p>\n      <p>\n       我们这里只认一个叫做先手的人\n      </p>\n      <p>\n       还是拿刚才我们的例子来讲解\n      </p>\n      <p>\n       1 1 2 2 5 5 7 7 10 10\n      </p>\n      <p>\n       <strong>\n        定义状态：\n       </strong>\n      </p>\n      <p>\n       <strong>\n        dp：这个叫做先手的人在取该位置上的元素可以造成的最大的分差（最终的结果）\n       </strong>\n      </p>\n      <p>\n       <strong>\n        状态转移方程：\n       </strong>\n      </p>\n      <p>\n       <strong>\n        dp[0]=0 根据定义显而易见\n       </strong>\n      </p>\n      <p>\n       <strong>\n        dp[i]=dp[i-1]&gt;data[i]-dp[i-1]?dp[i-1]:data[i]-dp[i-1]\n       </strong>\n      </p>\n      <p>\n       我知道大家肯定一眼都看不懂，我来解释一下\n      </p>\n      <p>\n       先明确，这里没有Alice也没有Bob，只有先手\n      </p>\n      <p>\n       当先手取完之后，肯定会造成分差，如果是Bob先取的话，那么Bob造成的分差肯定是正的，对Alice来说肯定是负的，同理，如果是Alice先取的话，那么Alice造成的分差肯定是正的，对Bob来说，这个分差肯定是负的\n      </p>\n      <p>\n       这么来说，比如现在先手\n       <strong>\n        只\n       </strong>\n       取位置i，那么对于位置i-1来说，该先手肯定是后手，那么dp[i-1]对于这个当前取位置i的先手来说就是负的，我们的dp[i]的值很明显就是data[i]-dp[i-1]（含义就是，我当前要把我之前的负逆差通过data[i]弥补回来）。\n      </p>\n      <p>\n       但是这样子就简简单单的求出来dp[i-1]了吗，并不是\n      </p>\n      <p>\n       假如说当前我计算出来的data[i]-dp[i-1]并没有dp[i-1]大，俺么这代表什么么意思呢\n      </p>\n      <p>\n       这样子代表的就是我们先手\n       <strong>\n        只取\n       </strong>\n       位置i的元素并不是最优的，我们可以通过先手取位置i和位置i-1（只以位置i-1的元素计分）元素获得更大的分差\n      </p>\n      <p>\n       实际上，思维敏感的同学很快就会发现，实际上，这意思就是，我们当前取位置i的先手转换到取位置i-1的先手上了\n      </p>\n      <p>\n       总之，对于这两种情况，我们取最大的一个\n      </p>\n      <p>\n       直到最后，我们求解出dp[n]时代表的含义就是先手取第n位置之后我们可以得到的最大的分差（就是最大的结果）\n      </p>\n      <p>\n       那么现在我们再来考虑Alice和Bob这两个污神，题中已经说了，Alice实现首，那么这个取位置n的先手就是Alice，我们直接输出dp[n]就好\n      </p>\n      <p>\n      </p>\n      <p>\n       最后，为了防止有的同学还不理解中间的步骤，我把上面的例子推导一遍\n      </p>\n      <p>\n       1 1 2 2 5 5 7 7 10 10\n      </p>\n      <ol>\n       <li>\n        dp[0]=0;\n       </li>\n       <li>\n        dp[1]=max(data[1]-dp[0],dp[0])=max(1,0)=1;\n       </li>\n       <li>\n        dp[2]=max(data[2]-dp[1],dp[1])=max(0,1)=1;\n       </li>\n       <li>\n        dp[3]=max(data[3]-dp[2],dp[2])=max(1,1)=1;\n       </li>\n       <li>\n        dp[4]=max(data[4]-dp[3],dp[3])=max(1,1)=1;\n       </li>\n       <li>\n        dp[5]=max(data[5]-dp[4],dp[4])=max(4,1)=4;\n       </li>\n       <li>\n        dp[6]=max(data[6]-dp[5],dp[5])=max(1,4)=4;这里的含义就是取6位置不如取5位置\n       </li>\n       <li>\n        dp[7]=max(data[7]-dp[6],dp[6])=max(3,4)=4;这里的含义就是取7位置不如取5位置\n       </li>\n       <li>\n        dp[8]=max(data[8]-dp[7],dp[7])=max(1,4)=4;这里的含义就是取8位置不如取7位置\n       </li>\n       <li>\n        dp[9]=max(data[9]-dp[8],dp[8])=max(6,4)=6;\n       </li>\n       <li>\n        dp[10]=max(data[10]-dp[9],dp[9])=max(4,6)=6;这里的含义就是取10位置不如取9位置\n       </li>\n      </ol>\n      <p>\n       最后的dp数组是 0 1 1 1 1 4 4 4 4 6 6最大的取6，符合正确答案\n      </p>\n      <p>\n       <br/>\n      </p>\n      <h2>\n       3.AC代码：\n      </h2>\n      <p>\n       只付上核心代码段：\n      </p>\n      <p>\n      </p>\n      <pre class=\'cpp\' name=\'code\'>for(int i=1;i&lt;=n;i++)  \n{  \n      dp[i]=dp[i-1]&gt;data[i]-dp[i-1]?dp[i-1]:data[i]-dp[i-1];  \n}\n</pre>\n      <br/>\n      <br/>\n     </div>\n    </div>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('e7162473b38db391290626baed73d07a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  2016BIT小学期——电话号码问题（哈希+位运算）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述：\n  </h2>\n  <p>\n  </p>\n  <div class=\'container-fluid\' id=\'page\'>\n   <div class=\'row-fluid\' id=\'page-content\'>\n    <div class=\'span9\' id=\'region-bs-main-and-pre\'>\n     <div class=\'row-fluid\' id=\'yui_3_17_2_1_1473520575458_105\'>\n      <div id=\'yui_3_17_2_1_1473520575458_109\'>\n       <div class=\'box description\' id=\'yui_3_17_2_1_1473520575458_108\'>\n        <div class=\'box intro\' id=\'yui_3_17_2_1_1473520575458_107\'>\n         <div class=\'no-overflow\' id=\'yui_3_17_2_1_1473520575458_106\'>\n          <p>\n           商业单位需要容易记忆的电话号码，有一些方法可以让电话号码变得更容易记忆。譬如，可以把电话号码写成单词或短语，如 MON-GLOP 可以代表滑铁卢大学的电话。有时仅仅是把号码的一部分写成单词，如打 310-GINO 便可向 GINO 比萨饼店定购比萨。另一种让电话号码容易记忆的方法是将数字用一种容易记的方式组合起来，譬如 3-10-10-10 也可以代表 GINO 比萨饼店。\n          </p>\n          <p>\n           电话号码的标准形式是七位十进制数字，在它的第三位和第四位之间用连字符连接(例如：666-1200)。电话的键盘提供了字符与数字之间的映射关系，如下所示：\n          </p>\n          <table align=\'center\' border=\'1\' cellpadding=\'1\' cellspacing=\'3\' frame=\'void\' rules=\'none\' style=\'border:1px solid rgb(0,0,0); width:200px; vertical-align:top; border-collapse:collapse\'>\n           <tbody>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              2\n             </td>\n             <td valign=\'top\'>\n              A、B和C\n             </td>\n            </tr>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              3\n             </td>\n             <td valign=\'top\'>\n              D、E和F\n             </td>\n            </tr>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              4\n             </td>\n             <td valign=\'top\'>\n              G、H和I\n             </td>\n            </tr>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              5\n             </td>\n             <td valign=\'top\'>\n              J、K和L\n             </td>\n            </tr>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              6\n             </td>\n             <td valign=\'top\'>\n              M、N和O\n             </td>\n            </tr>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              7\n             </td>\n             <td valign=\'top\'>\n              P、R和S\n             </td>\n            </tr>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              8\n             </td>\n             <td valign=\'top\'>\n              T、U和V\n             </td>\n            </tr>\n            <tr>\n             <td style=\'text-align:center\' valign=\'top\'>\n              9\n             </td>\n             <td valign=\'top\'>\n              W、X和Y\n             </td>\n            </tr>\n           </tbody>\n          </table>\n          <p>\n           Q 和 Z 没有映射到键盘，而连字符不需要被拨打并且可以根据需要添加和删除。MON-GLOP 的标准形式是 666-4567，310-GINO 的标准形式是310-4466，3-10-10-10的标准形式也是 310-1010。\n          </p>\n          <p>\n           如果两个电话号码有相同的标准形式，那么这两个电话号码是相同的。\n          </p>\n          <p>\n           你所在的公司正在编辑一本当地商业单位的电话簿，作为质量控制流程的一部分，你需要确认在该电话簿中有没有错误的电话号码，以及有没有两个(或两个以上的)商业单位使用相同的电话号码。由于当地只使用了 3 和 6 两个区段，因此电话号码的第一个数字应当永远是 3 或者 6，如果出现了其它数字，就表示这个电话号码错了。此外，如果电话号码中出现了 Q 和 Z，也说明这个电话错了。\n          </p>\n          <h3>\n           输入\n          </h3>\n          <p>\n           一次输入为一个样例。每个号码一行，每行的字符不会超过 20 个。每次输入的数据可能会非常大，譬如超过 1,000,000 个电话号码。\n          </p>\n          <p>\n           <strong>\n            <span style=\'color:#ff0000\'>\n             你可以假设输入中可能会出现重复的电话号码不超过 1,500 个，每个号码重复的次数不超过 1000 次。\n            </span>\n           </strong>\n          </p>\n          <h3>\n           输出\n          </h3>\n          <p>\n           输出包括两个部分，第一个部分是错误的电话号码，对于这些号码应当按照输入的顺序以原始的形式输出。在输出错误电话号码前输出“Error:”，随后输出这些号码，如果没有错误的电话号码，则输出“Not found.”。\n          </p>\n          <p>\n           第二部分是重复的电话号码，对每一个在电话簿中以任何形式出现一次以上的电话号码，生成一行输出。这一行应以标准形式给出电话号码，其后跟随一个空格，空格后跟随电话号码在电话簿中出现的次数。所有重复的电话号码输出行应以号码的升序排列（小号码在前）。在输出重复电话号码前输出“Duplication”，随后按照上述格式输出号码，如果在输入中没有重复的电话号码，则输出：“Not found.”。\n          </p>\n          <h3>\n           注意\n          </h3>\n          <p>\n           你所编写的程序以后可能会在一种特殊的嵌入式设备上运行，为了降低成本，这种设备使用的 CPU 不是很快、可用的 RAM 为 288K（跟\n           <a href=\'http://images.google.cn/images?q=GameBoy+Advance\' target=\'_blank\'>\n            GBA\n           </a>\n           一样）且它没有磁盘设备因此不能使用文件作为数据的临时存储。\n          </p>\n          <h3>\n           提示\n          </h3>\n          <p>\n           请参考《编程珠玑》第一部分，若程序不能在规定的内存中运行，则不得分。\n          </p>\n         </div>\n        </div>\n        <div class=\'box testcase-table\'>\n         <table class=\'generaltable \'>\n          <thead>\n           <tr>\n            <th class=\'header c0\' scope=\'col\'>\n            </th>\n            <th class=\'header c1 programming-io\' scope=\'col\'>\n             测试输入\n             <span class=\'helptooltip\'>\n              <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=input&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“测试输入”的帮助\'>\n               <img alt=\'关于“测试输入”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n              </a>\n             </span>\n            </th>\n            <th class=\'header c2 programming-io\' scope=\'col\'>\n             期待的输出\n             <span class=\'helptooltip\'>\n              <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=expectedoutput&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“期待的输出”的帮助\'>\n               <img alt=\'关于“期待的输出”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n              </a>\n             </span>\n            </th>\n            <th class=\'header c3\' scope=\'col\'>\n             时间限制\n             <span class=\'helptooltip\'>\n              <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=timelimit&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“时间限制”的帮助\'>\n               <img alt=\'关于“时间限制”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n              </a>\n             </span>\n            </th>\n            <th class=\'header c4\' scope=\'col\'>\n             内存限制\n             <span class=\'helptooltip\'>\n              <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=memlimit&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“内存限制”的帮助\'>\n               <img alt=\'关于“内存限制”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n              </a>\n             </span>\n            </th>\n            <th class=\'header c5 lastcol\' scope=\'col\'>\n             额外进程\n             <span class=\'helptooltip\'>\n              <a href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=nproc&amp;lang=zh_cn\' target=\'_blank\' title=\'关于“{$a} 个额外进程”的帮助\'>\n               <img alt=\'关于“{$a} 个额外进程”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/lambda/core/1470987833/help\'/>\n              </a>\n             </span>\n            </th>\n           </tr>\n          </thead>\n          <tbody>\n           <tr>\n            <td class=\'cell c0\'>\n             测试用例 1\n            </td>\n            <td class=\'programming-io cell c1\'>\n             <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=52904&amp;test=63337&amp;type=in&amp;download=0\' id=\'action_link57d423bb3a60f5\' target=\'_blank\'>\n              以文本方式显示\n             </a>\n             <div>\n              <ol>\n               <li>\n                4873279↵\n               </li>\n               <li>\n                ITS-EASY↵\n               </li>\n               <li>\n                666-4567↵\n               </li>\n               <li>\n                3-10-10-10↵\n               </li>\n               <li>\n                666-GLOP↵\n               </li>\n               <li>\n                MON-GLOP↵\n               </li>\n               <li>\n                367-11-11↵\n               </li>\n               <li>\n                310-GINO↵\n               </li>\n               <li>\n                F101010↵\n               </li>\n               <li>\n                666-1200↵\n               </li>\n               <li>\n                -4-8-7-3-2-7-9↵\n               </li>\n               <li>\n                487-3279↵\n               </li>\n              </ol>\n             </div>\n            </td>\n            <td class=\'programming-io cell c2\'>\n             <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=52904&amp;test=63337&amp;type=out&amp;download=0\' id=\'action_link57d423bb3a60f6\' target=\'_blank\'>\n              以文本方式显示\n             </a>\n             <div>\n              <ol>\n               <li>\n                Error:↵\n               </li>\n               <li>\n                4873279↵\n               </li>\n               <li>\n                ITS-EASY↵\n               </li>\n               <li>\n                -4-8-7-3-2-7-9↵\n               </li>\n               <li>\n                487-3279↵\n               </li>\n               <li>\n                ↵\n               </li>\n               <li>\n                Duplication:↵\n               </li>\n               <li>\n                310-1010 2↵\n               </li>\n               <li>\n                666-4567 3↵\n               </li>\n              </ol>\n             </div>\n            </td>\n            <td class=\'cell c3\'>\n             1秒\n            </td>\n            <td class=\'cell c4\'>\n             512KB\n            </td>\n            <td class=\'cell c5 lastcol\'>\n             0\n            </td>\n           </tr>\n           <tr class=\'lastrow\'>\n            <td class=\'cell c0\'>\n             测试用例 2\n            </td>\n            <td class=\'programming-io cell c1\'>\n             <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=52904&amp;test=63338&amp;type=in&amp;download=0\' id=\'action_link57d423bb3a60f7\' target=\'_blank\'>\n              以文本方式显示\n             </a>\n             <div>\n              <ol>\n               <li>\n                3456789↵\n               </li>\n              </ol>\n             </div>\n            </td>\n            <td class=\'programming-io cell c2\'>\n             <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=52904&amp;test=63338&amp;type=out&amp;download=0\' id=\'action_link57d423bb3a60f8\' target=\'_blank\'>\n              以文本方式显示\n             </a>\n             <div>\n              <ol>\n               <li>\n                Error:↵\n               </li>\n               <li>\n                Not found.↵\n               </li>\n               <li>\n                ↵\n               </li>\n               <li>\n                Duplication:↵\n               </li>\n               <li>\n                Not found.↵\n               </li>\n              </ol>\n             </div>\n            </td>\n            <td class=\'cell c3\'>\n             1秒\n            </td>\n            <td class=\'cell c4\'>\n             512KB\n            </td>\n            <td class=\'cell c5 lastcol\'>\n             0\n            </td>\n           </tr>\n          </tbody>\n         </table>\n         <h2>\n          2.思路：\n         </h2>\n         <div>\n          <p>\n           输入：给出大量的电话号码，我们需要判断是否错误以及是否重复，重复的话，按照号码大小顺序进行输出，如果错误的话，按照输入的顺序输出\n          </p>\n          <p>\n           存在字母到数字的映射，输出的时候需要我们输出标准型的电话号码\n          </p>\n          <p>\n          </p>\n          <p>\n           <strong>\n            本题涉及到两个知识点\n           </strong>\n          </p>\n          <p>\n           <strong>\n            1.哈希表的应用\n           </strong>\n          </p>\n          <p>\n           <strong>\n            2.位运算实现哈希函数\n           </strong>\n          </p>\n          <p>\n          </p>\n          <p>\n           首先本题有个难点就是我们限定了内存的大小，我们先从这里开始讲解\n          </p>\n          <p>\n           本题限制的内存大小事512k，但是我们可能存在很大的输入量，比如题中声明了我们会存在有1000000个电话号码\n          </p>\n          <p>\n           但是我们需要不断判断一个号码是不是重复，我们就必须要开辟很大的1000000的内存空间，大致进行计算，如果我们采用char类型来保存（相对int会节省空间）那么一个char一个字节，我们需要至少1000000byte==1000kb&gt;&gt;512kb\n          </p>\n          <p>\n           所以说，只用char来存储是不现实的\n          </p>\n          <p>\n          </p>\n          <p>\n          </p>\n          <p>\n           于是我根据我的思维导图来详细的阐释一下我的思维发展过程：\n          </p>\n          <h4>\n           1.这道题我们要存储还要快速（不快速的话，1000000个数据很明显会超时），那么我该用什么数据结构存储比较合适呢\n          </h4>\n          <p>\n           暑假我自学了数据结构，也了解了哈希表到底是什么，如果各位看官还不了解什么是哈希表，欢迎来参考我写的博客，里面详细的介绍了什么是哈希，以及怎么用哈希，哈西的核心思想是什么\n           <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52171743\' target=\'_blank\'>\n            http://blog.csdn.net/ltyqljhwcm/article/details/52171743\n           </a>\n          </p>\n          <p>\n           我就简言概括一下什么是哈希表，哈希表又名散列表，核心思想就是通过哈希函数将目标关键字进行映射，获得新的存储地址，从而实现数据的快速的存取（理想时间复杂度是O(1)，可以轻松解决我们的本题的超时的问题）\n          </p>\n          <p>\n           那么问题又来了，哈希实际上是以空间换取时间的一种数据结构，那么我们还是离不开大的数据存储，而且，我怎么设计哈希函数才能准确，平均而又不超出内存的限制下完成哈希表的构建，实现我们的随机存储呢？\n          </p>\n          <h4>\n           2.哈希函数的设计着实让我伤脑筋\n          </h4>\n          <p>\n           根据论文上的描述，有大量的哈希函数设计思路，比如除留取余，随机取中等等，但是本题我们的内存限制我们不能开很大的空间，但是不开很大的空间我们又不能将所有的情况覆盖，一旦出现输入的号码个数超过1000000并且又不重复，那不就GG了\n          </p>\n          <p>\n           <strong>\n            所以说，我又想起了我假期看过的一本书叫做《编程之美》，是之美不是珠玑，我不知道出题人在哪看到的，我没有在编程珠玑上找到类似的解答，但是我在《编程之美》上受到了启发\n           </strong>\n          </p>\n          <p>\n           编程之美的第一节是中国象棋将帅问题，大家有兴趣可以去了解一下，这道题和我们这道题有类似之处，两个题我们都限制了内存的大小，本题限制为288k还算比较宽容的，编程之美的问题限制内存是1个字节，但是为了保存两个将帅的位置信息，作者的处理方式是考虑到降水的坐标不会超过9的这个因素，将两个将帅的位置信息压缩到一个字节里面，因为9二进制不会超过4个二进制位，一个unsigned char有8位，我们一个字节存储绰绰有余\n          </p>\n          <p>\n           再回到我们这道题，在思考了两者的相似性之后，我决定尝试一种新的哈希函数的设计\n          </p>\n          <p>\n           我自己的思路是一个unsigned char有8位，我们有1000000个数据，那么只要（10000000/8,这里有个错误，下面的思考步骤中我会修改再压缩）的unsigned char数组就可以代表这一大量的内存，我们每一个二进制位有两个状态，0,1\n          </p>\n          <p>\n           0，代表该二进制（代表的数 反映射 的号码）没有出现过，1则代表出现过\n          </p>\n          <p>\n           利用位运算，我可以轻松处理将该为赋值为1,或者取出该为的值\n          </p>\n          <p>\n           位运算的核心代码如下：\n          </p>\n          <p>\n           <strong>\n            int w=number/8;\n            <br/>\n            int x=number%8;\n            <br/>\n            if(((judge1[w]&gt;&gt;(7-x))&amp;1)==1) return 1;   //判断该unsigned char的第x二进制位是否是1,\n            <br/>\n            else\n            <br/>\n            {\n            <br/>\n            judge1[w]=judge1[w]|(1&lt;&lt;(7-x));    //不是1，我们复制为1，代表该号码已经出现过\n            <br/>\n            return 0;\n            <br/>\n            }\n           </strong>\n          </p>\n          <p>\n           我们的含义就是把电话号码处理成一个整数，然后利用位运算存储在这个unsigned char数组里面\n          </p>\n          <p>\n           3.具体的实现：\n          </p>\n          <p>\n           实现之后，我自信的点击了提交，结果显示超过内存\n          </p>\n          <p>\n           我就很不是理解了，回头再仔细看了下代码，发现了这个问题\n          </p>\n          <p>\n           我设置的哈希表的大小是1000000/8（没有设置成1000000/8是因为我但是脑抽的以为首位有很多数字，不知3,6，所以说拉高了一位，从一百万拉到了1000万）\n          </p>\n          <p>\n           我当时就开始思考如何再压缩，因为题意说明了首位只能是3,6，那么我们电话号码对应的整数也就只能是两种情况，我开辟两个大小是（1000000/8）的哈希表就可以将内存相对之前的压缩方案压缩至少75%的内存空间\n          </p>\n          <p>\n           这样子算一下，125000*2=250000个字节也就是大约250kb 是我们限制的内存空间的一半，通过八位一压缩，我成功的将1000kb的最原始的损耗内存的方式优化到250kb，轻松解决了速度和内存的我心里面是高兴的（然而事实证明高兴的太早了）\n          </p>\n          <h4>\n           4.有了位运算实现哈希函数的哈希表这个数据结构，我开始了具体的实现这个代码\n          </h4>\n          <p>\n           但是很是心累的，我WA了将近二十发，下面我将我所有的bug汇总一下，希望可以帮助到所有还在WA的道路上的同志们\n          </p>\n          <p>\n           1.小心不要直接将输入的字符串的首元素判断是不是3,6，或者和3,6相映射的字母来判断是不是error的情况，首字符可能是-，或者很多的--------\n          </p>\n          <p>\n           2.输出数组元素的时候不要轻易的用%s输出，因为有可能字符串型的数组中的电话号码存在0的情况，是中断输出的\n          </p>\n          <p>\n           3.排序函数中，我们的判断的思维逻辑一定要严谨\n          </p>\n          <p>\n           一定要分成大于等于小于所有的情况都不要理所当然的漏掉\n          </p>\n          <p>\n           4.字符判断是否相等的时候不要用strcmp拷贝复制的额时候不要用strcpy，理由同第二条\n          </p>\n          <p>\n           5.输入的字符里面不存在和题目要求的无关的字符，大家尽可能放心\n          </p>\n          <p>\n           6.最后一个用例中有一个特殊的情况就是情况1里面提及到的（不要问我怎么知道的，都是泪）\n          </p>\n          <h4>\n           5.最后，位运算我给大家总结一波常用的和本题相关的一些基础用法作为结语\n          </h4>\n          <p>\n           左移&gt;&gt;:二进制位整体左移，左端不齐的用0补齐\n          </p>\n          <p>\n           右移&lt;&lt;:二进制位整体右移，右端不齐的用0补齐\n          </p>\n          <p>\n           按位与&amp;：二进制位逐位比较，同为1则该位为1，否则该位为0\n          </p>\n          <p>\n           按位或|：二进制位逐位比较，同为0则该位为0，否则该位为1\n          </p>\n          <p>\n           按位取反~：二进制位逐位取反\n          </p>\n          <p>\n          </p>\n          <p>\n           具体的常用用法：\n          </p>\n          <p>\n           1.取数字p的第k二进制位的具体数字：(p&gt;&gt;k)&amp;1\n          </p>\n          <p>\n           2.为数字p的第k二进制位赋1：p|(1&lt;&lt;k)\n          </p>\n          <p>\n           3.将数字p的第k二进制位清零：p&amp;~(1&lt;&lt;k)\n          </p>\n          <p>\n           4.p乘以2的k次方：p&lt;&lt;k\n          </p>\n          <p>\n           5.p除以2的k次方：p&gt;&gt;k\n          </p>\n          <p>\n           本题中这些位运算足够了，大家要是有兴趣百度即可\n          </p>\n          <h2>\n           3.代码：\n          </h2>\n         </div>\n         <div>\n          作为一名北理人，坚持贯彻不查重的政策，我只附上核心代码段：\n         </div>\n         <div>\n          <pre class=\'cpp\' name=\'code\'>int cmp(const void* a,const void* b)\n{\n	phone* x=(phone*)a;\n	phone* y=(phone*)b;\n	if(x-&gt;c &gt; y-&gt;c) return 1;\n	else if(x-&gt;c &lt; y-&gt;c) return -1;\n	else\n	{\n		for(int i=0;i&lt;6;i++)\n		{\n			if(x-&gt;code[i] &gt; y-&gt;code[i]) return 1;\n			else if(x-&gt;code[i]!=y-&gt;code[i]) return -1;\n			else continue;\n		}\n		//return -1;\n	}\n}\n\nint creat()\n{\n	int c[22];\n	memset(c,0,sizeof(c));\n	int j=0;\n	for(int i=0;i&lt;strlen(input);i++)\n	{\n		if(input[i]==\'-\') continue;\n		else if(input[i]==\'A\'||input[i]==\'B\'||input[i]==\'C\') c[j++]=2;\n		else if(input[i]==\'D\'||input[i]==\'E\'||input[i]==\'F\') c[j++]=3;\n		else if(input[i]==\'G\'||input[i]==\'H\'||input[i]==\'I\') c[j++]=4;\n		else if(input[i]==\'J\'||input[i]==\'K\'||input[i]==\'L\') c[j++]=5;\n		else if(input[i]==\'M\'||input[i]==\'N\'||input[i]==\'O\') c[j++]=6;\n		else if(input[i]==\'P\'||input[i]==\'R\'||input[i]==\'S\') c[j++]=7;\n		else if(input[i]==\'T\'||input[i]==\'U\'||input[i]==\'V\') c[j++]=8;\n		else if(input[i]==\'W\'||input[i]==\'X\'||input[i]==\'Y\') c[j++]=9;\n		else if(input[i]&gt;=\'0\'&amp;&amp;input[i]&lt;=\'9\') c[j++]=(int)input[i]-48;\n	}\n	for(int i=1;i&lt;j;i++) \n	number=number*10+c[i];\n	if(c[0]==3) return 1;   //3是1 \n	else return -1;   //6是-1 \n}\n\nint findbit(int atom)\n{\n	if(atom==1)\n	{\n		int w=number/8;\n    	int x=number%8;\n    	if(((judge1[w]&gt;&gt;(7-x))&amp;1)==1) return 1;\n    	else\n    	{\n     		judge1[w]=judge1[w]|(1&lt;&lt;(7-x)); \n     		return 0;\n    	}\n	}\n	else\n	{\n		int w=number/8;\n    	int x=number%8;\n    	if(((judge2[w]&gt;&gt;(7-x))&amp;1)==1) return 1;\n    	else\n    	{\n    		judge2[w]=judge2[w]|(1&lt;&lt;(7-x)); \n    		return 0;\n    	}\n	}\n}\n</pre>\n          <br/>\n          <br/>\n         </div>\n        </div>\n       </div>\n      </div>\n     </div>\n    </div>\n   </div>\n  </div>\n  <p>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('b05f249e46d6ed724d7bf5c2b76abc0f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ1100-BFS+优先队列\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.题目描述：\n  </h1>\n  <p>\n  </p>\n  <div class=\'problem-display\' style=\'font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n   <h2 style=\'margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体\'>\n    WAJUEJI which home strong！\n   </h2>\n   <div class=\'problem-ins\' style=\'text-align:center\'>\n    时间限制：\n    <span class=\'editable highlight\' id=\'problem[time_limit]\' style=\'color:rgb(113,32,21)\'>\n     1000\n    </span>\n    ms  |  内存限制：\n    <span class=\'editable highlight\' id=\'problem[memory_limit]\' style=\'color:rgb(113,32,21)\'>\n     65535\n    </span>\n    KB\n   </div>\n   <div class=\'problem-ins\' style=\'text-align:center\'>\n    难度：\n    <span class=\'editable highlight\' style=\'color:rgb(113,32,21)\'>\n     2\n    </span>\n   </div>\n  </div>\n  <div class=\'clr\' style=\'clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19.5px\'>\n  </div>\n  <dl class=\'problem-display\' style=\'margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n   <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n    描述\n   </dt>\n   <dd style=\'margin:0px; padding:0px\'>\n    <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px\'>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      在一个山沟里，姐弟俩同时考上了大学。但由于家里拮据，所以这并不是什么好消息。\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      父亲\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      对孩子说：\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      我就是砸锅卖铁也要把你们姐俩供出来。 当时\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      的姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      已经决定放弃上学的机会。 没想到第二天天还没亮，弟弟就偷偷带著几件破衣服和几个乾巴馒头走了，在\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      枕边留下一个纸条： 姐,\n      <span style=\'font-family:宋体\'>\n       你别愁了，考上大学不容易，我出去打工供你。弟。\n      </span>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      握著那张字条,\n      <span style=\'font-family:宋体\'>\n       趴在炕上\n      </span>\n      ,\n      <span style=\'font-family:宋体\'>\n       失声痛哭。 那一年，弟弟\n      </span>\n      17\n      <span style=\'font-family:宋体\'>\n       岁，\n      </span>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      20\n      <span style=\'font-family:宋体\'>\n       岁。\n      </span>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      用父亲满村子借的钱和弟弟在工地裏搬水泥挣的钱终於读到了大三。 一天\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      正在寝室\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      里\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      看书,\n      <span style=\'font-family:宋体\'>\n       同学跑进来\n      </span>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      对姐姐说，\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      有个老乡在找你。\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐很纳闷，\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      走出去\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      后，\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      远远地看见弟弟,\n      <span style=\'font-family:宋体\'>\n       穿著满身是水泥和沙子的工作服。\n      </span>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐说\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      ，你怎\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      么\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      和我同学说你是我老乡啊?\n      <span style=\'font-family:宋体\'>\n       他笑著说，你看我穿的这样，说是你弟，你同学还不笑话你？\n      </span>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      鼻子一酸，眼泪就落了下来。\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      弟弟\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      赶忙为\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      姐姐\n     </span>\n     <span style=\'font-family:Arial; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      擦掉眼泪，说：姐，你别哭，我这次来是想让你帮我打听一下，学挖掘机哪家强？\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n     </span>\n    </p>\n    <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px\'>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n     </span>\n    </p>\n    <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px\'>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      在你的帮助下，弟弟踏上了去蓝翔的路。\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n     </span>\n    </p>\n    <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px\'>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      那么问题就来了。\n     </span>\n    </p>\n    <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px\'>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n      <img alt=\'\' border=\'0\' src=\'http://acm.nyist.net/JudgeOnline/admin/kind/attached/20141017194215_48359.jpg\' style=\'border:0px none\'/>\n     </span>\n     <span style=\'font-family:宋体; letter-spacing:0pt; color:rgb(0,0,0); font-size:10.5pt\'>\n     </span>\n    </p>\n    <div class=\'clr\' style=\'clear:both\'>\n    </div>\n    <dl class=\'others\' style=\'margin:0px; padding:0px\'>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      第一个数T，T组测试数据。\n      <br/>\n      两个数 n, m; ( 0&lt; n , m &lt;= 100 ) 表示一个h行m列的二维地图。\n      <br/>\n      接下来n行每行m 个字符。\n      <br/>\n      ‘s’ 表示弟弟目前所在位置。\n      <br/>\n      ‘# ’表示此处为一座山。为了节省体力，不从此处通行。\n      <br/>\n      从‘A’-‘Z’表示各地的经济水平，对应1-26，路过对应字符的地区需要交对应的生活费。\n      <br/>\n      ‘l’表示蓝翔技校的所在地。\n      <br/>\n      s 与 l 均为小写字母。\n      <br/>\n      弟弟只能走四个方向。\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      输出一个数表示弟弟到达蓝翔需要的生活费最小是多少。\n      <br/>\n      如果不能到达，输出 -1。\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_input\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>3\n3 5\n#sVGF\nA##ZA\nlCDBC\n3 3\nsAB\nABS\nABl\n3 3\ns#B\n###\nABl</pre>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_output\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>48\n4\n-1</pre>\n     </dd>\n    </dl>\n   </dd>\n  </dl>\n  <br/>\n  <p>\n  </p>\n  <h1>\n   2.思路要点\n  </h1>\n  <div>\n   本题虽然给的难度评级是2，但是个人感觉不是一道好做的题，考察的知识点非常的全面\n  </div>\n  <div>\n   本题我们需要用到两个知识点：BFS，优先队列（本题中，博主我手动写堆模拟优先队列，毕竟是一个讨厌STL的boy）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   想法：\n  </div>\n  <div>\n   1.首先我们利用优先队列的BFS的想法的原因是，我们要找出最小代价，所以说，我们不断的用优先队列选择出优先级最高的元素（这里的话，当到该点的权值最小的时候优先级最大），当我们选择出的优先级最高的元素下一步直接就可以到达蓝翔的时候，我们就找到了最小代价，因为其他的BFS方向还在他们的路上~\n  </div>\n  <div>\n   2.有的同学可能和我一样会发现如果一个点已经被BFS开发过了，但是下一次我们另一条路径也开发到这个点的时候，让该点的权值变少了，那么很显然，这种情况下我们必须要让该点再一次进队列，以保证下一次我们从该点处触发的时候，我们还可以最优\n  </div>\n  <div>\n   3.由2可见，该题中我们不能用记录数组记录我们的访问了，有的同学可能又要问了，如果不记录的话，我们会不会走回头路，从而导致我们BFS陷入死循环的状态，答案是不会的，因为，我们在判断的时候，附加的条件是要是想要往回走，必须走回去之后可以让最小代价变小，但是走了回头路只会让最小代价变大，轻而易举的解决了这个问题\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h1>\n   3.AC代码\n  </h1>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 10010\n\nusing namespace std;\n\ntypedef struct node\n{\n	char c;\n	int x;\n	int y;\n	int s;\n}point;\n\ntypedef struct k\n{\n    int s;\n	char c;	\n}w;\n\nint n,m;\nint bx,by;\nint sum;\npoint queue[N];\nw map[120][120];\nint heap[N];\nint heapnum;\nint nn[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\n\nvoid swap(int x,int y)\n{\n	int t=heap[x];\n	heap[x]=heap[y];\n	heap[y]=t;\n}\n\nvoid siftdown(int i)\n{\n	int t;\n	while(i*2&lt;=heapnum)\n	{\n		if(queue[heap[i]].s&gt;queue[heap[i*2]].s) t=i*2;\n		else t=i;\n		if(i*2+1&lt;=heapnum&amp;&amp;queue[heap[i*2+1]].s&lt;queue[heap[t]].s) t=i*2+1;\n		if(t!=i)\n		{\n			swap(i,t);\n			i=t; \n		}\n		else break;\n	}\n} \n\nvoid siftup(int i)\n{\n	int t;\n	while(!(i==2||i==3||i==1))\n	{\n		if(queue[heap[i]].s&lt;queue[heap[i/2]].s)\n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else break;\n	}\n}\n\nint bfs(int x,int y)\n{\n	heap[1]=1;\n	heapnum=1;\n	int p=1;\n	int k;\n	queue[1].x=x;\n	queue[1].y=y;\n	queue[1].c=\'s\';\n	queue[1].s=0;\n	while(heapnum!=0)\n	{\n		for(int i=0;i&lt;4;i++)\n		{\n			int dx=queue[heap[1]].x+nn[i][0];\n			int dy=queue[heap[1]].y+nn[i][1];\n			if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy].c==\'#\') continue;\n			else\n			{\n				if(map[dx][dy].c==\'l\') return queue[heap[1]].s;\n				else\n				{\n					k=(int)map[dx][dy].c-64;\n					if(map[dx][dy].s==0||(queue[heap[1]].s+k)&lt;map[dx][dy].s)\n					{\n						heapnum++;\n						queue[++p].c=map[dx][dy].c;\n						queue[p].x=dx;queue[p].y=dy;\n						queue[p].s=queue[heap[1]].s+k;\n						map[dx][dy].s=queue[p].s;\n						heap[heapnum]=p;\n						siftup(heapnum);\n					}\n					else continue;\n				}\n			}\n		}\n		heap[1]=heap[heapnum];\n		heapnum--;\n		siftdown(1);\n	}\n	return -1;\n}\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);getchar();\n	while(t--)\n	{\n		memset(map,0,sizeof(map));\n		scanf(\'%d%d\',&amp;n,&amp;m);getchar();\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				scanf(\'%c\',&amp;map[i][j].c);\n				if(map[i][j].c==\'s\') bx=i,by=j;\n			}\n			getchar();\n		}\n		\n		int k;\n		if((k=bfs(bx,by))==-1) printf(\'-1\n\');\n		else printf(\'%d\n\',k);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('f6481dd9bca008d221ca52b74d06f1f9','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  哈夫曼（最优二叉树）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   最优二叉树：\n  </h2>\n  <h3>\n   定义：\n  </h3>\n  <div>\n   路径：数的路径就是从书中的一个节点到树中的另一个节点的分支的个数长度，路径上的分支数目我们称之为长度\n  </div>\n  <div>\n   树的路径长度：从树根到每一个节点的长度之和（完全二叉树是一种树的路径最短的二叉树）\n  </div>\n  <div>\n   节点的带权路径长度：从根节点到该节点的路径的分支数目与节点的权值的乘积\n  </div>\n  <div>\n   树的带权路径的长度：树中的所有的节点的带权路径长度之和，并且，我们将改长度定义为WPL\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    最优二叉树（哈夫曼树）：有n个权值的点，我们构造一颗有n个叶子节点的二叉树，WPL最小的二叉树我们称之为最优二叉树或者哈夫曼树\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   ps：首先我们要注意到，哈夫曼的压缩效果不是固定的，我们考虑的是整体的压缩效率而不是单次的压缩效果\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    pss:哈夫曼树或者最优二叉树的叶子节点才是我们的节点，中间的节点只是我们的合并过程中产生的新节点，不作为我们的考虑范围\n   </span>\n  </div>\n  <h2>\n   哈夫曼树：\n  </h2>\n  <h3>\n   1.算法的步骤：\n  </h3>\n  <div>\n   1.从森林中选出所有的节点中权值最小的两个节点并删除\n  </div>\n  <div>\n   2.合并两个最小的节点生成新的节点，插入到森林中\n  </div>\n  <div>\n   3.重复上述的1,2步骤直到森里中只有一颗树是我们变构建完了最优二叉树\n  </div>\n  <h3>\n   2.WPL最优证明：\n  </h3>\n  <div>\n   <img alt=\'\' src=\'http://a1.qpic.cn/psb?/V145d4wY2ao7bg/.uxOa4EfHovNW*WgdJetP5ACU4l5A2alBZaGJFrlfqI!/a/dPgAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=0gAIAQAAAAAFAPg!&amp;sce=60-4-4&amp;rf=0-0\'/>\n   <br/>\n  </div>\n  <div>\n   我们对于证明采用反证法：\n  </div>\n  <div>\n   首先，如上图，我们假设我们目前构建的二叉树\n  </div>\n  <div>\n   如果出现了A&gt;C的情况话，我们很明显可以发现，如果我们交换C和A的位置的话，显然\n   <span style=\'font-size:12px\'>\n    这样的话我们重新交换生成的二叉树明显要比我们之前的要更优一些\n   </span>\n  </div>\n  <div>\n   所以说，吐过我们对所有的节点之间的大小关系和层次关系进行比较的话就会很明显的发现，\n   <span style=\'font-size:12px\'>\n    只要存在上述的情况，我们就可以通过交换来优化我们当前的二叉树WPL的值\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    因此我们全部的考虑所有的情况，到最后不出现上述可以交换得到最优的情况的时候，我们得到的WPL就是最优的，无法再次优化的最优二叉树了\n   </span>\n  </div>\n  <div>\n   这是后我们再反过来考虑一下这样我们得到的树的性质：\n  </div>\n  <div>\n   我们很明显的额发现，底层的节点的权值必定比高层次的节点的权值要小，并且如果是最有的话，这个性质是必须要每层之间的每个节点都要保证的，在我们构建哈夫曼树的算法过程中，底层的节点代表我们最先合并，而高层的节点代表我们最后合并，所以说，这样我们也就证明了哈夫曼树构建算法的正确性\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   实际上，我们仅仅考虑算法本身的话，我们发现哈夫曼构建的算法实际上就是贪心的策略\n  </div>\n  <h3>\n   3.哈夫曼树的压缩性\n  </h3>\n  <div>\n   我们比较哈夫曼树的压缩效率，我们是考虑哈夫曼树的压缩能力和平常的每个字符的三位码的码长进行比较的\n  </div>\n  <div>\n   虽然哈夫曼树因为可能不唯一（存在权值相同的节点，或者存在计算过程中新生的节点的权值相同的情况），但是我们整体的压缩效果是一样的\n  </div>\n  <div>\n   因为，就算哈夫曼树是不唯一的，但是我们要记住，同为最优二叉树，WPL只是相同的，换句话来说，我们的不同的的最优二叉树的压缩比是相同的\n  </div>\n  <div>\n   举个例子：\n  </div>\n  <div>\n   ABACCDA\n  </div>\n  <div>\n   A 3\n  </div>\n  <div>\n   B 1\n  </div>\n  <div>\n   C 2\n  </div>\n  <div>\n   D 1\n  </div>\n  <div>\n   构建的编码有两种情况分别是：\n  </div>\n  <div>\n   1.\n  </div>\n  <div>\n   A:0\n  </div>\n  <div>\n   B:110\n  </div>\n  <div>\n   C:10\n  </div>\n  <div>\n   D:111\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.\n  </div>\n  <div>\n   A:0\n  </div>\n  <div>\n   B:100\n  </div>\n  <div>\n   C:11\n  </div>\n  <div>\n   D:101\n  </div>\n  <div>\n   但是对于压缩比：\n  </div>\n  <div>\n   原码长：7*3=21\n  </div>\n  <div>\n   哈夫曼码长：1*3+3*1+2*2+3*1=13\n  </div>\n  <div>\n   压缩比为：13/21\n  </div>\n  <h3>\n   4.哈夫曼编码的前缀编码\n  </h3>\n  <div>\n   上述的哈夫曼编码虽然可以很明显的压缩我们的码长，但是我们现在来考虑，如果我们不给出你现在的这串码的各个字符的频率，那么我们是没有办法构建出哈夫曼树的，那么我们就无法解码\n  </div>\n  <div>\n   为了解码，我们必须要确定我们的每个字符对应的二进制编码是不会出现二义性的，也就是说，我们不能让一个字符的编码成为另一个字符编码的前缀，那么样的话，我们就无法确定到底是用那个字符进行解释\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   但是不要担心，对于哈夫曼树来说，我们构建出的哈夫曼树最后如果我们将左分支定义成0/1，有分支定义成1/0，那么我们便可以发现任何一个字符编码都不可能成为另一个个字符的前缀，很巧妙的解决了这个问题\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   参考代码\n  </h2>\n  <div>\n   类封装：\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>测试用例:ABACCDA   编码结果:0111010101100  压缩比是:13/21;\n\n存在问题，哈夫曼树是不唯一的，那么就会存在多种编码方式，实际中是如何唯一确定唯一编码方式的，是将相等的权值情况进行了统一定义吗，求解？\n\n\n#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define MAXI 500\n\ntypedef struct node   //空节点的c值是\'#\'，count是-1；其余都是正常值； \n{\n	char c;\n	int count;\n	struct node* left;\n	struct node* right;\n	struct node* parent;\n}point;\n\ntypedef struct k\n{\n	char c;\n	char code[100];\n}bc;\n\nusing namespace std;\n\nclass haffman\n{\n	public:\n		 haffman()\n		 {\n		 	memset(bookchar,0,sizeof(bookchar));\n	     	memset(prefile,0,sizeof(prefile));\n	     	memset(code,0,sizeof(code));\n	     	memset(file,0,sizeof(file));\n	     	memset(workspace,0,sizeof(workspace));\n	     	root=NULL;\n	     	help=NULL;\n	     	number=0;\n	     	worknumber=0;\n		 }\n	     haffman(char p[])\n	     {\n	     	memset(bookchar,0,sizeof(bookchar));\n	     	memset(prefile,0,sizeof(prefile));\n	     	memset(code,0,sizeof(code));\n	     	memset(file,0,sizeof(file));\n	     	memset(workspace,0,sizeof(workspace));\n	     	root=NULL;\n	     	help=NULL;\n	     	number=0;\n	     	worknumber=0;\n	     	strcpy(prefile,p);\n	     }\n	     ~haffman()\n	     {\n	     	clear(root);\n	     	root=NULL;\n	     	number=0;\n	     }\n	     friend istream&amp; operator&gt;&gt;(istream&amp;,haffman&amp;);\n	     friend ostream&amp; operator&lt;&lt;(ostream&amp;,haffman&amp;);\n	     void creattree();\n	         void select(point*&amp;,int,point*);\n	     void followfiletomakecode();\n	         bc makecode(char);\n		     void codewritefile();\n		     void intobookchar(bc);\n		     void findhelp(point*,char);\n	     void clear(point*);\n	     void scan();   //从头到尾扫描文本prefile，生成workspace \n	private:\n		bc bookchar[100];    //记录字符对应编码，方便下次读取 \n		int booknumber;\n		char code[MAXI];   \n		char stack[MAXI];\n		\n		char file[MAXI];   //最终的翻译文本 \n		char prefile[MAXI];\n		int filenumber;\n		\n		point workspace[MAXI];   //哈夫曼算法需要的操作空间 \n		int worknumber;\n		point* help;\n		point* root;    //哈弗曼树根节点 \n		int number;    //字符总数 \n};\n\nistream&amp; operator&gt;&gt;(istream&amp; in,haffman&amp; x)\n{\n	cout&lt;&lt;\'请输入要转译的编码: \';\n	cin&gt;&gt;x.prefile;\n	return in;\n}\n\nostream&amp; operator&lt;&lt;(ostream&amp; out,haffman&amp; x)\n{\n	cout&lt;&lt;\'预处理电文:\'&lt;&lt;x.prefile&lt;&lt;endl;\n	cout&lt;&lt;\'哈夫曼编码:\'&lt;&lt;x.file&lt;&lt;endl;\n    return out;\n} \n\nvoid haffman::scan()\n{\n	for(int i=0;i&lt;strlen(prefile);i++)\n	{\n		int flag=0;\n		for(int j=1;j&lt;=number;j++)\n		{\n			if(workspace[j].c==prefile[i])\n			{\n				flag=1;\n				workspace[j].count++;\n				break;\n			}\n		}\n		if(flag==0)\n		{\n			number++;\n			workspace[number].c=prefile[i];\n			workspace[number].count++;\n			workspace[number].right=workspace[number].left=workspace[number].parent=NULL;\n		}\n	}\n}\n\nvoid haffman::select(point*&amp; a,int p,point* helppp)\n{\n	int mink=9999999;\n	if(p==1)\n	{\n		for(int i=1;i&lt;=worknumber;i++)\n		{\n			if(workspace[i].parent==NULL&amp;&amp;workspace[i].count&lt;mink)\n			{\n				a=&amp;workspace[i];\n				mink=workspace[i].count;\n			}\n		}\n	}\n	else\n	{\n		for(int i=1;i&lt;=worknumber;i++)\n		{\n			if(workspace[i].parent==NULL&amp;&amp;workspace[i].count&lt;mink)\n			{\n				a=&amp;workspace[i];\n				mink=workspace[i].count;\n			}\n		}\n		int minp=9999999;\n		for(int i=1;i&lt;=worknumber;i++)\n		{\n			if(workspace[i].parent==NULL&amp;&amp;workspace[i].count&lt;minp&amp;&amp;(&amp;workspace[i]!=helppp))\n			{\n				a=&amp;workspace[i];\n				minp=workspace[i].count;\n			}\n		}\n	}\n}\n\nvoid haffman::creattree()\n{\n	worknumber=number;\n	int w=number-1;\n	while(w--)\n	{\n    	point* a=NULL;\n    	point* b=NULL;\n    	point* helppp=NULL;\n    	select(a,1,helppp);\n    	helppp=a;\n    	select(b,2,helppp);\n    	worknumber++;\n    	workspace[worknumber].c=\'#\';\n    	if(a-&gt;count&gt;b-&gt;count)\n    	{\n    		workspace[worknumber].right=b;\n    		workspace[worknumber].left=a;\n    	}\n    	else\n    	{\n    		workspace[worknumber].right=a;\n    		workspace[worknumber].left=b;\n    	}\n    	workspace[worknumber].parent=NULL;\n    	a-&gt;parent=&amp;workspace[worknumber];\n    	b-&gt;parent=&amp;workspace[worknumber];\n    }\n    root=&amp;workspace[worknumber];\n}\n\nvoid haffman::findhelp(point* p,char k)\n{\n	if(p==NULL) return ;\n	else\n	{\n		if(p-&gt;c==k) \n		{\n			help=p;\n			return ;\n		}\n		findhelp(p-&gt;left,k);\n		findhelp(p-&gt;right,k);\n	} \n}\n\nbc haffman::makecode(char w)\n{\n	 int k=0;\n	 while(help!=root)\n	 {\n	 	if(help-&gt;parent-&gt;left==help) code[k++]=\'0\';\n	 	else code[k++]=\'1\';\n	 	help=help-&gt;parent;\n	 }\n	 bc p;\n	 memset(p.code,0,sizeof(p.code));\n	 p.c=w;\n	 int j=0;\n	 for(int i=k-1;i&gt;=0;i--,j++) p.code[j]=code[i];\n	 return p;\n}\n\nvoid haffman::intobookchar(bc p)\n{\n    bookchar[++booknumber]=p;\n}\n\nvoid haffman::codewritefile()\n{\n	for(int i=0;i&lt;strlen(prefile);i++)\n	{\n		for(int j=1;j&lt;=booknumber;j++)\n		{\n			if(prefile[i]==bookchar[j].c)\n			{\n				strcpy(file+filenumber,bookchar[j].code);\n				filenumber+=strlen(bookchar[j].code);\n				break;\n			}\n		}\n	}\n}\n\nvoid haffman::followfiletomakecode()\n{\n	booknumber=0;\n	filenumber=0;\n	for(int i=0;i&lt;strlen(prefile);i++)\n	{\n		int flag=0;\n		for(int j=1;j&lt;=booknumber;j++)\n		{\n			if(prefile[i]==bookchar[j].c)\n			{\n				flag=1;\n				break;\n			}\n		}\n		if(flag==0)\n		{\n			findhelp(root,prefile[i]);\n			bc p=makecode(prefile[i]);\n			intobookchar(p);\n		}\n	}\n	codewritefile();\n}\n\nvoid haffman::clear(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		clear(p-&gt;left);\n		clear(p-&gt;right);\n		delete p;\n	}\n}\n\nint main()\n{\n	haffman my;\n	cin&gt;&gt;my;\n	my.scan();\n	my.creattree();\n	my.followfiletomakecode();\n	cout&lt;&lt;my;\n	return 0;\n} </pre>\n   解码方法：\n  </div>\n  <div>\n   对于哈夫曼的解码方式我们采用了DFS的方式查找出个个字符对应的编码，我们直接对译码进行处理，从译码的排列触发DFS递归遍历哈夫曼树，直到找到叶子节点后就完成了一串的翻译工作，知道我们将整个串翻译完成：\n  </div>\n  <div>\n   下面的解码类继承了上面的类，直接写个深搜函数就可以了：\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>class rehuffman:public haffman\n{\n	public:\n		rehuffman()\n		{\n			memset(code,0,sizeof(code));\n			num=0; \n		}\n		void set()\n		{\n			cout&lt;&lt;\'输入要翻译的译码的长度:\';cin&gt;&gt;num;\n			cout&lt;&lt;\'输入你的译码:\';\n			for(int i=1;i&lt;=num;i++) scanf(\'%d\',&amp;code[i]);\n		}\n		void predfs()\n		{\n			for(int i=1;i&lt;=num;i++)\n			{\n				i=dfs(root,i)-1;\n			}\n			cout&lt;&lt;endl;\n		}\n		int dfs(point* root,int i)\n		{\n			if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) \n			{\n				cout&lt;&lt;root-&gt;c;\n				return i;\n			}\n			else\n			{\n				if(code[i]==0) return dfs(root-&gt;left,i+1);\n				else return dfs(root-&gt;right,i+1);\n			}\n		}\n	private:\n		int code[MAXI];\n		int num;\n};</pre>\n   <br/>\n   <h2>\n    参考试题：\n   </h2>\n   <div>\n    NYOJ801：本博主的解题报告链接地址\n    <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52472299\' target=\'_blank\'>\n     点开进入NYOJ801解题报告\n    </a>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('a675a49d805120afdf4fe0ef53d7ce9f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ801-哈夫曼编码（贪心AC）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.题目描述：\n  </h1>\n  <p>\n  </p>\n  <div class=\'problem-display\' style=\'font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n   <h2 style=\'margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体\'>\n    Haffman编码\n   </h2>\n   <div class=\'problem-ins\' style=\'text-align:center\'>\n    时间限制：\n    <span class=\'editable highlight\' id=\'problem[time_limit]\' style=\'color:rgb(113,32,21)\'>\n     1000\n    </span>\n    ms  |  内存限制：\n    <span class=\'editable highlight\' id=\'problem[memory_limit]\' style=\'color:rgb(113,32,21)\'>\n     65535\n    </span>\n    KB\n   </div>\n   <div class=\'problem-ins\' style=\'text-align:center\'>\n    难度：\n    <span class=\'editable highlight\' style=\'color:rgb(113,32,21)\'>\n     3\n    </span>\n   </div>\n  </div>\n  <div class=\'clr\' style=\'clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19.5px\'>\n  </div>\n  <dl class=\'problem-display\' style=\'margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n   <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n    描述\n   </dt>\n   <dd style=\'margin:0px; padding:0px\'>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     哈弗曼编码大家一定很熟悉吧（不熟悉也没关系，自己查去。。。）。现在给你一串字符以及它们所对应的权值，让你构造哈弗曼树，从而确定每个字符的哈弗曼编码。当然，这里有一些小规定：\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     1.规定哈弗曼树的左子树编码为0，右子树编码为1；\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     2.若两个字符权值相同，则ASCII码值小的字符为左孩子，大的为右孩子；\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     3.创建的新节点所代表的字符与它的左孩子的字符相同；\n    </p>\n    <p style=\'margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px\'>\n     4.所有字符为ASCII码表上32-96之间的字符（即“ ”到“`”之间的字符）。\n    </p>\n    <div class=\'clr\' style=\'clear:both\'>\n    </div>\n    <dl class=\'others\' style=\'margin:0px; padding:0px\'>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      输入包含多组数据（不超过100组）\n      <br/>\n      每组数据第一行一个整数n，表示字符个数。接下来n行，每行有一个字符ch和一个整数weight，表示字符ch所对应的权值，中间用空格隔开。\n      <br/>\n      输入数据保证每组测试数据的字符不会重复。\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      对于每组测试数据，按照输入顺序输出相应的字符以及它们的哈弗曼编码结果，具体格式见样例。\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_input\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>3\na 10\nb 5\nc 8\n4\na 1\nb 1\nc 1\nd 1</pre>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_output\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>a:0\nb:10\nc:11\na:00\nb:01\nc:10\nd:11</pre>\n     </dd>\n    </dl>\n   </dd>\n  </dl>\n  <h1>\n   2.算法思路：\n  </h1>\n  <p>\n  </p>\n  <p>\n   首先本体很明显使用贪心的哈夫曼编码的算法即生成最优二叉树\n  </p>\n  <p>\n   本题还要输出哈夫曼编码的编码序列\n  </p>\n  <p>\n   所以说生成最有二叉树之后，我们还需要利用DFS遍历整棵树求出所有的点的编码\n  </p>\n  <p>\n   DFS+贪心\n  </p>\n  <h1>\n   3.AC代码：\n  </h1>\n  <p>\n   本体，本人没有用优先队列的STL来实现，我亲自用堆模拟量优先队列\n  </p>\n  <p>\n   并且强烈的给出题人一个建议，把数据量加上\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 1001\n\nusing namespace std;\n\ntypedef struct node\n{\n	char c;\n	int weight;\n	int left;\n	int right;\n	int code[N];\n	int codenum;\n}point;\n\nint n;\npoint queue[N];\nint heapnum;\nint heap[N];\nint root;   //追踪莫下标 \nint p[N];\n\nvoid siftdown(int i)\n{\n	int t;\n	while(i*2&lt;=heapnum)\n	{\n		if(queue[heap[i]].weight&gt;=queue[heap[i*2]].weight) \n		{\n			if(queue[heap[i]].weight==queue[heap[i*2]].weight)\n			{\n				if(queue[heap[i]].c&lt;queue[heap[i*2]].c) t=i;\n				else t=i*2;\n			}\n			else t=i*2;\n		}\n		else t=i;\n		if(i*2+1&lt;=heapnum&amp;&amp;queue[heap[i*2+1]].weight&lt;=queue[heap[t]].weight)\n		{\n			if(queue[heap[i*2+1]].weight==queue[heap[t]].weight)\n			{\n				if(queue[heap[i*2+1]].c&lt;queue[heap[t]].c) t=i*2+1;\n			}\n			else t=i*2+1;\n		}\n		if(i!=t)\n		{\n			int w=heap[i];\n			heap[i]=heap[t];\n			heap[t]=w;\n			i=t;\n		}\n		else break;\n	}\n}\n\nvoid dfs(int root,int num)\n{\n	if(queue[root].left==0&amp;&amp;queue[root].right==0)\n	{\n		queue[root].codenum=num-1;\n		for(int i=1;i&lt;=queue[root].codenum;i++)\n		{\n			queue[root].code[i]=p[i];\n		}\n		return ;\n	}\n	else\n	{\n		p[num]=0;\n		dfs(queue[root].left,num+1);\n		p[num]=1;\n		dfs(queue[root].right,num+1);\n	}\n}\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)!=EOF)\n	{\n		getchar();\n		memset(p,0,sizeof(p));\n		memset(queue,0,sizeof(queue));\n		for(int i=1;i&lt;=n;i++)\n		{\n			scanf(\'%c\',&amp;queue[i].c);getchar();\n			scanf(\'%d\',&amp;queue[i].weight);getchar();\n		}\n		for(int i=1;i&lt;=n;i++) heap[i]=i;\n		heapnum=root=n;\n		for(int i=heapnum/2;i&gt;=1;i--) siftdown(i);\n		\n		while(heapnum!=1)\n		{\n			int k=queue[heap[1]].weight;\n			root++;\n			queue[root].c=queue[heap[1]].c;\n			queue[root].left=heap[1];\n			if(heapnum==2)\n			{\n				k+=queue[heap[2]].weight;\n				queue[root].weight=k;\n				queue[root].right=heap[2];\n				heap[2]=root;\n				heap[1]=heap[heapnum];\n				heapnum--;\n				siftdown(1);\n			}\n			else\n			{\n				heap[1]=heap[heapnum];\n				heapnum--;\n				siftdown(1);\n				queue[root].right=heap[1];\n				k+=queue[heap[1]].weight;\n				queue[root].weight=k;\n				heap[1]=root;\n				siftdown(1);\n			}\n		}\n		\n		dfs(root,1);\n		for(int i=1;i&lt;=n;i++)\n		{\n			printf(\'%c:\',queue[i].c);\n			for(int j=1;j&lt;=queue[i].codenum;j++) printf(\'%d\',queue[i].code[j]);\n			printf(\'\n\');\n		}\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('553c020eb715c10a4bf59bd0cf5d0660','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2388-排序水题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.题目：\n  </h1>\n  <p>\n   奇数个数排序求中位数\n  </p>\n  <h1>\n   2.三种排序方法：\n  </h1>\n  <div>\n   <br/>\n  </div>\n  <p>\n   1.快排 700k 16Ms\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1871608\' name=\'code\' snippet_file_name=\'blog_20160908_1_1982367\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 10010\n\nusing namespace std;\n\nint data[N];\nint n;\n\nvoid quicksort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int i=left;\n		int j=right;\n		int temp=data[left];\n		while(i!=j)\n		{\n			while(i&lt;j&amp;&amp;data[j]&gt;=temp) j--;\n			while(i&lt;j&amp;&amp;data[i]&lt;=temp) i++;\n			if(i!=j)\n			{\n				int t=data[i];\n				data[i]=data[j];\n				data[j]=t;\n			}\n		}\n		data[left]=data[i];\n		data[i]=temp;\n		quicksort(left,i-1);\n		quicksort(i+1,right);\n		return ;\n	}\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;n);\n	for(int i=1;i&lt;=n;i++) scanf(\'%d\',&amp;data[i]);\n	quicksort(1,n);\n	printf(\'%d\n\',data[(n+1)/2]);\n	return 0;\n}</pre>\n  <br/>\n  2.归并排序 700k 16Ms\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1871608\' name=\'code\' snippet_file_name=\'blog_20160908_2_7554501\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 10010\n#define inf 99999999\n\nusing namespace std;\n\nint data[N];\nint n;\n\nvoid mergesort(int left,int mid,int right)\n{\n	int n1=mid-left+1;\n	int n2=right-mid;\n	int s1[n1+2];\n	int s2[n2+2];\n	int i,j;\n	for(i=left;i&lt;=mid;i++) s1[i-left+1]=data[i];\n	for(j=mid+1;j&lt;=right;j++) s2[j-mid]=data[j];\n	i=j=1;\n	s1[n1+1]=s2[n2+1]=inf;\n	for(int k=left;k&lt;=right;k++)\n	{\n		if(s1[i]&gt;s2[j]) data[k]=s2[j++];\n		else data[k]=s1[i++];\n	} \n}\n\nvoid merge(int left,int right)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int mid=(left+right)/2;\n		merge(left,mid);\n		merge(mid+1,right);\n		mergesort(left,mid,right);\n	}\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;n);\n	for(int i=1;i&lt;=n;i++) scanf(\'%d\',&amp;data[i]);\n	merge(1,n);\n	printf(\'%d\n\',data[(n+1)/2]);\n	return 0;\n}</pre>\n  <br/>\n  3.堆排 736k 16Ms\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1871608\' name=\'code\' snippet_file_name=\'blog_20160908_3_7412798\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 10010\n\nusing namespace std;\n\nint data[N];\nint n;\nint heap[N];\nint heapnum;\n\nvoid swap(int x,int y)\n{\n	int t=data[x];\n	data[x]=data[y];\n	data[y]=t;\n}\n\nvoid siftdown(int i)\n{\n	int t;\n	while(i*2&lt;=heapnum)\n	{\n		if(data[heap[i]]&gt;data[heap[i*2]]) t=i*2;\n		else t=i;\n		if(i*2+1&lt;=heapnum&amp;&amp;data[heap[i*2+1]]&lt;data[heap[t]]) t=i*2+1;\n		if(i!=t)\n		{\n			swap(i,t);\n			i=t;\n		}\n		else break;\n	}\n}\n\nvoid heapsort()\n{\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		swap(1,heapnum);\n		heapnum--;\n		siftdown(1);\n	}\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;n);\n	for(int i=1;i&lt;=n;i++)\n	{\n		scanf(\'%d\',&amp;data[i]);\n		heap[i]=i;\n	}\n	heapnum=n;\n	for(int i=n/2;i&gt;=1;i--) siftdown(i);\n	heapsort();\n	printf(\'%d\n\',data[(n+1)/2]);\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('bf6117e70f273d2db48fb77ebddfd627','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ1129-很新颖的DFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.题目描述：\n  </h1>\n  <div>\n   <div class=\'problem-display\' style=\'font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n    <h2 style=\'margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体\'>\n     Salvation\n    </h2>\n    <div class=\'problem-ins\' style=\'text-align:center\'>\n     时间限制：\n     <span class=\'editable highlight\' id=\'problem[time_limit]\' style=\'color:rgb(113,32,21)\'>\n      1000\n     </span>\n     ms  |  内存限制：\n     <span class=\'editable highlight\' id=\'problem[memory_limit]\' style=\'color:rgb(113,32,21)\'>\n      65535\n     </span>\n     KB\n    </div>\n    <div class=\'problem-ins\' style=\'text-align:center\'>\n     难度：\n     <span class=\'editable highlight\' style=\'color:rgb(113,32,21)\'>\n      3\n     </span>\n    </div>\n   </div>\n   <div class=\'clr\' style=\'clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19.5px\'>\n   </div>\n   <dl class=\'problem-display\' style=\'margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n    <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n     描述\n    </dt>\n    <dd style=\'margin:0px; padding:0px\'>\n     <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px; text-align:center\'>\n      <span style=\'font-size:10.5pt; font-family:宋体\'>\n       <img alt=\'\' border=\'0\' height=\'240\' src=\'http://acm.nyist.net/JudgeOnline/admin/kind/attached/20141030204935_72500.jpg\' style=\'border:0px none\' width=\'400\'/>\n      </span>\n     </p>\n     <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px\'>\n      <span style=\'font-size:10.5pt; font-family:宋体\'>\n       神秘瀑布镇是一个神秘的地方，那里有吸血鬼，狼人，巫师，二重身。\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Klaus（吸血鬼祖先）\n       </span>\n       为了利用\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Elena\n       </span>\n       的血液发展他的混血大军（吸血鬼&amp;狼人），也来到了神秘瀑布镇。\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Stefan\n       </span>\n       因为深爱着\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Elena\n       </span>\n       ，于是\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Stefan\n       </span>\n       决定去唤醒吸血鬼猎人，来解救\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Elena\n       </span>\n       。\n      </span>\n      <span style=\'font-size:10.5pt; font-family:宋体\'>\n      </span>\n     </p>\n     <p class=\'p0\' style=\'margin-top:0pt; margin-bottom:0pt; padding-top:0px; padding-bottom:0px\'>\n      <span style=\'font-size:10.5pt; font-family:宋体\'>\n       吸血鬼猎人被封锁在一个迷宫里，这个迷宫有一种特性，只要进入就会失去方向感。于是\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Stefan\n       </span>\n       想到一种方法，以左为标准（即优先左走），其次向前，向右，如果都无法走就向后走（即向右转两次）。他可以向上下左右四个方向的空格移动一个格，每次耗费\n       <span style=\'font-family:\'Times New Roman\'\'>\n        1\n       </span>\n       分钟。\n       <span style=\'font-family:\'Times New Roman\'\'>\n        Stefan\n       </span>\n       在得知你是一个有天赋的程序员后，决定让你判断他是否能找到吸血鬼猎人。\n      </span>\n      <span style=\'font-size:10.5pt; font-family:宋体\'>\n      </span>\n     </p>\n     <div class=\'clr\' style=\'clear:both\'>\n     </div>\n     <dl class=\'others\' style=\'margin:0px; padding:0px\'>\n      <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n       输入\n      </dt>\n      <dd style=\'margin:0px; padding:0px\'>\n       输入包含多组测试数据，第一行输入 n , m ( 2 &lt; n ,m &lt;= 100) ,接下来n行每行m个字符，第 n + 2 行一个字符表示初始方向（E W S N）。\n       <br/>\n       “.”代表空格 ，“#”代表墙 , “ T ”代表初始位置，“X”代表吸血鬼猎人的位置。\n      </dd>\n      <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n       输出\n      </dt>\n      <dd style=\'margin:0px; padding:0px\'>\n       输出一行，如果能找到输出“YES”，否则输出“NO”。\n      </dd>\n      <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n       样例输入\n      </dt>\n      <dd style=\'margin:0px; padding:0px\'>\n       <pre id=\'sample_input\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>4 4\n....\n.##.\n.##.\nTX..\nN\n4 4\n....\n.##.\n.###\nT#.X\nN</pre>\n      </dd>\n      <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n       样例输出\n      </dt>\n      <dd style=\'margin:0px; padding:0px\'>\n       <pre id=\'sample_output\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>YES\nNO</pre>\n      </dd>\n      <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n       提示\n      </dt>\n      <dd style=\'margin:0px; padding:0px\'>\n       优先左走即：如果左边能走就向左走，如果不能走向前走，如果前不能走，向右走，如果右不能走向后走。\n      </dd>\n     </dl>\n    </dd>\n   </dl>\n   <h1>\n    2.算法思想：\n   </h1>\n  </div>\n  <div>\n   首先本体很明显需要用到DFS来查找可行解，但是本体新颖之处有两个\n  </div>\n  <div>\n   1.变方向\n  </div>\n  <div>\n   2.顺路径搜索\n  </div>\n  <div>\n   我们先来看看顺路径搜索的策略：\n  </div>\n  <div>\n   首先，根据我们以往的DFS的经验来看，我们想要查找可行解的话，需要的是将整个图进行遍历，用深搜的话是O(n*2)的时间复杂度，但是本体的特殊性在于我们是有方向优先的，所以说，我们不能按照以往的思维习惯来在每个点的基础上搜四个方向\n  </div>\n  <div>\n   相反，我们应该按照我们平常找路的思路来\n  </div>\n  <div>\n   其实我们平常找路的思路和标准的DFS的回溯思想还好i有着不一样的地方的\n  </div>\n  <div>\n   在理清题意之前，我们首先需要搞明白两者之间的不同之处\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   回溯的思想：利用递归，我们每次的四个方向查找失败之后，都会回溯至父点处重新进行下一轮选择\n  </div>\n  <div>\n   本题的思路：因为本题中声明了我们的搜索方式是按照左-前-右-后的思路来进行查找，所以说，加入我们走进了死胡同，三个方向都查找失败，但是轮到我们要往回走，往回走的时候，方向就改变了，在回溯法的思想中，我们遇到死胡同之后，因为向后的方向已经被标记过走过，所以说，我们是直接回溯至源点做下一轮选择，这两点是不一样的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   就跟本来说，其实我们只要将平常的DFS的搜索时不要进行标记，允许我们向后走原路的话，也可以轻而易举结局这个小的问题\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   其次，变方向，照理来说，变方向是非常的复杂的，我开始的思路是开辟四种选择策略，针对不同的方向选择不同的选择策略，但是发现没有领悟精髓\n  </div>\n  <div>\n   大神的公式键值精简到世界崩塌，还没有搞懂原理，但是参考一下吧\n  </div>\n  <h1>\n   3.AC代码\n  </h1>\n  <h2>\n   1.大神的简化代码：\n  </h2>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 120\n\nusing namespace std;\n\nint nx[4]={-1,0,1,0};\nint ny[4]={0,-1,0,1};\nint n,m;\nint book[N][N];\nchar map[N][N];\nint bx,by;\nint j;\nchar d;\nint ds;\n\nvoid dfs(int x,int y,int p)\n{\n	if(j) return ;\n	for(int i=1;i&gt;-3;i--)\n	{\n		int k=(p+i+8)%4;\n		int dx=x+nx[k];\n		int dy=y+ny[k];\n		if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy]==\'#\') continue;\n		else\n		{\n			if(map[dx][dy]==\'X\')\n			{\n				j=1;\n				return ;\n			}\n			else\n			{\n				if(book[dx][dy]==4) return ;\n				book[dx][dy]++;\n				dfs(dx,dy,k);\n				return ; \n			}\n		}\n	}\n} \n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)!=EOF)\n	{\n		j=0;\n		memset(book,0,sizeof(book));\n		memset(map,0,sizeof(map));\n		getchar();\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				scanf(\'%c\',&amp;map[i][j]);\n				if(map[i][j]==\'T\')\n				{\n					bx=i;\n					by=j;\n				} \n			}\n			getchar();\n		}\n		scanf(\'%c\',&amp;d);getchar();\n		if(d==\'N\') ds=0;  \n        else if(d==\'W\') ds=1;  \n        else if(d==\'S\') ds=2;  \n        else ds=3;\n		dfs(bx,by,ds);\n		if(j) printf(\'YES\n\');\n		else printf(\'NO\n\');\n	}\n	return 0;\n}</pre>\n   <br/>\n   <h2>\n    2.我的思路：\n   </h2>\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nint n,m;\nint nn[4][2]={{0,-1},{-1,0},{0,1},{1,0}};\nint ns[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nint nw[4][2]={{1,0},{0,-1},{-1,0},{0,1}};\nint ne[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\nchar map[200][200];\nint book[200][200];\nchar dir;\nint bx,by;\nint ex,ey;\n\nbool dfs(int x,int y,char d)\n{\n	if(d==\'N\')\n	{\n		int dx,dy;\n		for(int i=0;i&lt;4;i++)\n		{\n			dx=x+nn[i][0];\n			dy=y+nn[i][1];\n			if(book[dx][dy]==4) return false;\n			if(dx==ex&amp;&amp;dy==ey) return true;\n			book[dx][dy]++;\n			if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy]==\'#\') continue;\n			else\n			{\n				bool k;\n				switch(i)\n				{\n					case 0:k=dfs(dx,dy,\'W\');break;\n					case 1:k=dfs(dx,dy,\'N\');break;\n					case 2:k=dfs(dx,dy,\'E\');break;\n					case 3:k=dfs(dx,dy,\'S\');break;\n				}\n				if(k==true) return true;\n			    else return false;\n			}\n		}\n	}\n	else if(d==\'S\')\n	{\n		int dx,dy;\n		for(int i=0;i&lt;4;i++)\n		{\n			dx=x+ns[i][0];\n			dy=y+ns[i][1];\n			if(book[dx][dy]==4) return false;\n			if(dx==ex&amp;&amp;dy==ey) return true;\n			book[dx][dy]++;\n			if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy]==\'#\') continue;\n			else\n			{\n				bool k;\n				switch(i)\n				{\n					case 0:k=dfs(dx,dy,\'E\');break;\n					case 1:k=dfs(dx,dy,\'S\');break;\n					case 2:k=dfs(dx,dy,\'W\');break;\n					case 3:k=dfs(dx,dy,\'N\');break;\n				}\n				if(k==true) return true;\n				else return false;\n			}\n		}\n	}\n	else if(d==\'E\')\n	{\n		int dx,dy;\n		for(int i=0;i&lt;4;i++)\n		{\n			dx=x+ne[i][0];\n			dy=y+ne[i][1];\n			if(book[dx][dy]==4) return false;\n			if(dx==ex&amp;&amp;dy==ey) return true;\n			book[dx][dy]++;\n			if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy]==\'#\') continue;\n			else\n			{\n				bool k;\n				switch(i)\n				{\n					case 0:k=dfs(dx,dy,\'N\');break;\n					case 1:k=dfs(dx,dy,\'E\');break;\n					case 2:k=dfs(dx,dy,\'S\');break;\n					case 3:k=dfs(dx,dy,\'W\');break;\n				}\n				if(k==true) return true;\n				else return false;\n			}\n		}\n	}\n	else if(d==\'W\')\n	{\n		int dx;\n		int dy;\n		for(int i=0;i&lt;4;i++)\n		{\n			dx=x+nw[i][0];\n			dy=y+nw[i][1];\n			if(book[dx][dy]==4) return false;\n			if(dx==ex&amp;&amp;dy==ey) return true;\n			book[dx][dy]++;\n			if(dx&lt;1||dy&lt;1||dx&gt;n||dy&gt;m||map[dx][dy]==\'#\') continue;\n			else\n			{\n				bool k;\n				switch(i)\n				{\n					case 0:k=dfs(dx,dy,\'S\');break;\n					case 1:k=dfs(dx,dy,\'W\');break;\n					case 2:k=dfs(dx,dy,\'N\');break;\n					case 3:k=dfs(dx,dy,\'E\');break;\n				}\n				if(k==true) return true;\n				else return false;\n			}\n		}\n	}\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)!=EOF)\n	{\n		memset(book,0,sizeof(book));\n		getchar();\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				scanf(\'%c\',&amp;map[i][j]);\n				if(map[i][j]==\'T\')\n				{\n					bx=i;\n					by=j;\n				}\n				if(map[i][j]==\'X\')\n				{\n					ex=i;\n					ey=j;\n				}\n			}\n			getchar();\n		}\n		scanf(\'%c\',&amp;dir);\n		getchar();\n		if(dfs(bx,by,dir)) printf(\'YES\n\');\n		else printf(\'NO\n\'); \n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('47d53c29a468be6ee33429fde5d80ed0','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ3026-最小生成树+BFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.蛋疼的题目：\n  </h1>\n  <p>\n   这道题有两个蛋疼的地方\n  </p>\n  <p>\n   1.出题者脑残了，看来discuss才知道，WA了这么多原来是真是数据后面不止一个空哥个和换行\n  </p>\n  <p>\n   2.数据大小根本不是100，要比100大，尽量开大吧\n  </p>\n  <h1>\n   2.算法思路：\n  </h1>\n  <h2>\n   1.题意：\n  </h2>\n  <p>\n   在一个迷宫里，起点是S，A代表外星人，我们需要找到最短的路径将S和所有的A连接起来，输出最短的这个路径总长\n  </p>\n  <h2>\n   2.思路：\n  </h2>\n  <p>\n   1.首先，我们需要利用BFS对图进行预处理，我们是不知道每个节点之间的最短路径的，所以说，先用BFS对每个点进行处理，找到该店对于其他的点的所有的最短路径（注意，这样处理之后，我们会发现该图是稠密图，对于稠密图我们采用Prim算法）\n  </p>\n  <p>\n   2.套用Prim算法，求最小生成树\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   ps：本体明显是一道好题，但是出题者毁了它\n  </p>\n  <h1>\n   3.AC代码：63Ms\n  </h1>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'cstdio\' \n#define inf 1005\n\nusing namespace std;\n\ntypedef struct node\n{\n	char c;\n	int x;\n	int y;\n	int s;\n}k;\n\nk point[inf];\nint map[inf][inf];\nk tu[inf][inf];\nint pointnum;\nint sum;\nint dis[inf];\nint book[inf];\nint x,y;\nint nextk[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\n\nvoid bfs(int a,int b)\n{\n	int head=1;\n	int tail=1;\n	k queue[100*100];\n	queue[head].x=a;\n	queue[head].y=b;\n	queue[head].s=0;\n	int ju[105][105];\n	memset(ju,0,sizeof(ju));\n	ju[a][b]=1;\n	tail++;\n	while(head!=tail)\n	{\n		for(int i=0;i&lt;4;i++)\n		{\n			int dx=queue[head].x+nextk[i][0];\n			int dy=queue[head].y+nextk[i][1];\n			if(dx&lt;1||dy&lt;1||dx&gt;x||dy&gt;y||tu[dx][dy].c==\'#\'||ju[dx][dy]==1) continue;\n			else\n			{\n				if(tu[dx][dy].c==\'A\'||tu[dx][dy].c==\'S\')\n				{\n					map[tu[a][b].s][tu[dx][dy].s]=queue[head].s+1;\n				}\n				ju[dx][dy]=1;\n				queue[tail].x=dx;\n				queue[tail].y=dy;\n				queue[tail].s=queue[head].s+1;\n				tail++;\n			}\n		}\n		head++;\n	}\n}\n\nint main()\n{\n	char p[inf];\n	int t;\n	scanf(\'%d\',&amp;t);\n	getchar();\n	while(t--)\n	{\n		char p[55];\n		cin&gt;&gt;y&gt;&gt;x;\n		gets(p);\n		pointnum=1;\n		sum=0;\n		memset(map,0,sizeof(map));\n		memset(tu,0,sizeof(tu));\n		memset(dis,0,sizeof(dis));\n		memset(book,0,sizeof(book));\n		for(int i=1;i&lt;=x;i++)\n		{\n			for(int j=1;j&lt;=y;j++)\n			{\n				scanf(\'%c\',&amp;tu[i][j].c);\n				if(tu[i][j].c==\'S\')\n				{\n					point[1].x=i;\n					point[1].y=j;\n					tu[i][j].s=1;\n				}\n				if(tu[i][j].c==\'A\')\n				{\n					point[++pointnum].x=i;\n					point[pointnum].y=j;\n					tu[i][j].s=pointnum;\n				}\n			}\n			gets(p);\n		}\n		for(int i=1;i&lt;=pointnum;i++)\n		{\n			bfs(point[i].x,point[i].y);\n		}\n		for(int i=1;i&lt;=pointnum;i++)\n		{\n			dis[i]=map[1][i];\n		}\n		book[1]=1;\n		for(int i=1;i&lt;=pointnum-1;i++)\n		{\n			int mink=99999999;\n			int minpoint;\n			for(int j=1;j&lt;=pointnum;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&lt;mink) \n				{\n					mink=dis[j];\n					minpoint=j;\n				}\n			}\n			book[minpoint]=1;\n			sum+=mink;\n			for(int j=1;j&lt;=pointnum;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j]) dis[j]=map[minpoint][j];\n			}\n		}\n		printf(\'%d\n\',sum);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ce1ed2ba15f92006c1d67ea944cef29b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ1258-最小生成树水题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1870906\' name=\'code\' snippet_file_name=\'blog_20160907_1_317047\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define inf 99999999\n\nusing namespace std;\n\nint map[510][510];\nint dis[510];\nint n;\nint sum;\nint book[510];\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)!=EOF)\n	{\n		memset(book,0,sizeof(book));\n		sum=0;\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				scanf(\'%d\',&amp;map[i][j]);\n			}\n		}\n		memset(dis,0,sizeof(dis));\n		for(int i=1;i&lt;=n;i++) dis[i]=map[1][i];\n		book[1]=1;\n		for(int i=1;i&lt;=n-1;i++)\n		{\n			int minpoint;\n			int mink=inf;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&lt;mink)\n				{\n					mink=dis[j];\n					minpoint=j;\n				}\n			}\n			book[minpoint]=1;\n			sum+=mink;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j]) dis[j]=map[minpoint][j];\n			}\n		}\n		printf(\'%d\n\',sum);\n	}\n	return 0;\n} </pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('baa0f53625a6050e36ede49043cd75ac','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2485-最小生成树水题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.算法：\n  </h1>\n  <p>\n   本体已经给你邻接矩阵了\n  </p>\n  <p>\n   注意要点：\n  </p>\n  <p>\n   1.本题中图是边护很多的图，所以说，本体使用Krustral算法不太理想，我们要排序的边实在太多了，所以说我们采用Prim算法\n  </p>\n  <p>\n   2.本题的求解题意是求出最小生成树中的最大边，我们对求最小生成树的算法稍加改进就可以AC\n  </p>\n  <h1>\n   2.AC代码\n  </h1>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1870899\' name=\'code\' snippet_file_name=\'blog_20160907_1_4691388\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define inf 99999999\n\nusing namespace std;\n\nint map[510][510];\nint dis[510];\nint n;\nint sum;\nint book[510];\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		memset(book,0,sizeof(book));\n		sum=0;\n		scanf(\'%d\',&amp;n);\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				scanf(\'%d\',&amp;map[i][j]);\n			}\n		}\n		memset(dis,0,sizeof(dis));\n		for(int i=1;i&lt;=n;i++) dis[i]=map[1][i];\n		book[1]=1;\n		for(int i=1;i&lt;=n-1;i++)\n		{\n			int minpoint;\n			int mink=inf;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&lt;mink)\n				{\n					mink=dis[j];\n					minpoint=j;\n				}\n			}\n			book[minpoint]=1;\n			sum=sum&gt;mink?sum:mink;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j]) dis[j]=map[minpoint][j];\n			}\n		}\n		printf(\'%d\n\',sum);\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('69467a1e1005522c2cc3019a98581c0d','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  2016BIT 小学期 —— 编程珠玑 动态规划基础\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.题目描述\n  </h1>\n  <h2>\n   12.编程珠玑\n  </h2>\n  <div class=\'box time-table\'>\n   <table class=\'generaltable \'>\n    <tbody>\n     <tr>\n      <td class=\'cell c0\'>\n       成绩\n      </td>\n      <td class=\'cell c1\'>\n       10\n      </td>\n      <td class=\'cell c2\'>\n       开启时间\n      </td>\n      <td class=\'cell c3 lastcol\'>\n       2016年09月6日 星期二 11:00\n      </td>\n     </tr>\n     <tr>\n      <td class=\'cell c0\'>\n       折扣\n      </td>\n      <td class=\'cell c1\'>\n       0.8\n      </td>\n      <td class=\'cell c2\'>\n       折扣时间\n      </td>\n      <td class=\'cell c3 lastcol\'>\n       2016年09月12日 星期一 23:55\n      </td>\n     </tr>\n     <tr class=\'lastrow\'>\n      <td class=\'cell c0\'>\n       允许迟交\n      </td>\n      <td class=\'cell c1\'>\n       否\n      </td>\n      <td class=\'cell c2\'>\n       关闭时间\n      </td>\n      <td class=\'cell c3 lastcol\'>\n       2016年10月10日 星期一 23:55\n      </td>\n     </tr>\n    </tbody>\n   </table>\n  </div>\n  <div class=\'box description\'>\n   <div class=\'box intro\'>\n    <div class=\'no-overflow\'>\n     <p>\n      你有一条项链，它由 N 个随机排列的红、白和蓝色的珠子组成（3&lt;=N&lt;=350）。下面的例子展示了两条 N=29 时的项链：\n     </p>\n     <pre>             1 2                              1 2\n           r b b r                           b r r b\n          r         b                       b         b\n         r           r                     b           r\n        r             r                   w             r\n       b               r                 w               w\n      b                 b               r                 r\n      b                 b               b                 b\n      b                 b               r                 b\n       r               r                 b               r\n        b             r                   r             r\n         b           r                     r           r\n           r       r                         r       b\n             r b r                            r r w\n          Figure A                     Figure B\n                        r red bead\n                        b blue bead\n                        w white bead</pre>\n     <pre>项链上的第一个和第二个珠子已经在图中标出了。</pre>\n     <p>\n      图 A 也可以用一个由 b 和 r 组成的字符串直接表示，b 代表蓝色而 r 代表红色，如下所示：brbrrrbbbrrrrrbrrbbrbbbbrrrrb。\n     </p>\n     <p>\n      假设你想从项链的某处将它截断拉直；接着从一端向另外一端数收集同颜色的珠子，直到碰到一个不同颜色的珠子为止；然后再从另外一端做同样的操作。(一端收集的珠子颜色可以不同于另一端的。)\n     </p>\n     <p>\n      请想办法找到一个截断项链的位置，能够让我们尽量多地收集到同色的珠子。\n     </p>\n     <h3>\n      例子\n     </h3>\n     <p>\n      如图 A 中的项链，从第 9 和第 10 个或者第 24 和 第 25 个珠子中间截断，则我们可以收集到 8 个珠子。\n     </p>\n     <p>\n      图 B 中的项链有白色的珠子，当遇到白色的珠子时，它既可以作为蓝色的珠子看待，也可以作为红色的珠子看待，由收集珠子时的需求决定。包含有白色珠子的项链则会由 r、b 和 w 字符组成的字符串来表示。\n     </p>\n     <p>\n      请编写一个程序计算从某条项链中能够收集到多少个珠子。\n     </p>\n     <h3>\n      输入格式\n     </h3>\n     <p>\n      第一行： N，项链上珠子的个数\n     </p>\n     <p>\n      第二行：一个字符串，长度为 N，由 r、b 和 w字符组成\n     </p>\n     <h3>\n      输入样例\n     </h3>\n     <pre>29 wwwbbrwrbrbrrbrbrwrwwrbwrwrrb</pre>\n     <h3>\n      输出格式\n     </h3>\n     <p>\n      输出一行字符，它应该包含了计算出的结果。\n     </p>\n     <h3>\n      输出样例\n     </h3>\n     <h3>\n      11\n     </h3>\n     <h1>\n      2.算法：\n     </h1>\n     <div>\n      首先对于动态规划的算法我们首先需要定义状态：\n     </div>\n     <div>\n      这里我们根据题目需要，需要定义两个状态\n     </div>\n     <div>\n      dp1[i]代表数组标号为i的元素左边的连续最大长度\n     </div>\n     <div>\n      dp2[i]代表数组标号为i的元素的右边的最大连续长度\n     </div>\n     <div>\n      最终的结果，最大值应该是所有的dp1[i]+dp2[i+1]的最大值\n     </div>\n     <div>\n      <br/>\n     </div>\n     <div>\n      定义状态转移方程：\n     </div>\n     <div>\n      if data[i]=data[i-1]  dp1[i]=dp1[i-1]+1\n     </div>\n     <div>\n      else  dp1[i]=1\n     </div>\n     <div>\n      <br/>\n     </div>\n     <div>\n      if  data[i]=data[i+1]   dp2[i]=dp2[i+1]+1;\n     </div>\n     <div>\n      else dp2[i]=1\n     </div>\n     <div>\n      <br/>\n     </div>\n     <div>\n      上述只是我们的思维展示，实际上的一些技巧也是必须的\n     </div>\n     <div>\n      1.复制数组空间2倍\n     </div>\n     <div>\n      2.控制最终的访问边界\n     </div>\n     <div>\n      <br/>\n     </div>\n     <h1>\n      3.AC核心代码：\n     </h1>\n     <div>\n      为了防止网教查重，我只附上核心代码段：\n     </div>\n     <div>\n      dp1  （now控制访问边界）\n     </div>\n     <div>\n      <pre class=\'cpp\' code_snippet_id=\'1870690\' name=\'code\' snippet_file_name=\'blog_20160907_1_1197400\'>for(int i=2+n;i&lt;=2*n;i++)\n	{\n		if(j==\'\0\'||data[i]==j||data[i]==\'w\') \n		{\n			dp[i-n]=dp[i-1-n]+1;\n			if(data[i]!=\'w\') now=i;\n		}\n		else \n		{\n			dp[i-n]=i-now;\n			now=i;\n			j=data[i];\n		}\n	}</pre>\n      dp2\n     </div>\n     <div>\n      <pre class=\'html\' code_snippet_id=\'1870690\' name=\'code\' snippet_file_name=\'blog_20160907_2_3704871\'>	for(int i=n-1;i&gt;=1;i--)\n	{\n		if(j==\'\0\'||data[i]==j||data[i]==\'w\') \n		{\n			dpk[i]=dpk[i+1]+1;\n			if(data[i]!=\'w\') now=i;\n		}\n		else \n		{\n			dpk[i]=now-i;\n			now=i;\n			j=data[i];\n		}\n	}</pre>\n      <br/>\n      <br/>\n      最终合并的核心代码段;\n     </div>\n     <div>\n      <pre class=\'cpp\' code_snippet_id=\'1870690\' name=\'code\' snippet_file_name=\'blog_20160907_3_8546657\'>for(int i=1;i&lt;=n;i++)\n	{\n		int k;\n		if(i==n) k=dp[i]+dpk[1];\n		else k=dp[i]+dpk[i+1];\n		sum=sum&gt;k?sum:k;\n	}</pre>\n      <br/>\n      <br/>\n     </div>\n     <div>\n      <br/>\n     </div>\n    </div>\n   </div>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('25d48d7f593789a19d61d25b8dee58da','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ1789——最小生成树\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题意：\n  </h2>\n  <div>\n   输入：\n  </div>\n  <div>\n   n输入，代表有n个长度为7的字符串，我们以字符串本身为结点，题中定义了两个节点之间的距离，定义为两个字符串中相同位置处不同的字符的个数，所以我们发现本题是个非常稠密的图\n  </div>\n  <div>\n   我们直接用二维矩阵记录所有的数据比较能够大米毒的合理利用空间\n  </div>\n  <div>\n   输出最小生成树的倒数\n  </div>\n  <h2>\n   2.算法：\n  </h2>\n  <div>\n   本题中我们会发现，边的数目非常的庞大\n  </div>\n  <div>\n   这就引出了一个问题\n  </div>\n  <div>\n   Krustral算法要涉及到排序，如此大数据量的排序很明显会很消耗时间\n  </div>\n  <div>\n   所以说，我们综合考虑采用Prim算法来计算最小生成树的代价\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   ps:注意点：本题中，因为输入的数据过于庞大，所以说，我们最好不要用string类型和C++的流输入来编程，会超时的很严重，今次在此提醒，尤其是不要用String类型，对象的引入会让程序变的非常的慢\n  </div>\n  <h2>\n   3.AC代码：\n   <pre class=\'cpp\' code_snippet_id=\'1865706\' name=\'code\' snippet_file_name=\'blog_20160904_1_6563642\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 2010\n#define inf 99999999\n\nusing namespace std;\n\nint n;\nchar data[N][8];\nint map[N][N];\nint dis[N];\nint sum;\nint book[N];\n\nint getnum(int x,int y)\n{\n	int w=0;\n	for(int i=0;i&lt;7;i++)\n	{\n		if(data[x][i]!=data[y][i]) w++;\n	}\n	return w;\n}\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n!=0)\n	{\n		sum=0;\n		memset(book,0,sizeof(book));\n		for(int i=1;i&lt;=n;i++)\n		{\n			scanf(\'%s\',data[i]);\n		}\n		\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=i+1;j&lt;=n;j++)\n			{\n				if(i==j) continue;\n				map[i][j]=map[j][i]=getnum(i,j);\n			}\n		}\n		\n		for(int i=1;i&lt;=n;i++) dis[i]=inf;\n		dis[1]=0;\n		for(int i=1;i&lt;=n;i++) dis[i]=map[1][i];\n		book[1]=1;\n		for(int i=1;i&lt;=n-1;i++)\n		{\n			int mink=inf;\n			int minpoint;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&lt;mink)\n				{\n					mink=dis[j];\n					minpoint=j;\n				}\n			}\n			book[minpoint]=1;\n			sum+=mink;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j]) dis[j]=map[minpoint][j];\n			}\n		}\n		printf(\'The highest possible quality is 1/%d.\n\',sum);\n	}\n	return 0;\n} </pre>\n   <br/>\n  </h2>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('8f4b0ef1601de83b334fff8001f6d50a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2421——最小生成树复习\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目：\n  </h2>\n  <p>\n   村庄之间有些路，有的已经修过了\n  </p>\n  <p>\n   输入n代表村庄的数目\n  </p>\n  <p>\n   之后n*n代表村庄之间的道路的长度的矩阵\n  </p>\n  <p>\n   输入q\n  </p>\n  <p>\n   之后q行代表已经修过路的两个村庄的标号\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   求最小生成树\n  </p>\n  <h2>\n   2.算法：\n  </h2>\n  <p>\n   Krustral不解释\n  </p>\n  <h2>\n   3.AC代码：\n  </h2>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1865297\' name=\'code\' snippet_file_name=\'blog_20160904_1_9218917\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 105\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n	int w;\n}edge;\n\nedge queue[N*N];\nint edgenum;\n\nint n;\nint q;\nint fa[N];\nint deep[N];\nint book[N][N];\n\nvoid init()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		fa[i]=i;\n		deep[i]=1;\n	}\n}\n\nint find(int x)\n{\n	if(x==fa[x]) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y]) fa[y]=x;\n		else\n		{\n			if(deep[x]==deep[y]) deep[y]++;\n			fa[x]=y;\n		}\n	}\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nvoid quicksort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int i=left;\n		int j=right;\n		edge temp=queue[left];\n		while(i!=j)\n		{\n			while(i&lt;j&amp;&amp;queue[j].w&gt;=temp.w) j--;\n			while(i&lt;j&amp;&amp;queue[i].w&lt;=temp.w) i++;\n			if(i!=j)\n			{\n				edge t=queue[i];\n				queue[i]=queue[j];\n				queue[j]=t;\n			}\n		} \n		queue[left]=queue[i];\n		queue[i]=temp;\n		quicksort(left,i-1);\n		quicksort(i+1,right);\n		return ; \n	}\n}\n\nint main()\n{\n	memset(book,0,sizeof(book));\n	int sum=0;\n	scanf(\'%d\',&amp;n);\n	init();\n	edgenum=0;\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n				int x;\n				scanf(\'%d\',&amp;x);\n				if(x==0) continue;\n				if(book[i][j]==1) continue;\n				queue[++edgenum].w=x;\n				queue[edgenum].x=i;\n				queue[edgenum].y=j;\n				book[i][j]=book[j][i]=1;\n		}\n	}\n	\n	quicksort(1,edgenum);\n	scanf(\'%d\',&amp;q);\n	for(int i=1;i&lt;=q;i++)\n	{\n		int x,y;\n		scanf(\'%d%d\',&amp;x,&amp;y);\n		unit(x,y);\n	}\n	\n	for(int i=1;i&lt;=edgenum;i++)\n	{\n		if(!same(queue[i].x,queue[i].y))\n		{\n			unit(queue[i].x,queue[i].y);\n			sum+=queue[i].w; \n		}\n	}\n	\n	printf(\'%d\n\',sum);\n	return 0;\n}</pre>\n  <p>\n   <br/>\n  </p>\n  <p>\n   prim解法：注意，本体不知道为什么，如果用邻接表反而会T掉\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1865297\' name=\'code\' snippet_file_name=\'blog_20160904_2_986326\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 1005\n#define inf 99999999\n\nusing namespace std;\n\nint map[N][N];\nint dis[N];\nint n,q;\nint book[N];\n\nint main()\n{\n	scanf(\'%d\',&amp;n);\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=n;j++)\n		{\n			scanf(\'%d\',&amp;map[i][j]);\n		}\n	}\n	\n	scanf(\'%d\',&amp;q);\n	for(int i=1;i&lt;=q;i++)\n	{\n		int x,y;\n		scanf(\'%d%d\',&amp;x,&amp;y);\n		map[x][y]=map[y][x]=0;\n	}\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=inf;\n	}\n	dis[1]=0;\n	book[1]=1;\n	\n	for(int i=1;i&lt;=n;i++){\n		dis[i]=map[1][i];\n	}\n	\n	int sum=0;\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int minpoint;\n		int mink=inf;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;mink&gt;dis[j])\n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		} \n		book[minpoint]=1;\n		sum+=mink;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(book[j]==0&amp;&amp;dis[j]&gt;map[minpoint][j]) dis[j]=map[minpoint][j];\n		}\n	}\n	printf(\'%d\n\',sum);\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <p>\n   <br/>\n  </p>\n  <p>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('90f93e042ef17f54bae3ba9ffdecd4ab','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2299——归并排序求逆序对数\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目\n  </h2>\n  <p>\n   大意:\n  </p>\n  <p>\n   求一组数列的逆序对数\n  </p>\n  <p>\n   输入：\n  </p>\n  <p>\n   1.输入n代表之后输入的数据的数目\n  </p>\n  <p>\n   2.之后n+1行每行代表一个数据\n  </p>\n  <p>\n   3.如果n是0，结束程序，本次数据不作处理\n  </p>\n  <p>\n   <br/>\n  </p>\n  <h2>\n   2.思路\n  </h2>\n  <div>\n   归并排序，我们每次在归并的时候，对于前一个有序的数组和后一个有序的数组进行比较，如果前一个比后一个大，那么前一个数组之后的都比他大，加快计算\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   ps：易错点，本体最后的结果可能会非常大，建议用__int64进行数据的存储\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.AC代码：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1865233\' name=\'code\' snippet_file_name=\'blog_20160904_1_9373965\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 500005\n#define inf 99999999\n\nusing namespace std;\n\nint n;\n__int64 a[N];\n__int64 sum;\n\nvoid merge(int left,int mid,int right)\n{\n	int n1=mid-left+1;\n	int n2=right-mid;\n	int s1[n1+2];\n	int s2[n2+2];\n	int i,j; \n	for(i=left;i&lt;=mid;i++) s1[i-left+1]=a[i];\n	for(j=mid+1;j&lt;=right;j++) s2[j-mid]=a[j];\n	i=j=1;\n	s1[n1+1]=s2[n2+1]=inf;\n	for(int k=left;k&lt;=right;k++)\n	{\n		if(s1[i]&gt;s2[j])\n		{\n			sum+=mid-left+1-i+1;\n			a[k]=s2[j++]; \n		}\n		else a[k]=s1[i++]; \n	} \n}\n\nvoid mergesort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int mid=(left+right)/2;\n		mergesort(left,mid);\n		mergesort(mid+1,right);\n		merge(left,mid,right);\n	}\n}\n\nint main()\n{\n	while(scanf(\'%d\',&amp;n)&amp;&amp;n!=0)\n	{\n		sum=0;\n		for(int i=1;i&lt;=n;i++) scanf(\'%d\',&amp;a[i]);\n		mergesort(1,n);\n		printf(\'%I64d\n\',sum); \n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <p>\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('8000e983369664340e554ce4e9bec5ca','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  NYOJ14——贪心\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.题目描述：\n  </p>\n  <p>\n  </p>\n  <div class=\'problem-display\' style=\'font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n   <h2 style=\'margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体\'>\n    会场安排问题\n   </h2>\n   <div class=\'problem-ins\' style=\'text-align:center\'>\n    时间限制：\n    <span class=\'editable highlight\' id=\'problem[time_limit]\' style=\'color:rgb(113,32,21)\'>\n     3000\n    </span>\n    ms  |  内存限制：\n    <span class=\'editable highlight\' id=\'problem[memory_limit]\' style=\'color:rgb(113,32,21)\'>\n     65535\n    </span>\n    KB\n   </div>\n   <div class=\'problem-ins\' style=\'text-align:center\'>\n    难度：\n    <span class=\'editable highlight\' style=\'color:rgb(113,32,21)\'>\n     4\n    </span>\n   </div>\n  </div>\n  <div class=\'clr\' style=\'clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19.5px\'>\n  </div>\n  <dl class=\'problem-display\' style=\'margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun\'>\n   <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n    描述\n   </dt>\n   <dd style=\'margin:0px; padding:0px\'>\n    学校的小礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校小礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。\n    <br/>\n    <div class=\'clr\' style=\'clear:both\'>\n    </div>\n    <dl class=\'others\' style=\'margin:0px; padding:0px\'>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      第一行是一个整型数m(m&lt;100)表示共有m组测试数据。\n      <br/>\n      每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。\n      <br/>\n      随后的n行，每行有两个正整数Bi,Ei(0&lt;=Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;=Ei)\n      <br/>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      对于每一组输入，输出最多能够安排的活动数量。\n      <br/>\n      每组的输出占一行\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输入\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_input\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>2\n2\n1 10\n10 11\n3\n1 10\n10 11\n11 20\n</pre>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      样例输出\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      <pre id=\'sample_output\' style=\'margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,\'Courier New\',\'DejaVu Sans Mono\',\'Droid Sans Mono\',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)\'>1\n2</pre>\n     </dd>\n     <dt style=\'margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold\'>\n      提示\n     </dt>\n     <dd style=\'margin:0px; padding:0px\'>\n      注意：如果上一个活动在t时间结束，下一个活动最早应该在t+1时间开始\n     </dd>\n    </dl>\n   </dd>\n  </dl>\n  2.\n  <p>\n  </p>\n  <p>\n   思路：\n  </p>\n  <p>\n   本题中，我们这么来考虑，我们想要运行的内容的个数最多，应该让上一次我们选择的活动最早结束，以此类推，对我们每次都寻找结束时间最早的那个活动，从而，确定我们的贪心的策略是查找结束时间最早的复合要求的活动进行选择\n  </p>\n  <p>\n   3.AC代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 50005\n\nusing namespace std;\n\ntypedef struct node\n{\n	int b;\n	int e;\n}point;\n\nint n,m;\npoint timep[N];\nint sum;\n\nvoid quicksort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int i=left;\n		int j=right;\n		point temp=timep[left];\n		while(i!=j)\n		{\n			while(i&lt;j&amp;&amp;timep[j].e&gt;=temp.e) j--;\n			while(i&lt;j&amp;&amp;timep[i].e&lt;=temp.e) i++;\n			if(i!=j)\n			{\n				point t=timep[i];\n				timep[i]=timep[j];\n				timep[j]=t;\n			}\n		}\n		timep[left]=timep[i];\n		timep[i]=temp;\n		quicksort(left,i-1);\n		quicksort(i+1,right);\n		return ;\n	}\n}\n\nint main()\n{\n	scanf(\'%d\',&amp;n);\n	while(n--)\n	{\n		scanf(\'%d\',&amp;m);\n		for(int i=1;i&lt;=m;i++) scanf(\'%d%d\',&amp;timep[i].b,&amp;timep[i].e);\n		quicksort(1,m);\n		int j=1;\n		sum=1;\n		for(int i=2;i&lt;=m;i++)\n		{\n			if(timep[i].b&gt;timep[j].e)\n			{\n				sum++;\n				j=i;\n			}\n		}\n		printf(\'%d\n\',sum);\n	} \n	return 0;\n} </pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('792b7ae12c31217c2caff21baa9e69f0','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  合并果子\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   为了防止抄袭代码，本人只供应伪代码\n  </h1>\n  <h1>\n   1.题目：\n  </h1>\n  <p>\n  </p>\n  <h2 style=\'margin:0.5em 0px; padding:4px; color:rgb(85,85,85); line-height:35px; font-family:Helvetica,Arial,sans-serif; text-align:center\'>\n   合并果子\n  </h2>\n  <div class=\'box time-table\' style=\'color:rgb(85,85,85); margin:0px; padding:0px; font-family:arial,helvetica,clean,sans-serif; font-size:14px; line-height:17px\'>\n   <table class=\'generaltable \' style=\'border-collapse:collapse; border-spacing:0px; margin-bottom:1em; margin-left:auto; margin-right:auto\'>\n    <tbody>\n     <tr class=\'r0\'>\n      <td class=\'cell c0\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       成绩\n      </td>\n      <td class=\'cell c1\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       10\n      </td>\n      <td class=\'cell c2\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       开启时间\n      </td>\n      <td class=\'cell c3 lastcol\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       2013年03月19日 星期二 14:40\n      </td>\n     </tr>\n     <tr class=\'r1\'>\n      <td class=\'cell c0\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       折扣\n      </td>\n      <td class=\'cell c1\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       0.8\n      </td>\n      <td class=\'cell c2\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       折扣时间\n      </td>\n      <td class=\'cell c3 lastcol\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       2013年03月28日 星期四 14:40\n      </td>\n     </tr>\n     <tr class=\'r0 lastrow\'>\n      <td class=\'cell c0\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       允许迟交\n      </td>\n      <td class=\'cell c1\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       否\n      </td>\n      <td class=\'cell c2\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       关闭时间\n      </td>\n      <td class=\'cell c3 lastcol\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n       2013年06月30日 星期日 14:40\n      </td>\n     </tr>\n    </tbody>\n   </table>\n  </div>\n  <div class=\'box description\' id=\'yui_3_5_1_5_1371527498334_1148\' style=\'color:rgb(85,85,85); margin:0px; padding:0px; font-family:arial,helvetica,clean,sans-serif; font-size:14px; line-height:17px\'>\n   <div class=\'box intro\' id=\'yui_3_5_1_5_1371527498334_1147\' style=\'margin:0px; padding:0px\'>\n    <div class=\'no-overflow\' id=\'yui_3_5_1_5_1371527498334_1146\' style=\'margin:0px; padding:0px 0px 1px; overflow:auto\'>\n     <p id=\'yui_3_5_1_5_1371527498334_1145\' style=\'margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; font-family:Helvetica,Arial,sans-serif\'>\n      在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n     </p>\n     <p style=\'margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; font-family:Helvetica,Arial,sans-serif\'>\n      例如有3种果子，数目依次为1，2，9。可以先将 1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为 12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。\n     </p>\n     <p style=\'margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; font-family:Helvetica,Arial,sans-serif\'>\n      【输入】包括两行，第一行是一个整数n（1≤n≤10000），表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai（1≤ai≤20000）是第i种果子的数目。\n     </p>\n     <p style=\'margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; font-family:Helvetica,Arial,sans-serif\'>\n      【输出】包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于231。\n     </p>\n    </div>\n   </div>\n   <div class=\'box testcase-table\' style=\'margin:0px; padding:0px\'>\n    <table class=\'generaltable \' style=\'border-collapse:collapse; border-spacing:0px; margin-bottom:1em; margin-left:auto; margin-right:auto\'>\n     <thead>\n      <tr>\n       <th class=\'header c0\' scope=\'col\' style=\'margin:0px; padding:0.5em; font-weight:normal; text-align:center; border:0px solid rgb(0,0,0); font-size:14px; vertical-align:top\'>\n       </th>\n       <th class=\'header c1 programming-io\' scope=\'col\' style=\'margin:0px; padding:0.5em; font-weight:normal; text-align:center; border:0px solid rgb(0,0,0); font-size:14px; vertical-align:top\'>\n        测试输入\n        <span class=\'helplink\'>\n         <a class=\'tooltip\' href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=input&amp;lang=zh_cn\' style=\'text-decoration:none; color:rgb(51,102,153)\' target=\'_blank\' title=\'关于“测试输入”的帮助\'>\n          <img alt=\'关于“测试输入”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/bluebit/core/1365264925/help\' style=\'border:0px; height:17px; margin-right:4px; vertical-align:middle; width:17px\'/>\n         </a>\n        </span>\n       </th>\n       <th class=\'header c2 programming-io\' scope=\'col\' style=\'margin:0px; padding:0.5em; font-weight:normal; text-align:center; border:0px solid rgb(0,0,0); font-size:14px; vertical-align:top\'>\n        期待的输出\n        <span class=\'helplink\'>\n         <a class=\'tooltip\' href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=expectedoutput&amp;lang=zh_cn\' style=\'text-decoration:none; color:rgb(51,102,153)\' target=\'_blank\' title=\'关于“期待的输出”的帮助\'>\n          <img alt=\'关于“期待的输出”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/bluebit/core/1365264925/help\' style=\'border:0px; height:17px; margin-right:4px; vertical-align:middle; width:17px\'/>\n         </a>\n        </span>\n       </th>\n       <th class=\'header c3\' scope=\'col\' style=\'margin:0px; padding:0.5em; font-weight:normal; text-align:center; border:0px solid rgb(0,0,0); font-size:14px; vertical-align:top\'>\n        时间限制\n        <span class=\'helplink\'>\n         <a class=\'tooltip\' href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=timelimit&amp;lang=zh_cn\' style=\'text-decoration:none; color:rgb(51,102,153)\' target=\'_blank\' title=\'关于“时间限制”的帮助\'>\n          <img alt=\'关于“时间限制”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/bluebit/core/1365264925/help\' style=\'border:0px; height:17px; margin-right:4px; vertical-align:middle; width:17px\'/>\n         </a>\n        </span>\n       </th>\n       <th class=\'header c4\' scope=\'col\' style=\'margin:0px; padding:0.5em; font-weight:normal; text-align:center; border:0px solid rgb(0,0,0); font-size:14px; vertical-align:top\'>\n        内存限制\n        <span class=\'helplink\'>\n         <a class=\'tooltip\' href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=memlimit&amp;lang=zh_cn\' style=\'text-decoration:none; color:rgb(51,102,153)\' target=\'_blank\' title=\'关于“内存限制”的帮助\'>\n          <img alt=\'关于“内存限制”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/bluebit/core/1365264925/help\' style=\'border:0px; height:17px; margin-right:4px; vertical-align:middle; width:17px\'/>\n         </a>\n        </span>\n       </th>\n       <th class=\'header c5 lastcol\' scope=\'col\' style=\'margin:0px; padding:0.5em; font-weight:normal; text-align:center; border:0px solid rgb(0,0,0); font-size:14px; vertical-align:top\'>\n        额外进程\n        <span class=\'helplink\'>\n         <a class=\'tooltip\' href=\'http://online.bit.edu.cn/moodle/help.php?component=programming&amp;identifier=nproc&amp;lang=zh_cn\' style=\'text-decoration:none; color:rgb(51,102,153)\' target=\'_blank\' title=\'关于“{$a} 个额外进程”的帮助\'>\n          <img alt=\'关于“{$a} 个额外进程”的帮助\' class=\'iconhelp\' src=\'http://online.bit.edu.cn/moodle/theme/image.php/bluebit/core/1365264925/help\' style=\'border:0px; height:17px; margin-right:4px; vertical-align:middle; width:17px\'/>\n         </a>\n        </span>\n       </th>\n      </tr>\n     </thead>\n     <tbody>\n      <tr class=\'r0 lastrow\'>\n       <td class=\'cell c0\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n        测试用例 1\n       </td>\n       <td class=\'programming-io cell c1\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n        <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=29160&amp;test=24754&amp;type=in&amp;download=0\' id=\'action_link51bfd948b49c11\' style=\'text-decoration:none; color:rgb(51,102,153); font-size:9pt; margin-bottom:1.875em; line-height:1.875em\' target=\'_blank\'>\n         以文本方式显示\n        </a>\n        <div style=\'margin:0px; padding:0px 5px 0px 0px; vertical-align:top; width:10em; height:10em; overflow:auto\'>\n         <ol style=\'margin:0px 0px 0px 2em; padding:0px; list-style-position:outside; font-family:Helvetica,Arial,sans-serif; overflow:visible\'>\n          <li style=\'margin:0px; padding:0px; font-family:Consolas,\'Courier New\',Courier,mono,serif; overflow:visible\'>\n           <span style=\'margin:0px; padding:0px; white-space:nowrap; background-color:rgb(211,211,211)\'>\n            3↵\n           </span>\n          </li>\n          <li style=\'margin:0px; padding:0px; font-family:Consolas,\'Courier New\',Courier,mono,serif; overflow:visible\'>\n           <span style=\'margin:0px; padding:0px; white-space:nowrap; background-color:rgb(211,211,211)\'>\n            1 2 9↵\n           </span>\n          </li>\n         </ol>\n        </div>\n       </td>\n       <td class=\'programming-io cell c2\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n        <a class=\'showasplaintext small\' href=\'http://online.bit.edu.cn/moodle/mod/programming/testcase/download_io.php?id=29160&amp;test=24754&amp;type=out&amp;download=0\' id=\'action_link51bfd948b49c12\' style=\'text-decoration:none; color:rgb(51,102,153); font-size:9pt; margin-bottom:1.875em; line-height:1.875em\' target=\'_blank\'>\n         以文本方式显示\n        </a>\n        <div style=\'margin:0px; padding:0px 5px 0px 0px; vertical-align:top; width:10em; height:10em; overflow:auto\'>\n         <ol style=\'margin:0px 0px 0px 2em; padding:0px; list-style-position:outside; font-family:Helvetica,Arial,sans-serif; overflow:visible\'>\n          <li style=\'margin:0px; padding:0px; font-family:Consolas,\'Courier New\',Courier,mono,serif; overflow:visible\'>\n           <span style=\'margin:0px; padding:0px; white-space:nowrap; background-color:rgb(211,211,211)\'>\n            15↵\n           </span>\n          </li>\n         </ol>\n        </div>\n       </td>\n       <td class=\'cell c3\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n        1秒\n       </td>\n       <td class=\'cell c4\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n        64M\n       </td>\n       <td class=\'cell c5 lastcol\' style=\'margin:0px; padding:3px; border:0px solid rgb(0,0,0); vertical-align:middle\'>\n        0\n       </td>\n      </tr>\n     </tbody>\n    </table>\n   </div>\n  </div>\n  <h1>\n   2.思路\n  </h1>\n  <p>\n  </p>\n  <p>\n  </p>\n  <div class=\'left\' id=\'yui_3_17_2_1_1472529619811_108\'>\n   <div class=\'grouppictures\'>\n   </div>\n  </div>\n  <div class=\'no-overflow\'>\n   <div class=\'content\'>\n    <div class=\'posting fullpost\'>\n     <h2>\n      1.错误的思路：\n     </h2>\n     <p>\n      有的人在网上可能找到了一些参考的思路，比如贪心+快排，好吧，包括我在内，但是在这里我非常想要给各位提个醒，这道题的输入的数据有些强，快排的话我们每次都要对顺序表进行更新，所以说，虽然有着O(n*lgn)的强大的速度和效率，但是很抱歉，这道题会超时\n     </p>\n     <p>\n      在这里我们每次都要对数组进行实时的维护，时间复杂度计算有些麻烦，大致上应该是\n     </p>\n     <p>\n      O()=SUM(lg1+2*lg2+3*lg3+...n*lgn)很抱歉，学艺不精，大致应该是O(n*n*lgn)（如果错了，欢迎批评指正）,所以说，这道题在输入数据过于强大的时候，超时是一定会发生的事情\n     </p>\n     <h2>\n      2.正确的思路：\n     </h2>\n     <p>\n      这道题我们正确的思路应该是优先队列进行处理\n     </p>\n     <p>\n      首先我们先来了解一下什么是优先队列，优先队列是一种高级数据结构，我们队队列中的每个数据成员都附加上一个优先级，每一次，我们都是按照优先级对队列的成员进行排序，优先级高的成员先出队列\n     </p>\n     <p>\n      在这里，我们可以采用两种实现方式\n     </p>\n     <p>\n      1.二叉堆实现优先队列\n     </p>\n     <p>\n      2.链表模拟优先队列\n     </p>\n     <p>\n      对于二叉堆的优先队列的话，我们采用对的额性质，维护最小堆，每次对堆进行递减维护\n     </p>\n     <p>\n      用链表的话，我们这里的思路有些相对于优化快排+贪心的策略，我的思路是每次合并完之后，我们队队列进行插入操作，这样比整体快排要好一些，但是因为数据强大，本人尝试，本体用链表插入的思路非常的慢，刚刚好AC，所以大家最好不要尝试，对于二叉堆的思路我会原因我的博客作为讲解\n     </p>\n    </div>\n   </div>\n  </div>\n  3.代码讲解：\n  <p>\n  </p>\n  <p>\n   优先队列实现过于简单，我们不作讲解\n  </p>\n  <p>\n   在这里我们着重讲解二叉堆\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>siftdown(i)\n      t \n      flag &lt;- 0\n      while(i*2&lt;=n and flag = 0)\n           if heap[i*2]&lt;heap[i] t &lt;- i*2\n           else t &lt;- i\n           if i*2+1 &lt;=n and heap[i*2+1]&lt;heap[t] t &lt;- i*2+1\n           if t != i \n                swap(i,t)\n                i=t;\n           else flag = 1;</pre>\n  <br/>\n  在这里，我们会用到二叉树的一个性质就是，在顺序表中进行二叉树的存储的话，根节点的编号如果是n，那么做儿子存在的话编号就是2*n，右儿子存在的话就是2*n+1\n  <p>\n  </p>\n  <p>\n   建堆操作：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>buildheap(i)\n     for i = n/2 downto1\n          siftdown(i)</pre>\n  <br/>\n  这里的n/2根据上面的猜测就很好懂了\n  <p>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('31f9222f4ba30e330b73e3f9f48cc333','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  二分逼近/牛顿迭代——一元高次非线性方程求解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cmath\'\n#define precision 0.00000001\n\nusing namespace std;\n\nint count=0;\n\n//一元多次方程求解\ndouble function(double x)\n{\n	return 2*x*x+3.2*x-1.8;\n}\n\ndouble binary(double x,double y)\n{\n	double mid=(x+y)/2.0;\n	while(fabs(x-y)&gt;precision)\n	{\n		if(function(mid)==0) break;\n		if(function(x)*function(mid)&lt;0) y=mid;\n		else x=mid;\n		mid=(x+y)/2;\n		count++;\n	} \n	return mid;\n}\n\ndouble function2(double x)   //返回导数，高精度代倒数 \n{\n	return (function(x+0.000005)-function(x-0.000005))/0.00001; \n}\n\ndouble newtown(double x)\n{\n	double x1=x-function(x)/function2(x);\n	while(fabs(x1-x)&gt;precision)\n	{\n		if(function(x1)==0) break;\n		x=x1;\n		x1=x-function(x)/function2(x);\n		count++;\n	}\n	return x1;\n}\n\nint main()\n{\n	cout&lt;&lt;binary(-0.8,8.0)&lt;&lt;endl;\n	cout&lt;&lt;count&lt;&lt;endl;\n	count=0;\n	cout&lt;&lt;newtown(8)&lt;&lt;endl;\n	cout&lt;&lt;count&lt;&lt;endl;\n	count=0;\n	cout&lt;&lt;newtown(-8)&lt;&lt;endl;\n	cout&lt;&lt;count&lt;&lt;endl;\n	return 0;\n} </pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ac857659deda8ab6c63453f563a3c111','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ1308——并查集\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.题目：\n  </p>\n  <p>\n  </p>\n  <div class=\'ptt\' lang=\'en-US\' style=\'text-align:center; font-size:18pt; font-weight:bold; color:blue\'>\n   Is It A Tree?\n  </div>\n  <div class=\'plm\' style=\'text-align:center; font-size:14px\'>\n   <table align=\'center\'>\n    <tbody>\n     <tr>\n      <td>\n       <strong>\n        Time Limit:\n       </strong>\n       1000MS\n      </td>\n      <td width=\'10px\'>\n      </td>\n      <td>\n       <strong>\n        Memory Limit:\n       </strong>\n       10000K\n      </td>\n     </tr>\n     <tr>\n      <td>\n       <strong>\n        Total Submissions:\n       </strong>\n       29735\n      </td>\n      <td width=\'10px\'>\n      </td>\n      <td>\n       <strong>\n        Accepted:\n       </strong>\n       10173\n      </td>\n     </tr>\n    </tbody>\n   </table>\n  </div>\n  <p>\n  </p>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Description\n  </p>\n  <div class=\'ptx\' lang=\'en-US\' style=\'font-family:\'Times New Roman\',Times,serif; font-size:14px\'>\n   A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties.\n   <br/>\n   <br/>\n   There is exactly one node, called the root, to which no directed edges point.\n   <br/>\n   Every node except the root has exactly one edge pointing to it.\n   <br/>\n   There is a unique sequence of directed edges from the root to each node.\n   <br/>\n   For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not.\n   <br/>\n   <center>\n    <img alt=\'\' src=\'http://poj.org/images/1308_1.jpg\'/>\n   </center>\n   <br/>\n   In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not.\n  </div>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Input\n  </p>\n  <div class=\'ptx\' lang=\'en-US\' style=\'font-family:\'Times New Roman\',Times,serif; font-size:14px\'>\n   The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers;\r\n the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero.\n  </div>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Output\n  </p>\n  <div class=\'ptx\' lang=\'en-US\' style=\'font-family:\'Times New Roman\',Times,serif; font-size:14px\'>\n   For each test case display the line \'Case k is a tree.\' or the line \'Case k is not a tree.\', where k corresponds to the test case number (they are sequentially numbered starting with 1).\n  </div>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Sample Input\n  </p>\n  <pre class=\'sio\' style=\'font-family:\'Courier New\',Courier,monospace; font-size:14px\'>6 8  5 3  5 2  6 4\n5 6  0 0\n\n8 1  7 3  6 2  8 9  7 5\n7 4  7 8  7 6  0 0\n\n3 8  6 8  6 4\n5 3  5 6  5 2  0 0\n-1 -1</pre>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Sample Output\n  </p>\n  <pre class=\'sio\' style=\'font-family:\'Courier New\',Courier,monospace; font-size:14px\'>Case 1 is a tree.\nCase 2 is a tree.\nCase 3 is not a tree.</pre>\n  2.题目大意：我们给你小于100个数的集合，然后我们让你判断我们输入的这些边集是否构成一棵树\n  <p>\n   3.思路：\n  </p>\n  <p>\n   简单并查集：\n  </p>\n  <p>\n   我们开辟并查集之后，首先要用记录数组记录哪些点出现过，我们根据出现过的点在进行计数操作，森林是不成立的\n  </p>\n  <p>\n   其次，我们要知道空时也算一棵树\n  </p>\n  <p>\n   最后，我们一旦出现练得两个节点出现在一个集合中的话，那么我们在进行连边操纵必然导致环路的生成，就不是树了\n  </p>\n  <p>\n   就这三点记住就好\n  </p>\n  <p>\n   4.AC代码 0Ms水过\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\nint fa[N];\nint deep[N];\nint n;\nint x,y; \nbool flag=0;\nbool kright=0;\nbool book[N];\n\nvoid init()\n{\n	for(int i=1;i&lt;N;i++)\n	{\n		fa[i]=i;\n		deep[i]=1;\n	}\n	memset(book,0,sizeof(book));\n}\n\nint find(int x)\n{\n	if(x==fa[x]) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y]) fa[y]=x;\n		else\n		{\n			if(deep[x]==deep[y]) deep[y]++;\n			fa[x]=y; \n		}\n	}\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y); \n}\n\nint main()\n{\n	int t=0;\n	while(1)\n	{\n		kright=true; \n		t++;\n		init();\n		while(scanf(\'%d%d\',&amp;x,&amp;y)&amp;&amp;x!=0&amp;&amp;y!=0)\n		{\n			if(x==-1&amp;&amp;y==-1)\n			{\n				flag=1;\n				break;\n			}\n			if(find(x)==find(y)) kright=0;\n			unit(x,y);\n			book[x]=book[y]=1;\n		} \n		if(flag==1) break;\n		int sum=0;\n		for(int i=1;i&lt;N;i++)\n		{\n			if(fa[i]==i&amp;&amp;book[i]==1) sum++;\n		}\n		if(sum!=1&amp;&amp;sum!=0) kright=0;\n		if(kright) printf(\'Case %d is a tree.\n\',t);\n		else printf(\'Case %d is not a tree.\n\',t);\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('bed9760d644cb24d5436b3ccb616b15c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  并查集总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.并查集：\n  </h2>\n  <div>\n   什么是并查集，我们将并查集称之为不相交集合，在处理例如查找几个元素是否属于相同的集合的时候我们使用并查集可以达到非常高的处理速度（在合并和查找方面），我们利用并查集的思想有一点很重要就是我们我们利用的森林（父亲表示树）来对不同的不相交集合的状态，我们利用每个集合的根作为代表元素来对整个集合的数据进行“牵一发动全身”的合并处理\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   这里我们的额=编号和处理对都是整数，但是如果我们如果要对字符串等进行并查集的操纵，我们可以利用哈希函数进行映射，转化成相应的整数进行操作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   3.1数据结构的选择\n  </h3>\n  <div>\n   在这里，我们事先的时候通常用的是父亲表示树，我们的节点域的内容是父亲的标号，因为我们在进行相应的操作的时候没有必要对子节点进行查询，但是我们需要不断对父亲的位置进行查询，所以说我们选用父亲表示树构成的森林\n  </div>\n  <h2>\n   2.具体操作：\n  </h2>\n  <div>\n   对于并查集我们有如下几个特殊的操作\n  </div>\n  <div>\n   1.init()初始化操作，我们构建一群根为自己的森林\n  </div>\n  <div>\n   2.find()查找操作，我们find函数返回该元素对应的集合的根节点的编号（本集合的编号）\n  </div>\n  <div>\n   3.unit()合并操作，我们将两个元素对应的集合进行合并，如果是同一集合我们不进行操作，否则我们队两颗树进行合并\n  </div>\n  <div>\n   4.same()判断根节点是否相同的操纵\n  </div>\n  <div>\n   5.count()技术操纵，记录该森林中的数的个数（对应的不相交集合的个数）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   先上代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 10000\n\nusing namespace std;\n\nclass uniontree\n{\n	public:\n		uniontree()\n		{\n			memset(fa,0,sizeof(fa));\n			memset(deep,0,sizeof(deep));\n			num=0;\n		}\n		void init()   //初始化操作 \n		{\n			for(int i=1;i&lt;=n;i++)\n			{\n				fa[i]=i;\n				deep[i]=1;\n			} \n			num=n;   //初始化我们的不相交集合的数目就是元素的个数 \n		}\n		int find(int x)   //查找操作 \n		{\n			if(x==fa[x]) return x;   //如果该节点的父亲就是自己，那我们认为我们找到了该节点对应的集合的根（就是其本身）\n			else return fa[x]=find(fa[x]);   //这里我们用到了路径压缩的策略，每次我们进行查找的时候，我们都将集合的路径整体进行压缩，该路径的元素全部直接指向该集合的根节点 \n		}\n		void unit(int x,int y)   //合并操作\n		{\n			x=find(x);   //路径压缩的同时查找根 \n			y=find(y);\n			if(x==y) return ;\n			else\n			{\n				if(deep[x]&gt;deep[y]) fa[y]=x;\n				else\n				{\n					fa[x]=y;\n					if(deep[x]==deep[y]) deep[y]++; \n				} \n				num--;   //每次成功合并一次，集合个数递减 \n			} \n		} \n		bool same(int x,int y)   //判断集合是否相同 \n		{\n			return find(x)==find(y);\n		}\n		int count()\n		{\n			return num;\n		} \n		friend istream&amp; operator&gt;&gt;(istream&amp; in,uniontree&amp; k)\n		{\n			cout&lt;&lt;\'请输入节点个数\'&lt;&lt;endl;cin&gt;&gt;k.n;\n			return in;\n		}\n	private:\n		int num;  //记录森林中的不相交集合的数目\n		int fa[N];     //父亲域 \n		int deep[N];   //按秩进行合并的优化，之后我们会讲到 \n		int n;   //初始的元素的个数 \n};\n\nint main()\n{\n	uniontree lantian,liutianqi; \n	cin&gt;&gt;lantian;\n	lantian.init();\n	cout&lt;&lt;lantian.count()&lt;&lt;endl;\n	lantian.unit(2,3);\n	cout&lt;&lt;lantian.count()&lt;&lt;endl;\n	return 0;\n} </pre>\n   <h2>\n    3.优化操作：\n   </h2>\n   <h3>\n    3.1按秩合并：\n   </h3>\n   <div>\n    在这里我们的deep代表的是每个集合的秩，首先我们需要明确一点，在我们没有路径压缩的时候，我们森林中的每个集合树的高度都是随机的，并不都是1，所以说，这里会出现我们的集合树退化成偏树的情况，所以说，我们每次都要将树深浅的数插到树深大的树中，因为我们的合并函数中，我们利用了进行了路径压缩的查找函数，但是我们的树深相对大小还是不可预测的，我们这里的时候我们的秩在路径压缩的时候并不改变，所以说我们之后的判断都很复杂，我们在这里我们把秩只是看做一个上届，但是这一点我们已经可以避免我们将集合树退化的情况了\n   </div>\n   <h3>\n    3.2路径压缩：\n   </h3>\n   <div>\n    我们每次查找的时候，我们将亲子直接连接到集合的根上，我们下次再次查找相同的元素的时候，对根的查找可以优化到O（1）复杂度，何乐而不为\n   </div>\n   <div>\n    <br/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c6abd5ae3cc3ed0a2e1f3ec7d4d720be','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ1182——带权并查集\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.问题描述：\n  </p>\n  <p>\n  </p>\n  <div class=\'ptt\' lang=\'en-US\' style=\'text-align:center; font-size:18pt; font-weight:bold; color:blue\'>\n   食物链\n  </div>\n  <div class=\'plm\' style=\'text-align:center; font-size:14px\'>\n   <table align=\'center\'>\n    <tbody>\n     <tr>\n      <td>\n       <strong>\n        Time Limit:\n       </strong>\n       1000MS\n      </td>\n      <td width=\'10px\'>\n      </td>\n      <td>\n       <strong>\n        Memory Limit:\n       </strong>\n       10000K\n      </td>\n     </tr>\n     <tr>\n      <td>\n       <strong>\n        Total Submissions:\n       </strong>\n       64435\n      </td>\n      <td width=\'10px\'>\n      </td>\n      <td>\n       <strong>\n        Accepted:\n       </strong>\n       18933\n      </td>\n     </tr>\n    </tbody>\n   </table>\n  </div>\n  <p>\n  </p>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Description\n  </p>\n  <div class=\'ptx\' lang=\'en-US\' style=\'font-family:\'Times New Roman\',Times,serif; font-size:14px\'>\n   动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。\n   <br/>\n   现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。\n   <br/>\n   有人用两种说法对这N个动物所构成的食物链关系进行描述：\n   <br/>\n   第一种说法是\'1 X Y\'，表示X和Y是同类。\n   <br/>\n   第二种说法是\'2 X Y\'，表示X吃Y。\n   <br/>\n   此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。\n   <br/>\n   1） 当前的话与前面的某些真的话冲突，就是假话；\n   <br/>\n   2） 当前的话中X或Y比N大，就是假话；\n   <br/>\n   3） 当前的话表示X吃X，就是假话。\n   <br/>\n   你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。\n   <br/>\n  </div>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Input\n  </p>\n  <div class=\'ptx\' lang=\'en-US\' style=\'font-family:\'Times New Roman\',Times,serif; font-size:14px\'>\n   第一行是两个整数N和K，以一个空格分隔。\n   <br/>\n   以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。\n   <br/>\n   若D=1，则表示X和Y是同类。\n   <br/>\n   若D=2，则表示X吃Y。\n  </div>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Output\n  </p>\n  <div class=\'ptx\' lang=\'en-US\' style=\'font-family:\'Times New Roman\',Times,serif; font-size:14px\'>\n   只有一个整数，表示假话的数目。\n  </div>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Sample Input\n  </p>\n  <pre class=\'sio\' style=\'font-family:\'Courier New\',Courier,monospace; font-size:14px\'>100 7\n1 101 1 \n2 1 2\n2 2 3 \n2 3 3 \n1 1 3 \n2 3 1 \n1 5 5\n</pre>\n  <p class=\'pst\' style=\'font-size:18pt; font-weight:bold; color:blue\'>\n   Sample Output\n  </p>\n  <pre class=\'sio\' style=\'font-family:\'Courier New\',Courier,monospace; font-size:14px\'>3</pre>\n  2.算法描述：\n  <p>\n   本题有两种思路，第一是开辟三个并查集同时进行维护\n  </p>\n  <p>\n   第二是开辟一个带权并查集我们来记录，不相交集合中的元素之间的相对关系\n  </p>\n  <p>\n   3.解释：\n  </p>\n  <p>\n   3.1三个并查集：\n  </p>\n  <p>\n   首先，我们先要明确一下三个并查集是如何作用的\n  </p>\n  <p>\n   1.fa[1-n] 代表的全是A物种，fa[n+1-2*n]代表的全是B物种,fa[2*n+1-3*n]代表的全是C物种\n  </p>\n  <p>\n   这是三个并查集，我们进行合并操作的额时候，首先需要明确一点，并查集的作用是将有“关系”的两个元素拉进同一颗树中，那么我们对于合法（真话）的操作如何进行合并操作呢\n  </p>\n  <p>\n   如果关系值是1，说明是同类，我们unit(x,y),unit(x+n,y+n),unit(x+2*n,y+2*n)\n  </p>\n  <p>\n   这三句话的含义是在这句话我们判断合法的前提下，我们认为A物种的x,y是同一物种，B物种的x,y是同一物种,C物种的x,y是同一物种（他们是有关系的）\n  </p>\n  <p>\n   我们认为阿门是有关系的，并且在合法的前提下，他们既然有关系，说明他们的关系是同一物种\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   如果关系值是2，代表x吃y，我们在判断该句话的真实性的前提下，unit(x,y+n),unit(x+n,y+2*n),unit(x+2*n,y)这三句话的含义是我们认为在这句话的正确的前提下，我们认为Ax与By,Bx与Cy,Cx与Ay是有关系的，也就是说我们认为他们存在前者对后者的捕食关系\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   对于判断我们的思路也是一样的\n  </p>\n  <p>\n   归根到底，我们对于same(A,B)里面的结果认为是正确的，我们根据其正确性来判断当前的话的正确性，否则我们进行相应的合并操作\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   AC代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 150010\n\nusing namespace std;\n\nint fa[N];\nint n,m;\n\nvoid init()\n{\n	for(int i=1;i&lt;=3*n;i++)\n	{\n		fa[i]=i;\n	}\n}\n\nint find(int x)\n{\n	if(x==fa[x]) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else fa[y]=x;\n    return ;\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nint main()\n{\n	scanf(\'%d%d\',&amp;n,&amp;m);\n	init();\n	int sum=0;\n	for(int i=1;i&lt;=m;i++)\n	{\n		int x,y,z;\n		scanf(\'%d%d%d\',&amp;z,&amp;x,&amp;y);\n		if(x&gt;n||y&gt;n) sum++;\n		else if(z==2&amp;&amp;x==y) sum++;\n		else\n		{\n			if(z==1)\n			{\n				if(same(x,y+n)||same(x,y+2*n)) sum++;\n				else\n				{\n					unit(x,y);\n					unit(x+n,y+n);\n					unit(x+2*n,y+2*n);\n				}\n			}\n			else\n			{\n				if(same(x,y)||same(x,y+2*n)) sum++;   //这里我们只判断一次same(x,y)的原因而不用same(x+n,y+n)等都判断在于我们如果same(x,y)成立，那么same(x+n,y+n)等必然也成立，我们判断一个就可以代表全部的信息了\n				else\n				{\n					unit(x,y+n);\n					unit(x+n,y+2*n);\n					unit(x+2*n,y);\n				}\n			}\n		}\n	}\n	printf(\'%d\n\',sum);\n	return 0;\n}</pre>\n  <br/>\n  3.2带权并查集\n  <p>\n   我们都知道，并查集作为不相交集合，他的优势在于我们将有关系的两个数据进行合并，然后我们用一个根节点代表着一整个数据，从未实现我们队位置关系的快速判断，现在我们的手段对于解决高级的并查集的题目已经远远不能适应了，我们不仅要知道所谓的两者之间有没有关系，我们还要知道，两者之间的相对关系，本体作为一个绝好的例子，向我们说明了，相对的关系我们如何进行判断，我们采用带权的并查集\n  </p>\n  <p>\n   这里我们首先要明确，我们的权是带有方向的\n  </p>\n  <p>\n   在这里我先致歉，本人愚笨未能考虑出大神的向量思维的玄妙，这我只能证明方法的正确性，对于方法的来源 和具体作用却是真的一知半解\n  </p>\n  <p>\n   在这里我的讲解这是局限于我们对这道题的理解，非常的抱歉\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   首先我们将节点重新进行定义，我们不仅需要父亲域，我们还需要对于父亲的关系域，注意，在这里我们对于发亲的关系域是从本节点指向父亲节点的向量\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>typedef struct node\n{\n       int fa;\n       int re;   //记录和父亲之间的关系，0代表同类，1代表被父亲吃，2代表吃父亲\n};</pre>\n  <p>\n   之后对于find函数我们不仅要进行路径压缩（在本题的带权并查集的问题中，路径压缩是必须的，因为我们要通过根节点进行比较，我们对于根节点的额直接关系是必须要知道的，不进行路径压缩，我们的父亲节点就不一定是根节点，那么我们的关系域就不一定是针对根节点的），我们还要对关系域进行更新\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   在这里我本人对计算关系域的正确性的所有情况都进行了证明，是完全正确的也是非常玄妙的，为什么取模就可以实现这么完美有优秀的思想转变？百思不得其解\n  </p>\n  <p>\n   在这里，详细注释参考代码或者网上大神的讲解\n   <a href=\'http://blog.csdn.net/niushuai666/article/details/6981689\' target=\'_blank\'>\n    点击打开链接\n   </a>\n  </p>\n  <p>\n   AC代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 50010\n\nusing namespace std;\n\ntypedef struct node\n{\n	int fa;\n	int re;\n}point;\n\npoint data[N];\nint n,m;\n\nvoid init()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		data[i].fa=i;\n		data[i].re=0;\n	}\n}\n\nint find(int x)\n{\n	if(x==data[x].fa) return x;\n	else\n	{\n		int temp=data[x].fa;   //注意，这里我们要首先保存该节点的父亲节点，因为我们修改关系域的时候要用到和原父亲的关系，本人在这里WA了，没有保存，直接原父亲的标号\n		data[x].fa=find(temp);\n		data[x].re=(data[x].re+data[temp].re)%3;   //该式子可以证明\n		return data[x].fa;\n	}\n}\n\nint main()\n{\n	scanf(\'%d%d\',&amp;n,&amp;m);\n	init();\n	int count=0;\n	for(int i=1;i&lt;=m;i++)\n	{\n		int x,y,z;\n		scanf(\'%d%d%d\',&amp;z,&amp;x,&amp;y);\n		if(x&gt;n||y&gt;n) count++;\n		else if(z==2&amp;&amp;x==y)	count++;\n		else\n		{\n			int rootx=find(x);\n			int rooty=find(y);\n			if(rootx==rooty)\n			{\n				if(z==2&amp;&amp;(z-1!=(data[y].re+3-data[x].re)%3)) count++;   //向量的表示法\n				if(z==1&amp;&amp;data[x].re!=data[y].re) count++;\n			}\n			else\n			{\n				data[rooty].fa=rootx;\n				data[rooty].re=(z-1+3-data[y].re+data[x].re)%3;   //向量的表示法\n			}\n		}\n	}\n	printf(\'%d\n\',count);\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c61a16732f880ca8aee5eaeedd3a6bd8','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ1611-----并查集\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   1.题目大意描述：\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   <a href=\'http://poj.org/problem?id=1611\' style=\'color:rgb(202,0,0); text-decoration:none\' target=\'_blank\'>\n    题目链接\n   </a>\n   <br/>\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   某一个学校存在0-N-1名学生，0号学生已经确认患病，我们会给出如下数据\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   首先每组数据会开始输入两个数，第一个n代表学校的学生的数目，第二个m代表学校的社团的数目\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   接下来m行代表m个社团的成员的情况，（注意接下来的每行的第一个数字代表社团的成员的数目，后面的数字是成员的编号）\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   我们现在需要确认学校中有多少人确认患病\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   2.算法：\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   利用并查集我们来确认同一族谱中的父子关系\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   思路如下，我们对于下面的m行进行处理，第一个编号不管，我们从后面开始每一次将其和前一个的编号进行合并操作\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   <br/>\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   最后我们从头遍历一遍所有的学生编号，如果发现和0号患者是同一族谱的，我们将计数器累计（注意，开始计数器的值是1，因为计算0号病患）\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n   3.AC代码：\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\'>\n  </p>\n  <div class=\'dp-highlighter bg_cpp\' style=\'font-family:Consolas,\'Courier New\',Courier,mono,serif; font-size:12px; width:936.337px; overflow-y:hidden; overflow-x:auto; padding-top:1px; position:relative; line-height:26px; margin:18px 0px!important\'>\n   <div class=\'bar\' style=\'position:relative; padding-left:45px\'>\n    <div class=\'tools\' style=\'padding:3px 8px 10px 10px; font-size:9px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; border-left-width:3px; border-left-style:solid; border-left-color:rgb(153,153,153)\'>\n     <strong>\n      [cpp]\n     </strong>\n     <a class=\'ViewSource\' href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52334275#\' style=\'color:rgb(204,204,204); text-decoration:none; border:none; padding:0px; margin:0px 10px 0px 0px; font-size:9px; background-color:inherit\' target=\'_blank\' title=\'view plain\'>\n      view\r\n plain\n     </a>\n     <span>\n      <a class=\'CopyToClipboard\' href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52334275#\' style=\'color:rgb(204,204,204); text-decoration:none; border:none; padding:0px; margin:0px 10px 0px 0px; font-size:9px; background-color:inherit\' target=\'_blank\' title=\'copy\'>\n       copy\n      </a>\n     </span>\n     <div style=\'position:absolute; left:544px; top:830px; width:32px; height:16px; z-index:99\'>\n     </div>\n     <span>\n      <a class=\'PrintSource\' href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52334275#\' style=\'color:rgb(204,204,204); text-decoration:none; border:none; padding:0px; margin:0px 10px 0px 0px; font-size:9px; background-color:inherit\' target=\'_blank\' title=\'print\'>\n       print\n      </a>\n     </span>\n     <a class=\'About\' href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52334275#\' style=\'color:rgb(204,204,204); text-decoration:none; border:none; padding:0px; margin:0px 10px 0px 0px; font-size:9px; background-color:inherit\' target=\'_blank\' title=\'?\'>\n      ?\n     </a>\n    </div>\n   </div>\n   <ol class=\'dp-cpp\' start=\'1\' style=\'padding:0px; border:none; position:relative; color:rgb(92,92,92); margin:0px 0px 1px 45px!important\'>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'preprocessor\' style=\'margin:0px; padding:0px; border:none; color:gray; background-color:inherit\'>\n       #include\'iostream\'\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'preprocessor\' style=\'margin:0px; padding:0px; border:none; color:gray; background-color:inherit\'>\n       #include\'cstdio\'\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'preprocessor\' style=\'margin:0px; padding:0px; border:none; color:gray; background-color:inherit\'>\n       #include\'cstdlib\'\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'preprocessor\' style=\'margin:0px; padding:0px; border:none; color:gray; background-color:inherit\'>\n       #include\'cstring\'\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'preprocessor\' style=\'margin:0px; padding:0px; border:none; color:gray; background-color:inherit\'>\n       #define N 30100\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       using\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       namespace\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       std;\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       fa[N];\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       deep[N];\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       n,m;\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       void\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       init()\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       for\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       i=0;i&lt;n;i++)\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      fa[i]=i;\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      deep[i]=1;\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       find(\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       x)\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       if\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (fa[x]==x)\n      </span>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       return\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       x;\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       else\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       return\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       fa[x]=find(fa[x]);\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       void\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       unit(\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       x,\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       y)\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      x=find(x);\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      y=find(y);\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       if\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (x==y)\n      </span>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       return\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       ;\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       else\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       if\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (deep[x]&gt;deep[y]) fa[y]=x;\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       else\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      fa[x]=y;\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       if\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (deep[x]==deep[y]) deep[y]++;\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       bool\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       same(\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       x,\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       y)\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       return\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       find(x)==find(y);\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       main()\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       while\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (scanf(\n      </span>\n      <span class=\'string\' style=\'margin:0px; padding:0px; border:none; color:rgb(255,153,0); background-color:inherit\'>\n       \'%d%d\'\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       ,&amp;n,&amp;m)==2&amp;&amp;(n+m)!=0)\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      init();\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       for\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       i=1;i&lt;=m;i++)\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       p;\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      cin&gt;&gt;p;\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       * data=\n      </span>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       new\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       [p+5];\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       for\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       i=1;i&lt;=p;i++) cin&gt;&gt;data[i];\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       for\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       i=2;i&lt;=p;i++) unit(data[i],data[i-1]);\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       delete\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       [] data;\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       count=1;\n      </span>\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       for\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (\n      </span>\n      <span class=\'datatypes\' style=\'margin:0px; padding:0px; border:none; color:rgb(46,139,87); font-weight:bold; background-color:inherit\'>\n       int\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       i=1;i&lt;n;i++)\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      {\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       if\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       (same(0,i)) count++;\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      cout&lt;&lt;count&lt;&lt;endl;\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n    <li style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      <span class=\'keyword\' style=\'margin:0px; padding:0px; border:none; color:rgb(102,204,255); font-weight:bold; background-color:inherit\'>\n       return\n      </span>\n      <span style=\'margin:0px; padding:0px; border:none; background-color:inherit\'>\n       0;\n      </span>\n     </span>\n    </li>\n    <li class=\'alt\' style=\'margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(153,153,153); list-style:decimal-leading-zero outside; color:rgb(238,238,238); line-height:20px\'>\n     <span style=\'margin:0px; padding:0px; border:none; color:rgb(255,255,255); background-color:inherit\'>\n      }\n     </span>\n    </li>\n   </ol>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('dabb62e4558861ddf9b2468477a313d2','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ2524——并查集\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.题目描述：\n  </p>\n  <p>\n   <a href=\'http://poj.org/problem?id=2524\' target=\'_blank\'>\n    题目链接\n   </a>\n   <br/>\n  </p>\n  <p>\n   我们调查一所学校的宗教信仰我们询问m对人，看是否信仰相同，在这里，如果信仰相同，我们就对其进行合并操作就可以了\n  </p>\n  <p>\n   2.算法：\n  </p>\n  <p>\n   简单并查集，我们有两个思路\n  </p>\n  <p>\n   好的思路：初始我们的宗教数目是所有的人的个数，如果我们要合并的时候，如果判断的二者宗教信仰相同，我们在unit操作中要对其二者进行合并操作\n  </p>\n  <p>\n   如果目前二者判断是统一宗教并且我们没在同一族谱中，那么我们可以断定，这样操作之后我们的额count数目必定要减一，如果判断了是在同一族谱中，我们就没必要进行减法操作\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   坏的思路：我们再次便利一整遍之后，找出父亲就是自己的节点的个数就是宗教的数目，但是这样需要我们再次遍历，如果数据量较大，反而不理想\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   ps：注意我在用cin进行录入的时候出现了差点超时的状况，4357Ms,以后一定注意在大输入数据量的时候一定不用cin\n  </p>\n  <p>\n   3.AC代码:\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 50010\n\nusing namespace std;\n\nint fa[N];\nint deep[N];\nint n,m;\nint count;\n\nvoid init()\n{\n	for(int i=0;i&lt;=n;i++)\n	{\n		fa[i]=i;\n		deep[i]=1;\n	}\n}\n\nint find(int x)\n{\n	if(fa[x]==x) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y]) fa[y]=x;\n		else\n		{\n			fa[x]=y;\n			if(deep[x]==deep[y]) deep[y]++; \n		}\n	}\n	count--;\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nint main()\n{\n	int k=1;\n	while(scanf(\'%d%d\',&amp;n,&amp;m)==2&amp;&amp;(n+m)!=0)\n	{\n		init();\n		int x,y;\n		count=n;\n		for(int i=1;i&lt;=m;i++)\n		{\n			scanf(\'%d%d\',&amp;x,&amp;y); \n			unit(x,y); \n		}\n		printf(\'Case %d: %d\n\',k++,count);\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1272cd81b29ef228444c2ef86271b50d','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  环形链表+约瑟夫问题实现\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.问题描述：\n  </p>\n  <p>\n   约瑟夫问题：\n  </p>\n  <p>\n   已知m个人还坐在桌子上，从第k个人开始进行报数，报道第n个人出列，直达所有的额人都出列为止，求出出列的顺序\n  </p>\n  <p>\n   2。数据结构：\n  </p>\n  <p>\n   我们根据题意可以明显的发现，如果我们用环形链表来进行处理的话每次出队一人是非常好实现的，我们判断终点的条件就是环形链表内的权值为0\n  </p>\n  <p>\n   在这里没什么好说的，我们只要注意一点就好了，有的书上并没有说明，但是当约瑟夫问题的头节点被删除之后，我们的要提前将头节点向后转移，不能出现头节点为空的情况\n  </p>\n  <p>\n   3.代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nclass point\n{\n	public:\n		point(int n,point* p)\n		{\n			key=n;\n			next=p;  //next指向和p相同 \n		}\n		int getkey()\n		{\n			return key;\n		}\n		point*&amp; returnnext()\n		{\n			return next;\n		}\n		point* next;\n	private:\n		int key;\n};\n\nclass circlelist\n{\n	public:\n		circlelist()\n		{\n			head=NULL;\n			num=0;\n		}\n		~circlelist()\n		{\n			if(num==0) head=NULL;\n			else\n			{\n				point* p=head-&gt;next;\n	     		while(p!=head)\n	    		{\n    				head-&gt;next=head-&gt;next-&gt;next;\n    		    	free(p);\n    			}\n    			free(head);\n    		}\n   		}\n		point* find(int i)\n		{\n			int k=1;\n			point* p=head;\n			while(k!=i)\n			{\n				p=p-&gt;next;\n				k++;\n			}\n			return p;\n		}\n		void insert(int key,int i)\n		{\n			if(num==0)\n			{\n				head=new point(key,NULL);\n				head-&gt;next=head;\n				num++;\n				return ;\n			}\n			point* k=find(i-1);\n			point* help=new point(key,k-&gt;next);\n			k-&gt;next=help;\n			num++;\n		}\n		void delete_point(int i)\n		{\n			point* k=find(i-1);\n			point* help=k-&gt;next;\n			k-&gt;next=k-&gt;next-&gt;next;\n			free(help);\n			num--;\n		}\n		void delete_point(point* p)\n		{\n			if(p==head) \n			{\n				while(p-&gt;next!=head) p=p-&gt;next;\n				p-&gt;next=head-&gt;next;\n				point* help=head;\n				head=head-&gt;next;\n				free(help);\n				num--;\n				return ;\n			}\n			point* k=head;\n			while(k-&gt;next!=p) k=k-&gt;next;\n			k-&gt;next=k-&gt;next-&gt;next;\n			free(p);\n			num--;\n		}\n		bool empty()\n		{\n			return num;\n		}\n		void print()\n		{\n			point* p=head;\n			cout&lt;&lt;p-&gt;getkey()&lt;&lt;\' \';\n			p=p-&gt;next;\n			while(p!=head)\n			{\n				cout&lt;&lt;p-&gt;getkey()&lt;&lt;\' \';\n				p=p-&gt;next;\n			}\n			cout&lt;&lt;endl;\n		}\n	private:\n		point* head;\n		int num;\n};\n\nint main()\n{\n	circlelist my;\n	cout&lt;&lt;\'约瑟夫问题的个数\'&lt;&lt;endl;\n	int m;\n	cin&gt;&gt;m;\n	for(int i=1;i&lt;=m;i++) my.insert(i,i);\n	int k;\n	int n;\n	cin&gt;&gt;k&gt;&gt;n;\n//	my.print();\n	point* p=my.find(k);\n	while(my.empty()!=0)\n	{\n		int count=1;\n		while(count!=n)\n		{\n			count++;\n			p=p-&gt;next;\n		}\n		point* help=p;\n		cout&lt;&lt;help-&gt;getkey()&lt;&lt;\' \';\n		p=p-&gt;next;\n		my.delete_point(help);\n	}\n	cout&lt;&lt;endl;\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('773559c60d09a36f0bd7a9bc016dc68f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题017——哈希查找/优先队列\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.题目描述：\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。\n   </span>\n   <br/>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    2.算法讲解：\n   </span>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    本题中，我们需要一种数据结构可以让我们通过读取字符从而查找到对应的出现次数，并且我们要尽可能的提高查找的速度\n   </span>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    所以我们就会考虑到一种数据结构——哈希表，详情请点击\n    <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52171743\' target=\'_blank\'>\n     点击打开链接\n    </a>\n   </span>\n  </p>\n  <p>\n   我们都知道，通过哈希表，我们可以将存取的速度提高到O(1)的复杂度\n  </p>\n  <p>\n   并且，题目中，我们是将字符映射到对应的数据上的，所以说我们的哈希函数也是非常的好设定，我们直接将字符作为的关键字通过哈希函数转化成对应的256以内的ASCII码就很好解决了\n  </p>\n  <p>\n   但是有的同学可能会说，怎么办，一个字符串中出现相同的字符的话，那不就和哈希要求的减少冲突的要求相违背了吗\n  </p>\n  <p>\n   在这里，这个问题很好解决，首先我们需要明确一点，根据题目的特殊性，我们的冲突的解决是不用考虑的，我们有冲突直接计数就好\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   最后，我们将字符串便利结束之后，我们再次从头开始遍历，找到第一个出现的频度为1的字符就好（哈希对应的键值）\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   需要的时间复杂度就是O(n)\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   在这里，本人本来想要通过优先队列的方法看可不可以达到和哈希一样的额优化效果\n  </p>\n  <p>\n   3.代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1853482\' name=\'code\' snippet_file_name=\'blog_20160826_1_4875171\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 260\n\nusing namespace std;\n\nint hash[N];\nchar data[10000];\n\nvoid hashfunction(char p)\n{\n	hash[(int)p]++;\n}\n\nint main()\n{\n	memset(hash,0,sizeof(hash));\n	memset(data,0,sizeof(data));\n	scanf(\'%s\',data);\n	for(int i=0;i&lt;strlen(data);i++) hashfunction(data[i]);\n	for(int i=0;i&lt;strlen(data);i++) \n	{\n		if(hash[(int)data[i]]==1) \n		{\n			cout&lt;&lt;data[i]&lt;&lt;endl;\n			break;\n		}\n	}\n	return 0;\n}\n\n\n</pre>\n  <p>\n   优先队列的方法：\n  </p>\n  <p>\n   我们的count数组用来记录我们的对应的ASCII码对应的出现次数，我们用堆来维护标号，pos来查找对应的标号在堆中的位置\n  </p>\n  <p>\n   实际的算法的复杂度是O(N*lgN\n   <span style=\'font-size:12px\'>\n    )但是实际上我们的复杂度要远远比这个小，没有哈希表的方法优秀，但是总归是一种思路\n   </span>\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1853482\' name=\'code\' snippet_file_name=\'blog_20160826_2_7983261\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 260\n\nusing namespace std;\n\nint count[N];\nint heap[N];  //记录标号 \nint pos[N];   //记录位置 \nchar data[10000];\n\nvoid swap(int x,int y)\n{\n	int t=heap[x];\n	heap[x]=heap[y];\n	heap[y]=t;\n	\n	t=pos[heap[x]];\n	pos[heap[x]]=pos[heap[y]];\n	pos[heap[y]]=t;\n}\n\nvoid siftup(int i)\n{\n	while(i!=1)\n	{\n		if(count[heap[i/2]]!=1||heap[i]&lt;heap[i/2]) \n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else break;\n	}\n}\n\nvoid siftdown(int i)\n{\n	int t=i;\n	while(i*2&lt;N)\n	{\n		if(count[heap[i*2]==1]) t=i*2;\n		if(i*2+1&lt;N&amp;&amp;count[heap[i*2+1]]==1)\n		{\n			if(t==i) t=i*2+1;\n			else if(heap[i*2+1]&lt;heap[i*2]) t=i*2+1; \n		}\n		if(t!=i)\n		{\n			swap(i,t);\n			i=t;\n		} \n		else break;\n	}\n}\n\nint main()\n{\n	for(int i=1;i&lt;N;i++) heap[i]=pos[i]=i;\n	memset(count,0,sizeof(count));\n	memset(data,0,sizeof(data));\n	scanf(\'%s\',data+1);\n	for(int i=1;i&lt;strlen(data+1);i++)\n	{\n		count[(int)data[i]]++;\n		if(count[(int)data[i]]==1) siftup(pos[(int)data[i]]);\n		else siftdown(pos[(int)data[i]]);\n	}\n	printf(\'%c\n\',heap[1]);\n	return 0;\n} </pre>\n  <br/>\n  <br/>\n  <p>\n  </p>\n  <p>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('78bb285a9a6e651234cbb846d8968789','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题016——BST层序遍历\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.问题描述：\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    输入一颗二元树，从上往下按层打印树的每个结点，同一层中按照从左往右的顺序打印。\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    例如输入\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    7\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    8\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    / \n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    6 10\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    /  / \n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    5 7 9 11\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    输出8 6 10 5 7 9 11\n   </span>\n   <br/>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    2.算法解决：\n   </span>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    对于层序遍历，其实说白了就是BST的广度优先遍历，我们采用的策略是建立一个队列，不断向叶子结点进行扩展，当队列为空的时候，我们显示的结果是BST已经被广度优先遍历结束，队列中存放的内容是指向该节点的指针\n   </span>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    3.代码实现：\n   </span>\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1853030\' name=\'code\' snippet_file_name=\'blog_20160826_1_6037872\'>void rank_visit(point* root)   //BST的根节点root \n{\n	point* queue[N];\n	int head=1;\n	int tail=1;\n	queue[++tail-1]=root;\n	while(head!=tail)\n	{\n		if(queue[head]-&gt;left!=NULL) queue[tail++]=queue[head]-&gt;left;\n		if(queue[head]-&gt;right!=NULL) queue[tail++]=queue[head]-&gt;right;\n		head++;\n	} \n	for(int i=1;i&lt;tail;i++) cout&lt;&lt;queue[i]-&gt;data&lt;&lt;\' \';\n	cout&lt;&lt;endl;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ad93c249842133b1d8b11f9d6dba1aeb','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题012——5050的各种限制解法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    题目：求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C）。\n   </span>\n   <br/>\n  </div>\n  <h2>\n   2.解法：\n  </h2>\n  <h3>\n   2.1位运算：\n  </h3>\n  <div>\n   首先我们需要了解一下，在该操作中我们需要用奥的位运算有哪些首先，我们根据公式对式子进行化简\n  </div>\n  <div>\n   原式=（n*n+n）/2\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先对于最后的除以2操作我们直接调用右移操作就可以实现：\n  </div>\n  <div>\n   在这里我解释一下，为什么右移k位相当于对2^k做除法，首先我们要知道，在二进制转化成十进制的时候我们是对每一位乘上2的几次方最后做的加法，那么显然，我们一旦执行了移位操作之后，我们每一位是1的对应 的乘的倍数便都会下降，自然就实现了除以每一位都是对2的次方做除法，整体的数值也就相当于对2的次方做除法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   其次，我们来看看如何不用乘法和循环来实现n*n的操作，这里我们就会看到这种方法 的局限性了，我们要对二进制做乘法，只能利用我们乘法的基本操作，但是我们是实现不明白该数 的大小的，所以说，我们需要手动进行很多次操作，这里明显就会很麻烦，所以说我们不建议用这种方法\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   2.2类的静态成员+构造函数\n  </h3>\n  <div>\n   我们这里有一个好方法，在之前，我们需要知道两点\n  </div>\n  <div>\n   1.类的构造对象的时候必定会调用构造函数，并且，如果我们构造一些列对象的时候，这种情况也是对的，我们会隐式的调用一系列的构造函数\n  </div>\n  <div>\n   这里我们就会看到循环的影子\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.静态成员，我们知道，类的静态成员一个类只有一份内存空间，并且类的静态成员修改之后的效果在对象之间是互相影响的，所以说，这一点结合上面的构造函数的方式可以模拟一个循环的过程\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.代码如下：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1850373\' name=\'code\' snippet_file_name=\'blog_20160825_1_1878898\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nclass test\n{\n	public:\n		test()\n		{\n			++n;\n			sum+=n;\n		}\n		void reset()\n		{\n			n=0;\n			sum=0;\n		}\n		static int returnresult()\n		{\n			return sum;\n		}\n	private:\n		static int n;\n		static int sum; \n};\n\nint test::n=0;\nint test::sum=0;\n\nint main()\n{\n	test my[100];\n	cout&lt;&lt;test::returnresult()&lt;&lt;endl;\n	return 0;\n}\n </pre>\n   <div>\n    <br/>\n   </div>\n   <h3>\n    2.3虚函数+多态终止递归\n   </h3>\n   <div>\n    我们采用虚函数，一个类的函数充当终止条件，另一个类的函数充当递归的条件\n   </div>\n   <div>\n    具体看代码：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1850373\' name=\'code\' snippet_file_name=\'blog_20160825_2_8781998\'>#include\'iostream\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cstdio\'\n\nusing namespace std;\n\nclass a;  //这里的指针利用了多态的思想，用父类指针指向子类成员\na* array[2];   //注意这里提前声明，但是没有构造函数，我们只能用指针来代替 \n\nclass a\n{\n	public:\n		virtual int sum(int n)   //终止递归函数 \n		{\n			return 0;\n		}\n};\n\n\n\nclass b:public a\n{\n	public:\n		virtual int sum(int n)\n		{\n			n--;\n			return array[!!n]-&gt;sum(n)+n+1;\n		}\n};\n\nint main()\n{\n	a test1;\n	b test2;\n	array[0]=&amp;test1;\n	array[1]=&amp;test2;\n	cout&lt;&lt;array[1]-&gt;sum(100)&lt;&lt;endl;\n	return 0;\n}</pre>\n    <br/>\n    <br/>\n   </div>\n   <h3>\n    2.4逻辑与的短路+递归终止条件\n   </h3>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1850373\' name=\'code\' snippet_file_name=\'blog_20160825_3_352162\'>#include\'stdio.h\'\n\nint sum(int n)\n{\n	int val=0;\n	n&amp;&amp;(val=n+sum(n-1));\n	return val;\n}\n\nint main()\n{\n	printf(\'%d\n\',sum(100));\n	return 0;\n}</pre>\n   <br/>\n   <h3>\n    2.5C++模板特化+递归终止条件\n   </h3>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1850373\' name=\'code\' snippet_file_name=\'blog_20160825_4_8191963\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntemplate&lt;int N&gt;\nclass a\n{\n	public:\n		a()\n		{\n			sum=0;\n		}\n		int sum;\n		int getsum(int n=N-1)\n		{\n			a&lt;N-1&gt; b;\n			sum=b.getsum(n)+N;\n			return sum;\n		}\n};\n\ntemplate&lt;&gt;\nclass a&lt;0&gt;\n{\n	public:\n		int sum=0;\n		int getsum(int n)\n		{\n			return 0;\n		}\n};\n\nint main()\n{\n	a&lt;10&gt; b;\n	cout&lt;&lt;b.getsum()&lt;&lt;endl;\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('3c3205cf525925c9fbae594e7b36de27','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  线性表——线性表+抽象链表类+单向链表讲解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.讲解：\n  </h2>\n  <div>\n   线性表两种分类：\n  </div>\n  <div>\n   顺序表，链表\n  </div>\n  <div>\n   线性表&gt;记录（数据元素）&gt;数据项\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   顺序表：只有唯一一个节点只存在一个后继，不存在前驱，只有唯一一个节点存在前驱，不存在后继，中间所有的节点都存在位移的前驱和后继\n  </div>\n  <div>\n   顺序表的优点：可以随机存取，方便访问，存储密度大，空间利用率高\n  </div>\n  <div>\n   顺序表缺点：难以实现插入数据的操作，而且空间一旦定义就会固定，不能动态控制空间内存的大小\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   链表的缺点：不能随机存取，空间访问麻烦指针域会占用部分内存空间，\n  </div>\n  <div>\n   链表优点：可以方便实现数据节点的插入\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   顺序存储类就不过多讲解了\n  </div>\n  <div>\n   链式存储类中我们来实现一下抽象链表类\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   节点对象&lt;抽象链表对象&lt;单链表对象\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.代码：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1849400\' name=\'code\' snippet_file_name=\'blog_20160824_1_2766617\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;    \nclass listnode\n{\n	public:\n		listnode()\n		{\n			next=NULL;\n		}\n		listnode(T item,listnode&lt;T&gt;* another)\n		{\n			data=item;\n			next=another;\n		}\n		T data;\n		listnode&lt;T&gt;* next;\n};\n\ntemplate&lt;typename T&gt;\nclass ablist\n{\n	public:\n		ablist()\n		{\n			head=NULL;\n			length=0;\n		}\n		ablist(ablist&lt;T&gt;&amp; a)  //注意这里必须是引用，因为涉及到指针，不用引用的话，不会完整的复制过来 \n		{\n			head=NULL;\n			length=0;\n			listnode&lt;T&gt;* p=head;\n			listnode&lt;T&gt;* help=a.head;\n			while(help!=NULL)\n			{\n				p=new listnode&lt;T&gt;(help-&gt;data,NULL);\n				p=p-&gt;next;\n				help=help.next;\n			}\n		}\n		~ablist()\n		{\n			listnode&lt;T&gt;* p=head-&gt;next;\n			while(head-&gt;next!=NULL)\n			{\n				head-&gt;next=head-&gt;next-&gt;next;\n				free(p);\n				p=head-&gt;next;\n			}\n			free(head);\n		}\n		listnode&lt;T&gt;* gethead()\n		{\n			return head;\n		}\n		listnode&lt;T&gt;* getnext(listnode&lt;T&gt;&amp; n)\n		{\n			return n.next; \n		}\n		T getnumber(int i)  //取出第i个元素 \n		{\n			listnode&lt;T&gt;* p=head;\n			for(int j=1;j&lt;i;j++) p=p-&gt;next;\n			return p-&gt;data;\n		}\n		bool setnumber(T k,int i)\n		{\n			listnode&lt;T&gt;* p=head;\n			for(int j=1;j&lt;i;j++)\n			{\n				if(p==NULL) return false;\n				p=p-&gt;next;\n			}\n			p-&gt;data=k;\n			return true;\n		}\n		listnode&lt;T&gt;* find(int i)\n		{\n			listnode&lt;T&gt;* p=head;\n			for(int j=1;j&lt;i;j++)\n			{\n				if(p==NULL) return NULL;\n				p=p-&gt;next;\n			}\n			return p;\n		}\n		listnode&lt;T&gt;* find1(T num)\n		{\n			listnode&lt;T&gt;* p=head;\n			while(p!=NULL)\n			{\n				if(p-&gt;data==num) return p;\n				p=p-&gt;next;\n			}\n			return NULL;\n		}\n		void listempty()\n		{\n			listnode&lt;T&gt;* p=head-&gt;next;\n			while(head-&gt;next!=NULL)\n			{\n				head-&gt;next=head-&gt;next-&gt;next;\n				free(p);\n				p=head-&gt;next;\n			}\n			free(head);\n			head=NULL;\n			length=0;\n		}\n		int returnlength()\n		{\n			return length;\n		} \n		virtual bool insert(T,int)=0;\n		virtual bool delete_(int)=0;\n		virtual bool remove(T)=0;\n	protected:\n		listnode&lt;T&gt;* head;   //这一点可以学习一下，都定义成模板，通过外包类模板模范子类的模板\n		int length; \n};\n\ntemplate&lt;typename T&gt;\nclass singlelist:public ablist&lt;T&gt;   //万分小心，学习一下，在模板类继承的时候，我们的因为偏特化的存在，必须要用this才可以看到父类成员 \n{\n	public:\n    	singlelist()\n		{}\n    	bool insert(T num,int i)\n    	{\n    		if(i==0) \n    		{\n    		    this-&gt;head=new listnode&lt;T&gt;(num,NULL);\n    			this-&gt;length++;\n    			return true;\n    		}\n    		i++;\n    		listnode&lt;T&gt;* p=this-&gt;find(i-1);\n    		if(p==NULL) return false;\n    		listnode&lt;T&gt;* help=new listnode&lt;T&gt;(num,NULL);\n    		help-&gt;next=p-&gt;next;\n    		p-&gt;next=help;\n    		this-&gt;length++;\n    		return true;\n    	}\n     	bool delete_(int i)\n    	{\n    		listnode&lt;T&gt;* p=this-&gt;find(i-1);\n    		if(p==NULL||p-&gt;next==NULL) return false;\n    		else\n    		{\n    			listnode&lt;T&gt;* help=p-&gt;next;\n     			T num=p-&gt;next-&gt;data;\n    			p-&gt;next=p-&gt;next-&gt;next;\n       			free(help);\n       			this-&gt;length--;\n    			return true;\n    		}\n    	}\n    	bool remove(T num)\n    	{\n    		listnode&lt;T&gt;* help=NULL;\n    		listnode&lt;T&gt;* p=this-&gt;head;\n    		while(p!=NULL)\n    		{\n    			if(p-&gt;data==num) break;\n    			else help=p;\n	    		p=p-&gt;next;\n    		}\n     		if(p==NULL) return false;\n    		help-&gt;next=help-&gt;next-&gt;next;\n    		free(p);\n    		this-&gt;length--;\n    		return true;\n    	}\n    	void print()\n		{\n			listnode&lt;T&gt;* p=this-&gt;head;\n			while(p!=NULL)\n			{\n				cout&lt;&lt;p-&gt;data&lt;&lt;\' \';\n				p=p-&gt;next;\n			} \n			cout&lt;&lt;endl;\n		} \n};\n\nint main()\n{\n	singlelist&lt;int&gt; my;\n	my.insert(1,my.returnlength());\n	my.insert(2,my.returnlength());\n	my.insert(4,my.returnlength());\n	my.insert(7,my.returnlength());\n	my.insert(3,my.returnlength());\n	my.insert(8,my.returnlength());\n	my.insert(9,my.returnlength());\n	my.print();\n	my.delete_(5);\n	my.print();\n	my.remove(8);\n	my.print();\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <h2>\n   3.应用：单链表进行加法运算：\n  </h2>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdlib\'\n#include\'cstdio\'\n\nusing namespace std;\n\nclass point\n{\n	public:\n		point(int n,int m):ceof(n),exp(m){\n			next=NULL;\n		}\n		friend ostream&amp; operator&lt;&lt;(ostream&amp; out,point&amp; p)\n		{\n			printf(\'%+dx^%d\',p.ceof,p.exp);\n		}\n		int getceof()\n		{\n			return ceof;\n		}\n		int getexp()\n		{\n			return exp;\n		}\n		point* next;\n	private:\n		int ceof;\n		int exp;\n};\n\nclass singlelist\n{\n	public:\n		singlelist()\n		{\n			head=new point(0,0);\n			head-&gt;next=NULL;\n			num=0;\n		}\n		void insert(int ceof,int exp)\n		{\n			point* p=new point(ceof,exp);\n			point* help=head;\n			while(help-&gt;next!=NULL&amp;&amp;help-&gt;next-&gt;getexp()&gt;=p-&gt;getexp()) help=help-&gt;next;\n			p-&gt;next=help-&gt;next;\n			help-&gt;next=p;\n			num++;\n		}\n		void add(singlelist&amp; a,singlelist&amp; b)\n		{\n			point* heada=a.head-&gt;next;\n			point* headb=b.head-&gt;next;\n			point* headc;\n			point* help=head;\n			while(heada!=NULL&amp;&amp;headb!=NULL)\n			{\n				if(heada-&gt;getexp()==headb-&gt;getexp()) \n				{\n					headc=new point(heada-&gt;getceof()+headb-&gt;getceof(),heada-&gt;getexp());\n					heada=heada-&gt;next;\n					headb=headb-&gt;next;\n				}\n				else\n				{\n					if(heada-&gt;getexp()&lt;headb-&gt;getexp()) \n					{\n						headc=new point(headb-&gt;getceof(),headb-&gt;getexp());\n						headb=headb-&gt;next;\n					}\n					else \n					{\n						headc=new point(heada-&gt;getceof(),heada-&gt;getexp());\n						heada=heada-&gt;next;\n					}\n				} \n				help-&gt;next=headc;\n				help=help-&gt;next;\n				headc=headc-&gt;next;\n			} \n			if(heada==NULL)\n			{\n				while(headb!=NULL)\n				{\n					headc=new point(headb-&gt;getceof(),headb-&gt;getexp());\n					headc=headc-&gt;next;\n					headb=headb-&gt;next;\n				}\n			} \n			else\n			{\n				while(heada!=NULL)\n				{\n					headc=new point(heada-&gt;getceof(),heada-&gt;getexp());\n					headc=headc-&gt;next;\n					heada=heada-&gt;next;\n				}\n			}\n		}\n		void print()\n		{\n			point* p=head-&gt;next;\n			while(p!=NULL)\n			{\n				if(p-&gt;getceof()!=0) cout&lt;&lt;*p;\n				p=p-&gt;next;\n			}\n		}\n	private:\n		point* head;\n		int num;\n};\n\nint main()\n{\n	singlelist a;\n	singlelist b;\n	singlelist c;\n	a.insert(4,21);\n	a.insert(5,10);\n	a.insert(7,4);\n	a.insert(1,1);\n	b.insert(5,12);\n	b.insert(-5,10);\n	b.insert(11,4);\n	b.insert(1,1);\n	c.add(a,b);\n	c.print();\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('7b153f9d758efb5f8debbb7f71afc002','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ 2676 数独 &amp;&amp; 编程之美1.15\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   算法讲解：\n  </p>\n  <p>\n   low逼算法DFS,这里如果不用空间换时间会TLE\n  </p>\n  <p>\n   所以说我们加入三个判断矩阵\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1847953\' name=\'code\' snippet_file_name=\'blog_20160824_1_1714227\'>hang[x][i]  第x行有没有出现i\nlie[x][i]   第i列有没有出现i\nsq[x][y][i]   以x,y为首标号的子矩阵有没有i  </pre>\n  <br/>\n  然后总结一些常见错误：\n  <p>\n  </p>\n  <p>\n   1.每次试探成功，hang，lie，sq都要更新\n  </p>\n  <p>\n   2.我们如果不用bool类型的函数的话那么每次都要在试探语句下面加上强制返回语句，用了bool类型，那么加上if判断就好了\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   AC代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1847953\' name=\'code\' snippet_file_name=\'blog_20160824_2_2859279\'>#include\'iostream\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cstdio\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x;\n	int y;\n}point;\n\nchar data[10][10];\nbool hang[10][10];\nbool lie[10][10];\nbool sq[10][10][10];\nint starnum;\npoint star[100];\nint flag=0;\n\nvoid dfs(int x,int y,int num)\n{\n	if(flag==1) return ;\n	if(num&gt;starnum)\n	{\n		flag=1;\n		return ;\n	}\n	else\n	{\n		for(int i=1;i&lt;=9;i++)\n		{\n			if(hang[x][i]||lie[y][i]||sq[x/3*3][y/3*3][i]) continue;\n			else\n			{\n				data[x][y]=\'0\'+i;\n				hang[x][i]=lie[y][i]=sq[x/3*3][y/3*3][i]=1;\n				dfs(star[num+1].x,star[num+1].y,num+1);\n				if(flag==1) return ;\n				hang[x][i]=lie[y][i]=sq[x/3*3][y/3*3][i]=0;\n				data[x][y]=\'0\';\n			}\n		}\n	}\n}\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		starnum=flag=0;\n		memset(data,0,sizeof(data));\n		memset(hang,0,sizeof(hang));\n		memset(lie,0,sizeof(lie));\n		memset(sq,0,sizeof(sq));\n		for(int i=0;i&lt;9;i++)\n		{\n			for(int j=0;j&lt;9;j++)\n			{\n				cin&gt;&gt;data[i][j];\n				hang[i][data[i][j]-\'0\']=lie[j][data[i][j]-\'0\']=sq[i/3*3][j/3*3][data[i][j]-\'0\']=1;\n				if(data[i][j]==\'0\')\n				{\n					star[++starnum].x=i;\n					star[starnum].y=j;\n				}\n			}\n		}\n		dfs(star[1].x,star[1].y,1);\n		for(int i=0;i&lt;9;i++)\n		{\n			for(int j=0;j&lt;9;j++)\n			{\n				printf(\'%c\',data[i][j]);\n			}\n			printf(\'\n\');\n		}\n	} \n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <p>\n  </p>\n  <p>\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('266fe684c18f343f9380e1390d67807e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题015——镜像翻转BST\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述\n  </h2>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    题目：输入一颗二元查找树，将该树转换为它的镜像，即在转换后的二元查找树中，左子树的结点都大于右子树的结点。用递归和循环两种方法完成树的镜像转换。\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    例如输入：\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    8\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    / \n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    6 10\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    / /\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    5 7 9 11\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    输出：\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    8\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    / \n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    10 6\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    / /\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    11 9 7 5\n   </span>\n   <br/>\n  </div>\n  <h2>\n   2.算法思路：\n  </h2>\n  <div>\n   标准的递归思路，我们采用前序遍历的顺序，不断的对树进行翻转，知道遇到空节点为止\n  </div>\n  <div>\n   奇葩的非递归思路，首先，我们要意识到，递归其实完全可以用栈来进行代替，用辅助栈模拟递归的过程不困难\n  </div>\n  <div>\n   我们这么来看，我们每一层递归唯一的差别就是操作的根节点的不同，所以说所以说我们的辅助栈保存操作的根节点，直到我们的辅助栈为空说明镜像翻转完成\n  </div>\n  <h2>\n   3.代码示例：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1847503\' name=\'code\' snippet_file_name=\'blog_20160823_1_8810907\'>	void mirror(point* p)\n		{\n			if(p==NULL) return ;\n			else\n			{\n				point* k=p-&gt;left;\n				p-&gt;left=p-&gt;right;\n				p-&gt;right=k;\n				mirror(p-&gt;left);\n				mirror(p-&gt;right);\n			}\n		}\n		void mirroranother()\n		{\n			int num=0;\n			stack&lt;point*&gt; mystack;   //辅助栈\n			mystack.push(root);\n			while(mystack.size()!=0)\n			{\n				point* k=mystack.top();\n				point* help=k-&gt;left;\n				k-&gt;left=k-&gt;right;\n				k-&gt;right=help;\n				mystack.pop();\n				if(k-&gt;left!=NULL) mystack.push(k-&gt;left);   //小心这两句防止访问空节点\n				if(k-&gt;right!=NULL) mystack.push(k-&gt;right);\n			}\n		}</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('dca39f661ce7aa0b4cdc185f3a66f0bb','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  比赛总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.DP问题\n  </h2>\n  <h2>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20151229175608175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\' style=\'font-size:12px\'/>\n  </h2>\n  <div>\n   求解出从左上角到右下角的所有的路径的个数\n  </div>\n  <div>\n   该题明显的是动态规划的求解思路\n  </div>\n  <div>\n   首先：\n  </div>\n  <div>\n   定义状态：dp[i][j]代表走到地图的i，j处的路径总数\n  </div>\n  <div>\n   状态转移方程：根据定义来看，dp[i][j]=dp[i-1][j]+dp[i][j-1]\n  </div>\n  <div>\n   这个状态转移方程是核心：\n  </div>\n  <div>\n   含义是要走到map[i][j]的路径数等于走到map[i][j-1]处再走一步加上走到map[i-1][j]再走一步\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1839105\' name=\'code\' snippet_file_name=\'blog_20160818_1_9874585\'>int dp[n][n];\nfor(int i=0;i&lt;n;i++) dp[i][0]=dp[0][i]=1;\nfor(int i=0;i&lt;n;i++)\n{\n    for(int j=0;j&lt;n;j++) dp[i][j]=dp[i-1][j]+dp[i][j-1];\n}</pre>\n   <div>\n    <br/>\n   </div>\n   <h2>\n    2.BST问题：\n   </h2>\n   <div>\n    求数组最后两个最大的数的比较次数是多少\n   </div>\n   <div>\n    2*logn-1\n   </div>\n   <div>\n    -1是因为第二大的数肯定不在最后一层，这个要记住\n   </div>\n   <div>\n    <br/>\n   </div>\n   <h2>\n    3.快排：\n   </h2>\n   <div>\n    快排考的是算法导论里面的思路，以后记清楚了\n   </div>\n   <br/>\n   <h2>\n    4.总结：\n   </h2>\n  </div>\n  <div>\n   我只是一个自以为是的傻子，技不如人，我就继续奋斗\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2bb04749f872ea65e3efd519e1f6d98d','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题005——SBT再解第K数问题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述：\n  </h2>\n  <div>\n   求一组数组中的第K大或者第k小的数\n  </div>\n  <h2>\n   2.算法：\n  </h2>\n  <div>\n   上一期我们通过了二叉堆来进行该问题的求解，非常的高效，我们通过O(n)就可以解决问题\n  </div>\n  <div>\n   这一期我们通过SBT来解决：\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52237338\' target=\'_blank\'>\n    SBT详解\n   </a>\n  </div>\n  <div>\n   我们通过SBT的select来解决问题会变得非常高效，如果不考虑剑术的时间，时间复杂度是O(logn)，如果考虑建树是O(logn+n*logn)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   附上select函数代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1837939\' name=\'code\' snippet_file_name=\'blog_20160818_1_5822794\'>int SBT::select(int&amp; p,int k)  //选择第k大的元素 \n{\n	if(size[left[p]]+1==k) return p;\n	else\n	{\n		if(size[left[p]]+1&lt;k) return select(right[p],k-size[left[p]]-1);\n		else return select(left[p],k);\n	}\n}</pre>\n   SBT正因为有了size域，所以说在查找该问题方面会变的非常的快\n  </div>\n  <div>\n   当然这是查找第k小问题\n  </div>\n  <div>\n   如果是查找第k大问题，我们只要用O(1)求出数组长度\n  </div>\n  <div>\n   再用O(1)：length-k就可以了，问题是没有变化的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   一般的时候，我们都是不会考虑建树的时间的，这样的情况下，SBT的查找效率明显快于堆的操作\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('00a2b338af862c80a1183516ce9efba9','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  从BST到SBT（田劲峰老师论文读后感）6.\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.致歉：\n  </h2>\n  <div>\n   最近事务过于繁多，更新的次数变得缓慢了不少，但是我至少在继续，继续努力\n  </div>\n  <div>\n   之后，由于田劲峰老师的论文的证明非常严谨，我看了很长时间仍然是不得精华，只能是将作为初学者该掌握的都掌握了，至于证明正确性和复杂度，实在是难以参透，日后等学习算法导论的时候，有能力再回来看证明，并且，终于可以开始步入正轨了\n  </div>\n  <h2>\n   2.什么是BST：\n  </h2>\n  <div>\n   BST全称是二叉查找树，字面意思很显而易见，这是我们为了查找而开发的一种优秀的查找数据结构\n  </div>\n  <div>\n   如果还没有理解过二叉查找树，\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52081538\' target=\'_blank\'>\n    欢迎点击这里\n   </a>\n   来进行初步学习\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在这里我们先进行二叉查找树的一些简要的解析，进而引出我们的主要内容——自平衡二叉树之一的SBT\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   性质：\n  </div>\n  <div>\n   1.是一颗空树\n  </div>\n  <div>\n   2.非空树并且左子树所有的节点的数据都小于根节点\n  </div>\n  <div>\n   非空树并且右子树所有的节点的数据都大于根节点\n  </div>\n  <div>\n   3.BST内不存在相同键值的恋歌节点\n  </div>\n  <div>\n   4.根节点的左右子树都是BST\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   优劣：\n  </div>\n  <div>\n   优点：查找的时间复杂度：O(logn)非常高效的查找速度\n  </div>\n  <div>\n   缺点：对于存在部分有序的输入序列，会导致BST偏向于偏树，进而使得树的深度逐渐变大，导致查找速度不断退化，最坏的退化情况是退化成双向链表\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   引出：\n  </div>\n  <div>\n   对于BST的缺点，我们需要克服，我们最终需要的而是一种技能高效的查找数据又可以避免特殊的输入序列而导致的BST 的退化，所以这时候，我们引入了一种新的数据结构——自平衡二叉树，通过不同的操作，是的，这种进化过得BST可以拥有自动调节树高的能力，是的我们查找的时间复杂度稳定在O(logn)附近，避免特殊的序列而差生的退化\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在众多的自平衡二叉树中——相对于好实现的，在算法竞赛中常用的要数我国大神陈启峰发明的SBT（size balance tree），相对于treap，红黑树，splay，AVL等一些自平衡二叉树来说，SBT好实现，并且其中的核心操作只有Maintain操作，Maintain操作的高效和灵活性成为SBT流行的原因\n  </div>\n  <h2>\n   3.SBT的ADT\n  </h2>\n  <div>\n   性质：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_1_5485322\'>1.size[left[p]]&gt;=size[left[right[p]]]/size[right[right[p]]]\n2.size[right[p]]&gt;=size[left[left[p]]]/size[right[left[p]]]</pre>\n  </div>\n  <h3>\n   1.数据结构的选择：\n  </h3>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    SBT的实现来说，经过本博主的长时间的考虑，私以为，SBT用数组来实现是非常容易并且好考虑的，通过自己亲自实现链式的SBT发现，非常困难，而且对于算法的理解有所影响，所以说，我们这里采用数组来实现，在这里我们在C++代码中采用了引用来进行传址，这一点是非常的核心的，我们是必须要这么做的，在下面的代码中我会讲解这一点的必要性\n   </span>\n   <br/>\n  </div>\n  <h3>\n   <span style=\'font-size:13.3333px\'>\n    2.ADT\n   </span>\n  </h3>\n  <div>\n   成员变量：\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    //首先我们虽然不列举出来，但是实际上，在我们思考的时候我们要注意，我们要抽象出一段假想的空间，这一段空间是顺序的1-N，代表我们的输入的顺序\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    left[i]\n    <span style=\'white-space:pre\'>\n    </span>\n    第i次输入的节点的左节点的输入的次序（注意联系上面的那段假想的数据空间）\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    right[i]\n    <span style=\'white-space:pre\'>\n    </span>\n    第i次输入的节点的右节点的输入的次序\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    size[i]\n    <span style=\'white-space:pre\'>\n    </span>\n    第i次输入的节点为根的子树的节点的总数目，这个size域是SBT非常重要的核心数据\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    key[i]\n    <span style=\'white-space:pre\'>\n    </span>\n    第i次输入的节点的键值\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    num\n    <span style=\'white-space:pre\'>\n    </span>\n    该SBT的节点总数\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    root\n    <span style=\'white-space:pre\'>\n    </span>\n    该SBT的根节点的输入的次序\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    //我们根据不同的操作获得的输入次序为自变量，可以轻松的得到该输入次序的输入元素的键值和size域\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    函数：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    最核心的两个：(根节点子树左右旋操作)\n   </span>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_2_959963\'>left_rotation(int&amp;)\nright_rotation(int&amp;)</pre>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_3_9465464\'>Maintain(int&amp;,bool) //O(1)均摊时间复杂度</pre>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_4_4831421\'>insert(int&amp;,int);</pre>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_5_7448360\'>delete_(int&amp;,int,bool);</pre>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_6_2257910\'>find(int&amp;,int)</pre>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_7_2399613\'>select(int&amp;,int)</pre>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_8_2541317\'>after(int&amp;,int)</pre>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_9_9826101\'>pre(int&amp;,int)</pre>\n   <h3>\n    3.核心旋转操作解析：\n   </h3>\n   <div>\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20131129201336156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVybXVyZWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\'/>\n    <br/>\n   </div>\n   <div>\n    1.左旋：\n   </div>\n   <div>\n    <br/>\n   </div>\n   先来看看左旋操作，顾名思义，左旋我们相当于是把y提高，把x压下去，目的是可能y的size域过大，将y的比较对象降低（之后哦我们呢会看到，现在不理解这句话没关系）\n  </div>\n  <div>\n   其实这里的旋转操作就相当于是一系列的指针的操作\n  </div>\n  <div>\n   代码如下：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_10_8015958\'>void SBT::left_rotation(int&amp; p)  //我们已经指定了x指针，要进行操作还需要指向y的指针\n{\n	int k=right[p];   //确定指向y的指针k\n	right[p]=left[k];    //x右儿子指向b\n	left[k]=p;    //y的左儿子指向x\n	size[k]=size[p];      //因为k这里操作完之后，相当于是y取代了x的位置，所以说，size域也应该是没变之前的x的size域\n	size[p]=size[left[p]]+size[right[p]]+1;    //理所应当\n	p=k;     //这里的转换牵扯到引用\n}</pre>\n   ps：在这里，我对引用的必要性做一下解释，如果没有用引用，p在这里只是一个随机变量，p的任何改变是不会影响到上一层调用函数的形参表中的值得，所以我们之后需要将上一层的形参表中的指针的指向同步修改，就必须采用引用\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.右旋：\n  </div>\n  <div>\n   原理同左旋：\n  </div>\n  <div>\n   代码如下：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_11_9237457\'>void SBT::right_rotation(int&amp; p)\n{\n	int k=left[p];\n	left[p]=right[k];\n	right[k]=p;\n	size[k]=size[p];\n	size[p]=size[left[p]]+size[right[p]]+1;\n	p=k;\n}</pre>\n   <h3>\n    4.最具活力的Maintain操作\n   </h3>\n   <div>\n    maintain操作就是根据不同的不平衡情况从而采取不同的一系列的旋转操作\n   </div>\n   <div>\n    首先明确一点，在不平衡以前，始终是一颗SBT\n   </div>\n   <div>\n    1.Case1：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_12_1015364\'>size[left[left[p]]]&gt;size[right[p]]</pre>\n    <div>\n     <img alt=\'\' src=\'http://img.blog.csdn.net/20131129202211734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVybXVyZWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\'/>\n     <br/>\n    </div>\n   </div>\n   <div>\n    <br/>\n    这里就是size[A]&gt;size[R]\n   </div>\n   <div>\n    首先这里A与R比较，我们为了保持平衡，通过右旋操作把A拉高\n   </div>\n   <div>\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20131129203355843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVybXVyZWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\'/>\n    <br/>\n   </div>\n   这时候A是与B和R比较，因为size[A]&gt;size[R]，所以说只有两种情况不平衡\n  </div>\n  <div>\n   1.size[A]&lt;size[B]\n  </div>\n  <div>\n   2.size[B]&lt;size[C]或者size[B]&lt;size[D]\n   <br/>\n  </div>\n  <div>\n   有人这里可能会问，有没有可能\n   <span style=\'font-size:13.3333px\'>\n    size[B]&gt;=size[C]，size[B]&gt;=size[D]同时不成立，在这里通过反证法证明是不会的\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    证明如下：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_13_2760251\'>条件：\nsize[A]&gt;size[R]\nsize[B]&lt;size[C]\nsize[B]&lt;size[D]\nsize[B]&gt;size[left[A]]   //这两点的原因是，在不平衡之前，原树是一颗SBT\nsize[B]&gt;size[right[A]]\n\n结论：\nsize[left[A]]+size[right[A]]+1&lt;size[C]+size[D]+1=size[R]\n=&gt;size[A]&lt;size[R]\n与条件相违背，说明两种情况不能同时成立</pre>\n   之后我们再次进行递归定义维护Maintain(T)，因为Maintain(T)维护之后，L树的右儿子的左右子树就变得不可预料了，我们不知道其和A的size关系，所以说，还要再次用Maintain(L)维护以T为根的子树，之后维护停止，所有的操作都是常数时间的\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n    2.Case2:\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_14_2901955\'>size[right[left[p]]]&gt;size[right[p]]</pre>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20131129203745125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVybXVyZWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\'/>\n   <br/>\n   <br/>\n   在这里就是size[B]&gt;size[R]\n  </div>\n  <div>\n   首先我们左旋，将不平衡性转化到Case1的情况\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20131129203857906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVybXVyZWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\'/>\n   <br/>\n  </div>\n  <div>\n   之后同Case1,先右旋：\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20131129203924718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVybXVyZWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\'/>\n   <br/>\n  </div>\n  <div>\n   因为多次操作之后边的情况过于复杂，我们直接先Maintain(L),再Maintain(T),然后Maintain(B)\n  </div>\n  <div>\n   3.Case3,Case4和Case1,2是镜像对称，这里操作原理都是一样的，就不过多赘述了\n  </div>\n  <h3>\n   5.其他有用的操作：\n  </h3>\n  <div>\n   在之后附上的代码中解析\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   4.代码：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160818_15_3251402\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1000\n\nusing namespace std;\n\nclass SBT\n{\n	public:\n		SBT()\n		{\n			memset(size,0,sizeof(size));\n			memset(left,0,sizeof(left));\n			memset(right,0,sizeof(right));\n			memset(key,0,sizeof(key));\n			num=root=0;\n		}\n		void left_rotation(int&amp;);\n		void right_rotation(int&amp;);\n		void insert(int&amp;,int);\n		int delete_(int&amp;,int,bool);   //没有找到要烧出的元素，返回-1，否则返回被删除的点的 \n		void preorder(int);\n		void midorder(int);\n		void maintain(int&amp;,bool);\n		int&amp; returnroot()\n		{\n			return root;\n		}\n		int find(int&amp;,int);   //返回查找到的点的输入的序号，根据序号可以得到该点的size以及key信息 \n		int select(int&amp;,int);\n		int after(int&amp;,int);\n		int pre(int&amp;,int);\n	private:\n		int size[N];\n		int left[N];\n		int right[N];\n		int key[N];\n		int num;\n		int root;\n};\n\nvoid SBT::left_rotation(int&amp; p)\n{\n	int k=right[p];\n	right[p]=left[k];\n	left[k]=p;\n	size[k]=size[p];\n	size[p]=size[left[p]]+size[right[p]]+1;\n	p=k;\n}\n\nvoid SBT::right_rotation(int&amp; p)\n{\n	int k=left[p];\n	left[p]=right[k];\n	right[k]=p;\n	size[k]=size[p];\n	size[p]=size[left[p]]+size[right[p]]+1;\n	p=k;\n}\n\nvoid SBT::maintain(int&amp; p,bool judge)\n{\n	if(judge==false)\n	{\n		if(size[left[left[p]]]&gt;size[right[p]]) right_rotation(p);\n		else\n		{\n			if(size[right[left[p]]]&gt;size[right[p]]) \n			{\n				left_rotation(left[p]);\n				right_rotation(p);\n			}\n			else return ;\n		}\n	}\n	else\n	{\n		if(size[right[right[p]]]&gt;size[left[p]]) right_rotation(p);\n		else\n		{\n			if(size[left[right[p]]]&gt;size[left[p]])\n			{\n				right_rotation(right[p]);\n				left_rotation(p);\n			}\n			else return ;\n		}\n	}\n	maintain(left[p],false);\n	maintain(right[p],true);\n	maintain(p,false);\n	maintain(p,true);\n}\n\nvoid SBT::insert(int&amp; p,int k)\n{\n	if(p==0)\n	{\n		key[p=++num]=k;\n		size[num]=1;\n	}\n	else\n	{\n		size[p]++;\n		if(k&lt;key[p]) insert(left[p],k);\n		else insert(right[p],k);\n	}\n	if(p!=0) maintain(p,k&gt;=key[p]);\n}\n\nint SBT::delete_(int&amp; p,int k,bool judge)\n{\n	if(key[p]==k) judge=1;\n	if(key[p]==k||(left[p]==0&amp;&amp;k&lt;key[p])||(right[p]==0&amp;&amp;k&gt;key[p])) \n	{\n		if(((left[p]==0&amp;&amp;k&lt;key[p])||(right[p]==0&amp;&amp;k&gt;key[p]))&amp;&amp;judge==0)   \n		{\n			return -1;  //直接返回给主调函数为-1，代表查找失败 \n		}\n		else   //剩下的情况就是KEY[P]=K&amp;&amp;judge=1(代表之前已经找到过)\n		{\n			int r=key[p];\n			if(left[p]==0||right[p]==0) p=left[p]+right[p];\n			else key[p]=delete_(left[p],k+1,judge);\n			return r;\n		} \n	}\n	else\n	{\n		if(key[p]&gt;k) return delete_(left[p],k,judge);\n		else return delete_(right[p],k,judge);\n	}\n}\n\nint SBT::find(int&amp; p,int k)\n{\n	if(p==0||key[p]==k) return p;\n	else\n	{\n		if(k&lt;key[p]) return find(left[p],k);\n		else return find(right[p],k);\n	} \n}\n\nvoid SBT::preorder(int p)\n{\n	if(p==0) return ;\n	else\n	{\n		cout&lt;&lt;key[p]&lt;&lt;\' \';\n		preorder(left[p]);\n		preorder(right[p]);\n	}\n}\n\nvoid SBT::midorder(int p)\n{\n	if(p==0) return ;\n	else\n	{\n		midorder(left[p]);\n		cout&lt;&lt;key[p]&lt;&lt;\' \';\n		midorder(right[p]);\n	}\n}\n\nint SBT::select(int&amp; p,int k)  //选择第k大的元素 \n{\n	if(size[left[p]]+1==k) return p;\n	else\n	{\n		if(size[left[p]]+1&lt;k) return select(right[p],k-size[left[p]]-1);\n		else return select(left[p],k);\n	}\n}\n\nint SBT::after(int&amp; p,int k)\n{\n	if(p==0) return -1;  //-1代表查找失败的标记\n	else\n	{\n		if(key[p]==k) return key[right[p]];\n		else\n		{\n			if(k&lt;key[p]) return after(left[p],k);\n			else return after(right[p],k);\n		}\n	}\n}\n\nint SBT::pre(int&amp; p,int k)\n{\n	if(p==0) return -1;\n	else\n	{\n		if(key[p]==k) return key[left[p]];\n		else\n		{\n			if(k&lt;key[p]) return pre(left[p],k);\n			else return pre(right[p],k);\n		} \n	}\n}\n\nint main()\n{\n	SBT my;   //这里对left，right，size，key的含义可能不清楚，我来解释一下，每次输入一批数据的时候，我们嘉定对输入的数据进行编号，left[i]存储的是i次输入的数据的左儿子的输入的顺序编号   \n    my.insert(my.returnroot(),5);  \n    my.insert(my.returnroot(),2);  \n    my.insert(my.returnroot(),9);  \n    my.insert(my.returnroot(),4);  \n    my.insert(my.returnroot(),6);  \n    my.insert(my.returnroot(),8);  \n    my.preorder(my.returnroot());  \n    cout&lt;&lt;endl;   \n    my.insert(my.returnroot(),7);  \n    my.preorder(my.returnroot());  \n    cout&lt;&lt;endl;  \n    my.delete_(my.returnroot(),5,0);  \n    my.preorder(my.returnroot());  \n    cout&lt;&lt;endl;   \n    cout&lt;&lt;my.after(my.returnroot(),8)&lt;&lt;endl;\n	return 0;\n} </pre>\n   <h2>\n    6.模板化SBT\n   </h2>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1837882\' name=\'code\' snippet_file_name=\'blog_20160820_16_3054820\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 1000\n\nusing namespace std;\n\ntemplate&lt;typename T&gt; \nclass SBT\n{\n	public:\n		SBT()\n		{\n			memset(size,0,sizeof(size));\n			memset(key,0,sizeof(key));\n			memset(left,0,sizeof(left));\n			memset(right,0,sizeof(right));\n			num=root=0;\n		}\n		void left_rotation(int&amp;);\n		void right_rotation(int&amp;);\n		void maintain(int&amp;,bool);\n		void insert(int&amp;,T); \n		T delete_(int&amp;,T,bool);\n		void preorder(int);\n		void midorder(int);\n		T select(int&amp;,int);\n		T after(int&amp;,T);\n		T pre(int&amp;,T);\n		int find(int&amp;,T);\n		void afterdelete_();\n		int&amp; returnroot()\n		{\n			return root;\n		} \n	private:\n		T key[N];\n		int left[N];\n		int right[N];\n		int size[N];\n		int num;\n		int root;\n};\n\ntemplate&lt;typename T&gt;\nvoid SBT&lt;T&gt;::left_rotation(int&amp; p)\n{\n	int k=right[p];\n	right[p]=left[k];\n	left[k]=p;\n	size[k]=size[p];\n	size[p]=size[left[p]]+size[right[p]]+1;\n	p=k;\n}\n\ntemplate&lt;typename T&gt;\nvoid SBT&lt;T&gt;::right_rotation(int&amp; p)\n{\n	int k=left[p];\n	left[p]=right[k];\n	right[k]=p;\n	size[k]=size[p];\n	size[p]=size[left[p]]+size[right[p]]+1;\n	p=k;\n}\n\ntemplate&lt;typename T&gt;\nvoid SBT&lt;T&gt;::maintain(int&amp; p,bool judge)\n{\n	if(judge==false)\n	{\n		if(size[left[left[p]]]&gt;size[right[p]]) right_rotation(p);\n		else\n		{\n			if(size[right[left[p]]]&gt;size[right[p]])\n			{\n				left_rotation(left[p]);\n				right_rotation(p);\n			}\n			else return ;\n		}\n	}\n	else\n	{\n		if(size[right[right[p]]]&gt;size[left[p]]) left_rotation(p);\n		else \n		{\n			if(size[left[right[p]]]&gt;size[left[p]])\n			{\n				right_rotation(right[p]);\n				left_rotation(p);\n			}\n			else return ;\n		}\n	}\n	maintain(left[p],false);\n	maintain(right[p],true);\n	maintain(p,true);\n	maintain(p,false);\n}\n\ntemplate&lt;typename T&gt;\nvoid SBT&lt;T&gt;::insert(int&amp; p,T k)\n{\n	if(p==0) \n	{\n		key[p=++num]=k;\n		size[p]=1;\n	}\n	else\n	{\n		size[p]++; \n		if(key[p]&gt;k) insert(left[p],k);\n		else insert(right[p],k);\n		maintain(p,k&gt;=key[p]);\n	}\n} \n\ntemplate&lt;typename T&gt;\nT SBT&lt;T&gt;::delete_(int&amp; p,T k,bool judge)\n{\n	if(key[p]==k) judge=1;\n	if(key[p]==k||(left[p]==0&amp;&amp;k&lt;key[p])||(right[p]==0&amp;&amp;k&gt;key[p]))\n	{\n		if(((left[p]==0&amp;&amp;k&lt;key[p])||(right[p]==0&amp;&amp;k&gt;key[p]))&amp;&amp;judge==0) return key[0];\n		else\n		{\n			T r=key[p];\n			if(left[p]==0||right[p]==0) p=left[p]+right[p];\n			else key[p]=delete_(left[p],k,1);\n			return r;\n		}\n	}\n	else\n	{\n		size[p]--;\n		if(key[p]&gt;k) return delet_(left[p],k,judge);\n		else return delet_(right[p],k,judge);\n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid SBT&lt;T&gt;::afterdelete_()\n{\n	T r;\n	cout&lt;&lt;\'输入你要删除的节点的关键字\'&lt;&lt;endl;\n	cin&gt;&gt;r; \n	delete_(root,r,0);\n	num--;\n}\n\ntemplate&lt;typename T&gt;\nvoid SBT&lt;T&gt;::preorder(int p)\n{\n	if(p==0) return ;\n	else\n	{\n		cout&lt;&lt;key[p]&lt;&lt;\' \';\n		preorder(left[p]);\n		preorder(right[p]); \n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid SBT&lt;T&gt;::midorder(int p)\n{\n	if(p==0) return ;\n	else\n	{\n		midorder(left[p]);\n		cout&lt;&lt;key[p]&lt;&lt;\' \';\n		midorder(right[p]); \n	}\n}\n\ntemplate&lt;typename T&gt;\nT SBT&lt;T&gt;::select(int&amp; p,int k)\n{\n	if(size[left[p]]+1==k) return key[p];\n	else\n	{\n		if(size[left[p]]+1&gt;k) return select(left[p],k);\n		else return select(right[p],k-size[left[p]]-1);\n	}\n}\n\ntemplate&lt;typename T&gt;\nint SBT&lt;T&gt;::find(int&amp; p,T k)\n{\n	if(p==0||key[p]==k) return p;\n	else\n	{\n		if(key[p]&gt;k) return find(left[p],k);\n		else return find(right[p],k);\n	}\n} \n\ntemplate&lt;typename T&gt;\nT SBT&lt;T&gt;::pre(int&amp; p,T k)\n{\n	if(p==0) return key[0];\n	if(key[p]==k) return key[left[p]];\n	else\n	{\n		if(key[p]&gt;k) return pre(left[p],k);\n		else return pre(right[p],k); \n	}\n}\n\ntemplate&lt;typename T&gt;\nT SBT&lt;T&gt;::after(int&amp; p,T k)\n{\n	if(p==0) return key[0];\n	if(key[p]==k) return key[right[p]];\n	else\n	{\n		if(key[p]&gt;k) return after(left[p],k);\n		else return after(right[p],k);\n	}\n}\n\nint main()\n{\n	SBT&lt;double&gt; my;\n	my.insert(my.returnroot(),5);\n	my.insert(my.returnroot(),2);\n	my.insert(my.returnroot(),9);\n	my.insert(my.returnroot(),4);\n	my.insert(my.returnroot(),6);\n	my.insert(my.returnroot(),8);\n	my.insert(my.returnroot(),7);\n	my.insert(my.returnroot(),7.5);\n	my.preorder(my.returnroot());\n	return 0;\n} </pre>\n    <br/>\n    <br/>\n   </div>\n   <br/>\n   <h2>\n    7.应用：\n   </h2>\n  </div>\n  <div>\n   1.SBT的select函数可以求最大最小，第k大的元素，相对于我们用对来实现的话可能在建完树之后，操作会更快一点，我之后会出一个这个专题\n  </div>\n  <div>\n   2.SBT优化LCS问题的动态规划\n  </div>\n  <h2>\n   6.鸣谢：\n  </h2>\n  <div>\n   长时间没有读懂SBT\n  </div>\n  <div>\n   感谢：\n  </div>\n  <div>\n   田劲峰老师2011年的论文\n  </div>\n  <div>\n   感谢NOI百度贴吧的大牛的详解\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('53cdde910a21801450c4d7a5570a0d5c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  编程之美1.14——连连看工程（含全部代码，伪哈希+BFS）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.连连看问题描述：\n  </h2>\n  <div>\n   1.用计算机模型模拟这个问题\n  </div>\n  <div>\n   2.怎样判断两个图形可以相消（核心）\n  </div>\n  <div>\n   3.怎样求出相同图形之间的最短路径（转弯次数最少，路径经过的格子最少，后置是在前者的制约下的）动态规划的思想在队列中的实现\n  </div>\n  <div>\n   4.怎么确定死锁状态（本人的一点小创新，为了优化查找的时间复杂度，开辟了一个伪哈希表）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.算法思想：\n  </h2>\n  <div>\n   1.如何判断相消：\n  </div>\n  <div>\n   在本文章中，BFS的思路无疑是最好象，也是最出色，效率最搞得一种方法，网上的一些人说可以之间分类判断贵啊点的数目来判断，那是他们没有仔细思考多种特殊情况就没有是想，光凭想象说的，这里的BFS的思路是最合适的\n  </div>\n  <div>\n   首先我们以我们第一次选中的节点作为扩展的父节点，然后十字开辟空余的格子，然后分别以这些空余的格子作为父节点再次开辟（当然开辟的次数不能超过三次），还有，这里面我们为了下面好计算最短路径，我们将开始的转弯次数赋值为-1\n  </div>\n  <div>\n   本读者在这里其实对于搜索最短路径其实有一个自己的想法，我们从完成游戏的角度来看的话，完全没必要非求出最短路径，求出可行路径就可以，但是实际上的连连看游戏电脑是可以输出最短路径的，但是如果采用BFS来做的话，我们只要搜索到就可以从队列中出来，不用继续扩展队列了，除非如果用心的方法的话，那么的确有必要（可能更快）求出满足条件的最短路径\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.如何确定死锁：\n  </div>\n  <div>\n   在本问题中，我们通过遍历图中所有的剩余的格子，对美个剩余的格子，在图中查找所有的与之图案相同的格子都进行BFS判断一次，成功就返回非死锁\n  </div>\n  <div>\n   知道所有的空余的格子都被扫描完还是没有发现可行的解，那么就是死锁状态，提前返回失败，游戏结束\n  </div>\n  <div>\n   本人为了加快查找的效率，利用空间换时间，采用装填因子为200%的拉链法，虽然这已经超过了哈希表可以容忍的范围，但是我们不得不说，这样子的查找效率相对于对图的遍历来说，已经将O(n*n)降到O(C)常熟时间，已经是非常大的优化了，当惹按读者有什么更好的方法，欢迎在评论区联系我，骂我哦\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.扩展问题：\n  </h2>\n  <div>\n   本人目前还在研究如何实现这两个扩展问题，但是思路和想法还是有的\n  </div>\n  <div>\n   1.优缺点：\n  </div>\n  <div>\n   我们如果每次都要求出图中任意两点之间的最短路径来求解的话，对于一个高手来说，这要非常的耗时，但是对于一个敌手来说，这要非常的高效\n  </div>\n  <div>\n   2.不会。。。。。\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.代码实现：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1832558\' name=\'code\' snippet_file_name=\'blog_20160816_1_4965860\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define inf 99999999\n#define N 10\n\n//测试用例，40块，每组俩块 \n//1 3 7 4 -1 -1 5 6 3 2\n//5 7 8 -1 -1 -1 -1 6 4 7\n//2 1 -1 -1 -1 -1 -1 -1 0 9\n//6 -1 -1 -1 -1 -1 -1 -1 -1 8\n//-1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n//-1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n//5 -1 -1 -1 -1 -1 -1 -1 -1 1\n//6 9 -1 -1 -1 -1 -1 -1 2 4\n//4 0 0 -1 -1 -1 -1 2 3 8\n//1 3 0 7 -1 -1 8 9 9 5 \n\nusing namespace std;\n\ntypedef struct nod    //伪哈希表的判断成员，每个关键字基本被分配2.5个（涂图有25对的时候），会超过拉链法的120%的要求，但是这已经不是哈希表了，我的优化策略 \n{\n	int x;\n	int y;\n	struct nod* next;\n}node;\n\nclass hash\n{\n	public:\n		hash()\n		{\n			for(int i=0;i&lt;N;i++) book[i].next=NULL;\n		}\n		~hash()   //有指针的存在，防止内存泄漏 \n		{\n			for(int i=0;i&lt;N;i++)\n			{\n				node* p=book[i].next;\n				while(p!=NULL)\n				{\n					book[i].next=book[i].next-&gt;next;\n					free(p);\n					p=book[i].next;\n				}\n			}\n		}\n		node* returnxy(int);    //按照关键字返回下一个同状态的块的坐标信息\n		void push(node,int);    //int代表关键字，node代表位置，根据这两点在设置图的同时将信息加入哈希表\n		void pop(node,int);    //块已经被删除了，该点弹出哈希表 \n		node*&amp; returnnode(int key)\n		{\n			node* p=book[key].next;\n			return p;\n		}\n	private:\n		node book[N];\n};\n\nclass point\n{\n	public:\n		point()\n		{\n			thing=-1;\n			check=death=0;\n			mincross=mindest=inf;   //为了保持最优化转台并且好判断，该两项初始化为无穷大 \n		} \n		void givething(int);   //初始化图的时候和消除的时候的重行分配内容的操作 \n		void choosepoint();    //该点被加入队列，check准备变换,之后的map勒种还要加入全图清楚check标记的函数操作,形参表包含父亲点的坐标，目的是帮助在此函数内修改mincross和mindest成员 \n		void claimdeath();     //该点已经被判断过是思索的状态，这样做是为了方便之后的其他块判断死锁状态时忽略掉改掉，从而加快速度 \n		int returnthing()\n		{\n			return thing;\n		}\n		void initpoint()\n		{\n			check=death=0;\n			mincross=mindest=inf;\n		}\n		void setmincross(int a)\n		{\n			mincross=a;\n		}\n		void setmindest(int a)\n		{\n			mindest=a;\n		}\n		int returnmincross()\n		{\n			return mincross;\n		}\n		int returnmindest()\n		{\n			return mindest;\n		}\n		int returndeath()\n		{\n			return death;\n		}\n		int returncheck()\n		{\n			return check;\n		}\n	private:\n		bool check;   //当前是否被选中，加入队列中\n		int thing;   //该块中的信息,若为-1,代表此点没有块，为空，否则应该在0-9之间的状态 \n		bool death;   //死锁标记\n		int mincross;   //该点被扩展时的转弯次数，该项要被不断的更新为最小的状态\n		int mindest;   //该点被扩展的时候，在mincross的情况下的距离起点的路程 \n};\n\nclass linkup\n{\n	public:\n		linkup()\n		{\n			memset(queue,0,sizeof(queue));\n			head=tail=0;\n			num=0;\n			startx=starty=endx=endy=0;\n			cross=dest=inf;\n		}\n		void initmap();    //每次消除完或者判断连接失败之后之后，我们都要将图中每个点的queue,head,tail,check，death，mincross，mindest，startx等成员全部清空\n		bool bfs(int,int,int,int);    //后两个形参可以变更为判断死锁的时候的查找点，在游戏进行中的时候，代表的是起点和终点 \n		void creatmap();      //遗留问题，怎么实现随机生成图？？？ \n		bool spread(int,int,int,int);   //扩展的父亲点,bfs的附属函数 \n		void print();    //打印全图，以便玩家浏览\n		void listenmotion();    //监听玩家的动作，输入坐标\n		bool giveanswer();     //对于玩家的动作，根据bfs进行相应的处理，并且输出语句告知玩家\n		bool judge();    //判断是否死锁，如果死锁我们告知玩家游戏结束 \n		void stream();    //游戏的流程 \n		void clearjudge()\n		{\n			memset(queue,0,sizeof(queue));\n			head=tail=1;\n		}\n	private:\n		point map[N][N];    //10*10的图，50个空位，25对连接\n		hash hashmap;     //哈希表\n		int num;    //目前剩余的块的数目num/2代表目前剩下的对数 \n		int startx;\n		int starty;\n		int endx;\n		int endy;\n		node queue[N*N];\n		int head;\n		int tail;\n		int cross;    //每次连接完之后的最短路径的数据 \n		int dest;\n};\n\nnode* hash::returnxy(int key)\n{\n	node* p=book[key].next;\n	if(p==NULL) \n	{\n		cout&lt;&lt;\'图存在问题，你可以扇游戏制作者一个巴掌了\'&lt;&lt;endl;\n		return NULL;\n	}\n	else\n	{\n		return p;\n	}\n}\n\nvoid hash::push(node p,int key)\n{\n	node* k=new node;\n	k-&gt;x=p.x;	k-&gt;y=p.y;\n	k-&gt;next=book[key].next;\n	book[key].next=k;\n}\n\nvoid hash::pop(node p,int key)   \n{\n	node* help=&amp;book[key];\n	node* k=book[key].next;\n	while(k!=NULL)\n	{\n		if(k-&gt;x==p.x&amp;&amp;k-&gt;y==p.y) \n		{\n			help-&gt;next=k-&gt;next;\n			free(k);\n			break;\n		}\n		else help=k;\n		k=k-&gt;next;\n	}\n}\n\nvoid point::givething(int key)\n{\n	thing=key;\n}\n\nvoid point::choosepoint()\n{\n	check=1;\n}\n\nvoid point::claimdeath()\n{\n	death=1;\n}\n\nvoid linkup::creatmap()\n{\n	cout&lt;&lt;\'开始输入你的地图(-1代表空地，0-9代表块)\'&lt;&lt;endl;\n	for(int i=0;i&lt;N;i++)\n	{\n		for(int j=0;j&lt;N;j++)\n		{\n			node p;\n			p.x=i;p.y=j;\n			int key;\n			cin&gt;&gt;key;\n			map[i][j].givething(key);\n			hashmap.push(p,key);\n			if(key!=-1) num++;\n		} \n	}\n}\n\nvoid linkup::listenmotion()\n{\n	cout&lt;&lt;\'玩家开始输入必要的信息\'&lt;&lt;endl;\n	cout&lt;&lt;\'起点坐标\';cin&gt;&gt;startx&gt;&gt;starty;\n	cout&lt;&lt;\'终点坐标\';cin&gt;&gt;endx&gt;&gt;endy;\n	cout&lt;&lt;\'你的请求已经受理，即将返回你的选择结果\'&lt;&lt;endl;\n}\n\nbool linkup::bfs(int sx,int sy,int ex,int ey)\n{\n	tail++;\n	map[sx][sy].setmincross(-1);    //定义刚开始的拐弯数是-1，方便后续计算 \n	map[sx][sy].setmindest(0);\n	if(spread(sx,sy,ex,ey)==1) return true;\n	else\n	{\n		int i=1;\n		while(head!=tail&amp;&amp;i&lt;3)   //控制转弯次数 \n		{\n			if(spread(queue[head].x,queue[head].y,ex,ey)) return true;   //BFS找到了，返回true，在giveanswer中进行删除操作 \n			i++;\n		}\n	    return false;\n	}\n}\n\nbool linkup::giveanswer()\n{\n	if(map[startx][starty].returnthing()!=map[endx][endy].returnthing()) return false;\n	else\n	{\n		if(bfs(startx,starty,endx,endy))   //可以连接 \n    	{\n    		node help;\n	    	help.x=startx;help.y=starty;\n			hashmap.pop(help,map[startx][starty].returnthing());\n			help.x=endx;help.y=endy; \n			hashmap.pop(help,map[endx][endy].returnthing());\n			num-=2;    //块消除，数目减少 \n			map[startx][starty].givething(-1);   //消除两个点 \n	    	map[endx][endy].givething(-1);\n			return true;\n    	}\n    	else return false;     //不能连接 \n	}\n}\n\nvoid linkup::initmap()\n{\n	memset(queue,0,sizeof(queue));\n	head=tail=1;\n	for(int i=0;i&lt;N;i++)\n	{\n		for(int j=0;j&lt;N;j++) map[i][j].initpoint();\n	}\n	startx=starty=endx=endy=0;\n	cross=dest=inf;\n}\n\nbool linkup::spread(int x,int y,int ex,int ey)\n{\n	queue[head].x=x;\n	queue[head].y=y;\n	int nextstage=tail-1;\n	map[x][y].choosepoint();\n	while(head&lt;=nextstage)\n	{\n		x=queue[head].x;   //及时更新新的扩展父节点 \n		y=queue[head].y;\n	    for(int i=y+1;i&lt;N;i++)  //向右 \n    	{\n    		if(map[x][i].returncheck()==1&amp;&amp;map[x][i].returnthing()==-1)\n    		{\n    			if(map[x][i].returnmincross()&gt;=map[x][y].returnmincross()+1)\n		    	{\n			    	map[x][i].setmincross(map[x][y].returnmincross()+1);\n		    		map[x][i].setmindest(map[x][y].returnmindest()+i-y);\n    			}\n    			continue;\n    		}\n	    	if(map[x][i].returnthing()==-1) \n&lt;h2&gt;    		{&lt;/h2&gt;	    		if(map[x][i].returnmincross()&gt;=map[x][y].returnmincross()+1)\n		    	{\n			    	map[x][i].setmincross(map[x][y].returnmincross()+1);\n		    		map[x][i].setmindest(map[x][y].returnmindest()+i-y);\n    			}\n	    		map[x][i].choosepoint();\n		     	queue[tail].x=x;\n		    	queue[tail].y=i;\n		 	    tail++;\n	    	}\n	    	else\n	    	{\n		    	if(x==ex&amp;&amp;i==ey)\n		    	{\n		    		cross=map[x][y].returnmincross();    //搜集到最短路径的数据 \n		    		dest=map[x][y].returnmindest()+i-y;\n		    		return true;\n		    	}\n	    		else break;\n	    	}\n    	}\n    	for(int i=y-1;i&gt;=0;i--)    //向左 \n    	{\n    		if(map[x][i].returncheck()==1&amp;&amp;map[x][i].returnthing()==-1)\n    		{\n    			if(map[x][i].returnmincross()&gt;=map[x][y].returnmincross()+1)\n	    		{\n		    		map[x][i].setmincross(map[x][y].returnmincross()+1);\n			    	map[x][i].setmindest(map[x][y].returnmindest()+y-i);\n	    		}\n	    		continue;\n    		}\n	    	if(map[x][i].returnthing()==-1)\n		    {\n    			if(map[x][i].returnmincross()&gt;=map[x][y].returnmincross()+1)\n	    		{\n		    		map[x][i].setmincross(map[x][y].returnmincross()+1);\n			    	map[x][i].setmindest(map[x][y].returnmindest()+y-i);\n	    		}\n		    	map[x][i].choosepoint();\n	    		queue[tail].x=x;\n		    	queue[tail].y=i;\n	    		tail++;\n    		}\n	    	else\n	    	{\n		    	if(x==ex&amp;&amp;i==ey)\n		    	{\n		    		cross=map[x][y].returnmincross();\n		    		dest=map[x][y].returnmindest()+y-i;\n		    		return true;\n		    	}\n	     		else break;\n		    }\n    	}\n    	for(int i=x-1;i&gt;=0;i--)   //向上 \n    	{\n    		if(map[i][y].returncheck()==1&amp;&amp;map[i][y].returnthing()==-1)\n    		{\n    			if(map[i][y].returnmincross()&gt;=map[x][y].returnmincross()+1)\n	    		{\n		    		map[i][y].setmincross(map[x][y].returnmincross()+1);\n			    	map[i][y].setmindest(map[x][y].returnmindest()+x-i);\n		    	}\n		    	continue;\n    		}\n	    	if(map[i][y].returnthing()==-1)\n	    	{\n		    	if(map[i][y].returnmincross()&gt;=map[x][y].returnmincross()+1)\n	    		{\n		    		map[i][y].setmincross(map[x][y].returnmincross()+1);\n			    	map[i][y].setmindest(map[x][y].returnmindest()+x-i);\n		    	}\n	    		map[i][y].choosepoint();\n		    	queue[tail].x=i;\n		     	queue[tail].y=y;\n			    tail++;\n	    	}\n    		else\n	    	{\n		    	if(i==ex&amp;&amp;y==ey)\n		    	{\n		    		cross=map[x][y].returnmincross();\n		    		dest=map[x][y].returnmindest()+x-i;\n		    		return true;\n		    	}\n			    else break;\n    		}\n    	}\n	    for(int i=x+1;i&lt;N;i++)   //向下 \n    	{\n    		if(map[i][y].returncheck()==1&amp;&amp;map[i][y].returnthing()==-1)\n    		{\n    			if(map[i][y].returnmincross()&gt;=map[x][y].returnmincross()+1)\n		    	{\n			    	map[i][y].setmincross(map[x][y].returnmincross()+1);\n		    		map[i][y].setmindest(map[x][y].returnmindest()+i-x);\n	    		}\n	    		continue;\n    		}\n	    	if(map[i][y].returnthing()==-1)\n		    {\n	     		if(map[i][y].returnmincross()&gt;=map[x][y].returnmincross()+1)\n		    	{\n			    	map[i][y].setmincross(map[x][y].returnmincross()+1);\n		    		map[i][y].setmindest(map[x][y].returnmindest()+i-x);\n	    		}\n		    	map[i][y].choosepoint();\n	     		queue[tail].x=i;\n		    	queue[tail].y=y;\n			    tail++;\n	    	} \n    		else\n	    	{\n		    	if(i==ex&amp;&amp;y==ey) \n		    	{\n		    		cross=map[x][y].returnmincross();\n		    		dest=map[x][y].returnmindest()+i-x;\n		    		return true;\n		    	}\n	    		else break;\n    		}\n    	}\n    	head++;\n	}\n	return false;\n}\n\nbool linkup::judge()\n{\n	for(int i=0;i&lt;N;i++)\n	{\n		for(int j=0;j&lt;N;j++)\n		{\n			if(map[i][j].returnthing()!=-1&amp;&amp;map[i][j].returndeath()!=1)\n			{\n				int key=map[i][j].returnthing();\n				node* p=hashmap.returnnode(key);\n				while(p!=NULL)\n				{\n					if(p-&gt;x==i&amp;&amp;p-&gt;y==j) p=p-&gt;next;\n					else if(bfs(i,j,p-&gt;x,p-&gt;y)) return true;\n					else p=p-&gt;next;\n				}\n				clearjudge();\n			}\n			map[i][j].claimdeath();   //判断都不成功，加上死亡标记 \n		}\n	}\n	return false;\n}\n\nvoid linkup::print()\n{\n	printf(\'  \');\n	for(int i=0;i&lt;N;i++) cout&lt;&lt;i&lt;&lt;\' \';   //打印表头\n	cout&lt;&lt;endl;\n	for(int i=0;i&lt;N;i++)\n	{\n		cout&lt;&lt;i&lt;&lt;\' \';    //打印表列 \n		for(int j=0;j&lt;N;j++) \n		{\n			if(map[i][j].returnthing()!=-1) cout&lt;&lt;map[i][j].returnthing()&lt;&lt;\' \';\n			else printf(\'  \'); \n		} \n		cout&lt;&lt;endl;\n	} \n}\n\nvoid linkup::stream()\n{\n	creatmap();\n	print();\n	while(num!=0)\n	{\n		if(judge()==0)\n		{\n			clearjudge();\n			cout&lt;&lt;\'很不幸，地图死锁，游戏失败！\'&lt;&lt;endl;\n			return ;\n		}\n		else\n		{\n			clearjudge();\n			initmap();\n			listenmotion();\n			if(startx&lt;0||startx&gt;=N||starty&lt;0||starty&gt;=N||endx&lt;0||endx&gt;=N||endy&lt;0||endy&gt;=N) \n			{\n				cout&lt;&lt;\'输入的坐标点存在错误，请重新输入\'&lt;&lt;endl;\n				continue;\n			}\n			if(giveanswer()==1) \n			{\n				cout&lt;&lt;\'本次的连接，拐弯次数:\'&lt;&lt;cross+1&lt;&lt;\'路径长度:\'&lt;&lt;dest&lt;&lt;endl;\n				system(\'PAUSE\'); \n				system(\'cls\');\n				print();\n				cout&lt;&lt;\'连接有效，开始删除\'&lt;&lt;endl;\n			}\n			else\n			{\n				system(\'cls\');\n				print();\n				cout&lt;&lt;\'不能连接或者图样不匹配，连接失败！\'&lt;&lt;endl;\n			}\n		}\n	}\n	cout&lt;&lt;\'全部消除，恭喜你游戏成功！\'&lt;&lt;endl;\n	return ;\n}\n\nint main()\n{\n	linkup my;\n	my.stream();\n	return 0;\n}</pre>\n   <h2>\n    4.结语：\n   </h2>\n   <div>\n    Dijstra,DFS，BFS,A*都可以实现，各有优点，BFS是可以搜索出最优的拐弯数下的最优解路径\n   </div>\n   <div>\n    BFS可以较快低损耗的求出可行解，不一定最优\n   </div>\n   <div>\n    A*和Dijstra相对于上面的搜索算法来说，在这种地图下不高效在有些情况的路径下很低效\n   </div>\n   <div>\n    感谢《编程之美》这本书，我对数的扩展问题真的非常的有兴趣，对于我的代码实现的思路和优化，还有扩展问题的解决，如果读者有更好的思路，欢迎在评论区call我，希望和打架一起分享代码和优化思路的乐趣\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('86deed3be67bf11420f7a04c3acf8dcc','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题011——找数\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    题目：输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。要求时间复杂度是O(n)。如果有多对数字的和等于输入的数字，输出任意一对即可。\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    例如输入数组1、2、4、7、11、15 和数字15。由于4+11=15，因此输出4 和11。\n   </span>\n   <br/>\n  </div>\n  <h2>\n   2.解法：\n  </h2>\n  <div>\n   1.首先我们按照升序排序\n  </div>\n  <div>\n   2.添加头尾指针，sum和代表头尾指针对应的元素的和，如果这个和小于我们要找的数，说明头指针小，应该移动头指针，\n  </div>\n  <div>\n   如果和比我们所需要的值大，说明尾指针需要左移，知道我们找到合适的两者之和等于我们要找的数\n  </div>\n  <h2>\n   3.代码：\n  </h2>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1830615\' name=\'code\' snippet_file_name=\'blog_20160815_1_2029171\'>void find(int a[],int num,int pos)\n{\n	int* head=a;\n	int* tail=a+num-1;\n	int sum=*head+*tail;\n	while(head&lt;tail&amp;&amp;sum!=pos)\n	{\n		if(sum&lt;pos) sum=*(++head)+*tail;\n		else if(sum&gt;pos) sum=*head+*(++tail);\n	}\n	cout&lt;&lt;*head&lt;&lt;\'+\'&lt;&lt;*tail&lt;&lt;endl;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('76b2024a08d92b3d4a1d60f386f0fa52','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题010——二叉树节点最大距离\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   求二叉树结点中的最大距离（假设二叉树中节点都可以是双向的）\n  </div>\n  <h2>\n   2.思路：\n  </h2>\n  <div>\n   先援引一段很牛逼的英文：\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     ANSWER:\n     <br/>\n     This is interesting... Also recursively（递归的）, the longest distance between two nodes must be either from root to one leaf, or between two leafs. For the former case, it’s the tree height. For the latter case, it should be the sum of the heights of left and\r\n right subtrees of the two leaves’ most least ancestor.\n     <br/>\n     The first case is also the sum the heights of subtrees, just the height + 0.\n    </span>\n   </span>\n   <br/>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     根据上面的解答，我们会发现，二叉树中节点之间的最大的距离只有三种情况\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     第一种：经过根节点\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     第二种：全在左子树中\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     第三种：全在右子树中\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     <br/>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     所以说我们可以用递归的思路来求解这个问题：\n    </span>\n   </span>\n  </div>\n  <h2>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     3.代码：\n    </span>\n   </span>\n  </h2>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n    </span>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1829058\' name=\'code\' snippet_file_name=\'blog_20160814_1_7868989\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\ntypedef struct node\n{\n	struct node* left;\n	struct node* right;\n	int data;\n}point;\n\nclass tree\n{\n	public:\n		tree()\n		{\n			memset(preorder,0,sizeof(preorder));\n			memset(midorder,0,sizeof(midorder));\n			root=NULL;\n			num=ans=0;\n		}\n		void set()\n		{\n			cout&lt;&lt;\'节点数目\'&lt;&lt;endl;\n			cin&gt;&gt;num;\n			cout&lt;&lt;\'前序遍历\'&lt;&lt;endl;\n			for(int i=0;i&lt;num;i++) cin&gt;&gt;preorder[i];\n			cout&lt;&lt;\'后序遍历\'&lt;&lt;endl;\n			for(int i=0;i&lt;num;i++) cin&gt;&gt;midorder[i];\n		}\n		void prebuild()\n		{\n			root=buildtree(preorder,midorder,num);\n		}\n		point* buildtree(int* pre,int* mid,int i)   //i代表个数，构造函数类似于前序遍历的过程，只不过接住了中序遍历来进行划分 \n		{\n			if(i==0) return NULL;\n			point* k=new point;\n			k-&gt;data=pre[0];\n			k-&gt;left=k-&gt;right=NULL;\n			int* p;\n			int* q;\n			int w=0;\n			for(int i=0;i&lt;num;i++) \n			{\n				if(mid[i]==pre[0])\n				{\n					w=i;\n					break;\n				}\n			}\n			p=pre+1;\n			q=mid;\n			k-&gt;left=buildtree(p,q,w);\n			p=pre+w+1;\n			q=mid+w+1;\n			k-&gt;right=buildtree(p,q,i-w-1);   //w是左子树的个数，1是根节点的个数，i-w-1就是右子树的个数\n			return k; \n		}\n		void maxsituation(point* p,int&amp; k)   //返回目前最大的状态\n		{\n			if(p==NULL) \n			{\n				k=-1;\n			}\n			else\n			{\n				int l,r;\n				maxsituation(p-&gt;left,l);\n				l++;\n				maxsituation(p-&gt;right,r);\n				r++;\n				ans=max(max(ans,l),max(r,l+r));    //更新结果 \n				if(p==root) return ;\n				k=max(l,r);   //利用引用，k代表当前节点伟根的子树可以贡献的最大的长度，这个长度的路径必定果根节点 \n			}\n		}\n		void p()\n		{\n			maxsituation(root,ans);\n			cout&lt;&lt;\'结果是\'&lt;&lt;ans&lt;&lt;endl;\n		}\n		point* returnroot()\n		{\n			return root;\n		} \n		void previsit(point* p)\n		{\n			if(p==NULL) return ;\n			else\n			{\n				cout&lt;&lt;p-&gt;data&lt;&lt;\' \';\n				previsit(p-&gt;left);\n				previsit(p-&gt;right);\n				return ;\n			}\n		}\n	private:\n		int preorder[N];\n		int midorder[N];\n		point* root;\n		int num;\n		int ans;\n};\n\nint main()\n{\n	tree my;\n	my.set();\n	my.prebuild();\n	my.previsit(my.returnroot());\n	my.p();\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'color:rgb(255,0,0)\'>\n     <br/>\n    </span>\n   </span>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9e1799ac27ed59f99b3887e328ce7984','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  编程之美1.2——将帅问题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   学过象棋的朋友一定不会陌生，中国象棋中规定了，将帅不能碰面，也就是说，将帅是不可能出现在相同的一列上的\n  </div>\n  <div>\n   通过二重循环的遍历操作我们可以通过枚举的方法简单的求出将帅所有合适的位置组合，但是，现在的问题是，如何只利用一个字节的存储空间，将将帅所有的合适的位置信息都描述出来\n  </div>\n  <h2>\n   2.解析：（解法1）\n  </h2>\n  <h3>\n   2.1\n  </h3>\n  <div>\n   本问题中，我们的核心问题在于如何利用一个字节来表示不同的位置信息\n  </div>\n  <div>\n   首先我们先要想到，对于将帅的位置信息，我们可以采用如下的排列方式来进行存储的优化\n  </div>\n  <div>\n   1\n   <span style=\'white-space:pre\'>\n   </span>\n   2\n   <span style=\'white-space:pre\'>\n   </span>\n   3\n  </div>\n  <div>\n   4\n   <span style=\'white-space:pre\'>\n   </span>\n   5\n   <span style=\'white-space:pre\'>\n   </span>\n   6\n  </div>\n  <div>\n   7\n   <span style=\'white-space:pre\'>\n   </span>\n   8\n   <span style=\'white-space:pre\'>\n   </span>\n   9\n  </div>\n  <div>\n   将帅的位置都可以这么描述，这样的话，我们只需要一种存储空间就可以表示我们的列信息（我们只要对3取模就可以了）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么现在问题来了，我们如何只用一个字节来完成这个工作呢\n  </div>\n  <h3>\n   2.2\n  </h3>\n  <div>\n   我们需要了解到我们的位置空间只有9种情况，9的二进制只有4位，刚好，一个字节的二进制有8位，那么之歌问题就变得迎刃而解了，我们可以将一个字节的分成左右两半分别存储将和帅的位置信息，取模之后如果出现了相同，说明在一列，这种情况continue就好，然后输出所有的情况就好了\n  </div>\n  <h3>\n   2.3\n  </h3>\n  <div>\n   该算法的核心在于位运算和定义宏：\n  </div>\n  <div>\n   首先我们讲解一下本问题中我们需要涉及到的位运算有哪些：（位运算之后的内容我会再开一篇博客全面讲解）\n  </div>\n  <div>\n   1.\n   <strong>\n    &amp;：按位与操作：\n   </strong>\n  </div>\n  <div>\n   按位与操作的内容是两个数字的二进制对应位比较，同为1则为1，否则为0\n  </div>\n  <div>\n   2.\n   <strong>\n    |：按位或操作：（操作完返回的内容必须要接收，因为是二元运算符）\n   </strong>\n  </div>\n  <div>\n   按位或操作的内容是两个数字的二进制对应位比较，存在1则为1，否则为0\n  </div>\n  <div>\n   3.\n   <strong>\n    &gt;&gt;/&lt;&lt;:右移和左移操作：（操作完返回的是本身，是一元运算符）\n   </strong>\n  </div>\n  <div>\n   按位右移和左移操作的内容是我们将数字对应的二进制整体向右或者向左移动，空位用0补齐\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   下面我们讲解必要的定义宏的操作：\n  </div>\n  <div>\n   我们定义宏的时候，相当于我们将定义的部分在代码中全部强制替换掉，所以说可能会带来由县级的问题，这里我们加上括号可以很好的解决\n  </div>\n  <h3>\n   2.4代码实现：（对必要的步骤有详细的讲解）\n  </h3>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1828966\' name=\'code\' snippet_file_name=\'blog_20160814_1_4676494\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\n//开始定义运算宏    n&lt;=9 n只会用到四个存储单元，就是半个字节 \n#define halfbitlength 4   //一个bit单元长度，我们一次用一半 \n#define fullmask 255   //11111111八个1\n#define lmask (fullmask&lt;&lt;halfbitlength)   //左移半个字节，左边当做一个存储单元，结果为11110000\n#define rmask (fullmask&gt;&gt;halfbitlength)   //右移半个字节，右边当做一个存储单元，结果为00001111\n#define rset(b,n) (b=((b &amp; lmask) | (n)))   //将b的右边半个字节设置成n   （b&amp;lmask的作用是将右边半个字节先全部置空，再用或运算复制） \n#define lset(b,n) (b=((b &amp; rmask) | (n&lt;&lt;halfbitlength)))   //思路同上\n#define lget(b) (b&gt;&gt; halfbitlength)\n#define rget(b) (rmask &amp; b)\n\nusing namespace std;\n\nunsigned char b;\n\nint main()\n{\n	for(lset(b,1);lget(b)&lt;=9;lset(b,(lget(b)+1)))\n	{\n		for(rset(b,1);rget(b)&lt;=9;rset(b,(rget(b)+1)))\n		{\n			if(lget(b)%3==rget(b)%3) continue;\n			else printf(\'A=%d,B=%d\n\',lget(b),rget(b));\n		}\n	}\n	return 0;\n}</pre>\n   <br/>\n   <h2>\n    3.解法：（本人觉得最神奇的代码，优化二重循环）\n   </h2>\n  </div>\n  <div>\n   在这里我们先援引一位大神的讲解：\n   <a href=\'http://blog.csdn.net/kabini/article/details/2256421\' target=\'_blank\'>\n    博客专家对解法2的讲解\n   </a>\n  </div>\n  <div>\n   在这里，我们优化的核心就是一段代码：\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     var=(var/9)*9+var%9\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n    <strong>\n     没错，上面的就是我们的优化的核心\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      我们先附上代码：\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n     </strong>\n    </span>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1828966\' name=\'code\' snippet_file_name=\'blog_20160814_2_5265138\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nunsigned char i=81;\n\nint main()\n{\n	while(i--)\n	{\r\n                if(i/9%3==i%9%3) continue;\n		else printf(\'A=%d,B=%d\n\',i/9+1,i%9+1);\n	}\n	return 0;\n}</pre>\n   <br/>\n   在这里我们可能会看不懂这么一句话：if(i/9%3==i%9%3)  continue;\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      在这里就隐含着我们对多重循环的处理的一个超级神奇的优化操作\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      i=81的由来是9*9有81种将帅站位方式（我们以后再做相同的处理优化的时候，这相当于是所有的情况的总数目）\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      然后，i/9相当于是外层循环，i%9相当于是内层循环\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      因为我们已经知道了上面的一个公式：var=(var/9)*9+var%9;当然这里的9可以随意的替换，我们懂原理就好\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      这里我们巧妙的利用了i/9在没有9的进位下的时候值是不变的，但是i%9是相对会改变的，这样子我们就将一个二重循环巧妙的抓化成一个一重循环，虽然复杂度没有优化，但是我们还是可以看出一些精妙之处的\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      <br/>\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      对于解法三我们进行一下拓展：利用钢材的原理性质，来做几道枚举的小题目\n      <br/>\n     </strong>\n    </span>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1828966\' name=\'code\' snippet_file_name=\'blog_20160814_3_106925\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cmath\'\n\n//求x^2+y^2=2000的正整数解\n//45*45&gt;2000,所以说按照之前的\n \nusing namespace std;\n\nint main()\n{\n	int i=45*45;    //情况总数\n	while(i--)\n	{\n		if(pow(i/45,2)+pow(i%45,2)==2000) \n		{\n			printf(\'%d^2+%d^2==2000\n\',i/45,i%45); \n			break;\n		}\n	} \n	return 0;\n}</pre>\n   <br/>\n   对于2*3*4的三重循环来说，我们可以这么来分类看待循环过程：\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      <span style=\'white-space:pre\'>\n      </span>\n      i/2\n      <span style=\'white-space:pre\'>\n      </span>\n      |||\n      <span style=\'white-space:pre\'>\n      </span>\n      i%2(最后一层只有2种情况的循环)\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      <span style=\'white-space:pre\'>\n      </span>\n      i/2/3\n      <span style=\'white-space:pre\'>\n      </span>\n      i/2%3(第二层循环)\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      <span style=\'white-space:pre\'>\n      </span>\n      i/2/3/4\n      <span style=\'white-space:pre\'>\n      </span>\n      i/2/3%4(第三重循环)\n     </strong>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:14px; line-height:26px\'>\n     <strong>\n      <br/>\n     </strong>\n    </span>\n   </span>\n  </div>\n  <h2>\n   4.总结：\n  </h2>\n  <div>\n   编程世界如此广阔，此刻不再停留\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ed4ad348267d41a0ea1114bc7cce4f81','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题009——按词反转句子\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    翻转句子中单词的顺序。\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    例如输入“I am a student.”，则输出“student. a am I”。\n   </span>\n   <br/>\n  </div>\n  <h2>\n   2.解法：\n  </h2>\n  <div>\n   <strong>\n    栈\n   </strong>\n  </div>\n  <div>\n   我们先将句子的内容保存下来，然后开辟一个栈，以单词为单位不断的pop出，这是最好考虑也是最噶小的做法了：\n  </div>\n  <div>\n   附上代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1828630\' name=\'code\' snippet_file_name=\'blog_20160813_1_4978063\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\nclass sentence\n{\n	public:\n		sentence()\n		{\n			memset(juzi,0,sizeof(juzi));\n			memset(result,0,sizeof(result));\n			num=numr=0;\n		}\n		void set()\n		{\n			printf(\'请输入:\n\');\n			for(int i=0;;i++)\n			{\n				scanf(\'%c\',&amp;juzi[i]);\n				if(juzi[i]==\'.\') \n				{\n					num=i-1;\n					break;\n				}\n			}\n			getchar();\n		}\n		void pop()\n		{\n			int i;\n			while(num&gt;=0)\n			{\n				int k=num;\n				for(i=num;i&gt;=0;i--) if(juzi[i]==\' \') break;\n		    	for(int j=i+1;j&lt;=k;numr++,j++,num--) result[numr]=juzi[j];\n		    	for(int j=i;juzi[j]==\' \';j--,numr++,num--) result[numr]=juzi[j];  //连续空格复制的操作 \n			}\n		}\n		void print()\n		{\n			for(int i=0;i&lt;strlen(result);i++) printf(\'%c\',result[i]);\n			cout&lt;&lt;\'.\'&lt;&lt;endl;\n		}\n	private:\n		char juzi[N];\n		char result[N];\n		int num;  //兼具了栈的top成员的任务 \n		int numr;\n};\n\nint main()\n{\n	sentence my;\n	my.set();\n	my.print();\n	my.pop();\n	my.print();\n	return 0;\n} </pre>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9f635156d0c03560d40bed1799360db1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题008——后序遍历找BST\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述：\n  </h2>\n  <div>\n   通过我们给出的一个后序遍历结果，找出一颗二叉树满足要求，找到了，返回true，没找到返回false\n  </div>\n  <h2>\n   2.解法：\n  </h2>\n  <div>\n   又是一道BST 性质和后序遍历结合的题：\n  </div>\n  <div>\n   首先BST我们就不过多赘语了：\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52081538\' target=\'_blank\'>\n    BST总结\n   </a>\n  </div>\n  <div>\n   我们这道题主要考的使我们的后序遍历的性质：\n  </div>\n  <div>\n   我们对一个给出的后序遍历可以这么来理解：\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们把后序遍历先拆开两块：\n  </div>\n  <div>\n   后序遍历的划分特点\n  </div>\n  <div>\n   A\n   <span style=\'white-space:pre\'>\n   </span>\n   |B\n   <span style=\'white-space:pre\'>\n   </span>\n   |C      (A是左子树序列，B是右子树序列，C是根节点)\n  </div>\n  <div>\n   每个A,B都可以继续进行上述拆分知道我们拆到单独的节点元素为止\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   好了，这道题我们需要的知识点已经具备齐了，剩下的我们需要的就是理解一下综合BST和后序遍历的特征了\n  </div>\n  <div>\n   我们可以发现，如果BST的性质中是这么说的，左子树所有的节点都比根节点小，右子树的节点都比根节点大，那么我们可以很敏锐的通过递归的性质来看出，一旦我们将后序遍历按照我们上述讲解后序遍历的划分特点的话，那么我们只要判断左子树有没有比根节点大的，有就返回false，否则继续判断，知道我们找不到任何反例的话就返回true\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   不想网上的其他人写的那样，我们没必要根据后序遍历构建BST，再后序遍历来判断\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.C++代码封装：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1828479\' name=\'code\' snippet_file_name=\'blog_20160813_1_5111695\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass findBST\n{\n	public:\n		findBST()\n		{\n			memset(aftorder,0,sizeof(aftorder));\n			num=0; \n		} \n		void prejudge()\n		{\n			if(judge(1,num)) cout&lt;&lt;\'存在满足条件的BST\'&lt;&lt;endl;\n			else cout&lt;&lt;\'不存在满足条件的BST\'&lt;&lt;endl; \n		}\n		bool judge(int left,int right)    //递归的核心代码段，包含有后序遍历的意味在里面 \n		{\n			if(left&gt;=right) return true;   //如果我们都扫到唯一一个节点的时候，还满足BST 的性质，只能说明，这个后序遍历满足BST的数的性质 \n			int mid;\n			for(mid=left;mid&lt;right;mid++) if(aftorder[mid]&gt;aftorder[right]) break;   //查找mid分割点，查找第一个比根节点大的元素 \n			for(int i=mid+1;i&lt;right;i++) if(aftorder[i]&lt;aftorder[right]) return false;   //开始判断 \n			if(judge(left,mid-1)) return true;\n			if(judge(mid,right)) return true;\n			return false;\n		}\n		void set()\n		{\n			cout&lt;&lt;\'后序遍历的长度\'&lt;&lt;endl;\n			cin&gt;&gt;num;\n			cout&lt;&lt;\'请输入后序遍历的顺序\'&lt;&lt;endl;\n			for(int i=1;i&lt;=num;i++) cin&gt;&gt;aftorder[i];\n		} \n	private:\n		T aftorder[N];\n		int num;\n};\n\nint main()\n{\n	findBST&lt;int&gt; my;\n	my.set();\n	my.prejudge();\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>');
INSERT INTO `page` VALUES ('51b356c8e1a782955a6df64f5b10b21d','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  KMP next数组优化的思路彻底解析\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   首先我们假设各位都已经了解了next数组的作用，在这里我们的next数组记录的是该位置之前的子模式串的最长公共前后缀\n  </p>\n  <p>\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52190750\' target=\'_blank\'>\n    非常浅显易懂的KMP算法讲解\n   </a>\n   <br/>\n  </p>\n  <p>\n   那么我们优化的思路就来了：\n  </p>\n  <p>\n   这点优化的思路在于假设模式串中q号位置失配了，那么我们下一次要跳转到next[q-1]号位置进行匹配，但是如果pattern[q]==pattern[next[q-1]]的话，那么我们这一次的匹配还是失败的，我们需要继续我们的next迭代过程，知道找到开始匹配的为止\n  </p>\n  <p>\n   那么我们为什么不能再next数组的求解过程中就提前优化好呢，这一点就是优化的思路，我们既然还有再次调用next数组，还不如让next[q]=next[next[q-1]],这就是优化的思路\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   但是我们可以很明显的发现，在我们的KMP函数中，我们的语句\n   <strong>\n    while(j&gt;0&amp;&amp;pattern[i]!=pattern[j]) j=next[j-1]\n   </strong>\n   ;我们突然发现这句话的思路和KMP的next数组上述优化的思路是一致的，但是我们会发现，如果我们提前将next数组的优化确定下来的话，我们对于这种多次的迭代（被优化的部分）的过程只用进行一次，下一次就是常数时间的O(1)时间的调用，但是如果我们不对next数组进行优化，而只是决定依靠我们KMP函数中的那句话来进行我们的迭代过程，我们碰见一次就要迭代一次，原本我们可以一次求出直接用的方式就变成每次用都要求一遍，这样子的话，KMP\r\n 的速度就会大大降低，所以说，我们决定直接对next数组进行优化，反而还节省了大量的时间，并且我们在这样优化next数组的过程中时间复杂度并没有上升，时间复杂度是没有变的，所以说，但是不优化，频繁调用迭代的next会使我们的复杂度大幅度上升\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   作为实例，下面是我封装的代码，在代码中还有更详细的解释:\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1827852\' name=\'code\' snippet_file_name=\'blog_20160813_1_3955514\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class kmp;\ntemplate&lt;typename T&gt; istream&amp; operator&gt;&gt;(istream&amp;,kmp&lt;T&gt;&amp;);\ntemplate&lt;typename T&gt; ostream&amp; operator&lt;&lt;(ostream&amp;,kmp&lt;T&gt;&amp;);\n\ntemplate&lt;typename T&gt;\nclass kmp\n{\n	public:\n		kmp()\n		{\n			memset(next,0,sizeof(next));\n			memset(pattern,0,sizeof(pattern));\n			memset(mother,0,sizeof(mother));\n			num=plength=mlength=fpos=0;\n		} \n		friend istream&amp; operator&gt;&gt;&lt;&gt;(istream&amp;,kmp&lt;T&gt;&amp;);\n		friend ostream&amp; operator&lt;&lt;&lt;&gt;(ostream&amp;,kmp&lt;T&gt;&amp;);\n		void getnextone();   //未优化的\n		void getnexttwo();   //优化过的 \n		void find();\n	private:\n		T pattern[N];\n		int plength; \n		T mother[N];\n		int mlength;\n		int next[N];\n		int fpos;\n};\n\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp; in,kmp&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'请输入母串的长度\'&lt;&lt;endl;\n	cin&gt;&gt;k.mlength;\n	cout&lt;&lt;\'请输入母串\'&lt;&lt;endl;\n	for(int i=0;i&lt;k.mlength;i++) cin&gt;&gt;k.mother[i];\n	\n	cout&lt;&lt;\'请输入模式串的长度\'&lt;&lt;endl;\n	cin&gt;&gt;k.plength;\n	cout&lt;&lt;\'请输入模式串\'&lt;&lt;endl;\n	for(int i=0;i&lt;k.plength;i++) cin&gt;&gt;k.pattern[i];\n	return in;\n}\n\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; out,kmp&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'next数组的内容如下，以供查错\'&lt;&lt;endl;\n	for(int i=0;i&lt;k.plength;i++) cout&lt;&lt;k.next[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl; \n	cout&lt;&lt;\'母串中包含的传的个数是\'&lt;&lt;k.num&lt;&lt;endl;\n    cout&lt;&lt;\'第一次出现模式串的位置是\'&lt;&lt;k.fpos&lt;&lt;endl;\n	return out;\n}\n\ntemplate&lt;typename T&gt;\nvoid kmp&lt;T&gt;::getnextone()\n{\n	//next[0]=0,因为0号位置没有前缀和后缀 \n	int k=0;   //目前最长公共前后缀的长度\n	int q=1;   //q记录目前扫描的的位置 \n	for(;q&lt;plength;q++)   //永远记住，k代表的是长度，实际上的区间位置是0--k-1适合和额前缀 \n	{\n		while(k&gt;0&amp;&amp;pattern[k]!=pattern[q]) k=next[k-1];   //算法中描述的部分 \n		if(pattern[k]==pattern[q]) k++;    //再次匹配，我们扩充最长公共前后缀 \n		next[q]=k; \n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid kmp&lt;T&gt;::getnexttwo()\n{\n	int k=0;\n	int q=1;\n	for(;q&lt;plength;q++)\n	{\n		while(k&gt;0&amp;&amp;pattern[q]!=pattern[k]) k=next[k];\n		if(pattern[k]==pattern[q]) k++;    //再次匹配，我们扩充最长公共前后缀 \n		if(pattern[q]==pattern[next[q-1]]) next[q]=next[next[q-1]];   //优化的原理，当第q位置失配的时候，我们会跳转到next[q-1]来判断，如果pattern[q]==pattern[next[q-1]],书名这两个字符是一样的，前者失配了，后者必然也失配，所以说我们就直接再进一步，，实际上，如果不优化，我们在跳转到pattern[next[q-1]]的时候还是要在进行next的迭代一次操作，所以说next数组还不如初始就优化一下 \n		else next[q]=k;\n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid kmp&lt;T&gt;::find()\n{\n	int i=0;\n	int j=0;\n	getnexttwo();\n	for(;i&lt;mlength;i++)\n	{\n		while(j&gt;0&amp;&amp;pattern[j]!=mother[i]) j=next[j-1];    //其实这一句话和next数组的优化思路是一致的 \n		if(pattern[j]==mother[i]) j++;\n		if(j==plength)\n		{\n			fpos=i-plength+1;   //j-fpos+1=k.plength\n			cout&lt;&lt;\'我们找到了匹配的模式串，第一次出现的位置在\'&lt;&lt;fpos&lt;&lt;endl; \n			return ;\n		}\n	}\n	cout&lt;&lt;\'母串中不存在匹配的模式串\'&lt;&lt;endl;\n	return ;\n}\n\nint main()\n{\n	kmp&lt;int&gt; my;\n	cin&gt;&gt;my;\n	my.find();\n	cout&lt;&lt;my;\n	return 0;\n} </pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('33b713d1b03f8bafdcfed16ad6f695d8','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  KMP算法总结（纯算法，为优化，没有学应用）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1 style=\'margin:0px 0px 5px; font-family:\'Helvetica Neue\',Helvetica,Tahoma,Arial,STXihei,\'Microsoft YaHei\',微软雅黑,sans-serif; font-weight:normal; line-height:1.5em; color:rgb(51,51,51); font-size:24px\'>\n   先引入大神通俗易懂的博客内容\n  </h1>\n  <div class=\'article_body\' id=\'nei\' style=\'padding:20px 5px 25px; margin-bottom:0px; overflow-x:hidden; word-wrap:break-word; word-break:break-all; min-height:340px; font-size:16px; line-height:1.7em; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Tahoma,Arial,STXihei,\'Microsoft YaHei\',微软雅黑,sans-serif\'>\n   <div style=\'line-height:1.7em\'>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      KMP\n     </span>\n     算法，俗称“看毛片”算法，是字符串匹配中的很强大的一个算法，不过，对于初学者来说，要弄懂它确实不易。整个寒假，因为家里没有网，为了理解这个算法，那可是花了九牛二虎之力！不过，现在我基本上对这个算法理解算是比较透彻了！特写此文与大家分享分享！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     我个人总结了，\n     <span lang=\'EN-US\'>\n      KMP\n     </span>\n     算法之所以难懂，很大一部分原因是很多实现的方法在一些细节的差异。怎么说呢，举我寒假学习的例子吧，我是看了一种方法后，似懂非懂，然后去看另外的方法，就全都乱了！体现在几个方面：\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组，有的叫做“失配函数”，其实是一个东西；\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组中，有的是以下标为\n     <span lang=\'EN-US\'>\n      0\n     </span>\n     开始的，有的是以\n     <span lang=\'EN-US\'>\n      1\n     </span>\n     开始的；\n     <span lang=\'EN-US\'>\n      KMP\n     </span>\n     主算法中，当发生失配时，取的\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的值也不一样！就这样，各说各的，乱的很！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     所以，在阐述我的理解之前，我有必要说明一下，我是用\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的，\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组是以下标\n     <span lang=\'EN-US\'>\n      0\n     </span>\n     开始的！还有，我不会在一些基础的概念上浪费太多，所以你在看这篇文章时必须要懂得一些基本的概念，例如\n     <span lang=\'EN-US\'>\n      “\n     </span>\n     朴素字符串匹配\n     <span lang=\'EN-US\'>\n      ”“\n     </span>\n     前缀\n     <span lang=\'EN-US\'>\n      ”\n     </span>\n     ，\n     <span lang=\'EN-US\'>\n      “\n     </span>\n     后缀\n     <span lang=\'EN-US\'>\n      ”\n     </span>\n     等！还有就是，这篇文章的每一个字都是我辛辛苦苦码出来的，图也是我自己画的！如果要转载，请注明出处！好了，开始吧！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     假设在我们的匹配过程中出现了这一种情况：\n     <span lang=\'EN-US\'>\n      <img alt=\'\' src=\'http://img0.tuicool.com/qymeyu.jpg!web\' style=\'max-width:96%; height:auto; vertical-align:middle; border:0px none; margin:0px auto; text-align:center; display:block\'/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     根据\n     <span lang=\'EN-US\'>\n      KMP\n     </span>\n     算法，在该失配位会调用该位的\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的值！在这里有必要来说一下\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的作用！说的太繁琐怕你听不懂，让我用一句话来说明：\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span style=\'text-indent:0px\'>\n      返回失配位之前的最长公共前后缀！\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span style=\'text-indent:0px\'>\n      什么是最长公共前后缀：\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span style=\'text-indent:0px\'>\n      <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050114.png\'/>\n      <br/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     好，不管你懂不懂这句话，我下面的文字和图应该会让你懂这句话的意思以及作用的！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     首先，我们取之前已经匹配的部分（即蓝色的那部分！）\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      <img alt=\'\' src=\'http://img0.tuicool.com/3IvIJj.jpg!web\' style=\'max-width:96%; height:auto; vertical-align:middle; border:0px none; margin:0px auto; text-align:center; display:block\'/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     我们在上面说到\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的作用时，说到\n     <span lang=\'EN-US\'>\n      “\n     </span>\n     最长公共前后缀\n     <span lang=\'EN-US\'>\n      ”\n     </span>\n     ，体现到图中就是这个样子！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      <img alt=\'\' src=\'http://img2.tuicool.com/qqaMfaQ.jpg!web\' style=\'max-width:96%; height:auto; vertical-align:middle; border:0px none; margin:0px auto; text-align:center; display:block\'/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     接下来，就是最重要的了！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      <img alt=\'\' src=\'http://img2.tuicool.com/yMzAzi.jpg!web\' style=\'max-width:96%; height:auto; vertical-align:middle; border:0px none; margin:0px auto; text-align:center; display:block\'/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     没错，这个就是\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的作用了\n     <span lang=\'EN-US\'>\n      :\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     返回当前的最长公共前后缀长度，假设为\n     <span lang=\'EN-US\'>\n      len\n     </span>\n     。因为数组是由\n     <span lang=\'EN-US\'>\n      0\n     </span>\n     开始的，所以\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组让第\n     <span lang=\'EN-US\'>\n      len\n     </span>\n     位与主串匹配就是拿最长前缀之后的第\n     <span lang=\'EN-US\'>\n      1\n     </span>\n     位与失配位重新匹配，避免匹配串从头开始！如下图所示！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      <img alt=\'\' src=\'http://img0.tuicool.com/6BJFZz.jpg!web\' style=\'max-width:96%; height:auto; vertical-align:middle; border:0px none; margin:0px auto; text-align:center; display:block\'/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     （重新匹配刚才的失配位！）\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     如果都说成这样你都不明白，那么你真的得重新理解什么是\n     <span lang=\'EN-US\'>\n      KMP\n     </span>\n     算法了！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     接下来最重要的，也是\n     <span lang=\'EN-US\'>\n      KMP\n     </span>\n     算法的核心所在，就是\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的求解！不过，在这里我找到了一个全新的理解方法！如果你懂的上面我写的的，那么下面的内容你只需稍微思考一下就行了！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     跟刚才一样，我用一句话来阐述一下\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的求解方法，其实也就是两个字：\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     继承\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      a\n     </span>\n     、当前面字符的前一个字符的对称程度为\n     <span lang=\'EN-US\'>\n      0\n     </span>\n     的时候，只要将当前字符与子串第一个字符进行比较。这个很好理解啊，前面都是\n     <span lang=\'EN-US\'>\n      0\n     </span>\n     ，说明都不对称了，如果多加了一个字符，要对称的话最多是当前的和第一个对称。比如\n     <span lang=\'EN-US\'>\n      agcta\n     </span>\n     这个里面\n     <span lang=\'EN-US\'>\n      t\n     </span>\n     的是\n     <span lang=\'EN-US\'>\n      0\n     </span>\n     ，那么后面的\n     <span lang=\'EN-US\'>\n      a\n     </span>\n     的对称程度只需要看它是不是等于第一个字符\n     <span lang=\'EN-US\'>\n      a\n     </span>\n     了。\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      b\n     </span>\n     、按照这个推理，我们就可以总结一个规律，不仅前面是\n     <span lang=\'EN-US\'>\n      0\n     </span>\n     呀，如果前面一个字符的\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     值是\n     <span lang=\'EN-US\'>\n      1\n     </span>\n     ，那么我们就把当前字符与子串第二个字符进行比较，因为前面的是\n     <span lang=\'EN-US\'>\n      1\n     </span>\n     ，说明前面的字符已经和第一个相等了，如果这个又与第二个相等了，说明对称程度就是\n     <span lang=\'EN-US\'>\n      2\n     </span>\n     了。有两个字符对称了。比如上面\n     <span lang=\'EN-US\'>\n      agctag\n     </span>\n     ，倒数第二个\n     <span lang=\'EN-US\'>\n      a\n     </span>\n     的\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     是\n     <span lang=\'EN-US\'>\n      1\n     </span>\n     ，说明它和第一个\n     <span lang=\'EN-US\'>\n      a\n     </span>\n     对称了，接着我们就把最后一个\n     <span lang=\'EN-US\'>\n      g\n     </span>\n     与第二个\n     <span lang=\'EN-US\'>\n      g\n     </span>\n     比较，又相等，自然对称成都就累加了，就是\n     <span lang=\'EN-US\'>\n      2\n     </span>\n     了。\n     <span lang=\'EN-US\'>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      c\n     </span>\n     、按照上面的推理，如果一直相等，就一直累加，可以一直推啊，推到这里应该一点难度都没有吧，如果你觉得有难度说明我写的太失败了。\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     当然不可能会那么顺利让我们一直对称下去，如果遇到下一个不相等了，那么说明不能继承前面的对称性了，这种情况只能说明没有那么多对称了，但是不能说明一点对称性都没有，所以遇到这种情况就要重新来考虑，这个也是难点所在。\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      <img alt=\'\' src=\'http://img1.tuicool.com/umuea2.jpg!web\' style=\'max-width:96%; height:auto; vertical-align:middle; border:0px none; margin:0px auto; text-align:center; display:block\'/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     如果蓝色的部分相同，则当前\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     数组的值为上一个\n     <span lang=\'EN-US\'>\n      next\n     </span>\n     的值加一，如果不相同，就是我们下面要说的！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     如果不相同，用一句话来说，就是：\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span style=\'text-indent:0px\'>\n      从前面来找子前后缀\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      1\n     </span>\n     、如果要存在对称性，那么对称程度肯定比前面这个的对称程度小，所以要找个更小的对称，这个不用解释了吧，如果大那么就继承前面的对称性了。\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span style=\'text-indent:0px\'>\n      <span lang=\'EN-US\'>\n       2\n      </span>\n      、要找更小的对称，必然在对称内部还存在子对称，而且这个必须紧接着在子对称之后。\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     如果看不懂，那么看一下图吧！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <span lang=\'EN-US\'>\n      <img alt=\'\' src=\'http://img1.tuicool.com/zEVzm2.jpg!web\' style=\'max-width:96%; height:auto; vertical-align:middle; border:0px none; margin:0px auto; text-align:center; display:block\'/>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     好了，我已经把该说的尽可能以最浅显的话和最直接的图展示出来了，如果还是不懂，那我真的没有办法了！\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     <br/>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     针对KMP算法我在添加一下我自己人为非常重要的认识\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     1.KMP的核心在于移位代替回溯，我们通过查找出最长的公共前后缀，从而确定了可以最大效率简化我们的时间复杂度的移位的最大长度\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     先附图在附代码（求next数组的）解释：\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n    </p>\n    <pre class=\'cpp\' code_snippet_id=\'1827672\' name=\'code\' snippet_file_name=\'blog_20160813_1_7243560\'>void makeNext(const char P[],int next[])\n{\n    int q,k;//q:模版字符串下标；k:最大前后缀长度\n    int m = strlen(P);//模版字符串长度\n    next[0] = 0;//模版字符串的第一个字符的最大前后缀长度为0\n    for (q = 1,k = 0; q &lt; m; ++q)//for循环，从第二个字符开始，依次计算每一个字符对应的next值\n    {\n        while(k &gt; 0 &amp;&amp; P[q] != P[k])//递归的求出P[0]···P[q]的最大的相同的前后缀长度k\n            k = next[k-1];          //不理解没关系看下面的分析，这个while循环是整段代码的精髓所在，确实不好理解  \n        if (P[q] == P[k])//如果相等，那么最大相同前后缀长度加1\n        {\n            k++;\n        }\n        next[q] = k;\n    }\n}</pre>\n    <br/>\n    <br/>\n    <p>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     下面我们再来讲解一下利用next数组的KMP算法部分：\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n     先上代码：\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:0.75em; line-height:1.7em; text-indent:1em\'>\n    </p>\n    <pre class=\'cpp\' code_snippet_id=\'1827672\' name=\'code\' snippet_file_name=\'blog_20160813_2_5880357\'>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nvoid makeNext(const char P[],int next[])\n{\n    int q,k;\n    int m = strlen(P);\n    next[0] = 0;\n    for (q = 1,k = 0; q &lt; m; ++q)\n    {\n        while(k &gt; 0 &amp;&amp; P[q] != P[k])\n            k = next[k-1];\n        if (P[q] == P[k])\n        {\n            k++;\n        }\n        next[q] = k;\n    }\n}\n\nint kmp(const char T[],const char P[],int next[])\n{\n    int n,m;\n    int i,q;\n    n = strlen(T);\n    m = strlen(P);\n    makeNext(P,next);\n    for (i = 0,q = 0; i &lt; n; ++i)\n    {\n        while(q &gt; 0 &amp;&amp; P[q] != T[i])    //这里我们采取的是移动模式串的策略，可能看不出来，这需要我们画图来看\n            q = next[q-1];\n        if (P[q] == T[i])\n        {\n            q++;\n        }\n        if (q == m)\n        {\n            printf(\'Pattern occurs with shift:%d\n\',(i-m+1));\n        }\n    }    \n}\n\nint main()\n{\n    int i;\n    int next[20]={0};\n    char T[] = \'ababxbababcadfdsss\';\n    char P[] = \'abcdabd\';\n    printf(\'%s\n\',T);\n    printf(\'%s\n\',P );\n    // makeNext(P,next);\n    kmp(T,P,next);\n    for (i = 0; i &lt; strlen(P); ++i)\n    {\n        printf(\'%d \',next[i]);\n    }\n    printf(\'\n\');\n\n    return 0;\n}</pre>\n    <img alt=\'\' src=\'http://a1.qpic.cn/psb?/V145d4wY2ao7bg/s1tJiyxy4wkG93RtVjyKHmkW67RBx.QspbY.1PA3Jrw!/c/dKgAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=gAJxBAAAAAAFANQ!&amp;sce=60-2-2&amp;rf=0-0\'/>\n    <br/>\n    <br/>\n    <p>\n     以上就是我对KMP算法核心的了解\n    </p>\n    <p>\n     附上自己封装的KMP算法的代码如下：\n    </p>\n    <p>\n    </p>\n    <pre class=\'cpp\' code_snippet_id=\'1827672\' name=\'code\' snippet_file_name=\'blog_20160813_3_722144\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class kmp;\ntemplate&lt;typename T&gt; istream&amp; operator&gt;&gt;(istream&amp;,kmp&lt;T&gt;&amp;);\ntemplate&lt;typename T&gt; ostream&amp; operator&lt;&lt;(ostream&amp;,kmp&lt;T&gt;&amp;);\n\ntemplate&lt;typename T&gt;\nclass kmp\n{\n	public:\n		kmp()\n		{\n			memset(next,0,sizeof(next));\n			memset(pattern,0,sizeof(pattern));\n			memset(mother,0,sizeof(mother));\n			num=plength=mlength=fpos=0;\n		} \n		friend istream&amp; operator&gt;&gt;&lt;&gt;(istream&amp;,kmp&lt;T&gt;&amp;);\n		friend ostream&amp; operator&lt;&lt;&lt;&gt;(ostream&amp;,kmp&lt;T&gt;&amp;);\n		void getnextone();   //未优化的\n		void find();\n		void count();\n	private:\n		T pattern[N];\n		int plength; \n		T mother[N];\n		int mlength;\n		int next[N];\n		int num;   //母串中包含的个数 \n		int fpos;\n};\n\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp; in,kmp&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'请输入母串的长度\'&lt;&lt;endl;\n	cin&gt;&gt;k.mlength;\n	cout&lt;&lt;\'请输入母串\'&lt;&lt;endl;\n	for(int i=0;i&lt;k.mlength;i++) cin&gt;&gt;k.mother[i];\n	\n	cout&lt;&lt;\'请输入模式串的长度\'&lt;&lt;endl;\n	cin&gt;&gt;k.plength;\n	cout&lt;&lt;\'请输入模式串\'&lt;&lt;endl;\n	for(int i=0;i&lt;k.plength;i++) cin&gt;&gt;k.pattern[i];\n	return in;\n}\n\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; out,kmp&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'next数组的内容如下，以供查错\'&lt;&lt;endl;\n	for(int i=0;i&lt;k.plength;i++) cout&lt;&lt;k.next[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl; \n	cout&lt;&lt;\'母串中包含的传的个数是\'&lt;&lt;k.num&lt;&lt;endl;\n    cout&lt;&lt;\'第一次出现模式串的位置是\'&lt;&lt;k.fpos&lt;&lt;endl;\n	return out;\n}\n\ntemplate&lt;typename T&gt;\nvoid kmp&lt;T&gt;::getnextone()\n{\n	//next[0]=0,因为0号位置没有前缀和后缀 \n	int k=0;   //目前最长公共前后缀的长度\n	int q=1;   //q记录目前扫描的的位置 \n	for(;q&lt;plength;q++)   //永远记住，k代表的是长度，实际上的区间位置是0--k-1适合和额前缀 \n	{\n		while(k&gt;0&amp;&amp;pattern[k]!=pattern[q]) k=next[k-1];   //算法中描述的部分 \n		if(pattern[k]==pattern[q]) k++;    //再次匹配，我们扩充最长公共前后缀 \n		next[q]=k; \n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid kmp&lt;T&gt;::find()\n{\n	int i=0;\n	int j=0;\n	getnexttwo();\n	for(;i&lt;mlength;i++)\n	{\n		while(j&gt;0&amp;&amp;pattern[j]!=mother[i]) j=next[j-1];\n		if(pattern[j]==mother[i]) j++;\n		if(j==plength)\n		{\n			fpos=i-plength+1;   //j-fpos+1=k.plength\n			cout&lt;&lt;\'我们找到了匹配的模式串，第一次出现的位置在\'&lt;&lt;fpos&lt;&lt;endl; \n			return ;\n		}\n	}\n	cout&lt;&lt;\'母串中不存在匹配的模式串\'&lt;&lt;endl;\n	return ;\n}\n\nint main()\n{\n	kmp&lt;int&gt; my;\n	cin&gt;&gt;my;\n	my.find();\n	cout&lt;&lt;my;\n	return 0;\n} </pre>\n    <br/>\n    <br/>\n   </div>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('5b211a42b5d9a02fa7ff7f5d9c90f6e3','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  全排列生成算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.什么是全排列：\n  </h2>\n  <div>\n   我们假如有一串式子，排列组合的结果会有很多种，全排列就是按照字典序有序的将所有的排列组合的性质的陈列出来\n  </div>\n  <div>\n   问题可以这么描述：\n  </div>\n  <div>\n   <span style=\'color:rgb(51,51,51); font-family:KaiTi_GB2312; font-size:16px; line-height:26px\'>\n    对于给定的集合A{a1,a2,...,an},其中的n个元素互不相同，如何输出这n个元素的所有排列（全排列）\n   </span>\n   <br/>\n  </div>\n  <h2>\n   2.求解算法：\n  </h2>\n  <h3>\n   1.DFS(我们大多数人所谓的递归的方法)：\n  </h3>\n  <div>\n   我们来这么看这个问题，加入有n个数据要进行全排列，我们可以假想我们面前有n个盒子\n  </div>\n  <div>\n   每一次我们有大小顺序的依次将我们手头还空余的数放进盒子中，当我们手头已经空的时候，我们就已经生成了一种全排列\n  </div>\n  <div>\n   这个时候我们采用深搜（回溯法）的思想，我们收起我们刚才放入盒子的元素，然后放进去下一个恰好（一定要是恰好，中间不可以在空余出满足条件的元素）比他大的元素，然后继续这个过程，当我们所有的情况都结束之后，那么我们的全排列也就生成完毕了\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://hi.csdn.net/attachment/201112/15/0_1323938241foiZ.gif\'/>\n   <br/>\n  </div>\n  <div>\n   DFS代码如下\n   <span style=\'font-size:12px\'>\n    ：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1824629\' name=\'code\' snippet_file_name=\'blog_20160811_1_4617579\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\n//假设问题是求出1-5的全排列\nint a[6]; \nbool book[6];   //用来复制记录哪些我们已经用过了 \n\nvoid dfs(int n)   //n代表目前该操作哪个盒子 \n{\n	if(n==6)\n	{\n		for(int i=1;i&lt;=5;i++) cout&lt;&lt;a[i]&lt;&lt;\' \';\n		cout&lt;&lt;endl;\n		return ;\n	}\n	else\n	{\n		for(int i=1;i&lt;=5;i++)\n		{\n			if(book[i]==0)\n			{\n				a[n]=i;\n				book[i]=1;\n				dfs(n+1);\n				book[i]=0;\n			}\n		}\n	}\n}\n\nint main()\n{\n	memset(a,0,sizeof(a));\n	memset(book,0,sizeof(book));\n	dfs(1); \n	return 0;\n}</pre>\n   <br/>\n   <h3>\n    <span style=\'font-size:12px\'>\n     2.字典序算法：\n    </span>\n   </h3>\n  </div>\n  <div>\n   字典序算法很高效但是证明非常的麻烦\n  </div>\n  <div>\n   首先我们来看算法的步骤，我会一一讲解：\n  </div>\n  <div>\n   <ul style=\'color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\'>\n    <li>\n     <span style=\'font-family:KaiTi_GB2312; font-size:16px\'>\n      对于排列a[1...n]，找到所有满足a[k]&lt;a[k+1](0&lt;k&lt;n-1)的k的最大值，如果这样的k不存在，则说明当前排列已经是a的所有排列中字典序最大者，所有排列输出完毕。\n     </span>\n    </li>\n    <li>\n     <span style=\'font-family:KaiTi_GB2312; font-size:16px\'>\n      在a[k+1...n]中，寻找满足这样条件的元素l，使得在所有a[l]&gt;a[k]的元素中，a[l]取得最小值。也就是说a[l]&gt;a[k]，但是小于所有其他大于a[k]的元素。\n     </span>\n    </li>\n    <li>\n     <span style=\'font-family:KaiTi_GB2312; font-size:16px\'>\n      交换a[l]与a[k].\n     </span>\n    </li>\n    <li>\n     <span style=\'font-family:KaiTi_GB2312; font-size:16px\'>\n      对于a[k+1...n]，反转该区间内元素的顺序。也就是说a[k+1]与a[n]交换，a[k+2]与a[n-1]交换，……，这样就得到了a[1...n]在字典序中的下一个排列。\n     </span>\n    </li>\n   </ul>\n   <br/>\n  </div>\n  <div>\n   大神的解释（有几句话很有用）：\n  </div>\n  <div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <strong>\n      算法步骤1，\n     </strong>\n     得到的子串 s = {pj+1,.....,pn}， 是按照从大到小进行排列的。即有 pj+1 &gt; pj+2 &gt; ... &gt; pn， 因为\n     <span style=\'line-height:24px\'>\n      j=max{i|pi&lt;pi+1}。\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      <strong>\n       算法步骤2\n      </strong>\n      ，得到了最小的比pj大的pk，从n往j数，第一个比j大的数字。将pk和pj替换，保证了替换后的数字比当前的数字要大。\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      于是得到的序列为p1p2...pj-1\n      <span style=\'color:rgb(255,0,0)\'>\n       pk\n      </span>\n      pj+1...pk-1\n      <span style=\'color:rgb(255,0,0)\'>\n       pj\n      </span>\n      pk-1...pn.\n     </span>\n     <span style=\'line-height:24px\'>\n      注意这里已经将pk替换成了pk。\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'line-height:24px\'>\n     <span style=\'font-family:SimSun; font-size:16px\'>\n      这时候我们注意到比p1..pj-1pk.....，恰好比p1....pj.....pn大的数字集合。我们在这个集合中挑选出最小的一个即时所要求的下一个排列。\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      <strong>\n       算法步骤3\n      </strong>\n      ，即是将pk后面的数字逆转一下（\n      <strong>\n       从从大到小，变成了从小到大\n      </strong>\n      。）\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      由此经过上面3个步骤得到的下个排列时恰好比当前排列大的排列。\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      同时我们注意到，\n      <strong>\n       当所有排列都找完时，此时数字串从大到小排列\n      </strong>\n      。步骤1得到的j = 0，算法结束。\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      <strong>\n       上面的原理还是看不懂的，请看这里，这里对算法的本质有进一步的阐述：\n      </strong>\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      这里我假如我自己的一些认识：\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      1.这里的操作步骤我们可以明显的发现一点，找到的j号元素之后的序列完全都是从大到小的（这一点非常重要，这也是为什么我们一会还要进行反转的原因）\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      2.这里我们发现交换的时候都是找最次小来进行交换\n      <strong>\n       本人开始存在疑问，那么能不能简化算法的步骤，直接选择j序列最后的元素来交换？（求教大神，还是说我这里理解有一些错误）我会用代码验证，验证完毕，这是错误的，详情请见下面的代码片\n      </strong>\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      3.这里的交换的目的很明显是为了尽可能保证最小的改变，来尽可能选择到该排列的下一个排列，反转的目的和前面相同，也是为了保证最次小的性质\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      <br/>\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n      代码1（完全按照算法的要求来进行）：\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n     </span>\n    </span>\n    <pre class=\'cpp\' code_snippet_id=\'1824629\' name=\'code\' snippet_file_name=\'blog_20160811_2_1903146\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define inf 99999999\n\nusing namespace std;\n\nint a[6];\nint j=0;    //算法中描述的j \nint k=0;    //算法中描述的相对最次小于j号位置元素的k号位置 \n\nvoid print()\n{\n	for(int i=1;i&lt;=5;i++) cout&lt;&lt;a[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl;\n}\n\nbool findj()\n{\n	for(int i=5;i&gt;=2;i--)   //从后开始遍历，查找满足条件的最大的j号位置 \n	{\n		if(a[i-1]&lt;a[i])   //锁定j号位置 \n		{\n			j=i-1;\n			return 1;\n		}\n	} \n	return 0;    //找不到对应的j的位置，说明全排列已经全部输出 \n}\n\nvoid findk()\n{\n	int min=inf;\n	for(int i=j+1;i&lt;=5;i++)\n	{\n		if(a[i]&lt;min&amp;&amp;a[i]&gt;a[j])    //这一句很关键，知道我们findk的目的就好 \n		{\n			min=a[i];\n			k=i;\n		}\n	} \n} \n\nvoid swap(int x,int y)\n{\n	int t=a[x];\n	a[x]=a[y];\n	a[y]=t;\n}\n\nvoid change()\n{\n	int a=j+1;\n	int b=5;\n	while(a&lt;b)\n	{\n		swap(a,b);\n		a++;\n		b--;\n	}\n}\n\nint main()\n{\n	for(int i=1;i&lt;=5;i++) a[i]=i;\n	print();   //初始先输出一次\n	while(1)\n	{\n		if(findj())\n		{\n			findk();\n			swap(j,k);\n			change();\n			print();\n		}\n		else break;\n	}\n	return 0;\n}</pre>\n    代码2（k直接选取j最后一个元素，验证一下）：实际上错了\n   </div>\n   <div>\n    <span style=\'font-family:SimSun\'>\n     <span style=\'font-size:16px; line-height:24px\'>\n      我们在调试的时候会发现，当状态为2 3 1的时候，k应该是2，不是3\n     </span>\n    </span>\n   </div>\n   <div>\n    <span style=\'font-family:SimSun\'>\n     <span style=\'font-size:16px; line-height:24px\'>\n      这里我没有仔细的理解算法中k的限定，k位置的元素是恰好比j号元素要大，但是虽然j后元素都是递减有序的，但是最后一个元素未必比j号元素大，但是我们可以这么小优化一下，因为j后序列是有序的，我们可以从后往前遍历来找k号节点（和找j是一样的）\n     </span>\n    </span>\n   </div>\n   <div style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:SimSun; font-size:16px\'>\n     <span style=\'line-height:24px\'>\n     </span>\n    </span>\n    <pre class=\'cpp\' code_snippet_id=\'1824629\' name=\'code\' snippet_file_name=\'blog_20160811_3_5425157\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define inf 99999999\n\nusing namespace std;\n\nint a[6];\nint j=0;    //算法中描述的j \nint k=0;    //算法中描述的相对最次小于j号位置元素的k号位置 \n\nvoid print()\n{\n	for(int i=1;i&lt;=3;i++) cout&lt;&lt;a[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl;\n}\n\nbool findj()\n{\n	for(int i=3;i&gt;=2;i--)   //从后开始遍历，查找满足条件的最大的j号位置 \n	{\n		if(a[i-1]&lt;a[i])   //锁定j号位置 \n		{\n			j=i-1;\n			return 1;\n		}\n	} \n	return 0;    //找不到对应的j的位置，说明全排列已经全部输出 \n}\n\nvoid swap(int x,int y)\n{\n	int t=a[x];\n	a[x]=a[y];\n	a[y]=t;\n}\n\nvoid change()\n{\n	int a=j+1;\n	int b=3;\n	while(a&lt;b)\n	{\n		swap(a,b);\n		a++;\n		b--;\n	}\n}\n\nint main()\n{\n	for(int i=1;i&lt;=5;i++) a[i]=i;\n	print();   //初始先输出一次\n	while(1)\n	{\n		if(findj())\n		{\n			k=3;\n			swap(j,k);\n			change();\n			print();\n		}\n		else break;\n	}\n	return 0;\n}</pre>\n    <br/>\n    <br/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('11b99820a144e000e0d0fd44392d1de8','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  UESTC 1252 24点问题  DFS\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   <div class=\'col-md-12\' style=\'position:relative; min-height:1px; padding-right:15px; padding-left:15px; float:left; width:1143px; color:rgb(51,51,51); font-family:\'Open Sans\',\'Helvetica Neue\',Helvetica,Helvetica,Arial,sans-serif; font-size:14px; line-height:20px; margin-top:20px\'>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     <span class=\'MathJax\' id=\'MathJax-Element-401-Frame\' style=\'display:inline-table; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2531\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.301em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <br/>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       24\n      </span>\n     </span>\n     点就是给你一串数字，问你是否通过加减乘除括号构成\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-402-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2534\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.301em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <br/>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       24\n      </span>\n     </span>\n     点。\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     沈爷觉得这个很好玩，就决定考考你，给你\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-403-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2537\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.652em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.49em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2538\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2539\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            4\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       4\n      </span>\n     </span>\n     个数，可以交换位置，可以用加减乘除和括号，是否能构成\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-404-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2540\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.301em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2541\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2542\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            24\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       24\n      </span>\n     </span>\n     点呢？\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     注意哦~这里的除法并不是整数除法，比如样例\n    </p>\n   </div>\n   <div class=\'col-md-12\' style=\'position:relative; min-height:1px; padding-right:15px; padding-left:15px; float:left; width:1143px; color:rgb(51,51,51); font-family:\'Open Sans\',\'Helvetica Neue\',Helvetica,Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\'>\n    <h2 style=\'line-height:1.1; color:inherit; margin-top:20px; margin-bottom:10px; font-size:30px\'>\n     Input\n    </h2>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     第一行\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-405-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2543\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.031em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.76em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2544\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mi\' id=\'MathJax-Span-2545\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n            T\n            <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; overflow:hidden; height:1px; width:0.111em\'>\n            </span>\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       T\n      </span>\n     </span>\n     ，表示有多少组测试数据，\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-406-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2546\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:6.388em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:4.819em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2547\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2548\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            1\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2549\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            ≤\n           </span>\n           <span class=\'mi\' id=\'MathJax-Span-2550\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n            T\n            <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; overflow:hidden; height:1px; width:0.111em\'>\n            </span>\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2551\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            ≤\n           </span>\n           <span class=\'mn\' id=\'MathJax-Span-2552\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            50\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.282em; overflow:hidden; width:0px; height:1.218em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       1≤T≤50\n      </span>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     接下来\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-407-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2553\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.031em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.76em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2554\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mi\' id=\'MathJax-Span-2555\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n            T\n            <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; overflow:hidden; height:1px; width:0.111em\'>\n            </span>\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       T\n      </span>\n     </span>\n     行，每行\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-408-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2556\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.652em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.49em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2557\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2558\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            4\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       4\n      </span>\n     </span>\n     个正整数\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-409-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2559\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.356em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.031em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2560\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'msubsup\' id=\'MathJax-Span-2561\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n            <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px\'>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-4.002em; left:0.003em\'>\n              <span class=\'mi\' id=\'MathJax-Span-2562\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n               a\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-3.839em; left:0.544em\'>\n              <span class=\'mn\' id=\'MathJax-Span-2563\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-size:13.0654px; font-family:MathJax_Main\'>\n               1\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n            </span>\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.282em; overflow:hidden; width:0px; height:0.932em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       a1\n      </span>\n     </span>\n     ,\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-410-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2564\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.356em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.031em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2565\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'msubsup\' id=\'MathJax-Span-2566\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n            <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px\'>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-4.002em; left:0.003em\'>\n              <span class=\'mi\' id=\'MathJax-Span-2567\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n               a\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-3.839em; left:0.544em\'>\n              <span class=\'mn\' id=\'MathJax-Span-2568\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-size:13.0654px; font-family:MathJax_Main\'>\n               2\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n            </span>\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.282em; overflow:hidden; width:0px; height:0.932em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       a2\n      </span>\n     </span>\n     ,\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-411-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2569\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.356em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.031em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2570\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'msubsup\' id=\'MathJax-Span-2571\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n            <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px\'>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-4.002em; left:0.003em\'>\n              <span class=\'mi\' id=\'MathJax-Span-2572\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n               a\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-3.839em; left:0.544em\'>\n              <span class=\'mn\' id=\'MathJax-Span-2573\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-size:13.0654px; font-family:MathJax_Main\'>\n               3\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n            </span>\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.282em; overflow:hidden; width:0px; height:0.932em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       a3\n      </span>\n     </span>\n     ,\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-412-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2574\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.356em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.031em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2575\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'msubsup\' id=\'MathJax-Span-2576\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n            <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px\'>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-4.002em; left:0.003em\'>\n              <span class=\'mi\' id=\'MathJax-Span-2577\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n               a\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-3.839em; left:0.544em\'>\n              <span class=\'mn\' id=\'MathJax-Span-2578\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-size:13.0654px; font-family:MathJax_Main\'>\n               4\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n            </span>\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.282em; overflow:hidden; width:0px; height:0.932em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       a4\n      </span>\n     </span>\n     ，表示每个数都是多少，\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-413-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2579\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:6.604em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:4.981em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2580\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2581\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            1\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2582\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            ≤\n           </span>\n           <span class=\'msubsup\' id=\'MathJax-Span-2583\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px\'>\n            <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.869em; height:0px\'>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-4.002em; left:0.003em\'>\n              <span class=\'mi\' id=\'MathJax-Span-2584\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Math-italic\'>\n               a\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n             <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-3.839em; left:0.544em\'>\n              <span class=\'mi\' id=\'MathJax-Span-2585\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-size:13.0654px; font-family:MathJax_Math-italic\'>\n               i\n              </span>\n              <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:4.007em\'>\n              </span>\n             </span>\n            </span>\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2586\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            ≤\n           </span>\n           <span class=\'mn\' id=\'MathJax-Span-2587\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            13\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.282em; overflow:hidden; width:0px; height:1.218em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       1≤ai≤13\n      </span>\n     </span>\n    </p>\n   </div>\n   <div class=\'col-md-12\' style=\'position:relative; min-height:1px; padding-right:15px; padding-left:15px; float:left; width:1143px; color:rgb(51,51,51); font-family:\'Open Sans\',\'Helvetica Neue\',Helvetica,Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\'>\n    <h2 style=\'line-height:1.1; color:inherit; margin-top:20px; margin-bottom:10px; font-size:30px\'>\n     Output\n    </h2>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     对于每一次询问，如果能够凑成\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-414-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2588\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:1.301em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.977em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2589\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2590\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            24\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       24\n      </span>\n     </span>\n     点，输出\n     <code style=\'font-family:\'Source Code Pro\',Monaco,Menlo,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n      yes\n     </code>\n     ，否则输出\n     <code style=\'font-family:\'Source Code Pro\',Monaco,Menlo,Consolas,\'Courier New\',monospace; font-size:12.6px; padding:2px 4px; color:rgb(199,37,78); background-color:rgb(249,242,244)\'>\n      no\n     </code>\n    </p>\n   </div>\n   <div class=\'col-md-12\' style=\'position:relative; min-height:1px; padding-right:15px; padding-left:15px; float:left; width:1143px; color:rgb(51,51,51); font-family:\'Open Sans\',\'Helvetica Neue\',Helvetica,Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\'>\n    <h2 style=\'line-height:1.1; color:inherit; margin-top:20px; margin-bottom:10px; font-size:30px\'>\n     Sample input and output\n    </h2>\n    <table class=\'table table-bordered \' style=\'border-spacing:0px; border-collapse:collapse; width:1113px; max-width:100%; margin-bottom:20px; border:1px solid rgb(221,221,221); background-color:transparent\'>\n     <thead style=\'\'>\n      <tr style=\'\'>\n       <th style=\'padding:8px; line-height:1.42857; vertical-align:bottom; border-width:0px 1px 2px; border-bottom-style:solid; border-bottom-color:rgb(221,221,221); border-right-style:solid; border-left-style:solid; border-right-color:rgb(221,221,221); border-left-color:rgb(221,221,221); width:556px\'>\n        Sample Input\n       </th>\n       <th style=\'padding:8px; line-height:1.42857; vertical-align:bottom; border-width:0px 1px 2px; border-bottom-style:solid; border-bottom-color:rgb(221,221,221); border-right-style:solid; border-left-style:solid; border-right-color:rgb(221,221,221); border-left-color:rgb(221,221,221); width:556px\'>\n        Sample Output\n       </th>\n      </tr>\n     </thead>\n     <tbody style=\'\'>\n      <tr class=\'ng-scope\' style=\'\'>\n       <td style=\'padding:8px; line-height:1.42857; vertical-align:top; border:1px solid rgb(221,221,221)\'>\n        <pre class=\'sample ng-binding\' style=\'overflow:auto; font-family:\'Source Code Pro\',Monaco,Menlo,Consolas,\'Courier New\',monospace; font-size:13px; padding:0px; margin-top:0px; margin-bottom:0px; line-height:1.42857; color:rgb(51,51,51); word-break:break-all; word-wrap:break-word; border:0px; white-space:pre-wrap; background-color:transparent\'>2\n3 3 8 8\n1 1 1 1</pre>\n       </td>\n       <td style=\'padding:8px; line-height:1.42857; vertical-align:top; border:1px solid rgb(221,221,221)\'>\n        <pre class=\'sample ng-binding\' style=\'overflow:auto; font-family:\'Source Code Pro\',Monaco,Menlo,Consolas,\'Courier New\',monospace; font-size:13px; padding:0px; margin-top:0px; margin-bottom:0px; line-height:1.42857; color:rgb(51,51,51); word-break:break-all; word-wrap:break-word; border:0px; white-space:pre-wrap; background-color:transparent\'>yes\nno</pre>\n       </td>\n      </tr>\n     </tbody>\n    </table>\n   </div>\n   <div class=\'col-md-12\' style=\'position:relative; min-height:1px; padding-right:15px; padding-left:15px; float:left; width:1143px; color:rgb(51,51,51); font-family:\'Open Sans\',\'Helvetica Neue\',Helvetica,Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\'>\n    <h2 style=\'line-height:1.1; color:inherit; margin-top:20px; margin-bottom:10px; font-size:30px\'>\n     Hint\n    </h2>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-415-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2591\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.652em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.49em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2592\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2593\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            3\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       3\n      </span>\n     </span>\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-416-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2594\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.652em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.49em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2595\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2596\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            3\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       3\n      </span>\n     </span>\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-417-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2597\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.652em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.49em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2598\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2599\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            8\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       8\n      </span>\n     </span>\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-418-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2600\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.652em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0.49em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2601\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2602\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            8\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.068em; overflow:hidden; width:0px; height:1.075em\'>\n        </span>\n       </span>\n      </nobr>\n      <span class=\'MJX_Assistive_MathML\' style=\'\'>\n       8\n      </span>\n     </span>\n    </p>\n    <p style=\'margin-top:0px; margin-bottom:10px\'>\n     就可以构造出\n     <span class=\'MathJax_Preview\' style=\'color:inherit\'>\n     </span>\n     <span class=\'MathJax\' id=\'MathJax-Element-419-Frame\' style=\'display:inline; line-height:normal; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; padding:0px; margin:0px; position:relative\' tabindex=\'0\'>\n      <nobr style=\'border:0px; padding:0px; margin:0px; max-width:none; max-height:none; min-width:0px; min-height:0px; vertical-align:0px\'>\n       <span class=\'math\' id=\'MathJax-Span-2603\' style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:10.609em\'>\n        <span style=\'display:inline-block; position:relative; border:0px; padding:0px; margin:0px; vertical-align:0px; width:8.011em; height:0px; font-size:18.48px\'>\n         <span style=\'position:absolute; border:0px; padding:0px; margin:0px; vertical-align:0px; top:-2.27em; left:0.003em\'>\n          <span class=\'mrow\' id=\'MathJax-Span-2604\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px\'>\n           <span class=\'mn\' id=\'MathJax-Span-2605\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            8\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2606\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.219em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            ÷\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2607\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.219em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            (\n           </span>\n           <span class=\'mn\' id=\'MathJax-Span-2608\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            3\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2609\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            –\n           </span>\n           <span class=\'mn\' id=\'MathJax-Span-2610\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.165em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            8\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2611\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.219em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            ÷\n           </span>\n           <span class=\'mn\' id=\'MathJax-Span-2612\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.219em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            3\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2613\' style=\'display:inline; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            )\n           </span>\n           <span class=\'mo\' id=\'MathJax-Span-2614\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            =\n           </span>\n           <span class=\'mn\' id=\'MathJax-Span-2615\' style=\'display:inline; position:static; border:0px; padding:0px 0px 0px 0.273em; margin:0px; vertical-align:0px; font-family:MathJax_Main\'>\n            24\n           </span>\n          </span>\n          <span style=\'display:inline-block; position:static; border:0px; padding:0px; margin:0px; vertical-align:0px; width:0px; height:2.275em\'>\n          </span>\n         </span>\n        </span>\n        <span style=\'display:inline-block; position:static; border-width:0px; border-left-style:solid; border-color:initial; padding:0px; margin:0px; vertical-align:-0.425em; overflow:hidden; width:0px; height:1.432em\'>\n        </span>\n       </span>\n      </nobr>\n     </span>\n    </p>\n    <h2 style=\'margin-top:0px; margin-bottom:10px\'>\n     2.算法思路：\n    </h2>\n    <div>\n     我们对于这种题采用暴力搜索就好，本体采用深度优先搜索（DFS）\n    </div>\n    <div>\n     深搜的思路是这样的：\n    </div>\n    <div>\n     我们采用排列组合的方式，这样想选出来的两个数先进性计算（这个过程相当于我们的加括号限制优先级）\n    </div>\n    <div>\n     然后知道我们的所有数据数变成1，那就是答案，再用答案与24进行比较，因为我们是一步一步计算的，不会有人脑的对分数进行花间的功能，所以说，因为\n    </div>\n    <div>\n     除法的存在，我们会先出现小数的情况，对于这种情况，我们最后只要限制小数点点二位数就好，这里面对于题来说，我们限制为1e-2就可以了\n    </div>\n    <h2>\n     3.AC代码：\n    </h2>\n    <div>\n     <pre class=\'cpp\' code_snippet_id=\'1824415\' name=\'code\' snippet_file_name=\'blog_20160811_1_3953849\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cmath\'\n\nusing namespace std;\n\ndouble a[10];\n\nbool dfs(int n)\n{\n	if(n==1)\n	{\n		if(fabs(a[0]-24)&lt;1e-2) return true;\n		else return false;\n	}\n	else\n	{\n		for(int i=0;i&lt;n;i++)\n		{\n			for(int j=i+1;j&lt;n;j++)\n			{\n				double x=a[i];\n				double y=a[j];\n				a[j]=a[n-1];\n				a[i]=x+y;if(dfs(n-1)) return true;\n				a[i]=x-y;if(dfs(n-1)) return true;\n				a[i]=y-x;if(dfs(n-1)) return true;\n				a[i]=x*y;if(dfs(n-1)) return true;\n				if(x!=0) a[i]=y/x;\n				if(dfs(n-1)) return true;\n				if(y!=0) a[i]=x/y;\n				if(dfs(n-1)) return true;\n				a[i]=x;\n				a[j]=y;\n			}\n		}\n		return false;\n	}\n}\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		for(int i=0;i&lt;4;i++) cin&gt;&gt;a[i];\n		if(dfs(4)) cout&lt;&lt;\'yes\'&lt;&lt;endl;\n		else cout&lt;&lt;\'no\'&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n     <br/>\n     <br/>\n    </div>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('bce198b43aa2a32dd1435313b3b201fe','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题007——链表相交\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述：\n  </h2>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。为了简化问题，我们假设俩个链表均不带环。\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    问题扩展：\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    1.如何判断链表存在环\n   </span>\n   <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    2.如果需要求出俩个链表相交的第一个节点列?\n   </span>\n   <br/>\n  </div>\n  <h2>\n   2.求解：\n  </h2>\n  <div>\n   1.如何判断链表带环\n  </div>\n  <div>\n   我们加入两个指针，一个快指针，一个慢指针，快指针一次前进2个单位，慢指针一次前进一个单位\n  </div>\n  <div>\n   如果不存在环的话快指针会先扫描到NULL\n  </div>\n  <div>\n   如果存在环的话，快指针总是会和慢指针相遇（有的人可能会疑惑会不会刚好错过，仔细想一下会发现，没有入环之前两者距离不断增加1，如幻之后两者距离不断缩短1，必然会相遇）\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1822564\' name=\'code\' snippet_file_name=\'blog_20160811_1_983371\'>bool move(point* slow,point* fast)\n{\n	while(fast!=NULL&amp;&amp;fast!=slow)\n	{\n		slow=slow-&gt;next;\n		fast=fast-&gt;next;\n		if(fast!=NULL) fast=fast-&gt;NULL;   //这一句一定要小心 \n		else break;\n	}\n	if(fast==NULL) return 0;\n	else return 1;\n}</pre>\n   <br/>\n   2.如何快速判断环的入口点：\n  </div>\n  <div>\n   数学表达式计算：\n  </div>\n  <div>\n   L——链表的长度\n  </div>\n  <div>\n   A——链表头到环入口的距离\n  </div>\n  <div>\n   S——环入口到快慢指针相遇处距离\n  </div>\n  <div>\n   R——环长(R=L-A)\n  </div>\n  <div>\n   L-A-S——相遇处到环入口的距离\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   设慢指针走了K步，快指针走了2*K步\n  </div>\n  <div>\n   显然：K=nR\n  </div>\n  <div>\n   A+S=K=nR=（n-1）R+R=(n-1)R+L-A\n  </div>\n  <div>\n   A=(L-A-S)+(n-1)R\n  </div>\n  <div>\n   根据上面的共识我们会发现，只要我们在链表的开头和相遇点之处再假设同步的指针，分别向后移动，可定会在环入口点相遇\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1822564\' name=\'code\' snippet_file_name=\'blog_20160811_2_873904\'>point* find(point* head,point* meet)    //已经确认有环 \n{\n	while(head!=meet)\n	{\n		head=head-&gt;next;\n		meet=meet-&gt;next;\n	}\n	return head;\n}</pre>\n   <div>\n    <br/>\n   </div>\n   3.判断是否链表相交（相交后，之后的节点都是重合的）\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20131103005400734\'/>\n  </div>\n  <div>\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.最老的方法：O(n*n)选定一个节点之后我们去遍历另一个节点，每一次都遍历一遍，复杂度太高\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.将其中一个链表首尾相交，便利另一个链表如果可以扫描到已经相交的链表的头的话，说明相交，否则不相交\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   3.着第一个相交点：计算两个链表的长度差，指针弥补长度差，同时开始同步移动\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   4.hash法：\n  </div>\n  <div>\n   通过遍历一条链表，将内存地址哈希化，然后扫面另一个俩表寻找就可以了（目前还真不会哈希化内存地址）\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/zhoudaxia/article/details/8884402\' target=\'_blank\'>\n    http://blog.csdn.net/zhoudaxia/article/details/8884402\n   </a>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.遗留重要问题：\n  </h2>\n  <div>\n   我们怎么做才可以把内存地址当作关键字自己设定哈希函数来哈希化，求教\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('665796d41a4ff88b954c53044da5ecde','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  哈希表全解（简介+构造+冲突处理+查找分析计算+诸多要点）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   <span style=\'font-size:12px\'>\n    整理网上大牛和课本教材，争取为所有想要初学散列表的少年们打造一篇绝对看得懂，看完就懂的知识型博客，也算是顺便当作我的复习材料吧\n   </span>\n  </h1>\n  <h1>\n   1.哈希表（散列表）简介：\n  </h1>\n  <div>\n   <span style=\'font-size:12px\'>\n    我们都知道在查找领域有三种主要的查找方式，线性表查找，树形查找（类似BST），还有一种就是我们这次要提及的散列表查找，首先我们来解释一下为什么散列表又叫哈希表（可呢个是因为哈希的意思是杂糅吧），这个其实不是重点\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   先说内容吧：\n  </div>\n  <div>\n   1.哈希函数\n  </div>\n  <div>\n   2.哈希表\n  </div>\n  <div>\n   3.数据记录\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们一条一条来分析：\n  </div>\n  <div>\n   <strong>\n    其实说实话，哈希表查找就相当于我们的函数，对于每一个输入的键值，唯一映射一个存储地址，地址终究存放着我们的数据\n   </strong>\n  </div>\n  <div>\n   这么一说可能会让我们更好理解一点\n  </div>\n  <div>\n   下面我们就开始讲解诸多术语了：（之后可能还会有更多术语，我们在江街道的时候会再次引出，这里现在没有必要全部都说出来）\n  </div>\n  <div>\n   1）哈希函数是一个映射，因此我们的核心就是设计完美的哈希函数尽量减少冲突（下面就会讲解，现在没必要懂），只要是的任意关键字经过哈希函数的处理之后获得的哈希函数值都落在表长允许的范围内就好\n  </div>\n  <div>\n   2）哈希函数：对任意的键值返回出相应的唯一的内存地址一共我们对数据的插入删除和存储\n  </div>\n  <div>\n   3）冲突：就像函数中会出现周期函数一样，我们完全也是就对会碰见的一种情况就是，针对不同的关键字我们可能会获得相同的内存地址，这就是冲突，相应的这两个关键字我们也称作同义词\n  </div>\n  <div>\n   4）哈希表：哈希表就是根据我们设定的哈希函数和我们设定的解决冲突的方法将一组关键字映射到一个连续的地址集（区间）上，并以关键字在地址中的像作为记录在表中的存储位置，这就叫做哈希表，这一映射过程我们也叫做建立哈希表或者散列，我们得到的存储位置叫做哈希地址或者散列地址\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   综上我们会发现哈希表的两个核心了：\n  </div>\n  <div>\n   1.建立哈希（构建哈希函数）根据哈希函数，建立映射\n  </div>\n  <div>\n   2.处理冲突：我们很难设计出完全没有冲突的哈希函数，所以我恶魔你对冲突的处理是非常有必要的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    我们首先需要明确，哈希表这种方法是典型的空间换时间的做法\n   </strong>\n  </div>\n  <h1>\n   2哈希函数：\n  </h1>\n  <div>\n   核心：简单+均匀（简单好理解，生成的映射过程简单）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先我们对于哈希函数要有一个叫做     “均匀”\n   <span style=\'white-space:pre\'>\n   </span>\n   的认识，什么是均匀呢，我们知道如果我们设计的哈希函数如果在某些内存取值得时候会具有偏向性，那么我们会发现就算我们的哈希的内存开的非常的，冲突发生的概率还是很高，这就意味着我们的朝朝和插入的效率会变得越来越低下，所以说，均匀的意思是，对于每一个关键字我们都可以等概率的映射到内存地址上，从而使冲突最小化\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们设计出好的哈希函数可以为我们减少冲突的机会，从而使得我们的朝朝和插入效率都大大的提升，接近于完美的O(1)\n  </div>\n  <div>\n   哈希函数的构造的方法是非常多的，我们根据实际情况可以自己构造出不哦那个的哈希函数（并且因为哈希函数求解过程是不可逆的，所以说我们可以将其利用到加密公钥方面，好吧这是后话）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.1直接定址法：\n  </h2>\n  <div>\n   术语介绍：自身函数：我们通过直接定制的方法确定的哈希函数也叫做自身函数\n  </div>\n  <div>\n   这种哈希函数非常的简单，但是我们不常用\n  </div>\n  <div>\n   1.hashfunction(key)=key\n  </div>\n  <div>\n   2.hashfunction(key)=a*key+b（a，b是常数）\n  </div>\n  <div>\n   这种情况下，我们我们所需要的内存地址的大小和关键字的集合大小基本是一致的，所以这种情况是基本不会发生冲突的，但是应用较少\n  </div>\n  <h2>\n   2.2除留取余法：\n  </h2>\n  <div>\n   这是我们最常用的方法，其他的有些方法也是该方法拓展的得到的：\n  </div>\n  <div>\n   我们先来考虑如果关键字是正整数的情况下，这样好理解一点：\n  </div>\n  <div>\n   我们设哈希表长为M，p为模数（p&lt;=M） （\n   <strong>\n    这里我们先知道一下，哈希表长一般都开的很大，并且是一个大素数，至于为什么素数，我不得其解\n   </strong>\n   ）\n  </div>\n  <div>\n   哈希函数：\n   <strong>\n    hashfunction(key)=key % p (p&lt;=M)\n   </strong>\n  </div>\n  <div>\n   该哈希函数是我们最常用的也是应用最多的，我们不仅可以直接取模，还可以折叠取模或者平方取模，情况非常的多\n  </div>\n  <div>\n   <strong>\n    这里我们要注意p的选择是非常重要的，p选的不好的话，可能已造成冲突的现象，影响我们的效率（p可以尽量的接近M，尽可能利用哈希表的大的存储空间，但是如果哈希表的存储空间开的太大，远远超过了关键字的范围则会造成空间浪费）\n   </strong>\n  </div>\n  <div>\n   对于字符串的关键字，我们完全可以通过设计我们设计的哈希函数，将其每一位按照机器码来生成正整数然后我们在用除留取余的思路求解就好了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.3目前为止不常用的方法：\n  </h2>\n  <div>\n   数字分析法：我们通过分析关键字中的数位，发现如果数位中有几位的变化范围太小的话，那么这样我们生成的随机性就会下降，冲突的几率就会大大提高，所以我们根据对关键字数列的分析，找出随机性比较大的那几位数提取出来作为我们的新的关键字，然后设定我们的哈希函数\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   平房取中法：我们将关键字编码平方然后选取中间纪委做为新的关键字，\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    具体方法：先通过求关键字的平方值扩大相近数的差别，然后根据表长度取中间的几位数作为散列函数值。又因为一个乘积的中间几位数和乘数的每一位都相关，所以由此产生的散列地址较为均匀\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     相乘取整法\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     该方法包括两个步骤：首先用关键字key乘上某个常数A(0&lt;A&lt;1)，并抽取出key.A的小数部分；然后用m乘以该小数后取整。即：\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     该方法最大的优点是选取m不再像除余法那样关键。比如，完全可选择它是2的整数次幂。虽然该方法对任何A的值都适用，但对某些值效果会更好。Knuth建议选取\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     该函数的C代码为：\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     int Hash(int key){\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     double d=key *A； //不妨设A和m已有定义\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     return (int)(m*(d-(int)d))；//(int)表示强制转换后面的表达式为整数\n    </span>\n    <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     }\n    </span>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     <br/>\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n    <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n     折叠法和随机数法：.........................\n    </span>\n   </span>\n  </div>\n  <h1>\n   3.冲突处理：\n  </h1>\n  <div>\n   我们对于冲突必须要有合适的处理方式：（先介绍一些不常用的，之后着重介绍常用的）\n  </div>\n  <h2>\n   3.1建立公共溢出区：\n  </h2>\n  <div>\n   我们哈希表长是m，先建立一个哈希表，然后再建立一个溢出表，如果我们每次插入记录的时候发现都是空，那我们就直接插入记录就好，凡是一旦我们发现冲突，同意都放进公共溢出区中\n  </div>\n  <div>\n   在查找的时候，如果我们计算出来的内存地址上的关键字值不匹配，只能说明一点，当时这里发生了冲突，我们要查找的记录在公共溢出区中，这样子的话，我们就只需要再花费O(k)（k是公共溢出区的大小）来线性遍历一遍公共溢出区就好，如果发现关键字值是匹配的那么就只用O(1)就找到了要找的记录，这种情况在冲突较少，哈希函数设定均匀额时候，操作效率非常高\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.2再哈希法：\n  </h2>\n  <div>\n   实际上看上去每年工资很高打上，其实很好理解，再哈希的方法实际上就是我们对缠身冲突的时候，再次调用另一个哈希函数生成关键字对应的映射，知道我们的冲突不再发生为止，但是这种情况只适用于冲突发生比较低的情况，如果哦冲突发生比较高的话，我们就压迫设计很多的再哈希函数，这样实际上非常的累，也无用，而且增加了计算时间\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.3链地址法（拉链法）\n  </h2>\n  <div>\n   这里我们应用数组+链表的形式，感觉这好像是线性表的知识点\n  </div>\n  <div>\n   连续的数组用来保存指定的关键字对应的映射位置\n  </div>\n  <div>\n   每个数组后面都是一个线性链表，我们处理冲突的方式就是，在发生冲突的时候，直接插入链表的新的节点就可以了，这个方法非常的常用\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.4开放定址法：(构建方法我们采用常用的除留取余法)\n  </h2>\n  <h3>\n   3.4.1线性探测再散列：\n  </h3>\n  <div>\n   名字非常的高大上，实际上我来解释一下是什么一个原理\n  </div>\n  <div>\n   首先我们先介绍两个术语：\n  </div>\n  <div>\n   1.m哈希表长\n  </div>\n  <div>\n   2.d增量序列（我们每次要对d递增一次，马上就会讲到）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   hashfunction(key)=(hashfunction(key)+d)%m\n  </div>\n  <div>\n   公式很简单，但是这里我来解释一下原理，初始的时候d是0，没有增量，如果我们一次就求出了关键字地址，并且很开心的发现，这个地址是空的，那么我们可以放心的直接在这个地址上插入我们的节点了\n  </div>\n  <div>\n   但是很不走运，如果我们关键字指定的地点非空（就是发生冲突），那么我们就回退到计算哈希值的过程上，出现一次冲突，增量序列+1，知道我们找到了空的地方为止（这里我们必须要加入一个控制因子来记录已经带插入的元素记录的个数，当超过装载因子的时候我们重新弄分配哈希表的大小，这一回在后面我们会讲到，现在只是提一下）\n  </div>\n  <div>\n   这个就是线性探测再散列的过程，可能有的同学会有疑问，那么我们下一次查找的时候怎么办呢，又不知道到底冲突了几次，根本没法找到啊（这里我下面在查找的时候会讲，其实是可以找到的，\n   <strong>\n    只要我们保证和BST 的性质一样，哈希表中不存在几点相同的节点\n   </strong>\n   ）！！！这也引出来了我的问题\n  </div>\n  <h3>\n   3.4.2二次探测再散列：\n  </h3>\n  <div>\n   我们有的时候会发现，可能先行探测再散列太笨了，比若说不仅i号位置冲突了，i+1，i+2号位置都冲突了，我们就必须要让增量序列递增很多次才可以找到空位插入，但是如果这时候恰好i-1号位置是空的我们为什么就不能利用呢\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   这里我先道个歉，因为本身的能力问题，我不知道为什么是平方探测再散列，但是我知道了政府好的作用，求解于大神，这是我的一个问题\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   平方探测在三列种的增量序列d是这么变化的（d的变化都是有着固定的顺序的，所以查找的时候都是有规律的一定可以查找到）\n  </div>\n  <div>\n   d=1*1，-1*1，2*2，-2*2，....k*k，-k*k（k&lt;=m/2\n   <span style=\'font-size:12px\'>\n    ）  这里为什么要小于一半，超表可以取余挽救，这个就看不懂了？\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <h3>\n   <span style=\'font-size:12px\'>\n    3.4.3伪随机数序列法：不常用\n   </span>\n  </h3>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    这里我们要介绍一个叫做二次聚集的术语：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    可以这么解释：上面的例子中i，i+1,都已经占位了，我们这时候如果计算的哈希值是i，或者i+1的话，都会导致冲突，我们在查找的时候（你可以看完查找回来再看这一句话）如果i+2存储的是i的冲突之后的记录，那么我们i+1冲突之后下一个查找位置也是i+2，但是i+2和i+1的关键字没有任何关系，i+2是i的关键字指定的记录，这时候我们又要继续向后探查，增加了哦我们的冲突个数，降低了我们的效率，但是实际上，线性探查是避免不了这个缺陷的，就像拉链法也有自己的缺陷一样，线性探查的方法是冲突会过多\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   按照上面的例子来看，开放寻址的法会造成我们的二次聚集现象\n  </div>\n  <h1>\n   4.查找分析\n  </h1>\n  <div>\n   这里我们通常认为哈希表的理想的查找速度是O(1),但是实际上，因为存在着哈希冲突现象和我们的不同的冲突处理的方法，我们大多数情况下的哈希查找速度是常数级的O(c),但是这已经是非常优秀的了，毕竟空间换时间还是已经付出了我们的内存的代价了的\n  </div>\n  <div>\n   我们现在来分析一下我们的查找操作，我们按照主流的两个方式来讲解\n  </div>\n  <div>\n   1.拉链法\n  </div>\n  <div>\n   2.线形态测再散列（二测探测再散列）：两者本质上其实是一样的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    这里我在插一句嘴，我们在选取先行探测和拉链法的时候要有个判断标准，如果我们的记录的内容非常的多，那么我们可以采用拉链法，指针的大小可以忽略不计了，如果我们的记录内容非常的小，那么指针的大小会影响我们的效率和空间，我们还不如拿出来这些空间用来扩展我们的哈希表并且选取线性探测再散列的方法\n   </strong>\n  </div>\n  <div>\n   <strong>\n    <br/>\n   </strong>\n  </div>\n  <h2>\n   4.1拉链法：\n  </h2>\n  <div>\n   先附图：\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/94031/201410/312300560817372.png\'/>\n   <br/>\n  </div>\n  <div>\n   左图就算是正常情况吧，右图是坏的哈希函数造就的哈希表退化成单链表\n  </div>\n  <div>\n   查找策略：\n  </div>\n  <div>\n   1.利用关键字计算哈希值，映射到对应的单链表上\n  </div>\n  <div>\n   2.对单链表进行遍历查找\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.1遍历找到返回true / 指向该内存位置的指针\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.2遍历结束没有找到，返回false / NULL\n  </div>\n  <div>\n   <div style=\'font-size:13.3333px\'>\n    <strong>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      与开放定址法相比，拉链法有如下几个优点：\n     </span>\n     <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      (1)拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；\n     </span>\n     <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      (2)由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；\n     </span>\n     <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      (3)开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；\n     </span>\n     <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      (4)在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。\n     </span>\n     <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n     <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      （3）拉链法的缺点\n     </span>\n     <br style=\'font-family:Arial; font-size:14px; line-height:26px\'/>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。\n     </span>\n     <br/>\n    </strong>\n   </div>\n   <div>\n    <strong>\n     <span style=\'font-family:Arial; font-size:14px; line-height:26px\'>\n      <br/>\n     </span>\n    </strong>\n   </div>\n   <h2>\n    4.2线性探查：（线性探查需要我们不断地动态控制大小，否则会死循环（下面就会讲到））\n   </h2>\n  </div>\n  <div>\n   附图好看：\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img2.tuicool.com/UbAj2iQ.jpg!web\'/>\n   <br/>\n  </div>\n  <div>\n   线性探查的查找技术和我们插入技术是一样的\n  </div>\n  <div>\n   1.如果哈希值和我们找到的低智商的记录是匹配的，那么我们用O(1)的时间找到了\n  </div>\n  <div>\n   2.如果不匹配，那么我们增量序列+1，继续探查\n  </div>\n  <div>\n   3.如果我们发现找到的位置是空的话（说明该记录不存在于哈希表中），如果哈希表美满的话，改查找过程一定会终止（非常低效），但是如果满了的话会造成死循环，不断地便利我们的哈希表，导致程序崩溃\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   所以 为了判断我们的装填程度，我们这里引入一个术语：\n  </div>\n  <div>\n   装填因子=表中存在的记录数/哈希表大小（我们人为设定装填因子的大小，经验之谈是0.72，一旦超过了这个大小我们就要为线性探查技术的哈希表重新确定大小，这样我们要花费大量的时间，因为要遍历复制）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    在这里我们要小心，线性探测再散列中我们删除节点的时候不能直接抹去节点，因为这个节点可能包含有冲突的信息，我们家是哪一个删除标记就好了，当然，正如你们所想的，这样子的话，会占用我们的空间，所以说一般涉及到删除操作多的时候我们都用拉链法\n   </strong>\n  </div>\n  <h2>\n   4.3.ASL计算（平均查找长度和平均查找失败长度）\n  </h2>\n  <div>\n   平均查找长度ASL是有计算公式的，ASL的大小可以反映出处理冲突选择的方法的效率\n  </div>\n  <div>\n   ASL=(查找每个节点我们需要便利的节点的数目之和)/已经插入的节点的数目\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   平均查找失败的长度：查找不成功的情况下我们发现这一代你要遍历的数目的平均值（这个还没有做过相应的题，求谅解，还真不熟）\n  </div>\n  <div>\n   列举常见的方法的ASL和UNL：(都是≈,a代表装填因子\n   <span style=\'font-size:12px\'>\n    )\n   </span>\n  </div>\n  <div>\n   线性探测再散列ASL≈(1+1/(1-a))/2\n  </div>\n  <div>\n   再哈希+随即探测再散列+二次探测再散列≈ -ln(1-a)/a\n  </div>\n  <div>\n   拉链法≈1+a/2\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h1>\n   5.代码实现：（为了简单起见，哈希函数构造采用除留取余法）\n  </h1>\n  <div>\n   talk is cheap，show you the code！\n  </div>\n  <div>\n   C++代码类封装，在代码中我还会讲解，还是没有看懂的，再看看代码吧：\n  </div>\n  <div>\n   包含操作：\n  </div>\n  <div>\n   1.建立哈希表\n  </div>\n  <div>\n   2.删除哈希表\n  </div>\n  <div>\n   3.重新构造哈希表（在查过装填因子的限制后，C++代码实现中我们实现重载一个=就好了，或者写个复制函数，复制结束后，删除原来的拥挤的哈希表就可以了）\n  </div>\n  <div>\n   4.插入节点\n  </div>\n  <div>\n   5.删除节点\n  </div>\n  <div>\n   6.查找结点\n  </div>\n  <div>\n   动态控制大小\n  </div>\n  <div>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    static int prime_array[] = {\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    17,             /* 0 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    37,             /* 1 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    79,             /* 2 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    163,            /* 3 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    331,            /* 4 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    673,            /* 5 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    1361,           /* 6 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    2729,           /* 7 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    5471,           /* 8 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    10949,          /* 9 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    21911,          /* 10 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    43853,          /* 11 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    87719,          /* 12 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    175447,         /* 13 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    350899,         /* 14 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    701819,         /* 15 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    1403641,        /* 16 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    2807303,        /* 17 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    5614657,        /* 18 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    11229331,       /* 19 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    22458671,       /* 20 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    44917381,       /* 21 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    89834777,       /* 22 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    179669557,      /* 23 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    359339171,      /* 24 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    718678369,      /* 25 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    1437356741,     /* 26 */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    2147483647      /* 27 (largest signed int prime) */\n   </span>\n   <br style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'/>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    };\n   </span>\n   <br/>\n  </div>\n  <div>\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px\'>\n    这个是大小的素数集，每次我们挑选素数集大小，为什么是素数，我也不能讲清楚\n   </span>\n  </div>\n  <h2>\n   5.1拉链法代码：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1822116\' name=\'code\' snippet_file_name=\'blog_20160810_1_4050904\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nstatic int primarray[] = {   //0-27 ，我们设计的装填因子是  0.7 \n    17,             /* 0 */\n    37,             /* 1 */\n    79,             /* 2 */\n    163,            /* 3 */\n    331,            /* 4 */\n    673,            /* 5 */\n    1361,           /* 6 */\n    2729,           /* 7 */\n    5471,           /* 8 */\n    10949,          /* 9 */\n    21911,          /* 10 */\n    43853,          /* 11 */\n    87719,          /* 12 */\n    175447,         /* 13 */\n    350899,         /* 14 */\n    701819,         /* 15 */\n    1403641,        /* 16 */\n    2807303,        /* 17 */\n    5614657,        /* 18 */\n    11229331,       /* 19 */\n    22458671,       /* 20 */\n    44917381,       /* 21 */\n    89834777,       /* 22 */\n    179669557,      /* 23 */\n    359339171,      /* 24 */\n    718678369,      /* 25 */\n    1437356741,     /* 26 */\n    2147483647      /* 27 (largest signed int prime) */\n};\n\n//记录信息的节点 \ntypedef struct kkk\n{\n	int data;   //存储信息，也是关键字 \n	struct kkk* next;\n}point;\n\n//设计结构体 \ntypedef struct node\n{\n	//在这里，哈希值就是数组的下标 \n	point* next;\n}pnode; \n\nclass hash\n{\n	public:\n		hash()   //相当于建立哈希表的操作 \n		{\n			size=0;\n			number=0;\n			for(int i=0;i&lt;primarray[size];i++) \n			{\n				hashtable[i].next=NULL;\n			}\n		}\n		~hash()    //相当于删除清空哈希表的操作 \n		{\n			for(int i=0;i&lt;primarray[size];i++)\n			{\n				if(hashtable[i].next==NULL) continue;\n				point* head=hashtable[i].next;\n				while(hashtable[i].next!=NULL)\n				{\n					hashtable[i].next=hashtable[i].next-&gt;next;\n					free(head);\n					head=hashtable[i].next;\n				}\n			}\n		}\n		void operator==(hash&amp;);    //这里采用引用，就不会发生我们的函数传递值得时候发生的指针丢失的事件,该函数是重新分配哈希表大小的时候的复制函数 \n		int hashfunction(int);    //传入关键字，计算出哈希值\n		bool add(int);    //因为这里关键字就是记录内容，所以这里简化了，添加操作,超过装填容量，返回1，否则返回0 \n		bool del(int);    //删除操作，删除成功，返回1，否则返回0 \n		point* find(int);     //查找函数，成功返回指向性指针，否则返回NULL \n		void visit()\n		{\n			for(int i=0;i&lt;primarray[size];i++)\n			{\n				point* head=hashtable[i].next;\n				while(head!=NULL)\n				{\n					cout&lt;&lt;head-&gt;data&lt;&lt;\' \';\n					head=head-&gt;next;\n				}\n			}\n			cout&lt;&lt;endl;\n		}\n	private:\n		pnode hashtable[9999];  //哈希表 \n		int number;   //已经装填的记录的数目 \n		int size;    //记录size在primarray中的编号，初始化时0，如果还小的话，我们再复制函数中递加一次就好 \n};\n\nint hash::hashfunction(int key)\n{\n	return key%primarray[size];   //充分利用所有的空间 ，减少冲突 \n}\n\nbool hash::add(int p)\n{\n    int key=hashfunction(p);\n	point* head=new point;\n	head-&gt;data=p;\n	head-&gt;next=hashtable[key].next;\n	hashtable[key].next=head;   //采用头插法 \n	number++;\n	if(number&gt;=(int)primarray[size]*0.7) return 1;\n	else return 0;\n}\n\nbool hash::del(int p)\n{\n	int key=hashfunction(p);\n	point* head=hashtable[key].next;\n	point* help=NULL;\n	while(head!=NULL)\n	{\n		if(head-&gt;data==p&amp;&amp;help!=NULL)\n		{\n			help-&gt;next=head-&gt;next;\n			free(head);\n			return 1;\n		}\n		else\n		{\n			if(head-&gt;data==p&amp;&amp;help==NULL)\n			{\n				hashtable[key].next=hashtable[key].next-&gt;next;\n				free(head);\n				return 1;\n			}\n		}\n		help=head;\n		head=head-&gt;next;\n	}\n	if(head==NULL)\n	{\n		cout&lt;&lt;\'哈希表中没有该元素\'&lt;&lt;endl;\n		return 0;\n	}\n} \n\npoint* hash::find(int p)\n{\n	int key=hashfunction(p);\n	point* head=hashtable[key].next;\n	while(head!=NULL)\n	{\n		if(head-&gt;data==p) return head; \n		head=head-&gt;next;\n	}\n	return NULL;\n}\n\nvoid hash::operator==(hash&amp; k)\n{\n	size=k.size+1;\n	for(int i=0;i&lt;primarray[k.size];i++)\n	{\n		point* head=k.hashtable[i].next;\n		while(head!=NULL)\n		{\n			this-&gt;add(head-&gt;data);\n			head=head-&gt;next;\n		}\n	}\n}\n\nint main()\n{\n	hash* my=new hash; \n	hash my2;\n	for(int i=1;i&lt;=13;i++)   //17*0.7≈12 \n	{\n		int k;\n		cin&gt;&gt;k;\n		if(my-&gt;add(k)==1)\n		{\n			cout&lt;&lt;\'到达装填上限，请扩充哈希表！\';\n			my2==*my;\n			cout&lt;&lt;my-&gt;find(2)-&gt;data&lt;&lt;endl;\n			my-&gt;del(2);\n			my-&gt;visit();\n			delete my;\n			break; \n		}\n	}\n	cout&lt;&lt;\'开始测试删除函数\'&lt;&lt;endl;\n	int k;\n	my2.visit();\n	cin&gt;&gt;k;\n	cout&lt;&lt;my2.find(k)-&gt;data&lt;&lt;endl;\n	my2.del(k);\n	cout&lt;&lt;my2.find(k)-&gt;data&lt;&lt;endl;\n	return 0;\n} \n</pre>\n   <br/>\n   <br/>\n  </div>\n  <h2>\n   5.2线性探测再散列代码：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1822116\' name=\'code\' snippet_file_name=\'blog_20160810_2_7496468\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 1000\n\nusing namespace std;\n\nstatic int primarray[] = {\n    17,             /* 0 */\n    37,             /* 1 */\n    79,             /* 2 */\n    163,            /* 3 */\n    331,            /* 4 */\n    673,            /* 5 */\n    1361,           /* 6 */\n    2729,           /* 7 */\n    5471,           /* 8 */\n    10949,          /* 9 */\n    21911,          /* 10 */\n    43853,          /* 11 */\n    87719,          /* 12 */\n    175447,         /* 13 */\n    350899,         /* 14 */\n    701819,         /* 15 */\n    1403641,        /* 16 */\n    2807303,        /* 17 */\n    5614657,        /* 18 */\n    11229331,       /* 19 */\n    22458671,       /* 20 */\n    44917381,       /* 21 */\n    89834777,       /* 22 */\n    179669557,      /* 23 */\n    359339171,      /* 24 */\n    718678369,      /* 25 */\n    1437356741,     /* 26 */\n    2147483647      /* 27 (largest signed int prime) */\n};\n\ntypedef struct node\n{\n	int data;   //保存信息 + 关键字 \n	bool del;   //删除标记,0代表存在，1代表已删除 \n}point;\n\nclass hash\n{\n	public:\n		hash()\n		{\n			memset(hashtable,0,sizeof(hashtable));\n			number=size=0;\n		}\n		void operator=(hash&amp;);\n		bool add(int);\n		bool del(int);\n		int find(int);\n		int hashfunction(int);\n		void visit();    //用于检测的遍历函数 \n	private:\n		point hashtable[N];     //哈希表 \n		int number;   //目前已经插入的记录的数目\n		int size;   //primarray数组的标号，记录哈希表的容量 \n};\n\nvoid hash::operator=(hash&amp; k)\n{\n	size=k.size+1;\n	number=0;\n	memset(hashtable,0,sizeof(hashtable));\n	for(int i=0;i&lt;primarray[k.size];i++) hashtable[i]=k.hashtable[i];\n}\n\nint hash::hashfunction(int p)\n{\n	return p%primarray[size];\n}\n\nbool hash::add(int p)\n{\n	int key=hashfunction(p);\n	if(hashtable[key].data==0) hashtable[key].data=p;\n	else\n	{\n		int d=1;   //增量序列\n		while(hashtable[key].data!=0)\n		{\n			key=(hashfunction(p)+d)%primarray[size];\n			d++;\n		} \n		hashtable[key].data=p;\n	}\n	number++;\n	if(number&gt;=(int)primarray[size]*0.7) return 1;\n	else return 0;\n}\n\nbool hash::del(int p)\n{\n	int key=hashfunction(p);\n	if(hashtable[key].data==p) hashtable[key].del=1;\n	else\n	{\n		int d=1;\n		while(hashtable[key].data!=0&amp;&amp;hashtable[key].data!=p)\n		{\n			key=(hashfunction(p)+d)%primarray[size];\n			d++;\n		} \n		if(hashtable[key].data==p) \n		{\n			hashtable[key].del=1;\n			return 1;\n		}\n		else\n		{\n			cout&lt;&lt;\'没有找到该节点\'&lt;&lt;endl;\n			return 0;\n		}\n	} \n}\n\nint hash::find(int p)\n{\n	int d=1;\n	int key=hashfunction(p);\n	while(hashtable[key].data!=0&amp;&amp;hashtable[key].data!=p)\n	{\n		key=(hashfunction(p)+d)%primarray[size];\n		d++;\n	}\n	if(hashtable[key].data==0) return -1;\n	else\n	{\n		if(hashtable[key].del==1) \n		{\n			cout&lt;&lt;\'该节点曾经存在，但目前已经删除\'&lt;&lt;endl;\n			return -1;\n		}\n		else return key;\n	}\n}\n\nvoid hash::visit()\n{\n	for(int i=0;i&lt;primarray[size];i++)\n	{\n		if(hashtable[i].del==0&amp;&amp;hashtable[i].data!=0) cout&lt;&lt;hashtable[i].data&lt;&lt;\' \';\n	}\n	cout&lt;&lt;endl;\n}\n\nint main()\n{\n	hash* my1=new hash;\n	hash* my2=new hash;\n	for(int i=1;i&lt;=13;i++)\n	{\n		int k;\n		cin&gt;&gt;k;\n		if(my1-&gt;add(k)==1) \n		{\n			cout&lt;&lt;\'目前装载的记录已经超过我们的装载上限，请扩充哈希表！\'&lt;&lt;endl;\n			*my2=*my1;\n			my2-&gt;visit();\n			break;\n		}\n	} \n	cout&lt;&lt;my2-&gt;find(4)&lt;&lt;endl;\n	my2-&gt;del(4);\n	cout&lt;&lt;my2-&gt;find(4)&lt;&lt;endl;\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <h1>\n   6.优缺点：\n  </h1>\n  <div>\n   优点是查找快于树和线性表\n  </div>\n  <div>\n   缺点是散乱，如果我们还要求按照某个顺序排列的话，我们最好不要用散列表，因为还要牵扯到排序算法，而树和线性表我们都有有序的类型来解决这个问题\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h1>\n   7.遗留问题：\n  </h1>\n  <div>\n   1.和BST一样，是不是散列表中也要求不能有数据相同\n  </div>\n  <div>\n   2.还是不理解散列表的大小是素数的原因\n  </div>\n  <div>\n   3.平均失败查找长度\n  </div>\n  <div>\n   4.还可以如何优化重新构造散列表的操作\n  </div>\n  <div>\n   5.为了减少冲突，构造时候的模数一定要接近表长大小吗\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   以上问题欢迎有好思路和想法的大神在评论区告知我哦，感激不尽\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('feb9a779767c89cde6d12baefee0c149','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题005——堆实现求前k大/小的数\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.题目描述：\n  </h2>\n  <div>\n   请求出一组序列中的数中的前k小的数，或者前k大的数，问题很简单\n  </div>\n  <h2>\n   2.算法思路：\n  </h2>\n  <div>\n   该题利用顺序存储二叉堆可以很好的解决：\n  </div>\n  <div>\n   首先我们先解释一下“堆”这个数据结构\n  </div>\n  <div>\n   堆这个东西我们可以理解成是利用了二叉树的一条性质而人工构建的一组顺序存储二叉树\n  </div>\n  <div>\n   分类：\n  </div>\n  <div>\n   最小堆：每个父亲节点都比子节点小\n  </div>\n  <div>\n   最大堆：每个父亲节点都比子节点大\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   顺序存储实现的原理：\n  </div>\n  <div>\n   二叉树存在一条性质，（这个性质和二叉树的层序遍历的序号有关\n   <span style=\'font-size:12px\'>\n    ）\n   </span>\n  </div>\n  <div>\n   n号节点的左儿子的存在的话编号为2*n，右儿子存在的话，编号为2*n+1\n  </div>\n  <div>\n   那么我们依据这一条就可以完全实现二叉树的线性存储，并且这种结构和性质还可以方便我们进行各种操作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   下面主要来介绍二叉堆的核心的两个函数：向上浮动调整和向下浮动调整——目的是用来维护我们最小堆和最大堆的性质\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   《以求前k小的数来举例》\n  </div>\n  <div>\n   说到这里，有的人可能会问了，为什么我们用最小堆或者最大堆可以解决这个问题呢\n  </div>\n  <div>\n   我们来这么考虑，我们如果可以构建出只有k个元素的 最大堆\n  </div>\n  <div>\n   每次加入新的元素，我们将该元素和堆顶进行比较，如果比堆顶小的话，我们将其和堆顶进行替换，然后再次进行调整维护，直到所有的数据都加入完毕，那么堆里面剩下的就是所有的我们要求的元素，这时候我们再利用最小堆的维护函数进行调整进行堆排序就可以按顺序输出前k个元素了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   原理讲完了，那么这个核心的向上调整函数和乡下调整函数到底怎么实现呢\n  </div>\n  <h2>\n   3.核心代码段解析：（最小堆举例）\n  </h2>\n  <h3>\n   3.1 siftdown（向下调整）\n  </h3>\n  <div>\n   在代码段中进行解析：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1819142\' name=\'code\' snippet_file_name=\'blog_20160809_1_7506849\'>void siftdown(int i)   //i代表要开始维护的节点的层序标号 \n{\n	int t,flag=1;\n	while(i*2&lt;=num&amp;&amp;flag==1)\n	{\n		if(data[i]&gt;data[i*2]) t=i*2;   //如果比坐儿子大，t记录要交换的做儿子的标号 \n		else t=i;   //否则t只标记自己 \n		if(i*2+1&lt;=num&amp;&amp;data[i*2+1]&lt;data[t]) t=i*2+1;  //如果右儿子存在且右儿子比左儿子还小，那么更换标记为右儿子，保持更换后的最小堆性质\n		if(t!=i)\n		{\n			swap(i,t);\n			i=t;   //向下调整完之后，我们要再次追踪，看看是否还能满足最小堆的性质 \n		}\n		else flag=0;   //满足了，调整结束 \n	} \n} </pre>\n   <h3>\n    3.2 siftup（向上调整）\n   </h3>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1819142\' name=\'code\' snippet_file_name=\'blog_20160809_2_4889127\'>void siftup(int i) //在这里我们只要维护跟踪根节点就可以了 \n{\n	int t,flag=1;\n	while(i!=1&amp;&amp;fag==1)\n	{\n		if(data[i]&lt;data[i/2])\n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else flag=0;   //已经满足最小堆的性质，跳出即可 \n	} \n} </pre>\n    <br/>\n    <h3>\n     3.3 buildheap（建堆操作）\n    </h3>\n   </div>\n   <div>\n    1.整体操作（我们开始得到的就是一整个散乱的堆，我们维护成最小堆）\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1819142\' name=\'code\' snippet_file_name=\'blog_20160809_3_4016292\'>void buildheap(int num)   //num代表堆的大小\n{\n	for(int i=num/2;i&gt;=1;i--) siftdown(1);    //我们从倒数第二层最右边的根节点开始逐层向上维护 \n} </pre>\n    2.逐个插入不断维护：\n   </div>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1819142\' name=\'code\' snippet_file_name=\'blog_20160809_4_1922741\'>void buildheap(int num)\n{\n	for(int i=1;i&lt;=num;i++)\n	{\n		cin&gt;&gt;data[i];    //加入到堆尾 \n		siftup(i);     //向上调整 \n	}\n} </pre>\n   <br/>\n   <h2>\n    4.堆排序：\n   </h2>\n  </div>\n  <div>\n   基于上面的原理我们可以很好地实现查找前k个数的操作，但是至于堆排序我们还没有进行讲解\n  </div>\n  <div>\n   其是堆排序很简单\n  </div>\n  <div>\n   按照升序排列我们需要最大堆，按照降序排列我们需要最小堆\n  </div>\n  <div>\n   每次我们将堆尾和堆顶进行交换，然后将堆数递减，保持堆尾固定，然后在向下调整，重复过程，直到我们的堆数为1，然后这个堆就有序了\n  </div>\n  <div>\n   所以说根据上面的原理讲解我们很容易发现堆排序的复杂度始终是O(n*logn)的logn是指堆的二叉树深度，n是因为我们每次都要从未到头进行遍历交换\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/50859847\' target=\'_blank\'>\n    堆排序的详情请百度百科或者点击这里\n   </a>\n   <br/>\n  </div>\n  <div>\n   不多说了，附上代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1819142\' name=\'code\' snippet_file_name=\'blog_20160809_5_6241139\'>void heapsort(int num)   //堆的大小 \n{\n	int help=num;   //先记录下来对的原始大小，不然这个数据会丢失 \n	while(num!=1)\n	{\n		swap(1,num);\n		num--;\n		siftdown(1); \n	} \n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('dc2cff14baba536436cc047d97285310','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题004——指定BST路径和\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   微软面试百题004\n  </h1>\n  <h2>\n   1.题目大意：\n  </h2>\n  <div>\n   给出一颗二叉查找树BST\n  </div>\n  <div>\n   定义路径：从根节点出发到叶子节点终止视为一条路径\n  </div>\n  <div>\n   定义路径和：路径上的所有上的节点的权值之和\n  </div>\n  <div>\n   给定一个权值，请求出满足权值路径和的所有的路径\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.解题思路：\n  </h2>\n  <div>\n   因为我们是要求解出所有的情况，所以很自然而然的我们就会想到深度优先遍历(\n   <strong>\n    DFS\n   </strong>\n   )\n  </div>\n  <div>\n   我们从根节点开始，每次向下遍历至所有的根节点，满足条件打印一次（存储在余下支配号的内存中）\n  </div>\n  <div>\n   在这里我们可以为了加快速度，进行适当的剪枝\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   1.目前路径和已经大于给定权值，下一个遍历点大于0（这条路径可以剪枝）\n  </div>\n  <div>\n   2.目前路径和已经小于给定权值，下一个遍历点小于0（这条路径可以剪枝）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   //以上是主要的两个剪枝方式，因为BST的情况太多，可以涉及到的剪枝情况也很多，这里就不再过多赘述\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.代码实现：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1818753\' name=\'code\' snippet_file_name=\'blog_20160809_1_4131717\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 100\n\nusing namespace std;\n\ntypedef struct node\n{\n	int key;\n	struct node* left;\n	struct node* right;\n}point;\n\nclass errorsame\n{\n}; \n\nclass bst\n{\n	public:\n		bst()\n		{\n			root=NULL;\n			num=key=savenum=0;\n			memset(save,0,sizeof(save));\n		}\n		~bst()\n		{\n			clear(root);\n		}\n		void add(int);\n		void del(int);\n		point* find(int);\n		void clear(point*);\n		void preorder(point*);\n		void midorder(point*);\n		void aftorder(point*);\n		void rankorder();\n		point* returnroot() \n		{\n			return root;\n		}\n		void dfs(point*,int);\n		void right()\n		{\n			cout&lt;&lt;\'please your key!\'&lt;&lt;endl;\n			cin&gt;&gt;key;\n		}\n	private:\n		point* root;\n		int num;\n		int key;\n		int save[N];\n		int savenum;\n};\n\nvoid bst::dfs(point* p,int now)\n{\n	now+=p-&gt;key;\n	if(p-&gt;left==NULL&amp;&amp;p-&gt;right==NULL)\n	{\n		if(now==key)\n		{\n			for(int i=1;i&lt;=savenum;i++) cout&lt;&lt;save[i]&lt;&lt;\' \';\n		    cout&lt;&lt;p-&gt;key&lt;&lt;endl;\n	    	return ;\n		}\n		else return ;\n	}\n	else\n	{\n		save[++savenum]=p-&gt;key;\n		dfs(p-&gt;left,now);\n		savenum--;\n		save[++savenum]=p-&gt;key;\n		dfs(p-&gt;right,now);\n		savenum--;\n	}\n}\n\nvoid bst::clear(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		clear(p-&gt;left);\n		clear(p-&gt;right);\n		free(p);\n	}\n}\n\nvoid bst::add(int p)\n{\n	if(num==0) \n	{\n		root=new point;\n		root-&gt;right=root-&gt;left=NULL;\n		root-&gt;key=p;\n		num++;\n		return ;\n	}\n	else\n	{\n		try\n		{\n			point *k=root;\n			point* w=root;\n		    while(w!=NULL)\n		    {\n	     		if(w-&gt;key==p) throw errorsame();\n	     		else\n	     		{\n	     			if(w-&gt;key&gt;p) w=w-&gt;left;\n	     			else w=w-&gt;right;\n	     		}\n	     		if(w!=NULL) k=w;\n		    }\n		    if(k-&gt;key&gt;p) \n		    {\n		    	point *a=new point();\n		    	a-&gt;left=a-&gt;right=NULL;a-&gt;key=p;\n		    	k-&gt;left=a;\n		    }\n		    else\n		    {\n		    	point *a=new point();\n		    	a-&gt;left=a-&gt;right=NULL;a-&gt;key=p;\n		    	k-&gt;right=a;\n		    }\n		    num++;\n		}\n		catch(errorsame e)\n		{\n			cout&lt;&lt;\'try to add the same point in the tree!\'&lt;&lt;endl;\n		}\n	}\n}\n\nvoid bst::del(int p)\n{\n	point* now=root;\n	point* father=NULL;\n	while(now-&gt;key!=p)\n	{\n		if(now-&gt;key&gt;p)\n		{\n			father=now;\n			now=now-&gt;left;\n		}\n		else\n		{\n			father=now;\n			now=now-&gt;right;\n		}\n		if(now==NULL) \n		{\n			cout&lt;&lt;\'can not find the point!\'&lt;&lt;endl;\n			return ;\n		}\n	}\n	if(father==NULL) \n	{\n		point* help=root;\n		if(root-&gt;right==NULL) root=root-&gt;left;\n		else\n		{\n			if(root-&gt;right-&gt;left==NULL) \n			{\n				root-&gt;right-&gt;left=root-&gt;left;\n				root=root-&gt;right;\n			} \n			else\n			{\n				point* z=NULL;\n				point* k=root-&gt;right;\n				point* w=root;\n				while(k-&gt;left!=NULL) \n				{\n					if(k-&gt;left-&gt;left==NULL) z=k; \n					k=k-&gt;left;\n				}\n				z-&gt;left=k-&gt;right;\n				k-&gt;left=root-&gt;left;\n		    	k-&gt;right=root-&gt;right;\n		    	root=k;\n			}\n		} \n		free(help);\n	}\n	else if(now-&gt;right==NULL)\n	{\n		point* help=now;\n		if(father-&gt;left==now) father-&gt;left=now-&gt;left;\n		else father-&gt;right=now-&gt;left;\n		free(help);\n	}\n	else\n	{\n		if(now-&gt;right-&gt;left==NULL)\n		{\n			point* help=now;\n			now-&gt;right-&gt;left=now-&gt;left;\n			if(father-&gt;left==now) father-&gt;left=now-&gt;right;\n			else father-&gt;right=now-&gt;right;\n			free(help);\n		}\n		else\n		{\n			point* z;\n			point* k=now-&gt;right;\n			while(k-&gt;left!=NULL) \n			{\n				if(k-&gt;left-&gt;left==NULL) z=k;\n				k=k-&gt;left;\n			} \n			if(father-&gt;left==now)\n			{\n                z-&gt;left=k-&gt;right;\n				father-&gt;left=k;\n				k-&gt;left=now-&gt;left;\n				k-&gt;right=now-&gt;right;\n			}\n			else\n			{\n				z-&gt;left=k-&gt;right;\n				father-&gt;right=k;\n				k-&gt;left=now-&gt;left;\n				k-&gt;right=now-&gt;right;\n			}\n		}\n	}\n}\n\npoint* bst::find(int p)\n{\n	point* a=root;\n	while(a!=NULL)\n	{\n		if(a-&gt;key==p) return a; \n		if(a-&gt;key&gt;p) a=a-&gt;left;\n		else a=a-&gt;right;\n	}\n} \n\nvoid bst::preorder(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		printf(\'%d \',p-&gt;key);\n		preorder(p-&gt;left);\n		preorder(p-&gt;right);\n	}\n}\n\nvoid bst::midorder(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		midorder(p-&gt;left);\n		printf(\'%d \',p-&gt;key);\n		midorder(p-&gt;right);\n	}\n}\n\nvoid bst::aftorder(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		aftorder(p-&gt;left);\n		aftorder(p-&gt;right);\n		printf(\'%d \',p-&gt;key);\n	}\n}\n\nvoid bst::rankorder()\n{\n	point* queue[100];\n	int head=1;\n	int tail=2;\n	queue[1]=root;\n	while(head!=tail)\n	{\n		if(queue[head]-&gt;left!=NULL) queue[tail++]=queue[head]-&gt;left;\n		if(queue[head]-&gt;right!=NULL) queue[tail++]=queue[head]-&gt;right;\n		head++;\n	}\n	for(int i=1;i&lt;=tail-1;i++) printf(\'%d \',queue[i]-&gt;key);\n}\n\nint main()\n{\n	bst my;\n	my.add(10);\n	my.add(5);\n	my.add(4);\n	my.add(7);\n	my.add(12);\n	my.right();\n	my.dfs(my.returnroot(),0);\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('0c5a964a9d4b48627b08ea745edf3bed','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  手摇算法（三重反转算法/内存反转算法）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   本次我们介绍一种在字符串处理和大量的算法优化方面都有突出作用的算法——手摇算法（三重反转算法/内存反转算法）\n  </p>\n  <h2>\n   1.何为手摇算法：\n  </h2>\n  <div>\n   我们在初学程序设计语言的时候可能都会接触过一种问题，如何将字符串中的元素反转一下，就是逆序排列一遍\n  </div>\n  <div>\n   可能我们都会毫不犹豫的写出如下的代码段：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1817299\' name=\'code\' snippet_file_name=\'blog_20160808_1_6224333\'>//这里采用模板来举例：\nT* p1=&amp;data[left];\nT* p2=&amp;data[right];\nwhile(p1&lt;p2)\n{\n	T t=*p1;\n	*p1=*p2;\n	*p2=*p1;\n	p1++;\n	p2--; \n} </pre>\n   我们不要以为手摇算法多么的高级，实际上手摇算法非常的好理解\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么如果我们将问题稍微的变一下，反转字符串中两块元素的位置，该怎么做呢？\n  </div>\n  <div>\n   可能有的人会说，没问题，我们在开辟一块内存保存一部风的元素块到时候我们再复制两次就可以了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么如果题目加上限制，我们要求空间复杂度只能是O(1)，又该如何解决呢？\n  </div>\n  <div>\n   这里我们就要引入手摇算法的概念了：\n  </div>\n  <div>\n   手摇算法的处理方式非常的灵活，我们可以转换大小不均衡的元素块，那么他的原理该怎么解释呢？\n  </div>\n  <div>\n   举例：A B C D E F,我们要求A B和C D E F转换位置\n  </div>\n  <div>\n   1.我们先观察\n  </div>\n  <div>\n   根据上面的逆序交换的手段，我们怎么通过逆序交换的手段来实现位置的转换呢：\n  </div>\n  <div>\n   A B C D E F\n  </div>\n  <div>\n   C D E F A B\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先：我们推导一遍就明白了\n  </div>\n  <div>\n   A B C D E F\n  </div>\n  <div>\n   B A F E D C\n  </div>\n  <div>\n   C D E F A B (转换完成)\n  </div>\n  <div>\n   所以说算法存在三次反转的过程，实如其名：\n  </div>\n  <div>\n   1.反转前一段\n  </div>\n  <div>\n   2.反转后一段\n  </div>\n  <div>\n   2.反转整体\n  </div>\n  <div>\n   很明显我们的空间复杂度仅仅只是交换操作的t，O(1)实至名归\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.代码实现：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1817299\' name=\'code\' snippet_file_name=\'blog_20160808_2_9888830\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass triple\n{\n	public:\n		triple()\n		{\n			memset(data,0,sizeof(data));\n			num=ask=0;\n		}\n		void set();\n		void print();\n		void heart(int,int);\n		void reverse(int,int);\n		int returnnum()\n		{\n			return num;\n		}\n	private:\n		T data[N];\n		int num;\n		int ask;\n};\n\ntemplate&lt;typename T&gt;\nvoid triple&lt;T&gt;::set()\n{\n	cout&lt;&lt;\'please input the number of the data!\'&lt;&lt;endl;\n	cin&gt;&gt;num;\n	cout&lt;&lt;\'please input the ask number!\'&lt;&lt;endl;\n	cin&gt;&gt;ask;\n	cout&lt;&lt;\'please input the data!\'&lt;&lt;endl;\n	for(int i=1;i&lt;=num;i++) cin&gt;&gt;data[i];\n}\n\ntemplate&lt;typename T&gt;\nvoid triple&lt;T&gt;::print()\n{\n	cout&lt;&lt;\'After reverse,the data is now!\'&lt;&lt;endl;\n	for(int i=1;i&lt;=num;i++) cout&lt;&lt;data[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl; \n}\n\ntemplate&lt;typename T&gt;\nvoid triple&lt;T&gt;::reverse(int left,int right)   //上面写过的逆序操作\n{\n    T* p1; \n	T* p2;\n	p1=&amp;data[left];\n	p2=&amp;data[right];\n	while(p1&lt;p2)\n	{\n		T t=*p1;\n		*p1=*p2;\n		*p2=t;\n		p1++;\n		p2--;\n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid triple&lt;T&gt;::heart(int left,int right)   //三重反转\n{\n	 reverse(left,ask);\n	 reverse(ask+1,right);\n	 reverse(left,right);\n}\n\nint main()\n{\n	triple&lt;int&gt; my;\n	my.set();\n	my.heart(1,my.returnnum());\n	my.print();\n	return 0;\n}</pre>\n   <br/>\n   <h2>\n    3.应用（归并排序的空间复杂度优化）\n   </h2>\n  </div>\n  <div>\n   众所周知，归并排序虽然拥有可以匹敌快排的速度，但是致命硬伤是我们牺牲了大量的内存（和待排空间一样大小的内存）来进行了时间效率上的优化，但是在小内存的计算机上我们如何才能实现归并排序，而不导致内存溢出呢\n  </div>\n  <div>\n   这里我们就可以通过手摇算法加以应用，\n   <strong>\n    但是我们要明确一点，手摇算法的优化是对时间复杂度是有所牺牲的，下面我会给出手摇算法优化后，时间复杂度到底退化了多少。\n   </strong>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   先要知道，我们优化的是归并排序的插入排序部分，不开辟新的内存从而实现排序（左右各自有序的状态下）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   归并排序就不在多余赘述了，如果有所遗忘 ，欢迎参考我的博客\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52149080\' target=\'_blank\'>\n    地址在这\n   </a>\n  </div>\n  <div>\n   在进行讲解之前，我们首先要先明确一点：\n  </div>\n  <div>\n   <strong>\n    在递归回溯的过程中，归并排序的左子段和右子段都是各自有序的，这一点非常重要\n   </strong>\n  </div>\n  <h3>\n   3.1元素准备：\n  </h3>\n  <div>\n   1.指针p1，指向左子段的开头\n  </div>\n  <div>\n   2.指针p2，指向右子段的开头\n  </div>\n  <h3>\n   <span style=\'font-size:12px\'>\n    3.2算法描述：\n   </span>\n  </h3>\n  <div>\n   <span style=\'font-size:12px\'>\n    1.i指针不断向后移动，直到找到第一个比j指向的元素大的元素或者直到和j相遇\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    2.index指针先代替j指向右端的第一个元素\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    3.j指针不断向后移动，知道找到第一个比i指向元素大的元素或者直到遇到数组的末尾\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    4.将i——index-1段和index——j段进行手摇，之后将i移动j-index+1空位，然后继续上述操作（一旦相遇i，j或者j到达末尾，在该操作4结束后直接结束算法）\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <h3>\n   <span style=\'font-size:12px\'>\n    3.3区间段解释：\n   </span>\n  </h3>\n  <div>\n   1 2 3 4 5 6 7 8 9 10\n  </div>\n  <div>\n   i                j\n  </div>\n  <div>\n   在上述算法的过程中，i--index段都比index+1--j段大，换言之，index+1--j段（这一小段是有序的）应该整体位于i--index段之前，之后的都很好理解了\n  </div>\n  <div>\n   附上例题解释图就好理解了：\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20140421162245765\'/>\n   <br/>\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20140421175043781\'/>\n   <br/>\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20140421175812906\'/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   3.4代码封装：\n  </h3>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1817299\' name=\'code\' snippet_file_name=\'blog_20160808_3_3618585\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass bettermerge\n{\n	public:\n		bettermerge()\n		{\n			memset(data,0,sizeof(data));\n			num=0;\n		}\n		void set();\n		void print();\n		void premerge()\n		{\n			merge(1,num);\n		}\n		void merge(int,int);\n		void tripleone(int,int,int);\n		void tripletwo(int,int,int);\n		void reverse(int left,int right);\n	private:\n		T data[N];\n		int num;\n};\n\ntemplate&lt;typename T&gt;\nvoid bettermerge&lt;T&gt;::set()\n{\n	cout&lt;&lt;\'please input the number the data!\'&lt;&lt;endl;\n	cin&gt;&gt;num;\n	cout&lt;&lt;\'please input the data!\'&lt;&lt;endl;\n	for(int i=1;i&lt;=num;i++) cin&gt;&gt;data[i];\n}\n\ntemplate&lt;typename T&gt;\nvoid bettermerge&lt;T&gt;::print()\n{\n	cout&lt;&lt;\'After the sort，the data is now:\'&lt;&lt;endl;\n	for(int i=1;i&lt;=num;i++) cout&lt;&lt;data[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl;\n}\n\ntemplate&lt;typename T&gt;\nvoid bettermerge&lt;T&gt;::merge(int left,int right)\n{\n	if(left&gt;=right) return ;\n	else\n	{\n		int mid=(left+right)/2;\n		merge(left,mid);\n		merge(mid+1,right);\n		tripleone(left,mid,right);\n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid bettermerge&lt;T&gt;::tripleone(int left,int mid,int right)\n{\n	int i=left;\n	int j=mid+1;\n	int index=j;\n	while(j&lt;=right&amp;&amp;i&lt;j)\n	{\n		while(data[i]&lt;=data[j]&amp;&amp;i&lt;j)   //注意这里，如果是 &lt;= 那么优化后的归并排序是稳定的，否则就是不稳定的\n		{\n			i++;\n		}\n		if(i==j) break;\n		index=j;\n		while(data[j]&lt;data[i]&amp;&amp;j&lt;=right) j++;   //这里没有上面的影响，仔细想一下就会明白 \n		tripletwo(i,index-1,j-1);\n		i+=j-index;   //j-1-index+1=j-index(后一段的长度)，记住小心这里j是比data[i]大的，data[j-1]才是要移动的字段的后端 \n	}\n}\n\ntemplate&lt;typename T&gt;\nvoid bettermerge&lt;T&gt;::tripletwo(int left,int mid,int right)\n{\n	reverse(left,mid);\n	reverse(mid+1,right);\n	reverse(left,right);\n} \n\ntemplate&lt;typename T&gt;\nvoid bettermerge&lt;T&gt;::reverse(int left,int right)\n{\n	T* p1=&amp;data[left];\n	T* p2=&amp;data[right];\n	while(p1&lt;p2)\n	{\n		T t=*p1;\n		*p1=*p2;\n		*p2=t;\n		p1++;\n		p2--;\n	}\n}\n\nint main()\n{\n	bettermerge&lt;int&gt; my;\n	my.set();\n	my.premerge();\n	my.print();\n	return 0;\n}</pre>\n   <br/>\n   <h4>\n    3.5时间复杂度退化计算：\n   </h4>\n  </div>\n  <div>\n   首先我们要明确手摇算法的时间复杂度：\n  </div>\n  <div>\n   因为手摇算法相当于将数组惊醒了两次遍历，去掉常数项之后，时间复杂度是O(n)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   最好的情况：左子段和右子段直接全部交换\n  </div>\n  <div>\n   很明显此时原地归并的复杂度还是O(n*logn\n   <span style=\'font-size:12px\'>\n    )\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    最坏的情况：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    一段一段的缓慢前进的情况;此时算法的时间复杂度就是n*n\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    原地归并的复杂度就是O(n*n*logn)\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    显然这时候，虽然我们手摇算法将空间复杂度优化到了O(1)，但是我们牺牲了相对的时间\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    综合起来原地归并的时间复杂度在O(n*logn)--O(n*n*logn\n   </span>\n   <span style=\'font-size:12px\'>\n    )之间，而空间复杂度降到了O(1)，是可以满足我们特定的要求的\n   </span>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4fc324574064008eb3b9c3984b4ec76c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题003（归并排序/动态规划）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   微软面试百题003 求子数组最大和\n  </h1>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   请在O(n)时间复杂度之内求出数组的子数组最大和\n  </div>\n  <div>\n   在这里我们详细来讲解两种思路：\n  </div>\n  <div>\n   O(n*logn)：分治法：归并排序\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52149080\' target=\'_blank\'>\n    本博主的归并排序求最大子数组的详解\n   </a>\n  </div>\n  <div>\n   O(n) 动态规划\n  </div>\n  <h2>\n   2.动态规划的思路解析：\n  </h2>\n  <div>\n   我们这里采用动态规划的思路来解释一下，动态规划的核心在于缩小问题的规模\n  </div>\n  <div>\n   我们这里需要先作如下几个准备操作;\n  </div>\n  <div>\n   1.定义状态\n  </div>\n  <div>\n   2.定义状态转移方程\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态：我们设dp，定义状态，dp[i]的含义是i之前(必须包含data[i]这个元素)的元素中的最大的和，当我们遍历完整个数组之后自然就求出了整个数组中的最大子数组的和，我们额外用max来记录一下目前为止的所有的最大和就可以了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   状态转移方程:\n  </div>\n  <div>\n   <span style=\'margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n    <strong>\n     如果当前和为负数，那么就放弃前面的累加和，从数组中的下一个数再开始计数\n    </strong>\n   </span>\n   <br/>\n  </div>\n  <div>\n   如果一旦出现sum&lt;0(sum是前面的和)说明下一次他一定会拖累我们的最大值的出现，所以说还不如不要，直接将sum重置为0，重新以data[i]开始\n  </div>\n  <div>\n   dp[i]=max(data[i],sum+data[i])\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.C++代码封装实现：\n  </h2>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1815820\' name=\'code\' snippet_file_name=\'blog_20160808_1_84396\'>#include\'iostream\'\n#include\'cstring\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class smax;\ntemplate&lt;typename T&gt; istream&amp; operator&gt;&gt;(istream&amp;,smax&lt;T&gt;&amp;);\n\ntemplate&lt;typename T&gt; \nclass smax\n{\n	public:\n		smax()\n		{\n			memset(data,0,sizeof(data));\n			ans=num=0;\n		}\n		friend istream&amp; operator&gt;&gt;&lt;&gt;(istream&amp;,smax&lt;T&gt;&amp;);\n		T returnans();\n	private:\n		T data[N];\n		T ans;\n		int num;\n};\n\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp; in,smax&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'please input the number of the data!\'&lt;&lt;endl;\n	in&gt;&gt;k.num;\n	cout&lt;&lt;\'please input the data!\'&lt;&lt;endl;\n	for(int i=1;i&lt;=k.num;i++) cin&gt;&gt;k.data[i];\n	return in;\n}\n\ntemplate&lt;typename T&gt;\nT smax&lt;T&gt;::returnans()\n{\n	T sum=0;\n	for(int i=1;i&lt;=num;i++)\n	{\n		if(sum&lt;0) sum=data[i];\n		else sum+=data[i];\n		if(sum&gt;ans) ans=sum;\n	}\n	return ans;\n}\n\nint main()\n{\n	smax&lt;int&gt; my;\n	cin&gt;&gt;my;\n	cout&lt;&lt;my.returnans()&lt;&lt;endl;\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('d53006af98561402ab1be69090ece96a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  归并排序全解（含复杂度证明）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   归并排序\n  </h1>\n  <h2>\n   1.归并排序简介：\n  </h2>\n  <div>\n   归并排序是建立在多次递归的基础上的合并操作的排序算法，是一种建立在归并操作上的有效的排序算法，该算法是采用分治法的一个典型的用例，正因为采用了分治法，并且是二路分支，（我们也称其为二路归并），所以说归并排序的递归树始终是均衡的，在这一点上，归并排序相对于快速排序有明显的优越性（但是实际上因为牵扯到cache的概念，所以归并排序的实际的算法的速度是慢于快速排序的），在这上面本人参考了大量的博客和怠慢论坛但是都看不出快速排序，归并排序，堆排序，希尔排序的真正的忧虑，实感羞愧\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <strong>\n    因为我们在进行子数组归并的时候完全是按照数组的从左至右的顺序的，所以说，归并排序是稳定的排序\n   </strong>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   归并排序的递归树附图：\n  </div>\n  <div>\n   <img alt=\'\' src=\'http://img1.imgtn.bdimg.com/it/u=805691483,1872538022&amp;fm=21&amp;gp=0.jpg\'/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   优点：归并排序只对相邻的数组元素进行处理，所以相对来说归并排序的速度有可能在某一数据量区域内优于普通快排\n  </div>\n  <div>\n   缺点：归并排序占用了大量的内存空间（\n   <strong>\n    占用了和原数组等长的空间，一旦待排数组的量非常巨大的话，这完全是致命的缺点\n   </strong>\n   ）里进行排序操作，所以来说，归并排序在大数据的时候很容易造成内存的溢出。\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.算法讲解：\n  </h2>\n  <div>\n   算法的整体讲解：\n  </div>\n  <div>\n   我们通过不断的递归，直到每个小段的数据长度只有自身的时候我们自动认为此时已经达到了我们所谓的有序的状态，然后我们进行挑选式的插入排序操作，在这一段里面复杂度仅仅只是我们遍历的长度的大小，即O(n),所以说还是非常高效的（但是要认识到，我们这是采用了空间换时间来进行优化的）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   在算法的整体结构上，我们对于整个算法都可以分成两块来进行考虑\n  </div>\n  <div>\n   第一块代码段：\n  </div>\n  <div>\n   就是刚才提到的，对每段相邻的采取刚才提及的插入的排序\n  </div>\n  <div>\n   第二块代码段：\n  </div>\n  <div>\n   多次递归，当达到我们的递归终止条件（每段只有一个元素，默认有序）的时候，进行回溯的归并操作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   算法的复杂度证明：\n  </div>\n  <div>\n   因为归并排序算法是二分的，所以说分自然而然有以下的证明：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1815781\' name=\'code\' snippet_file_name=\'blog_20160808_1_873360\'>T(n)=2T(n/2)+f(n)  注意这里的f(n)的考虑是从后往前的，因为归并排序优点类似于二叉树的后序遍历，所以说f(n)代表每一层的递归树的归并操作，所以说f(n)是O(n)\nT(n)=4T(n/4)+2f(n)\n...log2n=k,共进行k层递归 \nT(n)= nT(1)+kf(n)=O(n*logn) </pre>\n   <br/>\n  </div>\n  <h2>\n   3.算法的实现：\n  </h2>\n  <div>\n   C++代码类封装：(代码中我会进行更详细的讲解)\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1815781\' name=\'code\' snippet_file_name=\'blog_20160808_2_6871388\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n#define inf 99999999 \n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class mergesort;\ntemplate&lt;typename T&gt; istream&amp; operator&gt;&gt;(istream&amp;,mergesort&lt;T&gt;&amp;);\ntemplate&lt;typename T&gt; ostream&amp; operator&lt;&lt;(ostream&amp;,mergesort&lt;T&gt;&amp;);\n\ntemplate&lt;typename T&gt;   //需要扩展O(n)的空间复杂度来实现排序操作 \nclass mergesort\n{\n	public:\n		mergesort()\n		{\n			memset(data,0,sizeof(data));\n			num=0;\n		}\n		friend istream&amp; operator&gt;&gt;&lt;&gt;(istream&amp;,mergesort&lt;T&gt;&amp;);\n		friend ostream&amp; operator&lt;&lt;&lt;&gt;(ostream&amp;,mergesort&lt;T&gt;&amp;);\n		void premerge()\n		{\n			merge_sort(1,num);\n		}\n		void merge_sort(int,int);\n		void mergearray(int,int,int); \n	private:\n		T data[N];\n		int num;\n};\n\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp; in,mergesort&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'please input the number of the data!\'&lt;&lt;endl;\n	cin&gt;&gt;k.num;\n	for(int i=1;i&lt;=k.num;i++) cin&gt;&gt;k.data[i];\n	return in;\n} \n\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; out,mergesort&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'排序结果如下：\'&lt;&lt;endl;\n	for(int i=1;i&lt;=k.num;i++) cout&lt;&lt;k.data[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl;\n	return out;\n}\n\ntemplate&lt;typename T&gt;\nvoid mergesort&lt;T&gt;::merge_sort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	int mid=(left+right)/2;\n	merge_sort(left,mid);\n	merge_sort(mid+1,right);\n	mergearray(left,mid,right);\n	return ;\n}\n\ntemplate&lt;typename T&gt;\nvoid mergesort&lt;T&gt;::mergearray(int left,int center,int right)\n{\n	int n1=center-left+1;\n	int n2=right-center;\n	T s1[n1+2];   //从1开始，并且最后一个元素设定成监视哨（虽然这么做会将空间复杂度提升至O(n+logn)但是毕竟好实现） \n	T s2[n2+2];\n	int j=1;\n	for(int i=left;i&lt;=center;i++,j++) s1[j]=data[i];\n	j=1;\n	for(int i=center+1;i&lt;=right;i++,j++) s2[j]=data[i];\n	int i=1;j=1;\n	s1[n1+1]=s2[n2+1]=inf;   //监视哨 \n	for(int k=left;k&lt;=right;k++)   //插入排序的过程 \n	{\n		if(s1[i]&lt;s2[j]) data[k]=s1[i++];\n		else data[k]=s2[j++];\n	}\n}\n\nint main()\n{\n	mergesort&lt;int&gt; my1;\n	mergesort&lt;double&gt; my2;\n	cin&gt;&gt;my1&gt;&gt;my2;\n	my1.premerge();\n	my2.premerge();\n	cout&lt;&lt;my1&lt;&lt;my2&lt;&lt;endl; \n	return 0;\n}</pre>\n   <br/>\n   <h2>\n    4.归并排序的应用：\n   </h2>\n  </div>\n  <h3>\n   4.1归并排序求最大逆序对数\n  </h3>\n  <div>\n   我们知道求最大逆序对数的一个方法就是从头到尾都扫一遍，时间复杂度是：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1815781\' name=\'code\' snippet_file_name=\'blog_20160808_3_3632785\'>T(n)=1+2+...+n-1=O(n*n)</pre>\n   但是通过归并排序我们可以将方法的时间复杂度优化到O(n*logn)\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   思路如下：\n  </div>\n  <div>\n   我们能可以发现，在归并的回溯过程中，我们前一段子数组始终是有序状态，后一段子数组始终是待有序状态（只有后一段也有序了，我们才开始下一次归并）\n  </div>\n  <div>\n   当后一组有序的时候，我们开始归并，在不断插入的时候我们如果发现了前一段中的某个元素比后一段的某个元素要大的时候，那么这个元素到前一段子数组的末尾这一段的元素都满足相同的状态，那么子数组的求解就会大大加快\n  </div>\n  <div>\n   但是有的人就会问了，难道这样不会重复计算吗，大男士不会的，因为我们每次是一段一段的来考虑：\n  </div>\n  <div>\n   这一个一段一段是这样理解的，前一段元素和后一段元素之间存在的逆序对的关系（数目）是不会随着前一段的排序和后一段的排序索引项的，我们之前计算的前一段的之间的逆序对数似小范围的，我们之后是不断将其范围进行扩大之后进行判断的，是完全正确的思路\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   又有的人可能会问，那么可不可以只记录不排序呢，这样会不会可以将时间复杂度在此优化呢:\n  </div>\n  <div>\n   这里的话，我们只能说有点异想天开了，我们上面的考虑都是在基于前一段子数组和后一段子数组的有序的情况下考虑的，所以说排序是必不可少的部分，只有排序我们才可以将重复的遍历的累计计算通过有序的方式简化为O(1)的数学表达式计算（下面的注释处）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   附上代码：（在刚才的地方进行类小改动而已）\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1815781\' name=\'code\' snippet_file_name=\'blog_20160808_4_361163\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n#define inf 99999999 \n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class mergesort;\ntemplate&lt;typename T&gt; istream&amp; operator&gt;&gt;(istream&amp;,mergesort&lt;T&gt;&amp;);\ntemplate&lt;typename T&gt; ostream&amp; operator&lt;&lt;(ostream&amp;,mergesort&lt;T&gt;&amp;);\n\ntemplate&lt;typename T&gt;   //需要扩展O(n)的空间复杂度来实现排序操作 \nclass mergesort\n{\n	public:\n		mergesort()\n		{\n			memset(data,0,sizeof(data));\n			num=0;\n			ans=0;\n		}\n		friend istream&amp; operator&gt;&gt;&lt;&gt;(istream&amp;,mergesort&lt;T&gt;&amp;);\n		friend ostream&amp; operator&lt;&lt;&lt;&gt;(ostream&amp;,mergesort&lt;T&gt;&amp;);\n		void premerge()\n		{\n			merge_sort(1,num);\n		}\n		void merge_sort(int,int);\n		void mergearray(int,int,int);\n	private:\n		T data[N];\n		int num;\n		int ans;\n};\n\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp; in,mergesort&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'please input the number of the data!\'&lt;&lt;endl;\n	cin&gt;&gt;k.num;\n	for(int i=1;i&lt;=k.num;i++) cin&gt;&gt;k.data[i];\n	return in;\n} \n\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; out,mergesort&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'排序结果如下：\'&lt;&lt;endl;\n	for(int i=1;i&lt;=k.num;i++) cout&lt;&lt;k.data[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl&lt;&lt;\'逆序对数为：\'&lt;&lt;k.ans&lt;&lt;endl;\n	return out;\n}\n\ntemplate&lt;typename T&gt;\nvoid mergesort&lt;T&gt;::merge_sort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	int mid=(left+right)/2;\n	merge_sort(left,mid);\n	merge_sort(mid+1,right);\n	mergearray(left,mid,right);\n	return ;\n}\n\ntemplate&lt;typename T&gt;\nvoid mergesort&lt;T&gt;::mergearray(int left,int center,int right)\n{\n	int n1=center-left+1;\n	int n2=right-center;\n	T s1[n1+2];   //从1开始，并且最后一个元素设定成监视哨（虽然这么做会将空间复杂度提升至O(n+logn)但是毕竟好实现） \n	T s2[n2+2];\n	int j=1;\n	for(int i=left;i&lt;=center;i++,j++) s1[j]=data[i];\n	j=1;\n	for(int i=center+1;i&lt;=right;i++,j++) s2[j]=data[i];\n	int i=1;j=1;\n	s1[n1+1]=s2[n2+1]=inf;   //监视哨 \n	for(int k=left;k&lt;=right;k++)   //插入排序的过程 \n	{\n		if(s1[i]&lt;=s2[j]) data[k]=s1[i++];\n		else    //满足逆序的条件\n		{\n			data[k]=s2[j++];\n			ans+=center-left+1-i+1;    //这就是上面讲解的部分\n		}\n	}\n}\n\nint main()\n{\n	mergesort&lt;int&gt; my1;\n	mergesort&lt;double&gt; my2;\n	cin&gt;&gt;my1&gt;&gt;my2;\n	my1.premerge();\n	my2.premerge();\n	cout&lt;&lt;my1&lt;&lt;my2&lt;&lt;endl; \n	return 0;\n}</pre>\n   <br/>\n  </div>\n  <h3>\n   4.2求最大子数组和（O(n*logn)）（下一篇博文会再次介绍O(n)的动态规划思路求解）\n  </h3>\n  <div>\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52148694\' target=\'_blank\'>\n    动态规划求解\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/50773600\' target=\'_blank\'>\n    先附上本博主几个月的前的分治法求最大子数组的讲解\n   </a>\n   <br/>\n  </div>\n  <div>\n   首先我们要明确一点，最大字数组只会有三种情况\n  </div>\n  <div>\n   1.全部在左半边\n  </div>\n  <div>\n   2.全部在右半边\n  </div>\n  <div>\n   3.横跨左中右（计算的时候我们从重点开始向两边扩展进行计算）\n  </div>\n  <div>\n   那么我们分治法（归并）的思路就是每次通过求解上一层的最大子数组返回其值来求出这一层的最大值，最后三者（上面讨论的）比较就好了\n  </div>\n  <div>\n   附上C++封装的代码：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1815781\' name=\'code\' snippet_file_name=\'blog_20160808_5_3218864\'>#include\'iostream\'\n#include\'cstdlib\'\n#include\'cstdio\'\n#include\'cstring\'\n#define N 100\n#define inf -99999999\n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class submax;\n\ntemplate&lt;typename T&gt; class submax;\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp;,submax&lt;T&gt;&amp;);\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp;,submax&lt;T&gt;&amp;);\n\ntemplate&lt;typename T&gt;\nclass submax\n{\n	public:\n		submax()\n		{\n			memset(data,0,sizeof(data));\n			num=ans=0;\n		}\n		friend istream&amp; operator&gt;&gt;&lt;&gt;(istream&amp;,submax&lt;T&gt;&amp;);\n		friend ostream&amp; operator&lt;&lt;&lt;&gt;(ostream&amp;,submax&lt;T&gt;&amp;);\n		void premerge()\n		{\n			ans=merge(1,num);\n		}\n		T merge(int,int);\n		T submaxcross(int,int,int);\n	private:\n		T data[N];\n		int num;\n		T ans;\n};\n\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp; in,submax&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'请输入你的数组的个数:\';cin&gt;&gt;k.num; \n	cout&lt;&lt;\'请输入你的数组\'&lt;&lt;endl;\n	for(int i=1;i&lt;=k.num;i++) cin&gt;&gt;k.data[i];\n	return in; \n}\n\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; out,submax&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'你所输入的数组的最大子数组之和是：\'&lt;&lt;k.ans&lt;&lt;endl;\n	return out; \n}\n\ntemplate&lt;typename T&gt;\nT submax&lt;T&gt;::merge(int left,int right)\n{\n	if(left&gt;=right);\n	else\n	{\n		T leftsum=inf;\n		T rightsum=inf;\n		T crosssum=inf;\n		int mid=(left+right)/2;\n		leftsum=merge(left,mid);\n		rightsum=merge(mid+1,right);\n		crosssum=submaxcross(left,mid,right);\n		if(leftsum&gt;rightsum&amp;&amp;leftsum&gt;crosssum) return leftsum;\n		else\n		{\n			if(rightsum&gt;leftsum&amp;&amp;rightsum&gt;crosssum) return rightsum;\n			else return crosssum;\n		} \n	}\n}\n\ntemplate&lt;typename T&gt;\nT submax&lt;T&gt;::submaxcross(int left,int mid,int right)\n{\n	T leftsum=inf;\n	T rightsum=inf;\n	T sum=0;\n	for(int i=mid;i&gt;=left;i--)\n	{\n		sum+=data[i];\n		if(sum&gt;leftsum) leftsum=sum;\n	} \n	sum=0;\n	for(int i=mid+1;i&lt;=right;i++)\n	{\n		sum+=data[i];\n		if(sum&gt;rightsum) rightsum=sum;\n	}\n	return leftsum+rightsum;\n}\n\nint main()\n{\n	submax&lt;int&gt; my1;\n	submax&lt;double&gt; my2;\n	cin&gt;&gt;my1&gt;&gt;my2;\n	my1.premerge();\n	my2.premerge();\n	cout&lt;&lt;my1&lt;&lt;my2&lt;&lt;endl;\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   5.归并排序的空间复杂度优化的思考（原地归并）\n  </h2>\n  <div>\n   先附上参考文献：\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52155097\' target=\'_blank\'>\n    本博主的原地归并算法全面讲解+手摇算法\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/hitxueliang/article/details/7542607\' target=\'_blank\'>\n    http://blog.csdn.net/hitxueliang/article/details/7542607\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://www.92to.com/bangong/2016/06-30/6929855.html\' target=\'_blank\'>\n    http://www.92to.com/bangong/2016/06-30/6929855.html\n   </a>\n   <br/>\n  </div>\n  <h2>\n   6.思考问题：\n  </h2>\n  <div>\n   1.如何记录最大子数组\n  </div>\n  <div>\n   2.还是没有彻底了解原地归并的原理（手摇算法） 本问题已经解决\n  </div>\n  <div>\n   3.还是不懂为什么归并相对快排来说慢，cache到底影响在了哪里？\n  </div>\n  <h2>\n   7.参考文献：\n  </h2>\n  <div>\n   <a href=\'http://blog.csdn.net/shawn_hou/article/details/38059701\' target=\'_blank\'>\n    http://blog.csdn.net/shawn_hou/article/details/38059701\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://zhidao.baidu.com/link?url=GbttGQ8bg-l2AlT7A-uibWXyLBDDhnmLETC1w2fsOc_jsc6JdE-jw01D8dvjTc757UG9vjVycejyaDAd1yclI5ZrmzixH81aCzuuXZrwoQi\' target=\'_blank\'>\n    http://zhidao.baidu.com/link?url=GbttGQ8bg-l2AlT7A-uibWXyLBDDhnmLETC1w2fsOc_jsc6JdE-jw01D8dvjTc757UG9vjVycejyaDAd1yclI5ZrmzixH81aCzuuXZrwoQi\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/morewindows/article/details/6678165/\' target=\'_blank\'>\n    http://blog.csdn.net/morewindows/article/details/6678165/\n   </a>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('253316d7fde83fe0c03ca44883156572','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  快速排序全面讲解（含复杂度证明）——即将引出八大排序算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   全面解析快速排序（包括证明）\n  </h1>\n  <h2>\n   1.快速排序简介：\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   好看的图：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150602150852238\'/>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   快速排序是目前公认的平均状态下速度最快的一种排序算法\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   优点如下：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   1.原地排序：空间复杂度为O(1)，相对于归并排序来说，占用非常小的内存便可以实现很高效的排序的效果\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   2.平均状态下的时间复杂度始终未O(logN)，属于非常高效的排序算法（下面会给出证明）\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   缺点如下：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   快速排序是不稳定的排序，因为牵扯到空间地址的跳跃交换，所以快速排序不能够保证在出现相同的元素的情况下的稳定的排序效果\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <h2>\n   2.快速排序的时间复杂度分析：\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   在参考了中国大神的笔记之后，对快排这类递归式 的分支算法的复杂度的分析有了如下几个认识：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   1.任意一个递归式的算法的复杂度很大程度上要考虑到递归树的深度（快排的递归的深度我之后会援引大神的图片来解释）\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   2.任意一个算法的市价复杂度Log（k,n），不管k的大小，只要k是属于常数级别的我们都可以将其考虑成log（2，n）的复杂度也就是O(\n   <span style=\'font-size:13.3333px\'>\n    logN\n   </span>\n   )的复杂度，这一点我们应用的是高中的对数的换底公式，正因为这一点，快速排序的划分只要是常数倍数的，不管是1:99,1:999,1:9999，只要不是1：(n-1) ,那么在考虑到数据足够大的情况下，我们的时间复杂度还是O(logN)，所以说，平均状态下，快排效果最好\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   3.对于快速排序，我们需要记住一点，复杂度是完全体现在画风的平衡性上的，划分的越均衡（二叉递归树越趋近于满二叉树），那么二叉树的深度就越浅，当然我们递归的深度就会越小，时间复杂度就会越低，排序的效果就会越好，（1:9的递归树表示如下图所示）\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <img alt=\'示例图片\' src=\'http://hi.csdn.net/attachment/201111/17/0_13215376015m1V.gif\'/>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   4.快速排序的最优复杂度证明：（常数倍数的都可以通过类似的方式导出）\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'1815012\' name=\'code\' snippet_file_name=\'blog_20160807_1_6434488\'>T(n)=2T(n/2)+f(n)----f(n)-O(n),因为实际上我们对每一层递归树进行划分的时候，都是将整个数组都遍历了一遍 \nT(n)=4T(n/4)+2f(n)\n...log2N=k，共进行k次 \nT(n)=nT(1)+kf(n)=O(n)+kO(n)==kO(n)=O(n*logn) </pre>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   但是当我们每次划分的比例都是1：n-1，即最坏的情况的话\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'1815012\' name=\'code\' snippet_file_name=\'blog_20160807_2_3435083\'>T(n)=T(1)+T(n-1)+f(n)=nT(1)+(n-1)f(n)=O(n*n)</pre>\n   <br/>\n   <h2>\n    3.算法讲解：\n   </h2>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   1.引入算法到轮的伪代码：（看不懂？下面有详解）\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <p style=\'margin:0in 0in 10pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     QUICKSORT(A, p, r)//\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     快速排序算法\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 10pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     if (p &lt; r )\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 10pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     {\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 10pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     q = PARTITION(A, p, r)//\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     分成左右两半，一半不大于\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[r],\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     一半不小于\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[r]\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 10pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     QUICKSORT(A, p, q-1)//\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     递归左半\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 10pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     QUICKSORT(A, q+1, r) //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     递归右半\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 10pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     }\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 10pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n   </p>\n   <p style=\'margin:0in 0in 10pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     PARTITION(A, p, r)\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     x\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     =\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[r]\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     选择最后一个元素作为比较元素\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     = p\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     –\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     这个慢速移动下标必须设定为比最小下表\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     p\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     小\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     ，否则两个元素的序列比如\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     2\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     ，\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     无法交换\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px\'>\n     <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n      for\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     j\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     =\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     p\n    </span>\n    <span style=\'margin:0px; padding:0px\'>\n     <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n      to\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     r-1\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     遍历每个元素\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     {\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px\'>\n     <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n      if (\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[j]\r\n &lt;=\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     x)\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     比较\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px\'>\n     <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n      {\n     </span>\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 1in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     =\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     +\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     移动慢速下标\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 1in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     Exchange\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[i]\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     with\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[j\r\n ]\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     交换\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt 0.5in; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     }\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     }\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     Exchange\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[i+1]\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     with\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     A[r]\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     交换\n    </span>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n   </p>\n   <p style=\'margin:0in 0in 0pt; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; background-color:rgb(245,250,254)\'>\n    <span style=\'margin:0px; padding:0px\'>\n     <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n      return\n     </span>\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     i\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     +\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     1\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     //\n    </span>\n    <span style=\'margin:0px; padding:0px; line-height:1.5; font-family:\'Comic Sans MS\'; font-size:14pt\'>\n     返回分割点\n    </span>\n   </p>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   在这里我对上面的核心部分，即partion函数给出自己用的一点帮助理解的想法思路：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   首先我们可能最难看懂的就是i和j的关系，我们 可以这么来考虑\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   在j不断向前进的过程中，i之前的元素都是比划分点小的，i——j之间的元素都是比i大的，j之后的元素都是未知的，是需要我们之后去遍历来看的\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   那么首先i要比左界要少1的想法思路在于这一点：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   因为我们可以通过伪代码发现，每次i出的元素都是比划分点小的集合的最右端，下一次我们和适合的j号元素进行交换的话，我们必须要先将i前进一格再进行交换，但是一开始，我们只能通过让i比左界小1的方式来通用化这种具体的实现操作\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   之后我们会发现要必须交换一次i+1和划分点（右界），这是为什么呢：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   因为我们要保证划分点左侧都比划分点小，右侧比划分点大，那么i+1实际上是属于右侧的，我们将其交换位置是合情合理的事情，也是必须要做的事情\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   之后的就是返回这个划分点的位置然后分段递归的操作了\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   例题图片详解：\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <img alt=\'\' src=\'http://images.cnblogs.com/cnblogs_com/pugang/QuickSort.JPG\'/>\n   <br/>\n  </div>\n  <h2>\n   4.C++代码封装实现：（牵扯到友元函数的模板的一个问题）\n  </h2>\n  <h3>\n   1.算法导论中的实现\n  </h3>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'1815012\' name=\'code\' snippet_file_name=\'blog_20160807_3_1864919\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class Qsort;\n\ntemplate&lt;typename T&gt; \nostream&amp; operator&lt;&lt;(ostream&amp;,Qsort&lt;T&gt;&amp;);\ntemplate&lt;typename T&gt; \nistream&amp; operator&gt;&gt;(istream&amp;,Qsort&lt;T&gt;&amp;);\n\ntemplate&lt;typename T&gt;   //算法导论的版本 \nclass Qsort\n{\n	public:\n		Qsort()\n		{\n			memset(data,0,sizeof(data));\n			num=0;\n		}\n		friend ostream&amp; operator&lt;&lt;&lt;&gt;(ostream&amp;,Qsort&lt;T&gt;&amp;);\n		friend istream&amp; operator&gt;&gt;&lt;&gt;(istream&amp;,Qsort&lt;T&gt;&amp;);\n		int partion(int,int);\n		void sort(int,int);\n		void presort()\n		{\n			sort(1,num);\n		}\n		void swap(int i,int j)\n		{\n			T t=data[j];\n			data[j]=data[i];\n			data[i]=t;\n		}\n	private:\n		T data[N];\n		int num;\n};\n\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; out,Qsort&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'Qsort结果如下:\'&lt;&lt;endl;\n	for(int i=1;i&lt;=k.num;i++) cout&lt;&lt;k.data[i]&lt;&lt;\' \';\n	cout&lt;&lt;endl;\n	return out;\n}\n\ntemplate&lt;typename T&gt;\nistream&amp; operator&gt;&gt;(istream&amp; in,Qsort&lt;T&gt;&amp; k)\n{\n	cout&lt;&lt;\'please input the number of your data!\'&lt;&lt;endl;\n	cin&gt;&gt;k.num;\n	for(int i=1;i&lt;=k.num;i++) cin&gt;&gt;k.data[i];\n	return in;  //为了实现流的连续输入 \n}\n\ntemplate&lt;typename T&gt;\nint Qsort&lt;T&gt;::partion(int left,int right)\n{\n	T key=data[right];\n	int i=left-1;\n	int j=left;\n	for(;j&lt;right;j++)\n	{\n		if(data[j]&lt;key)\n		{\n			i++;\n			swap(i,j);\n		}\n	}\n	swap(i+1,right);\n	return i+1;\n} \n\ntemplate&lt;typename T&gt;\nvoid Qsort&lt;T&gt;::sort(int left,int right)\n{\n	if(left&gt;=right) return ;\n	int q=partion(left,right);\n	sort(left,q-1);\n	sort(q+1,right);\n}\n\nint main()\n{\n	Qsort&lt;int&gt; my1;\n	Qsort&lt;double&gt; my2;\n	cin&gt;&gt;my1&gt;&gt;my2;\n	my1.presort();\n	my2.presort();\n	cout&lt;&lt;my1&lt;&lt;my2&lt;&lt;endl;\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   关于上面的模板类的友元函数的问题：（在代码讨论区中有如下有效的解答）\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'1815012\' name=\'code\' snippet_file_name=\'blog_20160807_4_8658552\'>//---test.h\n \n#ifndef test_h_\n#define test_h_\n#include &lt;iostream&gt;\nusing namespace std;\n \n// 改动一：增加函数模板的声明——而这又需要先声明类模板\ntemplate &lt;class T&gt; class Test;\ntemplate &lt;class T&gt;\nvoid display(Test&lt;T&gt; &amp;t);\n\ntemplate &lt;class T&gt;\nclass Test\n{\nprivate:\n    T x;\npublic:\n    Test (T x_): x(x_) {}\n    friend void display&lt;&gt;(Test&lt;T&gt; &amp;t);\n// 改动二：在函数名后面加上&lt;&gt;，指明它是之前声明的函数模板 的实例\n};\n \ntemplate &lt;class T&gt;\nvoid display(Test&lt;T&gt; &amp;t)\n{\n    cout &lt;&lt; t.x &lt;&lt; endl;\n}\n \n \n#endif // test_h_</pre>\n   <br/>\n   <h3>\n    2.参考的另一种好实现的简约化代码实现\n   </h3>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   （只付上核心代码段）原理记住上面的会实现会写会理解就好，这个当做模板来记吧\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <pre class=\'cpp\' code_snippet_id=\'1815012\' name=\'code\' snippet_file_name=\'blog_20160807_5_468697\'>void quicksort(int left,int right)\n{\n	if(left&gt;right) return ;\n	else\n	{\n		int i=left;\n		int j=right;\n		T t;\n		T temp=data[left];\n		while(i!=j)\n		{\n			while(i&lt;j&amp;&amp;data[j]&gt;=temp) j--;  //记住必须先动j \n			while(i&lt;j&amp;&amp;data[i]&lt;=temp) i++;\n			if(i!=j) swap(i,j);  //原地交换 \n		}\n		swap(left,i);\n		quicksort(left,i-1);\n		quicksort(i+1,right); \n	}\n}</pre>\n   <br/>\n  </div>\n  <h2>\n   5.拓展阅读：快排的优化（随机化快排）\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   <a href=\'http://blog.csdn.net/in_aday/article/details/47253435\' target=\'_blank\'>\n    随机化快排解释\n   </a>\n   <br/>\n  </div>\n  <h2>\n   6.参考文献：\n  </h2>\n  <div style=\'font-size:13.3333px\'>\n   <a href=\'http://blog.csdn.net/nvfumayx/article/details/6979197\' target=\'_blank\'>\n    参考博客1（强烈推荐）\n   </a>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <a href=\'http://www.cnblogs.com/pugang/archive/2012/06/27/2565093.html\' target=\'_blank\'>\n    参考博客2（必看）\n   </a>\n   <br/>\n  </div>\n  <div style=\'font-size:13.3333px\'>\n   <a href=\'http://blog.csdn.net/acm_lkl/article/details/44209121\' target=\'_blank\'>\n    参考博客3（选看）\n   </a>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('478db79c5f06e4ad6ca63e3c977e1d66','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题002——返回优先级的栈\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   微软面试百题002——看上去貌似很简单实则暗藏杀机 优先栈\n  </h1>\n  <h2>\n   1.问题描述：\n  </h2>\n  <div>\n   设计一个栈，添加min函数，可以让我们在O(1)时间复杂度内完成push，pop以及min操作（min操作返回栈内权值最小的元素）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   首先我们先来复习一下栈这个数据结构的性质：\n  </div>\n  <div>\n   栈作为一种先进先出的数据结构，pop出去的一定是刚刚才push进来的元素\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   但是本题中又牵扯到了min函数，又让我们感觉到了一丝一丝的优先队列的感觉\n  </div>\n  <h2>\n   2.思维发展导图\n  </h2>\n  <div>\n   1.首先刚开始想到既然是优先化一个栈的话，我已开始是这么考虑的，近顺序的存储结构很难来进行min的操作，可不可以采用链栈的方式呢\n  </div>\n  <div>\n   我是这么考虑的，链栈的话我们只需要额外开辟一个节点指向最小的元素节点就可以了，这不就轻松搞定了吗\n  </div>\n  <div>\n   显然这么做少考虑了一点，如果最小的成为栈顶的话，没有保存倒数第二小节点地址的我们就绝对会出错，导致我们之后的min的跟踪失败，而要是依旧采用链栈的话，我们为了解决这个问题就必须要开辟大量的节点保存最小信息，反而将问题复杂化了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.再次开辟一个内存空间，实现的内容是反向优先队列，用来保存递减的顺序\n  </div>\n  <div>\n   在这里可能就有人会问难道不会出现和上面一样的错误码，实际上我们可以证明，是不会出现那样的错误的，因为这个优先队列始终是保持递减有序的，我们pop的时候如果遇到在优先队列中的元素的话，同步pop，否则优先队列不变，这样做的话，一个优先队列中的节点如果存在一个比他先出现的且比他大的元素是一定在优先队列中比他更靠前的位置中的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   3.\n   <strong>\n    动态规划的应用：\n   </strong>\n   这个是参考了大神的笔记后发现还可以采用动态规划的思想，虽然一样占用了和第二种方法一样大的内存空间，但是这样子做的话就少了对另一种数据结构的维护，并且动态规划的思想也是非常的而优秀的\n  </div>\n  <div>\n   我们对于每一个节点不仅开辟内存保留原本应该保留的键值，我们还开辟内存保存该节点之前的栈的元素的最小值，那么根据动态规划的原理，我们只需要维护当前的节点就好\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.代码实现：（C++类封装）\n  </h2>\n  <h3>\n   3.1动态规划的思想：\n  </h3>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1814089\' name=\'code\' snippet_file_name=\'blog_20160807_1_7270593\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nstruct node\n{\n	T key;\n	T min;\n};\n\ntemplate&lt;typename T&gt;\nclass prestack\n{\n	public:\n		prestack()\n		{\n			memset(content,0,sizeof(content));\n			top=0;\n		} \n		void push(T);\n		T pop();\n		T min();\n	private:\n		struct node&lt;T&gt; content[N];\n		int top;\n};\n\ntemplate&lt;typename T&gt;\nvoid prestack&lt;T&gt;::push(T p)\n{\n	if(top==0)  \n	{\n		content[++top].key=p;\n		content[1].min=p;\n	}\n	else    //动态规划的思想\n	{\n		if(p&lt;content[top].min) content[++top].min=p;\n		else content[++top].min=content[top-1].min;\n		content[top].key=p;\n	}\n}\n\ntemplate&lt;typename T&gt;\nT prestack&lt;T&gt;::pop()    //小心prestack神明的时候必须要加&lt;T&gt;\n{\n	return content[top--].key;\n}\n\ntemplate&lt;typename T&gt;\nT prestack&lt;T&gt;::min()\n{\n	return content[top].min;\n}\n\nint main()\n{\n	prestack&lt;int&gt; my;\n	my.push(-2);\n	my.push(5);\n	my.push(9);\n	my.push(4);\n	my.push(6);\n	my.push(8);\n	my.push(-4);\n	my.push(-2);\n	cout&lt;&lt;my.min()&lt;&lt;endl;\n	cout&lt;&lt;my.pop()&lt;&lt;endl;\n	cout&lt;&lt;my.pop()&lt;&lt;endl;\n	cout&lt;&lt;my.min()&lt;&lt;endl;\n	return 0;\n} //输出结果是-4，-2，-4，-2，结果正确</pre>\n   <h3>\n    3.2优先队列+栈实现\n   </h3>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1814089\' name=\'code\' snippet_file_name=\'blog_20160807_2_6812461\'>#include\'iostream\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass prestack\n{\n	public:\n		prestack()\n		{\n			memset(data,0,sizeof(data));\n			memset(heap,0,sizeof(heap));\n			top=heapnum=0;\n		}\n		void push(T);\n		T pop();\n		T min();\n	private:\n		T data[N];\n		T heap[N];\n		int top;\n		int heapnum;\n};\n\ntemplate&lt;typename T&gt;\nvoid prestack&lt;T&gt;::push(T p)\n{\n	data[++top]=p;\n	if(p&lt;heap[heapnum]) heap[++heapnum]=p;\n}\n\ntemplate&lt;typename T&gt;\nT prestack&lt;T&gt;::pop()\n{\n	T help;\n	help=data[top--];\n	if(help==heap[heapnum]) heapnum--;\n	return help;\n}\n\ntemplate&lt;typename T&gt;\nT prestack&lt;T&gt;::min()\n{\n	return heap[heapnum];\n}\n\nint main()\n{\n	prestack&lt;int&gt; my;\n	my.push(-2);\n	my.push(5);\n	my.push(9);\n	my.push(4);\n	my.push(6);\n	my.push(8);\n	my.push(-4);\n	my.push(-2);\n	cout&lt;&lt;my.min()&lt;&lt;endl;\n	cout&lt;&lt;my.pop()&lt;&lt;endl;\n	cout&lt;&lt;my.pop()&lt;&lt;endl;\n	cout&lt;&lt;my.min()&lt;&lt;endl;\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <h2>\n   4.疑惑点：\n  </h2>\n  <div>\n   1.为什么C++中结构体模板不能对typedef进行作用，很是奇怪，特定语法吗？时为什么要提出这种语法结构的呢\n  </div>\n  <div>\n   2.当要再追加问题：请在O(1)时间内min还可以返回出该最小元素在栈内的位置的时候，除了再开辟一内存保存地址之外，还有什么更好的方法吗\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('28bcec8c422e63b598c6dd7b33126575','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  C++易混点——深度解析指针悬挂和虚析构函数\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   1.指针悬挂及解决要点\n  </h1>\n  <h2>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.1.何为指针悬挂：\n  </h2>\n  <div>\n   指针悬挂值得是我们在程序的浅层拷贝过程中，因为默认的拷贝构造函数的局限性，导致的内存泄漏（至于泄露了那一部分内存，马上讲解），再长时间的积累下，每一次使用该函数的该复制 的特性，那么电脑中的内存就会丢失一块，长时间下来，导致电脑崩溃的事故发生，这一点对于C++这种没有Java垃圾内存回收机制的语言来说是开发中非常致命的一个大问题\n  </div>\n  <h2>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.2.泄露了那一部分内存：\n  </h2>\n  <div>\n   当我们进行浅层拷贝的时候，电脑知识默认的将后者 的内存地址复制过去，使得两个指针对应的内存指向是相同的，那么之前一个内存不就变成了“野”内存，没有任何一个指针指向他，也就是说，我们永远无法找到那个内存区域，当然我们也就丢失了对他的控制了，这片内存就泄露了出去\n  </div>\n  <div>\n   代码举例：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1812977\' name=\'code\' snippet_file_name=\'blog_20160806_1_1183237\'>class test\n{\n	public:\n		//test(){\n		//}\n		//~test(){ \n		//}\n		void set(int p)\n		{\n			key=&amp;p;\n		}\n		void get()\n		{\n			printf(\'%d\n\',*key);\n		}\n	private:\n		int* key;\n};\n\nint main()\n{\n	test b,a;  \n	b=a;     //b原本key指向的内存有可能会丢失\n	return 0;\n}</pre>\n   另一个错误，在我们调用异构函数的时候一旦我们采用这种浅层的拷贝，那么当一个析构完之后，另一个因为指向是相同的，但是该片内存已经释放过了，重复释放也会导致错误\n  </div>\n  <div>\n   <h2>\n    <span style=\'white-space:pre\'>\n    </span>\n    1.3.如何避免：\n   </h2>\n   <div>\n    我们目前避免这种情况的方法就是对等于号“=”进行运算符重载，我们重载的功能就是，在进行同等的复制的时候，我们先将原内存清理释放（可能会泄露的那块内存释放掉），然后再开批一个新的内存，对内存的额内容进行复制，从而防止上面的两个错误\n   </div>\n   <div>\n    示例代码如下：\n   </div>\n   <div>\n    <pre class=\'cpp\' code_snippet_id=\'1812977\' name=\'code\' snippet_file_name=\'blog_20160806_2_5359931\'>#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'iostream\'\n\nusing namespace std;\n\nclass errornull{\n};\n\nclass test\n{\n	public:\n		test(){\n			key=NULL;\n		}\n		~test(){ \n		free(key);\n		}\n		void set(int&amp; p)   //注意必须加引用，否则我们指向的只是为了复制而开辟的随机的内存\n		{\n			key=&amp;p;\n		}\n		void get()\n		{\n			printf(\'%d\n\',*key);\n		}\n		test&amp; operator=(test&amp; k)\n		{\n			if(&amp;k==this) return *this;    //特殊情况，如果是本身复制的话，直接返回就好\n			else\n			{\n				try\n				{\n					if(k.key==NULL) throw errornull();\n					if(key==NULL);\n		    		else delete key;    //释放内存 \n		    		key=new int;    //重新开辟 \n		    		*key=*k.key;    //手动复制 \n		    		return *this; \n				}\n				catch(errornull e)\n				{\n					cout&lt;&lt;\'正在尝试复制不存在的内容\'&lt;&lt;endl;\n				} \n			} \n		}\n	private:\n		int* key;\n};\n\nint main()\n{\n	test b,a;\n	int s=3;\n	a.set(s);\n	a.get();\n	b=a;\n	b.get();\n	return 0;\n}</pre>\n    <br/>\n    <br/>\n   </div>\n   <h1>\n    2.虚析构函数\n   </h1>\n  </div>\n  <h2>\n   2.1.虚析构函数的必要性：\n  </h2>\n  <div>\n   我们一旦了解过多态的话都会知道（如果没有学过多态，请自行百度）\n  </div>\n  <div>\n   我们完全可以通过基类的指针来动态创建（或者直接指向一个已经存在过的）一个新的子类的对象，这里就是多态的一个优点\n  </div>\n  <div>\n   但是在析构函数这里（动态创建的情况下会出现），回出现一些麻烦的问题\n  </div>\n  <div>\n   首先我们都知道一个规则，就是继承的时候的构造的顺序：\n  </div>\n  <div>\n   构造：先基类后子类\n  </div>\n  <div>\n   析构：先子类后基类\n  </div>\n  <div>\n   代码里面好说一点：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1812977\' name=\'code\' snippet_file_name=\'blog_20160806_3_201718\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nclass a\n{\n	public:\n		a()\n		{\n			\n		}\n		~a()\n		{\n			\n		}\n	private:\n		int key;\n};\n\nclass b:public a\n{\n	public:\n		b():a()\n		{\n			\n		}\n		~b()\n		{\n			\n		}\n	private:\n		int oh;\n};\n\nint main()\n{\n	a* my;\n	my=new b;  //在这里我们析构的话我们没有用 虚 来实现多态的控制的话，那么我们之后自动delete my的时候，调用的只是my的析构函数，我们\n	//就相当于把子类b忘了，忘了析构子类，这时候必然会导致错误，所以我们致力的继承中析构函数都是用 虚 的，目的就是用指针析构的是真正的指向的子类，而不是子类中嵌套包含的基类的那一部分，而是子类全部\n	//换句话说，我们的目的是调用子类的析构函数而不是基类的析构函数，这时候的virtual，虚析构函数的作用就和我们当时多态的一样了，自然就达到了我们所谓的删除了我们想删除的东西的目的 \n	return 0;\n}</pre>\n   <br/>\n   <h1>\n    3.参考文献\n   </h1>\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/gaozhefeng/article/details/17248753\' target=\'_blank\'>\n    gaozhegfeng的博客\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/kevin1993year/article/details/8569538\' target=\'_blank\'>\n    Kevin1993year的博客\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://blog.csdn.net/starlee/article/details/619827\' target=\'_blank\'>\n    寒星轩的博客\n   </a>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('d78ccd28fb332062d6e4909048b3c32d','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  微软面试百题001——BST转化有序双向链表\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   001.微软面试百题之BST转双向链表\n  </h1>\n  <h2>\n   1.题意描述：\n  </h2>\n  <div>\n   不允许开辟新的节点，只是改变指针的转向，将一颗标准的BST转化为一个双向链表，返回双向链表的头指针\n  </div>\n  <div>\n   测试用例描述：\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   7\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   5\n   <span style=\'white-space:pre\'>\n   </span>\n   9\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   -2\n   <span style=\'white-space:pre\'>\n   </span>\n   8\n   <span style=\'white-space:pre\'>\n   </span>\n   10\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   3\n   <span style=\'white-space:pre\'>\n   </span>\n   12\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   1\n  </div>\n  <div>\n   这棵二叉查找树转化为双向链表的操作结果是：-2 --1 --3 --5 --7 --8 --9 --10 --12\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.思维考虑：\n  </h2>\n  <h3>\n   BST:\n  </h3>\n  <div>\n   <a href=\'http://blog.csdn.net/ltyqljhwcm/article/details/52081538\' target=\'_blank\'>\n    本博主的BST总结详解\n   </a>\n   <br/>\n  </div>\n  <div>\n   这里我们先考虑BST 的性质，BST作为一颗高效的二叉查找树，性质如下：\n  </div>\n  <div>\n   1.空树\n  </div>\n  <div>\n   2.非空树且左子树节点键值均小于根节点的键值，右子树所有的节点的键值均大于根节点的键值\n  </div>\n  <div>\n   左右子树均为一颗BST\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   那么再转化成双向链表的时候，我们根据题意只能通过改变指针来进行操作，当然操作的前提是比该节点的键值小的节点已经存在于有序的双向链表中，这样子进行递归的定义我们就会发现，我们要保证是有序的双向链表，那么我们根据BST 的性质完全可以通过所谓的中序遍历来实现，在中序遍历的时候我们队当前的根节点的指针域进行操作就可以了\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   指针域的操作如下：\n  </h3>\n  <h4>\n   准备操作\n  </h4>\n  <div>\n   首先我们要开辟两个辅助的指针来帮助我们根号的控制目前已经有序的双向链表\n  </div>\n  <div>\n   1.head指针：作为整个双向链表的头结点（只有两种状态，空或者非空，空代表目前双向链表不存在任何一个有序的节点，非空代表目前的双向链表中至少有一个有序的节点）\n  </div>\n  <div>\n   2.listtail指针：顾名思义，listtail时终止向目前的双向链表中的最后一个元素（只有两个状态，空和非空，空代表目前双向链表不存在任意一个有序的节点，非空代表至少存在一个有序的节点），实际上我们发现listtail和head的状态实际上是同步的，那我们为什么要新引入一个listtail指针呢，其实这完全是为了节省时间，如果我们不引入这个指针内存空间，那么我们就必须环肥O(n)复杂度的使劲去遍历一遍整个目前有序的双向链表，所谓空间换时间，相对而言，这么做是非常划算的\n  </div>\n  <h4>\n   指针变化\n  </h4>\n  <div>\n   (p代表当期吗遍历到的节点，方便后续我们的被描述)\n  </div>\n  <div>\n   1.如果head为空，那么我们令head只想当前遍历到的节点，然后listtail同样指向这个节点\n  </div>\n  <div>\n   2.如果head不为空，说明listtail目前有确定指向，那么我们将listtail-&gt;right=p,p-&gt;left=listtail,listtail=p(最后一步的作用实际上是扩展我们的listtail，保证期时终止向最后一个节点);\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.C++代码实现，类封装\n  </h2>\n  <div>\n   因为在博主上一期的数据结构专题中，已经讨论过BST并且封装了BST的代码，这次我就直接拿来调用了，强调一点，对于Cbst我是考虑了公有继承，所以之后要用到root成员，所以bst我们这里设定成保护类型（实际上C++代码中，一旦要被继承的对象中的成员我们都是设定成保护类型的）\n  </div>\n  <div>\n   具体的操作和解释在代码中进行注释\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1812818\' name=\'code\' snippet_file_name=\'blog_20160806_1_4003874\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node  \n{  \n    int key;  \n    struct node* left;  \n    struct node* right;  \n}point;  \n  \nclass errorsame  \n{  \n};   \n  \nclass bst  \n{  \n    public:  \n        bst()  \n        {  \n            root=NULL;  \n            num=0;  \n        }  \n        virtual ~bst()  \n        {  \n            clear(root);  \n        }  \n        void add(int);  \n        void del(int);  \n        point* find(int);  \n        void clear(point*);  \n        void preorder(point*);  \n        void midorder(point*);  \n        void aftorder(point*);  \n        void rankorder();  \n        point* returnroot()   \n        {  \n            return root;  \n        }  \n    protected:  \n        point* root;  \n        int num;  \n};  \n  \nvoid bst::clear(point* p)  \n{  \n    if(p==NULL) return ;  \n    else  \n    {  \n        clear(p-&gt;left);  \n        clear(p-&gt;right);  \n        free(p);  \n    }  \n}  \n  \nvoid bst::add(int p)  \n{  \n    if(num==0)   \n    {  \n        root=new point;  \n        root-&gt;right=root-&gt;left=NULL;  \n        root-&gt;key=p;  \n        num++;  \n        return ;  \n    }  \n    else  \n    {  \n        try  \n        {  \n            point *k=root;  \n            point* w=root;  \n            while(w!=NULL)  \n            {  \n                if(w-&gt;key==p) throw errorsame();  \n                else  \n                {  \n                    if(w-&gt;key&gt;p) w=w-&gt;left;  \n                    else w=w-&gt;right;  \n                }  \n                if(w!=NULL) k=w;  \n            }  \n            if(k-&gt;key&gt;p)   \n            {  \n                point *a=new point();  \n                a-&gt;left=a-&gt;right=NULL;a-&gt;key=p;  \n                k-&gt;left=a;  \n            }  \n            else  \n            {  \n                point *a=new point();  \n                a-&gt;left=a-&gt;right=NULL;a-&gt;key=p;  \n                k-&gt;right=a;  \n            }  \n            num++;  \n        }  \n        catch(errorsame e)  \n        {  \n            cout&lt;&lt;\'try to add the same point in the tree!\'&lt;&lt;endl;  \n        }  \n    }  \n}  \n  \nvoid bst::del(int p)  \n{  \n    point* now=root;  \n    point* father=NULL;  \n    while(now-&gt;key!=p)  \n    {  \n        if(now-&gt;key&gt;p)  \n        {  \n            father=now;  \n            now=now-&gt;left;  \n        }  \n        else  \n        {  \n            father=now;  \n            now=now-&gt;right;  \n        }  \n        if(now==NULL)   \n        {  \n            cout&lt;&lt;\'can not find the point!\'&lt;&lt;endl;  \n            return ;  \n        }  \n    }  \n    if(father==NULL)   \n    {  \n        point* help=root;  \n        if(root-&gt;right==NULL) root=root-&gt;left;  \n        else  \n        {  \n            if(root-&gt;right-&gt;left==NULL)   \n            {  \n                root-&gt;right-&gt;left=root-&gt;left;  \n                root=root-&gt;right;  \n            }   \n            else  \n            {  \n                point* z=NULL;  \n                point* k=root-&gt;right;  \n                point* w=root;  \n                while(k-&gt;left!=NULL)   \n                {  \n                    if(k-&gt;left-&gt;left==NULL) z=k;   \n                    k=k-&gt;left;  \n                }  \n                z-&gt;left=k-&gt;right;  \n                k-&gt;left=root-&gt;left;  \n                k-&gt;right=root-&gt;right;  \n                root=k;  \n            }  \n        }   \n        free(help);  \n    }  \n    else if(now-&gt;right==NULL)  \n    {  \n        point* help=now;  \n        if(father-&gt;left==now) father-&gt;left=now-&gt;left;  \n        else father-&gt;right=now-&gt;left;  \n        free(help);  \n    }  \n    else  \n    {  \n        if(now-&gt;right-&gt;left==NULL)  \n        {  \n            point* help=now;  \n            now-&gt;right-&gt;left=now-&gt;left;  \n            if(father-&gt;left==now) father-&gt;left=now-&gt;right;  \n            else father-&gt;right=now-&gt;right;  \n            free(help);  \n        }  \n        else  \n        {  \n            point* z;  \n            point* k=now-&gt;right;  \n            while(k-&gt;left!=NULL)   \n            {  \n                if(k-&gt;left-&gt;left==NULL) z=k;  \n                k=k-&gt;left;  \n            }   \n            if(father-&gt;left==now)  \n            {  \n                z-&gt;left=k-&gt;right;  \n                father-&gt;left=k;  \n                k-&gt;left=now-&gt;left;  \n                k-&gt;right=now-&gt;right;  \n            }  \n            else  \n            {  \n                z-&gt;left=k-&gt;right;  \n                father-&gt;right=k;  \n                k-&gt;left=now-&gt;left;  \n                k-&gt;right=now-&gt;right;  \n            }  \n        }  \n    }  \n}  \n  \npoint* bst::find(int p)  \n{  \n    point* a=root;  \n    while(a!=NULL)  \n    {  \n        if(a-&gt;key==p) return a;   \n        if(a-&gt;key&gt;p) a=a-&gt;left;  \n        else a=a-&gt;right;  \n    }  \n}   \n  \nvoid bst::preorder(point* p)  \n{  \n    if(p==NULL) return ;  \n    else  \n    {  \n        printf(\'%d \',p-&gt;key);  \n        preorder(p-&gt;left);  \n        preorder(p-&gt;right);  \n    }  \n}  \n  \nvoid bst::midorder(point* p)  \n{  \n    if(p==NULL) return ;  \n    else  \n    {  \n        midorder(p-&gt;left);  \n        printf(\'%d \',p-&gt;key);  \n        midorder(p-&gt;right);  \n    }  \n}  \n  \nvoid bst::aftorder(point* p)  \n{  \n    if(p==NULL) return ;  \n    else  \n    {  \n        aftorder(p-&gt;left);  \n        aftorder(p-&gt;right);  \n        printf(\'%d \',p-&gt;key);  \n    }  \n}  \n  \nvoid bst::rankorder()  \n{  \n    point* queue[100];  \n    int head=1;  \n    int tail=2;  \n    queue[1]=root;  \n    while(head!=tail)  \n    {  \n        if(queue[head]-&gt;left!=NULL) queue[tail++]=queue[head]-&gt;left;  \n        if(queue[head]-&gt;right!=NULL) queue[tail++]=queue[head]-&gt;right;  \n        head++;  \n    }  \n    for(int i=1;i&lt;=tail-1;i++) printf(\'%d \',queue[i]-&gt;key);  \n}  \n\nclass Cbst:public bst\n{\n	public:\n		Cbst():bst()\n		{\n			head=listtail=NULL;\n		}\n		virtual ~Cbst()  //这里就不再赘语为什么用虚析构函数了 \n		{\n			//强调一点，在这里我们必须要对bst进行变换，因为我懒得写那几行切换的代码了\n			point* p=head;\n			while(p!=NULL)\n			{\n				point* w=p;\n				p=p-&gt;right;\n				free(w);\n			} \n			root=NULL;    //很尴尬，我的虚析构函数知识点忘了，所以这里手工将root设定成NULL，防止指针玄关的错误发生，尴尬，继续去复习指针玄关的知识点去 \n		}\n		void visit(point*);     //中序遍历 \n		void change(point*);    //中序遍历中对指针的进行的节点指针操作 \n		void scan();    //程序正确性与否的测试代码段 \n	private:\n		point* head;\n		point* listtail;\n};\n\nvoid Cbst::visit(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		visit(p-&gt;left);\n		change(p);\n		visit(p-&gt;right);\n	} \n}\n\nvoid Cbst::change(point* p)\n{\n	if(head==NULL)\n	{\n		head=p;\n		listtail=p;\n	}\n	else\n	{\n		p-&gt;left=listtail;\n		listtail-&gt;right=p;\n		listtail=p;\n		return ;\n	}\n}\n\nvoid Cbst::scan()\n{\n	point* p=head;\n	while(p!=NULL)\n	{\n		cout&lt;&lt;p-&gt;key&lt;&lt;\' \';\n		p=p-&gt;right;\n	}\n	cout&lt;&lt;endl;\n}\n\nint main()\n{\n	Cbst my;\n	my.add(7);\n	my.add(5);\n	my.add(9);\n	my.add(-2);\n	my.add(10);\n	my.add(3);\n	my.add(1);\n	my.add(8);\n	my.add(12);\n	my.visit(my.returnroot());\n	my.scan();\n	return 0;\n} </pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('adfde3e9991657167389307653e7bc85','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  树及二叉树\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h2>\n   1.基础概念：\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   树是一种扩展性的数据结构，体现在树额一对多的方面上\n  </div>\n  <div>\n   一.树的表示方法\n   <br/>\n   1.双亲表示树：结构体包含数据域和指向双亲的指针域，我们也可以添加指向长子的指针域和只想有兄弟的指针域\n   <br/>\n   2.孩子表示树：两种结构体，一种结构体建立出顺序的数组结构，保存数据域和指向孩子的指针域\n   <br/>\n   第二种结构体，包含有指向对应的孩子的指针域，还包含指向与其有相同的双亲的兄弟的节点\n   <br/>\n   当然，这样我们确实也不好寻找双亲，所以我们也还可以再第一种结构体中添加有指向双亲的指针域\n   <br/>\n   3.孩子兄弟表示树：结构体包含三种数据，在第一种保存结点的数据，第二种包含长子域，记录指向他的最左孩子的节点的指针域，第三个数据记录本节点的右孩子的节点指针域\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   二叉树：\n  </div>\n  <div>\n   1.整个树不存在节点的度大于2的节点\n   <br/>\n   2.做字数和右子树是存在顺序的，不可以随意地调换\n   <br/>\n   3.及时数只存在一个子节点，我们也要区分是左节点还是右节点\n   <br/>\n   4.二叉树的一个节点主要基本形态：空二叉树，只有一个根节点，根节点只有左子树，根节点只有右子树，根节点左右子树均存在\n   <br/>\n   5.特殊二叉树：\n   <br/>\n   斜树：每个节点只有左子树或者所有的节点值又右子树\n   <br/>\n   满二叉树：所有的节点都存在左右两个节点\n   <br/>\n   完全二叉树：叶节点只可以出现在最下面的一层，最下面的节点一定是存在在左部连续区域，倒是第二层的叶子节点一定出现在又不的连续区域内，左孩子一定优先于右孩子，相同节点个数的二叉树，完全二叉树的层数一定是最小的\n   <br/>\n   （完全二叉树一定要注意连续的问题）\n   <br/>\n   6.二叉树的重要性质：\n   <br/>\n   1.二叉树的第i层上最多有2^(i-1)个节点\n   <br/>\n   2.深度为i的二叉树上最多有2^i-1个节点\n   <br/>\n   3.任意一棵二叉树叶子节点值是a，度是2的节点数是b，存在关系a=b+1;\n   <br/>\n   4.完全二叉树深度log2n+1；\n   <br/>\n   5.将层序编号之后我们会发现，i=1为节点，2*i&gt;n(二叉树的结点个数)，i无左孩子，2*i+1&gt;n二叉树无右孩子\n   <br/>\n   7.二叉树的存储结构：\n   <br/>\n   1.顺序存储，二叉树若存在度数不为2的节点，该空间元素赋值为空，(考虑极端情况，若是斜树的话，会造成严重的空间浪费)\n   <br/>\n   所以二叉树的顺序存储只限定于完全二叉树\n   <br/>\n   2.二叉链表：数据域，左孩子指针域，右有孩子指针域\n   <br/>\n   8.二叉树遍历顺序：\n   <br/>\n   1.前序遍历：根节点-&gt;左子树-&gt;右子树\n   <br/>\n   2.中序遍历：左子树-&gt;根节点-&gt;右子树\n   <br/>\n   3.后序遍历：左子树-&gt;右子树-&gt;根节点\n   <br/>\n   4.层序遍历：层级从左到右\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.二叉树的构建：\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   编者在大量浏览网上讲解的二叉树的博客发现，都是主讲遍历，对于构建则是很少涉及，所以，为了给大家对二叉树一个清晰的认识，在开始讲二叉树之前，我们首先先来学习一下二叉树的构建，实在不行也可以先阅读第3段遍历来熟悉一下遍历顺序的应用\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.1.人为辅助的单一顺序为基础的构建二叉树\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   该方法通过人为加入界定判断符来帮助通过一种构建顺序来建立二叉树，该方法的好处是只需要一种遍历顺序，但是坏处是人为依赖性非常大，当数据量非常庞大的时候，该方法毫无用处\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   实例讲解，代码如下：（前序构建）后序和中序可以这样吗（后序貌似可以通过转变遍历顺序来进行，还是说这样会存在错误）\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>void build(point*&amp; p)\n{\n	char key=0;\n	cin&gt;&gt;key;\n	if(key==\'#\')\n	{\n		p=NULL;\n		return ;\n	}\n	else\n	{\n		p-&gt;key=key;\n		p-&gt;left=p-&gt;right=NULL;\n		build(p-&gt;left);\n		build(p-&gt;right);\n	}\n}</pre>\n   <h3>\n    <span style=\'white-space:pre\'>\n    </span>\n    2.2.前序+中序/后序+中序（中序必不可少，但是中序单独又不可）\n   </h3>\n   <div>\n    因为无论是前序遍历还是后续遍历，我们无法确定真正的树的节点在哪里，我们只知道在整体的顺序上的遍历顺序分布\n    <br/>\n    这些节点的先后，但是具体的空间的分布是由节点来确定的，所以，我们必须要引入中序遍历\n    <br/>\n    中序遍历的特点是：中序遍历的节点的左右两边的节点组分别是该节点的左子树和右子树，从容帮助我们确定了节点的位置，从而使得\n    <br/>\n    利用中序+前序   中序+后序实现构建二叉树（二叉树的还原）成为可能\n    <br/>\n   </div>\n   <span style=\'white-space:pre\'>\n   </span>\n   代码如下：\n  </div>\n  <div>\n   测试用例：\n  </div>\n  <div>\n   8\n   <br/>\n   1 2 3 5 4 6 7 8\n   <br/>\n   3 5 2 6 4 1 8 7\n   <br/>\n   5 3 6 4 2 8 7 1\n   <br/>\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#define N 100\n\nusing namespace std;\n\ntypedef struct node\n{\n	int key;\n	struct node* left;\n	struct node* right;\n}point;\n\nclass BT\n{\n	public:\n		BT()\n		{\n			memset(pre,0,sizeof(pre));\n			memset(mid,0,sizeof(mid));\n			memset(aft,0,sizeof(aft));\n			root=NULL;\n			num=0;\n		}\n		~BT()\n		{\n			clear(root);   //这里牵扯到遍历的一个应用，那就是后续遍历来删除节点 \n		}\n		friend istream&amp; operator&gt;&gt;(istream&amp;,BT&amp;);\n		point* premidbuild(int*,int*,int);\n		point* aftmidbuild(int*,int*,int);\n		void preorder(point*);\n		void clear(point*);\n		void prepremidbuild()\n		{\n			root=premidbuild(pre,mid,num);\n		}\n		void preaftmidbuild()\n		{\n			root=aftmidbuild(aft,mid,num);\n		}\n		point* returnroot()\n		{\n			return root;\n		}\n	private:\n		point* root;\n		int num;	\n		int pre[N];\n		int mid[N];\n		int aft[N];\n};\n\nistream&amp; operator&gt;&gt;(istream&amp; in,BT&amp; k)\n{\n	cout&lt;&lt;\'节点总数：\';in&gt;&gt;k.num; \n	cout&lt;&lt;\'前序遍历：\';for(int i=0;i&lt;k.num;i++) in&gt;&gt;k.pre[i];\n	cout&lt;&lt;\'中序遍历：\';for(int i=0;i&lt;k.num;i++) in&gt;&gt;k.mid[i];\n	cout&lt;&lt;\'后序遍历；\';for(int i=0;i&lt;k.num;i++) in&gt;&gt;k.aft[i]; \n	return in;\n}\n\nvoid BT::clear(point* p)    //这里采用后序遍历的方式来实现二叉树的逐个删除\n{\n	if(p==NULL) return ;\n	else\n	{\n		clear(p-&gt;left);\n		clear(p-&gt;right);\n		free(p);\n	}\n}\n\nvoid BT::preorder(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		printf(\'%d \',p-&gt;key);\n		preorder(p-&gt;left);\n		preorder(p-&gt;right);\n	}\n}\n\npoint* BT::premidbuild(int* pre,int* mid,int i)\n{\n	if(i==0) return NULL;\n	point* w=new point;\n	w-&gt;key=pre[0];\n	w-&gt;left=w-&gt;right=NULL;\n	int* p=NULL;\n	int* q=NULL;\n	int a=0;    //w的作用是记录当前前序遍历访问到的节点在中序遍历中的序号位置 \n	for(int j=0;j&lt;i;j++)\n	{\n		if(pre[1]==mid[j])   //这里就要求二叉树正不可以出现相同的元素 \n		{\n			a=j;\n			break;\n		}\n	} \n	p=pre+1;\n	q=mid;\n	w-&gt;left=premidbuild(p,q,a);\n	p=pre+a+1;\n	q=mid+a+1;\n	w-&gt;right=premidbuild(p,q,i-a-1);\n	return w;\n} \n\npoint* BT::aftmidbuild(int* aft,int* mid,int i)\n{\n	if(i==0) return NULL;\n	point* w=new point;\n	w-&gt;left=w-&gt;right=NULL;\n	w-&gt;key=aft[i-1];\n	int* p=NULL;\n	int* q=NULL;\n	int a=0;\n	for(int j=i-1;j&gt;=0;j--)\n	{\n		if(aft[i-1]==mid[j])\n		{\n			a=j;\n			break;\n		}\n	}\n	p=aft+a;\n	q=mid+a;\n	w-&gt;right=aftmidbuild(p,q,i-a-1);\n	p=aft;\n	q=mid;\n	w-&gt;left=aftmidbuild(p,q,a);\n	return w;\n}\n\nint main()\n{\n	BT my;\n	cin&gt;&gt;my;\n	//my.prepremidbuild();\n	//my.preorder(my.returnroot());\n	my.preaftmidbuild();\n	my.preorder(my.returnroot());\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.二叉树的四种遍历方式：\n  </h2>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.前序遍历：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   前序遍历的顺序在于：1.根访问（可以包含很多操作）\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.左节点扩展\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   3.右节点扩展\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   前序遍历的实现由两种：1.递归\n   <span style=\'white-space:pre\'>\n   </span>\n   2.循环\n   <span style=\'white-space:pre\'>\n   </span>\n   （实际上因为递归的实现较为好理解，所以一般我们都是用递归来实现树的遍历）\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   数据结构的选择：1.顺序存储（因为二叉树的特殊性，我们用顺序结构（数组）来存储的时候需要人为加入控制结束的条件，因为我们实际上是不清楚一个二叉树上的节点的度是多少）\n   <span style=\'white-space:pre\'>\n   </span>\n   2.链式存储（\n   <span style=\'font-size:13.3333px\'>\n    定义结构体\n   </span>\n   ）\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   代码解析：\n  </div>\n  <div>\n   1.结构体的定义：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1808401\' name=\'code\' snippet_file_name=\'blog_20160804_3_5871638\'>typedef struct node\n{\n	int key;\n	struct node* left;\n	struct node* right;\n}point:</pre>\n   <br/>\n   2.链式访问：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1808401\' name=\'code\' snippet_file_name=\'blog_20160804_4_5599421\'>void preorder(point* p)\n{\n	if(p==NULL) return ;  //子树终止 \n	else\n	{\n		printf(\'%d \',p-&gt;key);//a sort of work(such as print the key)\n		preorder(p-&gt;left);\n		preorder(p-&gt;right);\n	}\n} </pre>\n   <br/>\n  </div>\n  <div>\n   3.顺序访问：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1808401\' name=\'code\' snippet_file_name=\'blog_20160804_5_3582317\'>void preorder(int root)  //first used to be the array[1](begin from the array[1])\n{\n	//函数外存在全局的顺序存储内存（数组），并且用num记录数组中元素的大小，low记录二叉树的层数 \n	if(array[root]=\'#\') return ; //#代表人为加入的中断标记\n	else\n	{\n		printf(\'%d \',array[root]);\n		preorder(2*root);    //应用二叉树的性质，标号存在规律，n（根节点）-》n*2（左孩子存在的话）-》n*2+1（右孩子存在的话）\n		preorder(2*root+1);\n	}\n} </pre>\n   <h3>\n   </h3>\n   <h3>\n    <span style=\'font-size:12px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     2.3\n    </span>\n    <span style=\'font-size:12px\'>\n     中序遍历和后序遍历\n    </span>\n   </h3>\n   <div>\n    <span style=\'white-space:pre\'>\n    </span>\n    实际上中序遍历和后序遍历的原理和前序遍历是差不多的，这里就不再过多赘述，我们接下来详细的讨论层序遍历的方法\n   </div>\n   <h3>\n    <span style=\'font-size:12px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n    </span>\n   </h3>\n   <h3>\n    <span style=\'font-size:12px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     4.层序遍历：\n    </span>\n   </h3>\n   <h3>\n   </h3>\n   <h3>\n   </h3>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   实际上层序遍历并没有我们想象的那么简单，我们在这里需要引入一种数据结构叫做：队列，实际上我们是一层一层的逐一扩展，将新的节点加入队列，下一次将该节点的孩子节点再加入队列，知道我们的队列访问为空截止，说明说有的点都已经遍历完全\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   talk is cheap，show me the code\n  </div>\n  <div>\n   1.链式存储：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1808401\' name=\'code\' snippet_file_name=\'blog_20160804_6_3342337\'>void rankorder(point* root)\n{\n	point* queue[N];    //在下不喜欢用STL，那就人工模拟队列，希望看客海量谅解一下 \n	int head=1;\n	int tail=2;\n	queue[1]=root;\n	while(head!=tail)\n	{\n		if(queue[head]-&gt;left!=NULL) queue[tail++]=queue[head]-&gt;left;\n		if(queue[head]-&gt;right!=NULL) queue[tail++]=queue[head]-&gt;right;\n		head++;\n	} \n	for(int i=1;i&lt;=tail-1;i++) printf(\'%d \',queue[i]-&gt;key);   //当然niyekeyi在加入队列的时候将其输出，复杂度是没有影响的 \n}</pre>\n   2.顺序存储：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1808401\' name=\'code\' snippet_file_name=\'blog_20160804_7_3833488\'>void preorder(int first)\n{\n	int queue[N];\n	int head=1;\n	int tail=2;\n	queue[1]=array[first];\n	while(head!=tail)\n	{\n		if(queue[head*2]!=\'#\') queue[tail++]=queue[head*2];\n		if(queue[head*2+1]!=\'#\') queue[tail++]=queue[head*2+1];\n		head++;\n	}\n	for(int i=1;i&lt;=tail-1;i++) printf(\'%d \',queue[i]);\n}</pre>\n   <br/>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('5e122f4c3cb2fb8c563aef07b99800a5','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  二叉查找树BST总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   二叉查找树BST总结分析\n  </h1>\n  <h2>\n   1.ADT（抽象数据类型）\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   ADT BST\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   数据元素：数据节点（键值，位置信息）\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   数据关系：父子关系\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   基本操作：\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   插入节点\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   查找节点\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   删除节点\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   遍历节点（前中后层序）\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n  </div>\n  <h2>\n   2.二叉查找树性质：（不存在相同键值的节点）\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.空树\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.非空树并且左子树所有节点的键值均小于本节点的键值\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   <span style=\'white-space:pre\'>\n   </span>\n   <span style=\'white-space:pre\'>\n   </span>\n   右子树所有的节点的键值均大于本节点的键值\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   该节点的左右子树均为二叉查找树\n  </div>\n  <h2>\n   3.二叉查找树的核心操作复杂度分析：\n  </h2>\n  <div>\n   <span style=\'font-family:\'microsoft yahei\'; font-size:14px; line-height:1.25; white-space:pre\'>\n    T( n ) = T( n/2 ) + O( 1 )\n   </span>\n   <span style=\'white-space:pre\'>\n   </span>\n   <p style=\'margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; line-height:1.25; font-family:\'microsoft yahei\'; font-size:14px\'>\n    T( n ) = T( n/4 ) + 2 O( 1 )\n    <br style=\'\'/>\n    T( n ) = T( n/8 ) + 3 O( 1 )\n    <br style=\'\'/>\n    …\n    <br style=\'\'/>\n    …[共 logN 次]\n    <br style=\'\'/>\n    …\n    <br style=\'\'/>\n    T( n ) = T( 1 ) + logN·O( 1 )\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:1.25; font-family:\'microsoft yahei\'; font-size:14px\'>\n    T( n ) = O(logN)\n   </p>\n   <h2>\n    4.二叉查找树的基本操作分析：\n   </h2>\n   <h3>\n    <span>\n    </span>\n    1.插入节点：\n   </h3>\n   <div>\n    <span>\n    </span>\n    插入节点的核心在于查找到当前的节点的父亲节点，对于空树来说，插入的节点直接充当根节点\n   </div>\n   <div>\n    <span>\n    </span>\n    对于非空树来说，操作步骤如下：（c节点代表当前访问到的的节点的位置，p节点代表带插入的节点，n代表待插入节点的父节点）\n   </div>\n   <div>\n    <span>\n    </span>\n    1.c节点为空，那么n即为c节点的父亲节点，此时我们要进行大小比较少，如果p节点的键值比n节点的键值小，那么p作为n的左孩子否则作为右孩子\n   </div>\n   <div>\n    <span>\n    </span>\n    2.否则，比较p节点的键值与c节点的键值\n   </div>\n   <div>\n    <span>\n    </span>\n    3.如果键值相同，说明用户正在试图插入一个已经存在的节点，此时根据情况，我们可以抛出异常或者我们提醒用户\n   </div>\n   <div>\n    <span>\n    </span>\n    4.如果p节点的键值比c节点的键值要小，说明p节点应该存在于c节点的左子树中，此时，n节点为c节点，我们将c转移到左孩子上，跳转到操作1\n   </div>\n   <div>\n    <span>\n    </span>\n    5.否则，跳转到右孩子上，然后执行操作1\n   </div>\n   <div>\n    <br/>\n   </div>\n   <h3>\n    <span>\n    </span>\n    2.查找节点：\n   </h3>\n   <div>\n    <span>\n    </span>\n    查找节点的操作和插入节点的操作大致是相同的，复杂度都是logN：（k代表待查找的键值，c代表当前的节点（初始为根节点））\n   </div>\n   <div>\n    <span>\n    </span>\n    1.如果k等于c的键值，说明该节点我们已经查找到了，返回查找到的地址就好\n   </div>\n   <div>\n    <span>\n    </span>\n    2.如果c节点为空，说明该节点查找失败，该节点不存在，返回NULL即可\n   </div>\n   <div>\n    <span>\n    </span>\n    3.否则，我们进行判断，如果k的键值相对较小，说明待查找的节点要么不存在要么就在左子树中，我们将c跳转到左子树中，执行操作1\n   </div>\n   <div>\n    <span>\n    </span>\n    4.否则，说明待查找的节点要么不存在，要么就存在在右子树中，我们将c跳转到右孩子中，执行操作1\n   </div>\n   <div>\n    <span>\n    </span>\n   </div>\n   <h3>\n    <span>\n    </span>\n    3.遍历结点：（前中后层序遍历二叉树是一样的）\n   </h3>\n   <h3>\n    <span>\n    </span>\n    4.删除节点：\n   </h3>\n   <div>\n    <span>\n     <span style=\'font-size:13.3333px\'>\n     </span>\n    </span>\n    <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:16px; font-family:Helvetica,\'Microsoft Yahei\',Verdana,Arial,sans-serif\'>\n     从 BST 中删除节点比插入节点难度更大。因为删除一个非叶子节点，就必须选择其他节点来填补因删除节点所造成的树的断裂。如果不选择节点来填补这个断裂，那么就违背了 BST 的性质要求。\n    </p>\n    <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:16px; font-family:Helvetica,\'Microsoft Yahei\',Verdana,Arial,sans-serif\'>\n     删除节点算法的第一步是定位要被删除的节点，这可以使用前面介绍的查找算法，因此运行时间为 O(log­\n     <sub style=\'margin:0px; padding:0px\'>\n      2\n     </sub>\n     n)。接着应该选择合适的节点来代替删除节点的位置，它共有三种情况需要考虑。\n    </p>\n    <ul style=\'margin:6px 0px 0px 50px; padding:0px; line-height:25px; font-family:Helvetica,\'Microsoft Yahei\',Verdana,Arial,sans-serif; font-size:13.92px\'>\n     <li style=\'margin:0px; padding:0px; list-style:disc; font-size:16px\'>\n      <span style=\'margin:0px; padding:0px\'>\n       情况 1：\n      </span>\n      如果删除的节点没有右孩子，那么就选择它的左孩子来代替原来的节点。二叉查找树的性质保证了被删除节点的左子树必然符合二叉查找树的性质。因此左子树的值要么都大于，要么都小于被删除节点的父节点的值，这取决于被删除节点是左孩子还是右孩子。因此用被删除节点的左子树来替代被删除节点，是完全符合二叉搜索树的性质的。\n     </li>\n     <li style=\'margin:0px; padding:0px; list-style:disc; font-size:16px\'>\n      <span style=\'margin:0px; padding:0px\'>\n       情况 2：\n      </span>\n      如果被删除节点的右孩子没有左孩子，那么这个右孩子被用来替换被删除节点。因为被删除节点的右孩子都大于被删除节点左子树的所有节点，同时也大于或小于被删除节点的父节点，这同样取决于被删除节点是左孩子还是右孩子。因此，用右孩子来替换被删除节点，符合二叉查找树的性质。\n     </li>\n     <li style=\'margin:0px; padding:0px; list-style:disc; font-size:16px\'>\n      <span style=\'margin:0px; padding:0px\'>\n       情况 3：\n      </span>\n      如果被删除节点的右孩子有左孩子，就需要用被删除节点右孩子的左子树中的最下面的节点来替换它，就是说，我们用被删除节点的右子树中最小值的节点来替换。\n     </li>\n    </ul>\n    <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:16px; font-family:Helvetica,\'Microsoft Yahei\',Verdana,Arial,sans-serif\'>\n     <img alt=\'\' src=\'http://images.cnitblog.com/i/175043/201406/291214353511360.gif\' style=\'max-width:800px; margin:0px auto; padding:0px; border:0px; display:block\'/>\n     <br style=\'margin:0px; padding:0px\'/>\n     我们知道，在 BST 中，最小值的节点总是在最左边，最大值的节点总是在最右边。因此替换被删除节点右子树中最小的一个节点，就保证了该节点一定大于被删除节点左子树的所有节点。同时，也保证它替代了被删除节点的位置后，它的右子树的所有节点值都大于它。因此这种选择策略符合二叉查找树的性质。\n    </p>\n    <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:16px; font-family:Helvetica,\'Microsoft Yahei\',Verdana,Arial,sans-serif\'>\n     和查找、插入算法类似，\n     <span style=\'margin:0px; padding:0px\'>\n      删除算法的运行时间也与 BST 的拓扑结构有关，最佳情况是 O(log­\n      <sub style=\'margin:0px; padding:0px\'>\n       2\n      </sub>\n      n)，而最坏情况是 O(n)。\n     </span>\n    </p>\n    <h2>\n     <span style=\'margin:0px; padding:0px\'>\n      5.C++类封装（代码示例）:\n     </span>\n    </h2>\n    <div style=\'font-size:13.3333px\'>\n     <span style=\'margin:0px; padding:0px\'>\n     </span>\n     <pre class=\'cpp\' code_snippet_id=\'1797958\' name=\'code\' snippet_file_name=\'blog_20160731_1_5784966\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int key;\n	struct node* left;\n	struct node* right;\n}point;\n\nclass errorsame\n{\n}; \n\nclass bst\n{\n	public:\n		bst()\n		{\n			root=NULL;\n			num=0;\n		}\n		~bst()\n		{\n			clear(root);\n		}\n		void add(int);\n		void del(int);\n		point* find(int);\n		void clear(point*);\n		void preorder(point*);\n		void midorder(point*);\n		void aftorder(point*);\n		void rankorder();\n		point* returnroot() \n		{\n			return root;\n		}\n	private:\n		point* root;\n		int num;\n};\n\nvoid bst::clear(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		clear(p-&gt;left);\n		clear(p-&gt;right);\n		free(p);\n	}\n}\n\nvoid bst::add(int p)\n{\n	if(num==0) \n	{\n		root=new point;\n		root-&gt;right=root-&gt;left=NULL;\n		root-&gt;key=p;\n		num++;\n		return ;\n	}\n	else\n	{\n		try\n		{\n			point *k=root;\n			point* w=root;\n		    while(w!=NULL)\n		    {\n	     		if(w-&gt;key==p) throw errorsame();\n	     		else\n	     		{\n	     			if(w-&gt;key&gt;p) w=w-&gt;left;\n	     			else w=w-&gt;right;\n	     		}\n	     		if(w!=NULL) k=w;\n		    }\n		    if(k-&gt;key&gt;p) \n		    {\n		    	point *a=new point();\n		    	a-&gt;left=a-&gt;right=NULL;a-&gt;key=p;\n		    	k-&gt;left=a;\n		    }\n		    else\n		    {\n		    	point *a=new point();\n		    	a-&gt;left=a-&gt;right=NULL;a-&gt;key=p;\n		    	k-&gt;right=a;\n		    }\n		    num++;\n		}\n		catch(errorsame e)\n		{\n			cout&lt;&lt;\'try to add the same point in the tree!\'&lt;&lt;endl;\n		}\n	}\n}\n\nvoid bst::del(int p)\n{\n	point* now=root;\n	point* father=NULL;\n	while(now-&gt;key!=p)\n	{\n		if(now-&gt;key&gt;p)\n		{\n			father=now;\n			now=now-&gt;left;\n		}\n		else\n		{\n			father=now;\n			now=now-&gt;right;\n		}\n		if(now==NULL) \n		{\n			cout&lt;&lt;\'can not find the point!\'&lt;&lt;endl;\n			return ;\n		}\n	}\n	if(father==NULL) \n	{\n		point* help=root;\n		if(root-&gt;right==NULL) root=root-&gt;left;\n		else\n		{\n			if(root-&gt;right-&gt;left==NULL) \n			{\n				root-&gt;right-&gt;left=root-&gt;left;\n				root=root-&gt;right;\n			} \n			else\n			{\n				point* z=NULL;\n				point* k=root-&gt;right;\n				point* w=root;\n				while(k-&gt;left!=NULL) \n				{\n					if(k-&gt;left-&gt;left==NULL) z=k; \n					k=k-&gt;left;\n				}\n				z-&gt;left=k-&gt;right;\n				k-&gt;left=root-&gt;left;\n		    	k-&gt;right=root-&gt;right;\n		    	root=k;\n			}\n		} \n		free(help);\n	}\n	else if(now-&gt;right==NULL)\n	{\n		point* help=now;\n		if(father-&gt;left==now) father-&gt;left=now-&gt;left;\n		else father-&gt;right=now-&gt;left;\n		free(help);\n	}\n	else\n	{\n		if(now-&gt;right-&gt;left==NULL)\n		{\n			point* help=now;\n			now-&gt;right-&gt;left=now-&gt;left;\n			if(father-&gt;left==now) father-&gt;left=now-&gt;right;\n			else father-&gt;right=now-&gt;right;\n			free(help);\n		}\n		else\n		{\n			point* z;\n			point* k=now-&gt;right;\n			while(k-&gt;left!=NULL) \n			{\n				if(k-&gt;left-&gt;left==NULL) z=k;\n				k=k-&gt;left;\n			} \n			if(father-&gt;left==now)\n			{\n                z-&gt;left=k-&gt;right;\n				father-&gt;left=k;\n				k-&gt;left=now-&gt;left;\n				k-&gt;right=now-&gt;right;\n			}\n			else\n			{\n				z-&gt;left=k-&gt;right;\n				father-&gt;right=k;\n				k-&gt;left=now-&gt;left;\n				k-&gt;right=now-&gt;right;\n			}\n		}\n	}\n}\n\npoint* bst::find(int p)\n{\n	point* a=root;\n	while(a!=NULL)\n	{\n		if(a-&gt;key==p) return a; \n		if(a-&gt;key&gt;p) a=a-&gt;left;\n		else a=a-&gt;right;\n	}\n} \n\nvoid bst::preorder(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		printf(\'%d \',p-&gt;key);\n		preorder(p-&gt;left);\n		preorder(p-&gt;right);\n	}\n}\n\nvoid bst::midorder(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		midorder(p-&gt;left);\n		printf(\'%d \',p-&gt;key);\n		midorder(p-&gt;right);\n	}\n}\n\nvoid bst::aftorder(point* p)\n{\n	if(p==NULL) return ;\n	else\n	{\n		aftorder(p-&gt;left);\n		aftorder(p-&gt;right);\n		printf(\'%d \',p-&gt;key);\n	}\n}\n\nvoid bst::rankorder()\n{\n	point* queue[100];\n	int head=1;\n	int tail=2;\n	queue[1]=root;\n	while(head!=tail)\n	{\n		if(queue[head]-&gt;left!=NULL) queue[tail++]=queue[head]-&gt;left;\n		if(queue[head]-&gt;right!=NULL) queue[tail++]=queue[head]-&gt;right;\n		head++;\n	}\n	for(int i=1;i&lt;=tail-1;i++) printf(\'%d \',queue[i]-&gt;key);\n}\n\nint main()\n{\n	bst my;\n	my.add(1);\n	my.add(15);\n	my.add(7);\n	my.add(5);\n	my.add(11);\n	my.add(2);\n	my.add(9);\n	my.preorder(my.returnroot());\n	cout&lt;&lt;endl;\n	my.midorder(my.returnroot());\n	cout&lt;&lt;endl;\n	my.aftorder(my.returnroot());\n	cout&lt;&lt;endl;\n	my.rankorder();\n	cout&lt;&lt;endl;\n	cout&lt;&lt;my.find(7)-&gt;key&lt;&lt;endl;\n	my.del(1);\n	my.preorder(my.returnroot());\n	return 0;\n} </pre>\n     <br/>\n     <br/>\n    </div>\n    <h2>\n     <span style=\'margin:0px; padding:0px\'>\n      6.效率低下的原因：\n     </span>\n    </h2>\n    <div style=\'font-size:13.3333px\'>\n     <span style=\'margin:0px; padding:0px\'>\n      <span>\n      </span>\n      因为作为二叉查找树，根据输入的顺序的不同，最终构造的二叉查找树的拓扑状态是不一样的，所以我们有可能最后构造出来的二叉查找树是类似于一个链表，所以我们的查找的效率会大大的降低，不会打到我们期望的logN的水平，会不断的趋近于n发展，所以说我们需要对BST进行一种优化，即将引出SBT自平衡二叉树。\n     </span>\n    </div>\n    <div style=\'font-size:13.3333px\'>\n     <span style=\'margin:0px; padding:0px\'>\n      <br/>\n     </span>\n    </div>\n    <h2>\n     <span style=\'margin:0px; padding:0px\'>\n      7.遗留问题：\n     </span>\n    </h2>\n    <div style=\'font-size:13.3333px\'>\n     <span style=\'margin:0px; padding:0px\'>\n      <span>\n      </span>\n      1.二叉查找树在退化线性结构的时候，复杂度的计算目前尚且不熟练\n     </span>\n    </div>\n    <div style=\'font-size:13.3333px\'>\n     <span style=\'margin:0px; padding:0px\'>\n      <span>\n      </span>\n      2.二分法和二叉链表的核心区别\n     </span>\n    </div>\n    <div style=\'font-size:13.3333px\'>\n     <span>\n     </span>\n     3.为什么说遍历儿茶查找树的效率相对来说会低于线性结构的数据结构，是因为访问点回溯的原因吗\n    </div>\n    <div style=\'font-size:13.3333px\'>\n     <br/>\n    </div>\n    <h2>\n     8.参考文献：\n    </h2>\n    <div style=\'font-size:13.3333px\'>\n     <a href=\'http://http//www.cnblogs.com/gaochundong/p/binary_search_tree.html\' target=\'_blank\'>\n      Scale-out Thinking的博客\n     </a>\n     <br/>\n    </div>\n    <div style=\'font-size:13.3333px\'>\n     <a href=\'http://http//bbs.csdn.net/topics/50383955\' target=\'_blank\'>\n      CSDN论坛\n     </a>\n     <br/>\n    </div>\n    <div style=\'font-size:13.3333px\'>\n     <a href=\'http://http//blog.csdn.net/qilei2010/article/details/51345278\' target=\'_blank\'>\n      递推式的复杂度分析\n     </a>\n     <br/>\n    </div>\n    <div style=\'font-size:13.3333px\'>\n     <a href=\'http://http//blog.csdn.net/npy_lp/article/details/7426431\' target=\'_blank\'>\n      tanglinux的博客\n     </a>\n     <br/>\n    </div>\n    <div>\n     <br/>\n    </div>\n   </div>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('969795d117d0046a59051ac212296854','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  最小生成树算法汇总\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   达神上次给我提了一个建议，对算法进行数学证明，我也是这么想的，但是这样的话，我就需要在自学一遍算法学了，不过学习嘛，就是这样\n  </p>\n  <p>\n   所以，再过几期之后我会开始自学算法学，尽力将数学证明过程添加到讲解里面，让算法变的更加的“原来如此\n   <span style=\'font-size:12px\'>\n    ”\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <br/>\n   </span>\n  </p>\n  <p>\n   步入正题：\n  </p>\n  <h1>\n   最小生成树算法汇总\n  </h1>\n  <h2>\n   1.Krustral（贪心+并查集+排序）\n  </h2>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.算法的思路：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   Krustral算法通过边集数组来保存图中的边的信息，我们通过对边集数组按照边的权重进行排序后，按照从小到大的顺序每次选择一条边（头和尾不在不在一个集合中（并查集判断））知道我们选择完了n-1条边之后，最小生成树酒构造完毕（算法的贪心的证明我以后会给出）\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.算法举例描述（无情的粘自百度百科，毕竟人家有图言卵）：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n    <a href=\'http://http://baike.baidu.com/link?url=Qx0ctZuS7IOi27Avtc1aVoiqAhfcwUo5YFs1q6ph69qsCCfWeupcphDHBoBIRnJloQEKfzIlriiAn6_ul0xKs_\' target=\'_blank\'>\n     百度讲解Krustral\n    </a>\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   3.代码示例：\n  </h3>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1790276\' name=\'code\' snippet_file_name=\'blog_20160728_1_4837988\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int x,y;\n	int weight;\n}e;\n\ne edge[100];\nint fa[100];\nint deep[100];\nint n,m;\nint sum=0;\n\nvoid init()\n{\n	for(int i=1;i&lt;=n;i++)\n	{\n		fa[i]=i;\n		deep[i]=1;\n	}\n}\n\nint find(int x)\n{\n	if(x==fa[x]) return x;\n	else return fa[x]=find(fa[x]);\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y]) fa[y]=x;\n		else\n		{\n			fa[x]=y;\n			if(deep[x]==deep[y]) deep[y]++;\n		}\n	}\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nvoid quicksort(int left,int right)\n{\n	if(left&gt;right) return ;\n	else\n	{\n		int i=left;\n		int j=right;\n		e t;\n		e temp=edge[left];\n		while(i!=j)\n		{\n			while(i&lt;j&amp;&amp;edge[j].weight&gt;=temp.weight) j--;\n			while(i&lt;j&amp;&amp;edge[i].weight&lt;=temp.weight) i++;\n			if(i&lt;j)\n			{\n				t=edge[i];\n				edge[i]=edge[j];\n				edge[j]=t;\n			}\n		}\n		edge[left]=edge[i];\n		edge[i]=temp;\n		quicksort(left,i-1);\n		quicksort(i+1,right);\n		return ;\n	}\n}\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=m;i++) cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].weight;\n	init();\n	quicksort(1,m);\n	for(int i=1;i&lt;=n-1;)\n	{\n		if(!same(edge[i].x,edge[i].y))\n		{\n			unit(edge[i].x,edge[i].y);\n			sum+=edge[i].weight;\n			i++;\n		}\n	}\n	cout&lt;&lt;sum&lt;&lt;endl;\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   4.数据结构的选择：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   因为我们要涉及到边集的排序，所以我们选择边集数组算是一个不错的选择\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   5.总结：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   Krustral算法通过利用贪心的策略，每一次都是选择相对小最小的权值的边，直至构建出来最小生成树，在这里，排序算法我推荐快排，冰茶记得作用是通过判断是否具有仙童的父亲来判断这条边是否会构成回路，从而方便我们进行选择。\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   2.Prim（贪心+扩展）\n  </h2>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.算法的思路：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   在这里Prim算法思路和Dijstra算法的思路有一些类似，我们都通过开辟内存空间记录距离，但是区别在于，Dijstra算法记录的是单元最短路距离，而，Prim算法的记录数组记录的是点到生成树的最短距离\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.算法的过程：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   初始的时候选择一个开始源点，此时生成树中只有她一个源点，所以此时dis数组的含义就是其他店到该生成树上的最短距离，然后我们选择最近的一个加入到生成树中，形成新的生成树，然后进行dis数组的维护，知道所有的点都已经在生成树中为止\n   <span style=\'white-space:pre\'>\n   </span>\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   3.代码示例：\n  </h3>\n  <h4>\n   <span style=\'white-space:pre\'>\n   </span>\n   3.1》》朴素Prim：\n  </h4>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1790276\' name=\'code\' snippet_file_name=\'blog_20160728_2_3015871\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nint n,m;\nint dis[100];\nint u[100];\nint v[100];\nint w[100];\nint first[100];\nint nextk[100];\nint book[100];\nint sum=0;\nint inf=99999999;\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=inf;\n		first[i]=-1;\n		book[i]=0;\n	}\n	memset(nextk,0,sizeof(nextk));\n	dis[1]=0;    //我把 1 当作初始扩展节点\n	book[1]=1;\n	for(int i=1;i&lt;=m;i++) cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n	for(int i=m+1;i&lt;=2*m;i++)   //无向图 \n	{\n		u[i]=v[i-m];\n		v[i]=u[i-m];\n		w[i]=w[i-m]; \n	}\n	for(int i=1;i&lt;=2*m;i++)\n	{\n		nextk[i]=first[u[i]];\n		first[u[i]]=i;\n	}\n	int k=first[1];\n	while(k!=-1)\n	{\n		dis[v[k]]=w[k];\n		k=nextk[k];\n	} \n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int minpoint;\n		int mink=inf;\n		for(int j=1;j&lt;=n;j++)   //寻找最近的节点 \n		{\n			if(book[j]==0&amp;&amp;dis[j]&lt;mink)\n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		}\n		book[minpoint]=1;\n		sum+=dis[minpoint];\n		k=first[minpoint];\n		while(k!=-1)    //松弛出边 \n		{\n			if(dis[v[k]]&gt;w[k]) dis[v[k]]=w[k];\n			k=nextk[k];\n		}\n	}\n	cout&lt;&lt;sum&lt;&lt;endl; \n	return 0;\n}</pre>\n   <br/>\n   <h4>\n    <span style=\'white-space:pre\'>\n    </span>\n    3.2》》堆优化：\n   </h4>\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1790276\' name=\'code\' snippet_file_name=\'blog_20160728_3_1892649\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nint n,m;\nint u[100];\nint v[100];\nint w[100];\nint first[100];\nint nextk[100];\nint dis[100];\nint heap[100];\nint pos[100];\nint sum=0;\nint inf=99999999;\nint heapnum=0;\n\nvoid swap(int x,int y)\n{\n	int t=heap[x];\n	heap[x]=heap[y];\n	heap[y]=t;\n	\n	t=pos[heap[x]];    //同步调整 \n	pos[heap[x]]=pos[heap[y]];\n	pos[heap[y]]=t;\n}\n\nvoid siftdown(int i)\n{\n	int t,flag=0;\n	while(i*2&lt;=heapnum&amp;&amp;flag==0)\n	{\n		if(dis[heap[i]]&gt;dis[heap[i*2]]) t=i*2;\n		else t=i;\n		if(i*2+1&lt;=heapnum&amp;&amp;dis[heap[i*2+1]]&lt;dis[heap[t]]) t=i*2+1;\n		if(t!=i)\n		{\n			swap(i,t);\n			i=t;\n		} \n		else flag=1;\n	}\n} \n\nvoid siftup(int i)\n{\n	int t,flag=0;\n	while(i!=1&amp;&amp;flag==0)\n	{\n		if(dis[heap[i]]&lt;dis[heap[i/2]])\n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else flag=1;\n	}\n}\n\nint pop()\n{\n	int t=heap[1];\n	swap(1,heapnum);\n	heapnum--;\n	siftdown(1);\n	return t;\n}\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	memset(first,-1,sizeof(first));\n	memset(nextk,0,sizeof(nextk));\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=inf;\n		heap[i]=pos[i]=i;\n	}\n	for(int i=1;i&lt;=m;i++) cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n	for(int i=1+m;i&lt;=2*m;i++)\n	{\n		u[i]=v[i-m];\n		v[i]=u[i-m];\n		w[i]=w[i-m];\n	}\n	for(int i=1;i&lt;=2*m;i++)\n	{\n		nextk[i]=first[u[i]];\n		first[u[i]]=i;\n	}\n	int k=first[1];\n	dis[1]=0;    //同样以 1 为初始节点\n	heapnum=n;\n	while(k!=-1)\n	{\n		dis[v[k]]=w[k];\n		k=nextk[k];\n	}\n	for(int i=n/2;i&gt;=1;i--) siftdown(i);   //堆初始化 \n	pop();\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int d=pop();    //弹出节点 \n		sum+=dis[d];\n		k=first[d];\n		while(k!=-1) \n		{\n			if(dis[v[k]]&gt;w[k])\n			{\n				dis[v[k]]=w[k];   \n				siftup(pos[v[k]]);   //按照dis数组进行堆调整 \n			}\n			k=nextk[k];\n		}\n	} \n	cout&lt;&lt;sum&lt;&lt;endl; \n	return 0;\n}</pre>\n   <br/>\n   <h3>\n    <span style=\'white-space:pre\'>\n    </span>\n    4.数据结构的选择：\n   </h3>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   因为我们要涉及到对节点出边松弛，所以说我们用数组链表（邻接表）可以很简单的实现\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   5.堆优化：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   通过对来进行优化，我们可以降低选边的复杂度，从而加快prim算法的速度\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.路径记录的策略：\n  </h2>\n  <div>\n   其实我们都可以用二维数组的方式来记录两个顶点之间是否存在边，但是二维数组的空间消耗太大，所以引出下面的方法\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.Krustral算法：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   Krustral算法应用了边集数组，所以我们可以直接记录边就可以记录下来最小生成树中的边\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.Prim算法：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   Prim算法因为是采用了邻接表还不断进进行了变得优化，看样子好像无法记录，但是实际上，我们可以开辟一个前驱数组记录在最小生成树中直接连\n   <pre class=\'cpp\' code_snippet_id=\'1790276\' name=\'code\' snippet_file_name=\'blog_20160728_4_1957122\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nint n,m;\nint u[100];\nint v[100];\nint w[100];\nint first[100];\nint nextk[100];\nint dis[100];\nint heap[100];\nint pos[100];\nint sum=0;\nint inf=99999999;\nint heapnum=0;\nint pre[100];\n\ntypedef struct node\n{\n	int x,y;\n	int weight;\n}e;\n\ne edge[100];\n\nvoid swap(int x,int y)\n{\n	int t=heap[x];\n	heap[x]=heap[y];\n	heap[y]=t;\n	\n	t=pos[heap[x]];    //同步调整 \n	pos[heap[x]]=pos[heap[y]];\n	pos[heap[y]]=t;\n}\n\nvoid siftdown(int i)\n{\n	int t,flag=0;\n	while(i*2&lt;=heapnum&amp;&amp;flag==0)\n	{\n		if(dis[heap[i]]&gt;dis[heap[i*2]]) t=i*2;\n		else t=i;\n		if(i*2+1&lt;=heapnum&amp;&amp;dis[heap[i*2+1]]&lt;dis[heap[t]]) t=i*2+1;\n		if(t!=i)\n		{\n			swap(i,t);\n			i=t;\n		} \n		else flag=1;\n	}\n} \n\nvoid siftup(int i)\n{\n	int t,flag=0;\n	while(i!=1&amp;&amp;flag==0)\n	{\n		if(dis[heap[i]]&lt;dis[heap[i/2]])\n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else flag=1;\n	}\n}\n\nint pop()\n{\n	int t=heap[1];\n	swap(1,heapnum);\n	heapnum--;\n	siftdown(1);\n	return t;\n}\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	memset(first,-1,sizeof(first));\n	memset(nextk,0,sizeof(nextk));\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=inf;\n		heap[i]=pos[i]=pre[i]=i;   //开始每个点的前驱都是自己，因为 1 是厨师的节点所以1的前驱永远是自己，这一点反而可以用作我们判断 \n	}\n	for(int i=1;i&lt;=m;i++) cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n	for(int i=1+m;i&lt;=2*m;i++)\n	{\n		u[i]=v[i-m];\n		v[i]=u[i-m];\n		w[i]=w[i-m];\n	}\n	for(int i=1;i&lt;=2*m;i++)\n	{\n		nextk[i]=first[u[i]];\n		first[u[i]]=i;\n	}\n	int k=first[1];\n	dis[1]=0;    //同样以 1 为初始节点\n	heapnum=n;\n	while(k!=-1)\n	{\n		dis[v[k]]=w[k];\n		pre[v[k]]=1;\n		k=nextk[k];\n	}\n	for(int i=n/2;i&gt;=1;i--) siftdown(i);   //堆初始化 \n	pop();\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int d=pop();    //弹出节点 \n		sum+=dis[d];\n		k=first[d];\n		while(k!=-1) \n		{\n			if(dis[v[k]]&gt;w[k])\n			{\n				dis[v[k]]=w[k];\n				pre[v[k]]=u[k];   //修改前驱   \n				siftup(pos[v[k]]);   //按照dis数组进行堆调整 \n			}\n			k=nextk[k];\n		}\n		edge[i].x=pre[d];\n		edge[i].y=d;\n		edge[i].weight=dis[d];\n	} \n	for(int i=1;i&lt;=n-1;i++)\n	{\n		cout&lt;&lt;edge[i].x&lt;&lt;\'-\'&lt;&lt;edge[i].y&lt;&lt;\'-\'&lt;&lt;edge[i].weight&lt;&lt;endl;\n	}\n	cout&lt;&lt;sum&lt;&lt;endl; \n	return 0;\n}</pre>\n   <br/>\n  </div>\n  <h2>\n   4.次小生成树（动态规划+最小生成树）\n  </h2>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.算法描述：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   我们发现在最小生成树上加一条边必然会构成一个环，那么如果我枚举出来所有的环得情况，然后都删除掉环中\n   <strong>\n    第二大的边\n   </strong>\n   ，找到最小的那种变更情况不就是次小生成树了吗，在这里我要对第二大进行一下简单的解析，如果加了一条不在生成树上的边，那么这条边必然是加后环里面最大的边，为什么呢，如果这条边在不再生成树里面，说明它比环的和还要大，所以必然是最大得，我们只要删除第二大的就好，因为这样才可以保证是次小的\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   我们用反证法来证明一下，构成环的那一个新家的边一定是乘的环里面最大的一条边\n  </div>\n  <div>\n   我们加上这条不在生成树中的边，构成了环，如果该边比环中的其中一条边的权值小，那么我们完全可以删除比他大的边构成一个更小的最小生成树，但是实际上我们意境的到了最小生成树，所以我们的假设是错误的\n  </div>\n  <div>\n   即新的加的那一条边必定是新城的环中最大的一条边\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.算法的实现：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   在这里，我们用到了动态规划的思想，我们开辟所谓的dp二位数组，dp[i][]j用来记录从i到j的路径中最大的那条边的权值\n  </div>\n  <div>\n   在这里动态转移方程是dp[i][j]=max(dp[i][j],min) 【min的含义是目前我们在进行最小生成树的构建过程中，挑选出来的最短的边的权值】\n  </div>\n  <div>\n   最后我们只要枚举出所有不在最小生成树上的点之后，统一计算一下新的生成树的权值求出最小的那就是次小生成树的权值\n  </div>\n  <div>\n   在这里如果我们要记录边的话，需要再开辟一个记录内存保存当前的最小的次小生成树的边的状态，如果遇到更小的，用原来的最小生成树的替换一下就好（还有好方法吗？）\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   3.注意要点：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   因为这里我们需要枚举边，所以说我们最好用二维数组来保存二者之间是否存在边，空间换时间，方便我们遍历操作\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   4.代码示例：\n  </h3>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1790276\' name=\'code\' snippet_file_name=\'blog_20160728_5_1880675\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n\nusing namespace std;\n\nint n,m;\nint book[100][100];   //记录生成树上的存边 \nint sum=0;\nint u[100];\nint v[100];\nint w[100];\nint first[100];\nint nextk[100];\nint dp[100][100];     //为了节约脑力，就不写堆优化了 \nint dis[100];\nint inf=99999999;\nint vis[100];\nint pre[100];\n\nint main()\n{\n	memset(vis,0,sizeof(vis));\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=n;i++) \n	{\n		dis[i]=inf;\n		pre[i]=i;\n	}\n	dis[1]=0;\n	vis[1]=1;\n	memset(first,-1,sizeof(first));\n	memset(book,0,sizeof(book));\n	memset(dp,0,sizeof(dp));\n	for(int i=1;i&lt;=m;i++) cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n	for(int i=1+m;i&lt;=m*2;i++)\n	{\n		u[i]=v[i-m];\n		v[i]=u[i-m];\n		w[i]=w[i-m]; \n	}\n	for(int i=1;i&lt;=2*m;i++)\n	{\n		nextk[i]=first[u[i]];\n		first[u[i]]=i;\n	}\n	int k=first[1];\n	while(k!=-1)\n	{\n		dis[v[k]]=w[k];\n		pre[v[k]]=u[k];\n		k=nextk[k];\n	}\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int mink=inf;\n		int minpoint;\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(vis[j]==0&amp;&amp;dis[j]&lt;mink)\n			{\n				mink=dis[j];\n				minpoint=j;\n			}\n		}\n		book[pre[minpoint]][minpoint]=book[minpoint][pre[minpoint]]=1;   //记录最小生成树上的边 \n		vis[minpoint]=1;\n		sum+=dis[minpoint];\n		\n		for(int j=1;j&lt;=n;j++)   //动态规划 \n		{\n			if(vis[j]==1)\n			{\n				dp[minpoint][j]=dp[j][minpoint]=max(dis[minpoint],dp[j][pre[minpoint]]);\n			}\n		}\n		\n		k=first[minpoint];\n		while(k!=-1)\n		{\n			if(dis[v[k]]&gt;w[k]) \n			{\n				dis[v[k]]=w[k];\n				pre[v[k]]=minpoint;\n			}\n			k=nextk[k];\n		}\n	}\n	\n	int high=inf; \n	for(int i=1;i&lt;=n;i++)\n	{\n		int p=first[i];\n		while(p!=-1)\n		{\n			if(book[u[p]][v[p]]==0)\n			{\n				 high=min(high,sum-dp[u[p]][v[p]]+w[p]);\n				 book[u[p]][v[p]]=book[v[p]][u[p]]=1;   //杜绝下次无用的判断，把判断过的边锁死\n			}\n			p=nextk[p];\n		}\n	}\n	cout&lt;&lt;high&lt;&lt;endl;\n	return 0;\n}</pre>\n   <br/>\n   <h2>\n    <br/>\n   </h2>\n  </div>\n  <h2>\n   5.待解决的问题：\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   1.存在不存在求解k小生成树的算法呢\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.记录次小生成树上的边有没有更好的方法\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   3.堆优化Prim的判断与分析，算法的复杂度分析学习\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   6.POJ例题解决（次小生成树）：\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n    <a href=\'http://http://poj.org/problem?id=1679\' target=\'_blank\'>\n     POJ1679 次小生成树水题\n    </a>\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   AC代码如下（本体描述有问题，在下将变得大小扩大至1000则AC，意欲AC这道题的小朋友注意一下，不要相信题的100那个数据，是1000）：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1790276\' name=\'code\' snippet_file_name=\'blog_20160728_6_5566219\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n#include\'cstdlib\'\n#include\'cmath\'\n#define N 1005\n\nusing namespace std;\n\nint n,m;\nint u[N*20];\nint v[N*20];\nint w[N*20];\nint first[N];\nint nextk[N*20];\nint sum=0;\nint high=0;\nint dp[N][N];\nint pre[N];\nint book[N][N];\nint dis[N];\nint inf=99999999;\nint vis[N];\nint number[N];\nint num=0;\n\nint main()\n{\n	int t;\n	scanf(\'%d\',&amp;t);\n	while(t--)\n	{\n		scanf(\'%d%d\',&amp;n,&amp;m);\n		sum=0;\n		num=0;\n		number[++num]=1;\n		memset(first,-1,sizeof(first));\n		for(int i=1;i&lt;=n;i++) \n		{\n			dis[i]=inf;\n			pre[i]=i;\n		}\n		dis[1]=0;\n		memset(book,0,sizeof(book));\n		memset(vis,0,sizeof(vis));\n		for(int i=1;i&lt;=m;i++) scanf(\'%d%d%d\',&amp;u[i],&amp;v[i],&amp;w[i]);\n		for(int i=m+1;i&lt;=2*m;i++)\n 		{\n			u[i]=v[i-m];\n			v[i]=u[i-m];\n			w[i]=w[i-m];\n		}\n		for(int i=1;i&lt;=2*m;i++)\n		{\n			nextk[i]=first[u[i]];\n			first[u[i]]=i;\n		}\n		int k=first[1];\n		while(k!=-1)\n		{\n			dis[v[k]]=w[k];\n			pre[v[k]]=1;\n			k=nextk[k];\n		}\n		\n		vis[1]=1;\n		for(int i=1;i&lt;=n-1;i++)\n		{\n			int mink=inf;\n			int minpoint;\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(vis[j]==0&amp;&amp;dis[j]&lt;mink)\n				{\n					mink=dis[j];\n					minpoint=j;\n				}\n			}\n			vis[minpoint]=1;\n			sum+=dis[minpoint];\n			book[minpoint][pre[minpoint]]=book[pre[minpoint]][minpoint]=1;\n			\n			for(int j=1;j&lt;=num;j++) dp[minpoint][number[j]]=dp[number[j]][minpoint]=max(dp[number[j]][pre[minpoint]],dis[minpoint]);\n			\n			number[++num]=minpoint;\n			k=first[minpoint];\n			while(k!=-1)\n			{\n				if(dis[v[k]]&gt;w[k])\n				{\n					dis[v[k]]=w[k];\n					pre[v[k]]=u[k];\n				}\n				k=nextk[k];\n			}\n		}\n		\n		high=inf;\n		for(int i=1;i&lt;=n;i++)\n		{\n			k=first[i];\n			while(k!=-1)\n			{\n				if(book[u[k]][v[k]]==0)\n				{\n					high=min(high,sum+w[k]-dp[u[k]][v[k]]);\n					book[u[k]][v[k]]=book[v[k]][u[k]]=1;\n				}\n				k=nextk[k];\n			}\n		}\n		if(high==sum) printf(\'Not Unique!\n\');\n		else printf(\'%d\n\',sum);\n	}\n	return 0;\n}</pre>\n   <div>\n    <br/>\n   </div>\n   2016-11-10-补充\n   <br/>\n   <h2>\n    7.算法分析:\n   </h2>\n  </div>\n  <div>\n   1.Prim算法我们得分析会发现，我们每次要对每个点的出边就你行维护以及查询每个的最小出边，都需要遍历一遍所有的出度\n  </div>\n  <div>\n   但是我们始终没有考虑边的分类，所以说我们在图很稠密的时候，图中的边非常的多的时候，我们尽量采用Prim算法，时间复杂度是O(n^2)，n是点的数目\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   2.Krustral算法：\n  </div>\n  <div>\n   我们会发现Krustral算法的话，我们是对边的操作，先排序，我们在挑选变，所以说在边少的时候我们采用Krustral算法，时间复杂度是O(n*logn)，n是边的数目，适用于稀疏图\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   8.参考文献：\n  </h2>\n  <div>\n   <a href=\'http://http://www.cnblogs.com/hxsyl/p/3290832.html\' target=\'_blank\'>\n    火星十一郎-张鹏飞的博客\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://http://blog.sina.com.cn/s/blog_63509b890100r445.html\' target=\'_blank\'>\n    语文-满分的博客\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://http://blog.csdn.net/niushuai666/article/details/6925258\' target=\'_blank\'>\n    飘过的小牛的博客\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://http://baike.baidu.com/link?url=kOd56zqkzhfpSDcMW4F_-xPeykQluIkpfMJj55Yj7ShmBazYAA0T29W0X2FZFLBE5c8czBoSXQAe29_d555C3q\' target=\'_blank\'>\n    Krustral百度百科\n   </a>\n   <br/>\n  </div>\n  <div>\n   <a href=\'http://https://xueshu.glgoo.org/scholar?hl=zh-CN&amp;q=次小生成树&amp;btnG=&amp;lr=\' target=\'_blank\'>\n    Google学术-最小生成树论文集和\n   </a>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('107b61f763b01c3db33c036f200ac722','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  最短路径算法汇总\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   <strong>\n    <span style=\'font-size:24px\'>\n     最短路径算法精讲\n    </span>\n   </strong>\n  </h1>\n  <p>\n   <strong>\n    1.Floyd\n   </strong>\n  </p>\n  <p>\n   <strong>\n    2.Dijkstra\n   </strong>\n  </p>\n  <p>\n   <strong>\n    3.SPFA（队列优化Bellman算法）\n   </strong>\n  </p>\n  <p>\n   <strong>\n    4.Best-First-Search——A算法\n   </strong>\n  </p>\n  <p>\n   <strong>\n    5.启发式A*\n   </strong>\n  </p>\n  <p>\n   <strong>\n    6.启发式的A*的平局打破\n   </strong>\n  </p>\n  <p>\n   <strong>\n    7.目前自学存在的急需解决的问题\n   </strong>\n  </p>\n  <p>\n   <strong>\n    8.\n    <span style=\'font-size:13.3333px\'>\n     最短路径算法的优劣比较\n    </span>\n   </strong>\n  </p>\n  <p>\n   <strong>\n    9.各个算法的路径记录的策略\n   </strong>\n  </p>\n  <h2>\n   <strong>\n    1.Floyd（全局最短路径算法）\n   </strong>\n  </h2>\n  <h3>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    1）数据结构的选择：\n   </span>\n  </h3>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'font-weight:bold; white-space:pre\'>\n    </span>\n    Floyed算法是需要不断的通过第三方节点来松弛目标两个节点之间的距离，通过遍历图中所有的顶点，从而实现全局最短路径的求解\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    所以这里，我们的两点之间的边权值是要不断的改变的，所以我们果断采用邻接矩阵来进行图的存储，这样会更加利于操作\n   </span>\n  </p>\n  <h3>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    <strong>\n     2）算法的核心：\n    </strong>\n   </span>\n  </h3>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'font-weight:bold; white-space:pre\'>\n    </span>\n    我们通过求解最优子路径来求得全局最优路径，在这里，两个点之间的最优路径要么就是两点之间直接的连边，要么就是通过其他若干\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    的节点来进行松弛，所以，这里面我们一各个点为基准，构建三个循环，最外面的循环遍历所有的第三方节点，里面的循环控制两个目标\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    节点，在这里，可能有的人会问了，这样的话，只是以一个节点作为中间节点来考虑的，但是实际上，有可能最短路径包含不止一个中间节点\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    没错，在这里，我们要这么考虑，每次一个中间节点考虑完之后，邻接矩阵中的所有的边的权重都是考虑了这个已经考虑过得第三方节点\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    优化后的结果，所以我们下次再用别的第三方节点的时候就必然会将之前的所有的考虑过得第三方节点都纳入考虑过的优化范围之内，所以\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    最后的结果就是，我们任意两点之间的最短路径都是考虑了所有的第三方节点来进行优化的\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:12px\'>\n    <strong>\n     个人感觉一点：Floyd的本质很可能就是动态规划\n    </strong>\n   </span>\n  </p>\n  <h3>\n   <span style=\'font-size:12px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    <strong>\n     3) 核心代码段：\n    </strong>\n   </span>\n  </h3>\n  <p>\n  </p>\n  <pre class=\'html\' code_snippet_id=\'1771940\' name=\'code\' snippet_file_name=\'blog_20160719_1_566163\'>for(int k=1;k&lt;=n;k++)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				if(map[i][j]&gt;map[i][k]+map[k][j]) map[i][j]=map[i][k]+map[k][j];   //考虑第三方节点k的优化\n			}\n		}\n	}</pre>\n  <br/>\n  <p>\n  </p>\n  <h3>\n  </h3>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   <strong>\n    4）Floyed可以解决负权边，在下面我会提出问题，无向图的负权边会重复考虑吗？\n    <br/>\n   </strong>\n  </h3>\n  <h3>\n   <strong>\n    Floyed不可以解决负权回路，因为负权回路不存在最短路径\n   </strong>\n  </h3>\n  <p>\n  </p>\n  <p>\n   <strong>\n    <br/>\n   </strong>\n  </p>\n  <p>\n   <strong>\n    <br/>\n   </strong>\n  </p>\n  <p>\n   <strong>\n    <br/>\n   </strong>\n  </p>\n  <h2>\n   <strong>\n    2.Dijkstra（单源最短路径算法）\n   </strong>\n  </h2>\n  <h3>\n   <strong>\n    <span style=\'white-space:pre\'>\n    </span>\n    1）数据结构的选择：\n   </strong>\n  </h3>\n  <p>\n   <span style=\'font-weight:bold; white-space:pre\'>\n   </span>\n   Dijstra的核心是不断的维护一个dis数组，最后得到的dis数组中的左右的权重就是源点到图中所有的节点的最短路径的长度，所以在这里\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   数据结构我们是不必过分的强求的，邻接矩阵，邻接表，链式前向星，边集数组都是可以的，这里我们用数组模拟链表来进行数据结构的讲解\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   其他的数据结构在理解了核心的之后都是轻而易举\n  </p>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   <strong>\n    2）算法的核心：\n   </strong>\n  </h3>\n  <h4>\n   <strong>\n    <span style=\'white-space:pre\'>\n    </span>\n    1》算法大致流程：\n   </strong>\n  </h4>\n  <p>\n   <span style=\'font-weight:bold; white-space:pre\'>\n   </span>\n   a.录入图的信息完成初始化\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   b.找到在dis数组中权重最小的节点p（目前距离源节点最近的节点）\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   c.利用p的所有的出边优化源节点到p出边的临近节点的边权值\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   d.图中除了源节点以外的n-1个点都已经优化过，继续e，否则返回b\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   e.输出dis数组的权重\n  </p>\n  <h4>\n   <span style=\'white-space:pre\'>\n   </span>\n   <strong>\n    2》算法讲解：\n   </strong>\n  </h4>\n  <p>\n   <span style=\'font-weight:bold; white-space:pre\'>\n   </span>\n   Dijstra算法其实很好理解，我们每次利用距离原点最近的节点作为第三方节点来优化源节点和第三方节点的出边临近节点，当所有的\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   节点全部考虑完了以后，我们得到的必然就是单源节点到其余节点的最短路径\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   先对朴素的Dijstra来说，我们需要用book数组记录那些节点我们已经访问过，在遍历求解距离单源点最近的节点的时候我们可以不访问\n  </p>\n  <p>\n   <span style=\'white-space:pre\'>\n   </span>\n   那些考虑过的节点\n  </p>\n  <h5>\n   <span style=\'white-space:pre\'>\n   </span>\n   <strong>\n    2.1》朴素的Dijstra算法的示例代码：\n   </strong>\n  </h5>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1771940\' name=\'code\' snippet_file_name=\'blog_20160719_2_1503471\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define inf 99999999\n#define Nedge 5000\n#define Npoint 1000\n\nusing namespace std;\n\nint u[Nedge];\nint v[Nedge];\nint w[Nedge];\nint first[Npoint];\nint nextk[Nedge];\n//上面是链式前向星的数据结构 \nint book[Npoint];\nint npoint,nedge;\nint dis[Npoint];\n\nint main()\n{\n	cin&gt;&gt;npoint&gt;&gt;nedge;\n	memset(book,0,sizeof(book));\n	memset(first,-1,sizeof(first));\n	memset(nextk,0,sizeof(nextk));\n	for(int i=1;i&lt;=nedge;i++)\n	{\n		int a,b,c;\n		cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n		nextk[i]=first[u[i]];\n		first[u[i]]=i;\n	} \n	book[1]=1;\n	int k=first[1];     //这里讲 1 当做源节点，下面的代码是对dis进行初始化\n	for(int i=1;i&lt;=npoint;i++) dis[i]=inf;\n	while(k!=-1)\n	{\n		dis[v[k]]=w[k];\n		k=nextk[k];\n	} \n	dis[1]=0;    //自己到自己的距离肯定是0 \n	\n	for(int i=1;i&lt;=npoint-1;i++)\n	{\n		int minedge=inf;\n		int minpoint;\n		for(int i=1;i&lt;=npoint;i++)    //找到最近的节点 \n		{\n			if(book[i]==0&amp;&amp;dis[i]&lt;minedge)\n			{\n				minpoint=i;\n				minedge=dis[i];\n			}\n		}\n		book[minpoint]=1;\n		k=first[minpoint];\n		while(k!=-1)     //松弛出边 \n		{\n			if(book[v[k]]==0&amp;&amp;dis[v[k]]&gt;dis[minpoint]+w[k]) dis[v[k]]=dis[minpoint]+w[k];\n			k=nextk[k];\n		}\n	}\n	\n	for(int i=1;i&lt;=npoint;i++) cout&lt;&lt;dis[i]&lt;&lt;\' \'; \n	return 0;\n}</pre>\n  <span style=\'white-space:pre\'>\n  </span>\n  在这里我们要注意因为每次选最近的点都要进行遍历操作，但是我们可以优化一下，对，我们可以用堆，根据dis中的权重为判断依据，我                                   们来构建最小堆，可以大大提高Dijstra的速度\n  <p>\n  </p>\n  <h5>\n   <span style=\'white-space:pre\'>\n   </span>\n   <strong>\n    2.2》堆优化Dijstra算法代码示例\n   </strong>\n   <span style=\'font-weight:normal\'>\n    ：\n   </span>\n  </h5>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1771940\' name=\'code\' snippet_file_name=\'blog_20160719_3_7773717\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define inf 99999999\n#define NP 1000\n#define NE 2000\n\nusing namespace std;\n\nint u[NE];\nint v[NE];\nint w[NE];\nint first[NP];\nint nextk[NE];\n\nint dis[NP];\nint heap[NP];\nint pos[NP];      //pos记录i号节点在堆中的位置，在变松弛之后方便向上调整 \nint heapnumber=0;\nint n,m;\n\nvoid swap(int x,int y)\n{\n	int t=heap[x];\n	heap[x]=heap[y];\n	heap[y]=t;\n	\n	t=pos[heap[x]];     //同步更新 \n	pos[heap[x]]=pos[heap[y]];\n	pos[heap[y]]=t;\n}\n\nvoid siftdown(int i)\n{\n	int t,flag=0;\n	while(i*2&lt;=heapnumber&amp;&amp;flag==0)\n	{\n		if(dis[heap[i]]&gt;dis[heap[i*2]]) t=i*2;\n		else t=i;\n		if(i*2+1&lt;=heapnumber&amp;&amp;dis[heap[i*2+1]]&lt;dis[heap[t]]) t=i*2+1;\n		if(t!=i) \n		{\n			swap(i,t);\n			i=t;\n		}\n		else flag=1;\n	}\n} \n\nvoid siftup(int i)\n{\n	int t,flag=0;\n	while(i!=1&amp;&amp;flag==0)\n	{\n		if(dis[heap[i]]&lt;dis[heap[i/2]])\n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else flag=1;\n	}\n}\n\nint pop()\n{\n	int t=heap[1];\n	swap(1,heapnumber);\n	heapnumber--;\n	siftdown(1);\n	return t;\n}\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	heapnumber=n;\n	for(int i=1;i&lt;=n;i++)\n	{\n		first[i]=-1;\n		nextk[i]=0;\n		heap[i]=pos[i]=i;\n		dis[i]=inf;\n	}\n	dis[1]=0;    //以 1 为源点\n	for(int i=1;i&lt;=m;i++)\n	{\n		cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n		nextk[i]=first[u[i]];\n		first[u[i]]=i;\n	} \n	int k=first[1];\n	while(k!=-1)     //初始化dis数组 \n	{\n		dis[v[k]]=w[k];\n		k=nextk[k];\n	}\n	\n	for(int i=n/2;i&gt;=1;i--) siftdown(i);   //初始化堆\n	\n	pop();\n	for(int i=1;i&lt;=n-1;i++)\n	{\n		int minpoint=pop();\n		k=first[minpoint];\n		while(k!=-1)\n		{\n			if(book[v[k]]==0&amp;&amp;dis[v[k]]&gt;dis[minpoint]+w[k]) \n			{\n				dis[v[k]]=dis[minpoint]+w[k];\n				siftup(pos[v[k]]);\n			}\n			k=nextk[k];\n		} \n	} \n	\n	for(int i=1;i&lt;=n;i++) cout&lt;&lt;dis[i]&lt;&lt;\' \'; \n	return 0;\n}</pre>\n   <h3>\n    <span style=\'white-space:pre\'>\n    </span>\n    3）Dijkstra分析：援引大神的解释为什么Dijstra不能解决负权边——贪心的前提错误\n   </h3>\n  </div>\n  <div>\n   还有我们的Dijstra算法的过程中注意，我们必须要对访问过的点进行标记，之后松弛的 时候我们是不松弛被访问的点的\n  </div>\n  <div>\n   <p style=\'margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:14px; line-height:35px\'>\n    <a href=\'http://blog.csdn.net/baidu_31818237/article/details/50611592\' target=\'_blank\'>\n     点击打开链接\n    </a>\n    <br/>\n   </p>\n   <p style=\'margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:14px; line-height:35px\'>\n    我们首先来分析下含负权边的无向图：\n    <br style=\'\'/>\n    <img alt=\'\' src=\'\'/>\n    <br style=\'\'/>\n    1.先看图\n    <br style=\'\'/>\n    我们求A点到C点的最短距离，很明显答案为1.\n    <br style=\'\'/>\n    2.我们用dij来跑下，看过程：\n   </p>\n   <ul style=\'color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:14px; line-height:35px\'>\n    <li style=\'\'>\n     先把A点标记哈，不需要访问本身\n    </li>\n    <li style=\'\'>\n     首先找到距A最近的且直接相连的点（也就是两点间没有中转点）C，把C标记哈\n    </li>\n    <li style=\'\'>\n     找出C点的出点A,，B，A被标记了不管，此时A到B的距离为3，大于A到C的距离加上C到B的距离0，所以更新A到B的距离为0\n    </li>\n    <li style=\'\'>\n     更新后A到C的距离仍然为2，A到B的距离为0，A，C都被标记，只有B未被标记，进行下一步\n    </li>\n    <li style=\'\'>\n     找到距A最近的且未被标记的点B，标记B\n    </li>\n    <li style=\'\'>\n     找出B的出点A，C，然而A，C两点都被标记，不能松弛\n    </li>\n    <li style=\'\'>\n     好，程序结束，结果为A到C的距离为2而不是1，说明普通dij并不能处理带负权边的无向图\n    </li>\n   </ul>\n   <p style=\'margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:14px; line-height:35px\'>\n    3.看完了dij过程可能仍有人不是很明白为什么，没关系，待会儿会详细解释，现在我们看下带负权边的有向图：\n    <br style=\'\'/>\n    <img alt=\'\' src=\'\'/>\n    <br style=\'\'/>\n    4.如图，我们还是求A到C的最短距离，很明显，答案还是15.我们还是用dij来跑下：\n   </p>\n   <ul style=\'color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:14px; line-height:35px\'>\n    <li style=\'\'>\n     先把A点标记哈，不需要访问本身\n    </li>\n    <li style=\'\'>\n     首先找到距A最近的且直接相连的点（也就是两点间没有中转点）C，把C标记哈\n    </li>\n    <li style=\'\'>\n     找出C点的出点，哦豁，莫得，不方，莫得就不管，走下一步\n    </li>\n    <li style=\'\'>\n     找到距A最近的且未被标记的点B，标记B\n    </li>\n    <li style=\'\'>\n     找出B的出点C，好，松弛，等等！！！松弛个锤子，C是标记了的，按照dij远的点是不能松弛近的点的，所以不能松弛。\n    </li>\n    <li style=\'\'>\n     好，程序结束，结果为A到C的距离为2，跟答案不同。说明也不能用dij来处理带负权边的有向图。\n    </li>\n   </ul>\n   <p style=\'margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(85,85,85); font-family:\'microsoft yahei\'; font-size:14px; line-height:35px\'>\n    PS（有的人在倒数第二步没有判断点是否标记，导致求出来的结果是1，然而这时错误的，下面我将说明）\n    <br style=\'\'/>\n    6.我们来看看原因：\n    <br style=\'\'/>\n    我们先来看看dij的由来，dij求最短路的算法是由贪心得来的，也就是说长路径的松弛正确的前提是用来松弛它的短路径是最短的，也就是说在之后是不会变的，这在非负权值的情况下是对的，然而遇到负权值便错了，因为当加入了负权值边后便可能使之前的短边变得更短，就如图中一样，我们先访问了C点，则AC的距离在之后的距离应该是不变的，这在都是非负权值时是正确的，因为每条边都是非负的，当通过其他点来中转时，所经过的路径和必然不小于AC的距离，然而加入了负权边后，使得AC的距离变得比初始更小，这便使得前提错误，前提都错了，dij算法便不成立，结果便错误，这也是为什么有那么多人糊涂的原因，也是我专门举这个例子的原因\n   </p>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   3.SPFA (Bellman队列优化，单源最短路径)\n  </h2>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1）数据结构的选择：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   和Dijstra的操作大致相似，我们也是要维护dis数组，换言之，dis数组的结果也就是最后的单源最短路径的结果\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   所以，这里我们和Dijstra算法的数据结构是基本一样的，我们举例也是通过模拟链表的方式来进行讲解\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2）算法讲解:\n  </h3>\n  <div>\n   <h4>\n    <span style=\'white-space:pre\'>\n    </span>\n    2.1》Bellman算法步骤：\n   </h4>\n   <h4>\n    <span style=\'font-weight:normal; white-space:pre; font-size:12px\'>\n     <span style=\'white-space:pre\'>\n     </span>\n     首先，我们要先弄懂Bellman算法的原理，Bellman算法算法和Dijstra还是有区别的，Dijstra算法是枚举点，但是Bellma\n     <span style=\'white-space:pre\'>\n     </span>\n     n算法\n    </span>\n    <span style=\'font-size:12px; font-weight:normal; white-space:pre\'>\n     是枚举边，我们换个角度，从原点到所求的点之间的路径优化的方式可以看做是第三方节点加上第三方节点与目标节点之间的一\n     <span style=\'white-space:pre\'>\n     </span>\n     条边，所以\n    </span>\n    <span style=\'font-size:13.3333px; white-space:pre; font-weight:normal\'>\n     我们通过枚举边来优化两点之间的路径，但是要优化几轮才够呢\n    </span>\n    <span style=\'font-weight:normal\'>\n     <span style=\'font-size:13.3333px; white-space:pre\'>\n      我们可以这么来看，每次成功优化的时候，两点之间的\n      <span style=\'white-space:pre\'>\n      </span>\n      路径是会被扩展成另外一组路径的，这组路径的边的个数比原先的路径的个数总是多\n     </span>\n     <span style=\'font-size:13.3333px; white-space:pre\'>\n      1，所以，我们发现假如：\n     </span>\n     <span style=\'font-size:13.3333px; white-space:pre\'>\n      最坏的情况就\n      <span style=\'white-space:pre\'>\n      </span>\n      是源节点n到目标结点p之间的路径需要通过图中的所有的点来进行辅助才能优化，那么我们需要进行多少轮，才能成功将n与\n      <span style=\'white-space:pre\'>\n      </span>\n     </span>\n     <span style=\'font-size:13.3333px; white-space:pre\'>\n      p之间的路径优化到最短呢，（假设有k个节点k个节点全部连接至少要k-1条边）显然，答案是k-1，因为刚开始的时候我们一\n      <span style=\'white-space:pre\'>\n      </span>\n      条边都没有松\n     </span>\n     <span style=\'font-size:13.3333px; white-space:pre\'>\n      弛，所以，可以推理出，我们总共需要k-1轮就可以成功优化出单源最短路径\n     </span>\n     <span style=\'font-size:13.3333px; white-space:pre\'>\n     </span>\n    </span>\n   </h4>\n  </div>\n  <h4>\n   <span style=\'white-space:pre\'>\n   </span>\n   2.2》SPFA算法：\n  </h4>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   在了解了Bellman算法之后，我们开始着手SPFA算法，SPFA算法实际上是对Bellman的一种优化，我们发现实际上，Bellman算法其\n   <span style=\'white-space:pre\'>\n   </span>\n   实有的时候没必要进行n-1轮就可以结束，因为n-1轮是最坏的情况，所以我们什么时候开始判断可以结束了呢\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   这时候我们发现，假设有一个点刚刚被优化了，我们可以很明显的发现，针对这条边，也就只有这条边的出边上的终点才可以继续被优\n   <span style=\'white-space:pre\'>\n   </span>\n   化，这就给了我们启示，其实我们可以再维护一个队列，一个点如果被优化过了，那么就进队列，（当然我们这么做还需要开一个\n   <span style=\'white-space:pre\'>\n   </span>\n   book记录数组记录在队列中的节点），我们只需要对队列中的点的出边进行松弛就可以了，当队列空的时候说明松弛结束，最短路径\n   <span style=\'white-space:pre\'>\n   </span>\n   已经求出来了\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   3）代码示例：SPFA\n  </h3>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1771940\' name=\'code\' snippet_file_name=\'blog_20160719_4_4043963\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#define inf 99999999\n#define NP 1000\n#define NE 2000\n\nusing namespace std;\n\nint queue[NP*2];\nint head,tail;\nint dis[NP];\nint book[NP];\nint n,m;\nint u[NE];\nint v[NE];\nint w[NE];\nint first[NP];\nint nextk[NE]; \n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=n;i++)\n	{\n		dis[i]=inf;\n		first[i]=-1;\n		nextk[i]=0;\n		book[i]=0;\n	}\n	memset(queue,0,sizeof(queue));\n	head=tail=1;\n	dis[1]=0;     //假设 1 为源点\n	for(int i=1;i&lt;=m;i++)\n	{\n		cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n		nextk[i]=first[u[i]];\n		first[u[i]]=i; \n	} \n	queue[1]=1;\n	tail++;\n	book[1]=1;     //小心这里dis一定不可以先初始化，因为一旦初始化将源节点的出边进行添加的话，源节点的出边的弧头书不会入队列的，算法就                       //出现问题了\n	\n	while(head!=tail)\n	{\n		int k=first[queue[head]];\n		while(k!=-1)\n		{\n			if(dis[v[k]]&gt;dis[u[k]]+w[k]) \n			{\n				dis[v[k]]=dis[u[k]]+w[k];\n			    if(book[v[k]]==0)\n	     		{\n	    			book[v[k]]=1;\n	    			queue[tail]=v[k];\n	    			tail++;\n	    		}\n			}\n			k=nextk[k];\n		}\n		book[queue[head]]=0;    //这一步是非常有必要的\n		head++;\n	}\n	\n	for(int i=1;i&lt;=n;i++) cout&lt;&lt;dis[i]&lt;&lt;\' \'; \n	return 0;\n}</pre>\n   <h3>\n    <span style=\'white-space:pre\'>\n    </span>\n    4）总结:\n   </h3>\n   <div>\n    <span style=\'white-space:pre\'>\n    </span>\n    在最后，我强调一点，SPFA是可以正确的求解出负权边的\n   </div>\n  </div>\n  <div>\n   PS:2016-11-21\n  </div>\n  <div>\n   发现思维漏洞：\n  </div>\n  <div>\n   对于SPFA算法，如果我们每一个队列中的顶点松弛出边之后并没有将顶点的访问标记去掉的话，会导致程序出现错误\n  </div>\n  <div>\n   错误的原因很简单：\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1771940\' name=\'code\' snippet_file_name=\'blog_20161121_5_4444370\'>     1\n2        3\n      4  5  6</pre>\n  </div>\n  <div>\n   <span style=\'font-size:12px\'>\n    无向或者有向边为\n   </span>\n  </div>\n  <div>\n   1 2 1\n  </div>\n  <div>\n   1 3 5\n  </div>\n  <div>\n   3 4 1\n  </div>\n  <div>\n   3 5 1\n  </div>\n  <div>\n   3 6 1\n   <br/>\n  </div>\n  <div>\n   如果我们不将3号顶点取出队列的话，我们会发现，通过2顶点我们可以对3重新松弛，但是3不出顶点的话，我们无法对4,5,6继续松弛，这是有问题的\n  </div>\n  <div>\n   所以中间注释的那一句book[queue[head]]=0;是非常有必要的\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   5）SPFA的拓展应用：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   我们如果在优化完了以后，重新遍历一边所有的边，如果我们发现仍按存在可以松弛的情况，只能说明一点，存在负权回路\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   4.Best-First-Search(带启发函数的最短寻路算法 A)\n  </h2>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1）简介：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   虽然缩写也是BFS，但是不同于BFS，实际上我们也可以将最佳优先搜索称之为A算法，最佳优先搜索算法实际上在图搜索中应用的更\n   <span style=\'white-space:pre\'>\n   </span>\n   为广泛,因为最佳优先算法和A*算法实际上都是在图上寻找出一条最短路径的，当然我们这里书他是启发式的，是因为和盲目搜索不同\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   BFS‘（最佳优先算法）通过启发估价函数来指向目标，所以可以比在图搜索中的Dijstra的四周盲目搜索更有目的性，当然也就更快\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2）实现：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   在下实在是才疏学浅，瞻仰大神们的博客之后才率为了解了一点原理，这里的原理就只有启发估价函数F(n)了，\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   F（n）=h(n)    //h（n）是当前位置到终点位置的估价，目的是，尽量避免盲目搜索，让搜索具有优先性，\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   3）数据结构的选择：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   我们既然是有优先性的选择的话，那么我们就需要一个优先队列来实现维护一个Open表，然后我们再用一个Close表来保存已经访问\n   <span style=\'white-space:pre\'>\n   </span>\n   过的位置\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   4）算法描述：\n  </h3>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   <span style=\'font-weight:normal\'>\n    最佳优先搜索的过程可以被描述为：\n    <span style=\'font-size:12px\'>\n    </span>\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-size:12px; font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    a.将根节点放入优先队列open中。\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    b.从优先队列中取出优先级最高的节点X。\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    c.根据节点X生成子节点Y:\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    c.1. X的子节点Y不在open队列或者closed中，由估价函数计算出估价值，放入open队列中。\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    c.2. X的子节点Y在open队列中，且估价值优于open队列中的子节点Y，将open队列中的子节点Y的估价值替\n    <span style=\'white-space:pre\'>\n    </span>\n    换成新的估价值并按优先值排序。\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    c.3. X的子节点Y在closed集中，且估价值优于closed集中的子节点Y，将closed集中的子节点Y移除，并将子\n    <span style=\'white-space:pre\'>\n    </span>\n    节点Y加入open优先队列。     //c.3的目的是：把优化后的位置的参数保留下来，让其对后续扩展节点都进行优化\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    d.将节点X放入closed集中。\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    e.重复过程2,3,4直到目标节点找到，或者open为空，程序结束。\n   </span>\n  </h3>\n  <h3>\n   <span style=\'font-weight:normal; white-space:pre\'>\n   </span>\n   5）代码示例：\n  </h3>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   简易的题目描述，找到从起点到终点的最短路径，（在二维地图上）0表示空地，1表示障碍物，并输出路径（本问题中采用的启发式函\n   <span style=\'white-space:pre\'>\n   </span>\n   数应用欧几里得距离——连线距离）\n  </div>\n  <div>\n   <pre class=\'cpp\' code_snippet_id=\'1771940\' name=\'code\' snippet_file_name=\'blog_20160719_5_8362361\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cmath\'\n#define N 1000\n\nusing namespace std;\n\ntypedef struct node\n{\n	int c;\n	int x,y;\n	double prev;    //优先顺序 \n	int px,py;     //记录前驱，输出路径的时候需要 \n}point;\n\nint book[100][100];    //记录是否在close数组里面 \npoint map[100][100];\npoint pre[N];     //堆\nint numpre=0; \npoint close[N];\nint numclo=0;\nint nextk[4][2]={{1,0},{0,1},{-1,0},{0,-1}};   //四个方向的扩展 \n\nint n,m;\nint sx,sy;\nint ex,ey;\n\nvoid swap(int x,int y)\n{\n	point t=pre[x];\n	pre[x]=pre[y];\n	pre[y]=t;\n}\n\npoint count(int x,int y)\n{\n	point w;\n	w.x=x;w.y=y;\n	w.prev=sqrt(pow(w.x-ex,2)+pow(w.y-ey,2));\n	return w;\n}\n\nvoid siftup(int i)\n{\n	int t,flag=0;\n	while(i!=1&amp;&amp;flag==0)\n	{\n		if(pre[i].prev&lt;pre[i/2].prev) \n		{\n			swap(i,i/2);\n			i=i/2;\n		}\n		else flag=1;\n	}\n}\n\nvoid siftdown(int i)\n{\n	int t,flag=0;\n	while(i*2&lt;=numpre&amp;&amp;flag==0)\n	{\n		if(pre[i].prev&gt;pre[i*2].prev) t=i*2;\n		else t=i;\n		if(i*2+1&lt;=numpre&amp;&amp;pre[i*2+1].prev&lt;pre[t].prev) t=i*2+1;\n		if(t!=i)\n		{\n			swap(i,t);\n			i=t;\n		}\n		else flag=1;\n	}\n}\n\npoint pop()\n{\n	point k=pre[1];\n	pre[1]=pre[numpre];\n	siftdown(1);\n	numpre--;\n	close[++numclo]=k;\n	book[k.x][k.y]=1;\n	return k;\n}\n\nvoid push(int x,int y,int a,int b)\n{\n	pre[++numpre].x=x;pre[numpre].y=y;\n	pre[numpre].px=a;pre[numpre].py=b;\n	pre[numpre].prev=count(x,y).prev;\n	siftup(numpre);\n}\n\nbool judgeopen(int x,int y)\n{\n	for(int i=1;i&lt;=numpre;i++)\n	{\n		if(pre[i].x==x&amp;&amp;pre[i].y==y)    //因为我把g（n）耗散函数设为零了，这样方便一点，这一向我们就可以不用进行处理了\n			return 1;\n	}\n	return 0;\n}\n\nbool judgeclose(int x,int y,int a,int b)\n{\n	for(int i=1;i&lt;=numclo;i++)\n	{\n		if(x==sx&amp;&amp;y==sy) return 1;\n		if(close[i].x==x&amp;&amp;close[i].y==y&amp;&amp;count(x,y).prev&lt;close[i].prev)\n		{\n			pre[++numpre]=close[i];\n			pre[numpre].px=a,pre[numpre].py=b;\n			pre[numpre].prev=count(x,y).prev;\n			return 1;\n		}\n	}\n	return 0;\n}\n\nint main()\n{\n	memset(book,0,sizeof(book)); \n	cin&gt;&gt;n&gt;&gt;m;\n	memset(map,0,sizeof(map));\n	memset(pre,0,sizeof(pre));\n	memset(close,0,sizeof(close));\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=m;j++)\n		{\n			cin&gt;&gt;map[i][j].c;\n		}\n	}\n	cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey;\n	map[sx][sy]=count(sx,sy);map[sx][sy].px=map[sx][sy].py=0;\n	pre[1]=count(sx,sy);pre[1].px=pre[1].py=0;\n	numpre++;\n	while(numpre!=0)\n	{\n		point w=pop();\n		for(int i=0;i&lt;4;i++)\n		{\n			int dx=w.x+nextk[i][0];\n			int dy=w.y+nextk[i][1];\n			if(book[dx][dy]==0) \n			{\n				map[dx][dy].x=dx;map[dx][dy].y=dy;\n	    		map[dx][dy].px=w.x;\n		    	map[dx][dy].py=w.y;\n			}\n			if(dx==ex&amp;&amp;dy==ey)\n			{\n				numpre=0;\n				break;\n			}\n			if(map[dx][dy].c==1||dx&lt;1||dx&gt;n||dy&lt;1||dy&gt;m||book[dx][dy]==1) continue;\n			if(judgeopen(dx,dy));\n			else if(judgeclose(dx,dy,w.x,w.y));\n			else push(dx,dy,w.x,w.y);\n		}\n	}\n	point stack[N];\n	memset(stack,0,sizeof(stack));\n	int numberofstack=0;\n	stack[1]=map[ex][ey];\n	numberofstack=1;\n	while(!(stack[numberofstack].px==0&amp;&amp;stack[numberofstack].py==0))\n	{\n		stack[numberofstack+1]=map[stack[numberofstack].px][stack[numberofstack].py];\n		numberofstack++;\n	}\n	for(int i=numberofstack;i&gt;=1;i--) cout&lt;&lt;\'(\'&lt;&lt;stack[i].x&lt;&lt;\',\'&lt;&lt;stack[i].y&lt;&lt;\')\'&lt;&lt;endl;\n	return 0;\n} </pre>\n   <h3>\n    <span style=\'white-space:pre\'>\n    </span>\n    6）比较与Dijstra：\n   </h3>\n   <div>\n    <span style=\'white-space:pre\'>\n    </span>\n    相对于Dijstra而言，BFS更具有目的性，也就是说，我们在搜索的时候根据优先队列会优先选择要扩展的点，这在图搜索中十分有用\n    <span style=\'white-space:pre\'>\n    </span>\n    的，Dijstra属于盲目搜索，因为没有启发，所以搜索的时候我们事项四周进行的，没有目的性的扩展队列，所以说在图很大的时候，我\n    <span style=\'white-space:pre\'>\n    </span>\n    们用启发式的搜索会更快一点\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <h2>\n    5+6.启发式A*\n   </h2>\n   <h3>\n    <span style=\'white-space:pre\'>\n    </span>\n    1）启发式的A*算法简介：\n   </h3>\n   <div>\n    <span style=\'white-space:pre\'>\n    </span>\n    启发式的A*算法实在BFS（最佳优先搜索）的基础上增添了所谓的耗散函数，通过耗散函数和误差估计函数之和，从而决定我们优先开\n    <span style=\'white-space:pre\'>\n    </span>\n    发的顺序\n   </div>\n   <h3>\n    <span style=\'white-space:pre\'>\n    </span>\n    2）启发式A*算法和BFS基本上原理：\n   </h3>\n   <div>\n    <span style=\'white-space:pre\'>\n    </span>\n    这里的原理是差不多的，鄙人也总结不出来好的意见，这里援引大牛的博客就好，平局打破的思路是非常的优秀的\n   </div>\n   <div>\n    <span style=\'white-space:pre\'>\n     <a href=\'http://http://blog.csdn.net/free4wuyou/article/details/15676597\' target=\'_blank\'>\n      启发式A*以及平局打破的策略\n     </a>\n     （\n    </span>\n    我们打破平局的原因是，如果我们考虑平局的话，有可能我们会将所有的最短路径都遍历一遍，但是实                                         际上我们只需要找到一个最短路径就可以了，所以通过各种策略减少遍历的个数——本人比较倾向于计算向量内积的策略）\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <div>\n    <br/>\n   </div>\n   <h2>\n    7.目前的问题：\n   </h2>\n  </div>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   1）SPFA如何解决负权边\n  </h3>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   2）Floyed的动态规划原理理解\n  </h3>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   3）Dijstra的贪心原理理解\n  </h3>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   4）启发式算法A*的深度优化的原理\n   <span style=\'white-space:pre\'>\n   </span>\n  </h3>\n  <h3>\n   <span style=\'white-space:pre\'>\n   </span>\n   5）Floyed算法的路径记录策略\n  </h3>\n  <h2>\n   <br/>\n  </h2>\n  <h2>\n   8.路径记录的策略：\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   对于图来说，我们可以构造结构体，开辟内存记录前驱，但是对于Floyed算法，暂时没有想到好的解决思路\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   对于普通的有图的问题中，我们如果需要正向的输出路径，可以开辟栈来存储，然后反向输出，这里要注意\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   记录前驱以后，我们每次要不断在循环中的更新前驱，还要在起点处的前驱设置特别标记，否则会找不到头\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <h2>\n   9.参考文献：\n  </h2>\n  <div>\n   <span style=\'white-space:pre\'>\n   </span>\n   《算法的乐趣》\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n    <a href=\'http://http://tungfaifong.com/best-first_search/\' target=\'_blank\'>\n     TUNGFAIFONG\n    </a>\n   </span>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n    <a href=\'http://http://tungfaifong.com/a-star_search/\' target=\'_blank\'>\n     TUNGFAIFONG\n    </a>\n   </span>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n    <a href=\'http://http://blog.csdn.net/free4wuyou/article/details/15676597\' target=\'_blank\'>\n     free4wuyou\n    </a>\n   </span>\n  </div>\n  <div>\n   <span style=\'white-space:pre\'>\n    <a href=\'http://http://blog.csdn.net/shi_zyb/article/details/44833489\' target=\'_blank\'>\n     shi_zyb\n    </a>\n   </span>\n  </div>\n  <div>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('f7ed70049dcb92e8b2f6244c9eeece3f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU 并查集 1272\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1764993\' name=\'code\' snippet_file_name=\'blog_20160715_1_8784164\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nbool book[200000];\nint edge=0;\nint point=0;\nint x,y;\nint fa[200000];\nint deep[200000];\nint flag=0;\n\nvoid init()\n{\n	for(int i=1;i&lt;=200000;i++)\n	{\n		fa[i]=i;\n		deep[i]=0; \n	}\n}\n\nint find(int x)\n{\n	if(fa[x]==x) return x;\n	else\n	{\n		return fa[x]=find(fa[x]);\n	}\n}\n\nvoid unit(int x,int y)\n{\n	x=find(x);\n	y=find(y);\n	if(x==y) return ;\n	else\n	{\n		if(deep[x]&gt;deep[y]) fa[y]=x;\n		else\n		{\n			fa[x]=y;\n			if(deep[x]==deep[y]) deep[y]++;\n		}\n	}\n}\n\nbool same(int x,int y)\n{\n	return find(x)==find(y);\n}\n\nint main()\n{\n	x=y=0;\n	while(1)\n	{\n		memset(book,0,sizeof(book));\n		flag=0;\n		edge=0;\n		point=0;\n		init();\n 		while(1)\n		{\n			scanf(\'%d%d\',&amp;x,&amp;y);\n			if(x==0&amp;&amp;y==0) \n			{\n				getchar();\n				break;\n			}\n			if(x==-1&amp;&amp;y==-1) exit(0);\n			if(same(x,y)) \n			{\n				flag=1;\n			}\n 			else\n 			{\n 				unit(x,y);\n 				edge++;\n 				if(book[x]==0) point++;\n 				if(book[y]==0) point++;\n 				book[x]=book[y]=1;\n 			}\n		}\n		if(flag==0&amp;&amp;point==edge+1) cout&lt;&lt;\'Yes\'&lt;&lt;endl;\n		else\n		{\n			if(flag==0&amp;&amp;point==edge&amp;&amp;point==0) cout&lt;&lt;\'Yes\'&lt;&lt;endl;\n			else cout&lt;&lt;\'No\'&lt;&lt;endl;\n		}\n    }\n	return 0;\n} </pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('98c9e65fc9bd6dcb57f1c05ab6c2374f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU 搜索 1518\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   这道题，要点比较多\n  </p>\n  <p>\n   1.在深搜之前我们可以剪两次枝：边长和不是4的倍数，或者存在任意一条边比变长和的四分之一要大，直接判否\n  </p>\n  <p>\n   2.在深搜递归的时候，一旦我们找全了四条边，就可以直接不论什么情况都直接返回就好，如果这时候不加判断条件的话，可能会一直递归到所有的解都完成，肯定会超时，下面的代码中我会注释出来\n  </p>\n  <p>\n   3.对于边长度直接就是变长和四分之一的边我们直接标注，下次就不用搜索这条边就好\n  </p>\n  <p>\n   4.在dfs函数中的最后一个judge是有很大的优化的功能的\n  </p>\n  <p>\n   这个比较难理解，就这么说吧，针对目前的情况，在之前判断不可能构成一条边的初始边，在我们下一次递归的时候，也是必定不会参与构成边的，因为下一      次递归只要没有凑成变长和的四分之一，那么只对上一次递归，len长度是只会少不会增的，好好理解一下，就明白了\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   AC代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1764490\' name=\'code\' snippet_file_name=\'blog_20160715_1_8558887\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nbool book[25];\nint stick[25];\nint sum;\nint s;\nint flag=0;\n\nvoid dfs(int have,int len,int judge)\n{\n	if(have==4)\n	{\n		flag=1;\n		return ;     //直接递归回去\n	}\n	if(len==sum/4)\n	{\n		dfs(have+1,0,1);\n		if(flag==1) return ;     //直接递归回去\n	}\n	for(int i=judge;i&lt;=s;i++)\n	{\n		if(book[i]==0&amp;&amp;len+stick[i]&lt;=sum/4)\n		{\n			book[i]=1;\n			dfs(have,len+stick[i],i+1);\n			if(flag==1) return ;       //直接递归回去，不进行下次的递归，因为已经找到了可行解\n			book[i]=0;\n		}\n	}\n}\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		flag=0;\n	    sum=0;\n		s;\n		cin&gt;&gt;s;\n		for(int i=1;i&lt;=s;i++)\n		{\n			cin&gt;&gt;stick[i];\n			sum+=stick[i];\n		}\n		if(sum%4!=0)\n		{\n			cout&lt;&lt;\'no\'&lt;&lt;endl;\n			continue;\n		}\n		int wflag=0;\n		for(int i=1;i&lt;=s;i++)\n		{\n			if(stick[i]&gt;sum/4) \n			{\n				cout&lt;&lt;\'no\'&lt;&lt;endl;\n				wflag=1;\n				break;\n			}\n		}\n		if(wflag==1) \n		{\n			cout&lt;&lt;\'no\'&lt;&lt;endl;\n			continue;\n		}\n		\n		memset(book,0,sizeof(book));\n		int count=0;\n		for(int i=1;i&lt;=s;i++)\n		{\n			if(stick[i]==sum/4)\n			{\n			     count++;\n			     book[i]=1;\n			}\n		}\n		dfs(count,0,1);\n		if(flag==1) cout&lt;&lt;\'yes\'&lt;&lt;endl;\n		else cout&lt;&lt;\'no\'&lt;&lt;endl; \n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('70127a99e31e7a9dd63caafb50b1d37c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU 搜索 2952\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1764311\' name=\'code\' snippet_file_name=\'blog_20160715_1_8245166\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nchar map[105][105];\nint book[105][105];\nint n,m;\nint nextk[4][2]={{1,0},{-1,0},{0,-1},{0,1}};\nint sum=0;\n\nvoid dfs(int i,int j)\n{\n	for(int a=0;a&lt;4;a++)\n	{\n		int dx=i+nextk[a][0];\n		int dy=j+nextk[a][1];\n		if(dx&lt;1||dx&gt;n||dy&lt;1||dy&gt;m||book[dx][dy]==1||map[dx][dy]!=\'#\') continue;\n		else\n		{\n			book[dx][dy]=1;\n			dfs(dx,dy);\n		}\n	}\n}\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t; \n	while(t--)\n	{\n		sum=0;\n		cin&gt;&gt;n&gt;&gt;m;\n		memset(book,0,sizeof(book));\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				cin&gt;&gt;map[i][j];\n			}\n		}\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				if(book[i][j]==0&amp;&amp;map[i][j]==\'#\')\n				{\n					book[i][j]=1;\n					sum++;\n					dfs(i,j);\n				}\n			}\n		}\n		cout&lt;&lt;sum&lt;&lt;endl;\n	} \n	return 0;\n} </pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('6d5d09f93bb79d1554fdce507b9be8d1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU 搜索 1241\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1764274\' name=\'code\' snippet_file_name=\'blog_20160715_1_3941882\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n\nusing namespace std;\n\nchar map[105][105];\nint n,m;\nint sum=0;\nbool book[105][105];\nint nextk[8][2]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n\nvoid dfs(int i,int j)\n{\n	for(int a=0;a&lt;8;a++)\n	{\n		int dx=i+nextk[a][0];\n		int dy=j+nextk[a][1];\n		if(dx&lt;1||dx&gt;n||dy&lt;1||dy&gt;m||book[dx][dy]==1||map[dx][dy]==\'*\') continue;\n		else\n		{\n			book[dx][dy]=1;\n			dfs(dx,dy);\n		}\n	}\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)==2&amp;&amp;n!=0&amp;&amp;m!=0)\n	{\n		sum=0;\n		memset(book,0,sizeof(book));\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				cin&gt;&gt;map[i][j]; \n			}\n		}\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				if(book[i][j]==0&amp;&amp;map[i][j]==\'@\')\n				{\n					book[i][j]=1;\n					sum++;\n					dfs(i,j);\n				}\n			}\n		}\n		cout&lt;&lt;sum&lt;&lt;endl;\n	}\n	return 0;\n} </pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1a6a2d7b2f80e174999594b02462c42f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  针对最近最短路径的问题的考虑\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   最近在做最短路径的题的时候，经常用到SPFA，但是我不是很喜欢用STL，所以自己模拟了一下队列，但是针对HDU上大数据的题总是RE\n  </p>\n  <p>\n   现在明白了，队列的话，我要是开的稍微小一点的话，那么队列的开头是一直在后退，但是队列的尾部一直在延伸，完全有可能会出现队列爆队的情况\n  </p>\n  <p>\n   这时候就会运行时错误，造成RE了，以后一定注意\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('68d72bdd504050c5e48c12e2f7c7c87b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU3790 SPFA\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  我终于会了SPFA\n  <pre class=\'cpp\' code_snippet_id=\'1756199\' name=\'code\' snippet_file_name=\'blog_20160711_1_249716\'>#include\'iostream\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint map[1005][1005];\nint cost[1005][1005];\nint dis[1005];\nint val[1005];\nint inf=9999999;\nint book[1005];\nint queue[70000];\nint head=1;\nint tail=1;\nint n,m,s,t;\n\nvoid spfa()\n{\n	queue[head]=s;\n	tail++;\n	book[s]=1;\n	dis[s]=val[s]=0;\n	while(head!=tail)\n	{\n		int k=queue[head];\n		for(int i=1;i&lt;=n;i++)\n		{\n			if(dis[i]&gt;dis[k]+map[k][i])\n			{\n				dis[i]=dis[k]+map[k][i];\n				val[i]=val[k]+cost[k][i];\n				if(book[i]==0)\n				{\n					queue[tail]=i;\n			    	tail++;\n			    	book[i]=1;\n				}\n			}\n			else\n			{\n				if(dis[i]==dis[k]+map[k][i]&amp;&amp;val[i]&gt;val[k]+cost[k][i])\n				{\n					val[i]=val[k]+cost[k][i];\n				}\n			}\n		}\n		book[queue[head]]=0;\n		head++;\n	}\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)==2&amp;&amp;n!=0&amp;&amp;m!=0)\n	{\n		for(int i=1;i&lt;=n;i++)\n		{\n			for(int j=1;j&lt;=n;j++)\n			{\n				map[i][j]=map[j][i]=cost[i][j]=cost[j][i]=inf;\n			}\n		}\n		memset(queue,0,sizeof(queue));\n		memset(book,0,sizeof(book));\n		head=tail=1;\n		for(int i=1;i&lt;=n;i++)\n		{\n			dis[i]=val[i]=inf;\n		}\n		for(int i=1;i&lt;=m;i++)\n		{\n			int a,b,c,d;\n			scanf(\'%d%d%d%d\',&amp;a,&amp;b,&amp;c,&amp;d);\n			if(map[a][b]&gt;c) \n			{\n				map[a][b]=map[b][a]=c;\n				cost[a][b]=cost[b][a]=d;\n			}\n			else\n			{\n				if(map[a][b]==c&amp;&amp;cost[a][b]&gt;d) cost[a][b]=cost[b][a]=d;\n			}\n		}\n		scanf(\'%d%d\',&amp;s,&amp;t);\n		spfa();\n		printf(\'%d %d\n\',dis[t],val[t]);\n	}\n	return 0;\n}</pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('850aa4315a0eb552863a889baa8b99b8','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU2544 spfa\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1756100\' name=\'code\' snippet_file_name=\'blog_20160711_1_5482829\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'queue\' \n\nusing namespace std;\n\nint u[70005];\nint v[70005];\nint w[70005];\nint first[105];\nint nextk[20010];\nint n,m;\nint a,b,c;\nint book[105];\nint dis[105];\n\nvoid spfa()\n{\n	std::queue&lt;int&gt; q;\n	q.push(1);\n	book[1]=1;\n	while(!q.empty())\n	{\n		int k=first[q.front()];\n		book[q.front()]=0;\n		q.pop();\n		while(k!=-1)\n		{\n			if(dis[v[k]]&gt;dis[u[k]]+w[k]) \n			{\n				dis[v[k]]=dis[u[k]]+w[k];\n				if(book[v[k]]==0)\n				{\n					q.push(v[k]);\n			    	book[v[k]]=1;\n				}\n			}\n			k=nextk[k];\n		}\n	}\n}\n\nint main()\n{\n	while(scanf(\'%d%d\',&amp;n,&amp;m)==2&amp;&amp;n!=0&amp;&amp;m!=0)\n	{\n		for(int i=1;i&lt;=m;i++)\n		{\n			cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n		}\n		for(int i=m+1;i&lt;=2*m;i++)\n		{\n			u[i]=v[i-m];\n			v[i]=u[i-m];\n			w[i]=w[i-m];\n		}\n		memset(first,-1,sizeof(first));\n		memset(nextk,0,sizeof(nextk));\n		for(int i=1;i&lt;=2*m;i++)\n		{\n			nextk[i]=first[u[i]];\n			first[u[i]]=i;\n		}\n		for(int i=1;i&lt;=n;i++)\n		{\n			dis[i]=9999999;\n		}\n		dis[1]=0;\n		spfa();\n		cout&lt;&lt;dis[n]&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n  这道题万分小心，邻接表对于无向图的话，要小心RE 数组越界，u，v,w数组中下标代表的是边数不是点数\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c38e9b3b7c5447f3fc6a9fd5bd17eae3','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  SPFA最短路径模板\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1755738\' name=\'code\' snippet_file_name=\'blog_20160711_1_5040237\'>int spfa(int src)\n{\n    queue&lt;int&gt; q;\n    bool inq[SIZE] = {0};\n    for(int i = 0; i &lt;= n; i++) d[i] = (i == src)? 0:INF;\n    q.push(src);\n    while(!q.empty())\n    {\n        int x = q.front(); q.pop();    //并不是很理解，为什么之前就要出队\n        inq[x] = 0;     //HDU3790之后出队会WA，找不到原因\n        for(int e = first[x]; e!=-1; e = next[e]) if(d[v[e]] &gt; d[x]+w[e])\n        {\n            d[v[e]] = d[x]+w[e];\n            if(!inq[v[e]])\n            {\n                inq[v[e]] = 1;\n                if(++sum[v[e]] &gt; n)   //判断负环 \n                {\n                    return -1;\n                }\n                q.push(v[e]);\n            }\n        }\n    }\n    if(d[n] == INF) return -2;\n    else return d[n];\n}</pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('959477141e29a0dd5d9fd81963a4641e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU 3790单源最短路径\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   这个题注意一点，千万不要用cin，太慢\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1755534\' name=\'code\' snippet_file_name=\'blog_20160711_1_2178748\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cmath\'\n\nusing namespace std;\n\nint map[1005][1005];\nint cost[1005][1005];\nint book[1005];\nint dis[1005];\nint val[1005];\nint n,m;\nint s,t;\n\nvoid dijstra()\n{\n	int j,i,k;\n	for(j=1;j&lt;n;j++)\n	{\n		int mink;\n		int minf=9999999;\n		for(i=1;i&lt;=n;i++)\n		{\n			if(book[i]==0&amp;&amp;dis[i]&lt;minf)\n			{\n				minf=dis[i];\n				mink=i;\n			}\n		}\n		book[mink]=1;\n		for(k=1;k&lt;=n;k++)\n		{\n			if(book[k]==0&amp;&amp;map[mink][k]&lt;9999999)\n			{\n			    if(dis[k]&gt;dis[mink]+map[mink][k])\n			    {\n			    	dis[k]=dis[mink]+map[mink][k];\n			    	val[k]=val[mink]+cost[mink][k];\n			    }\n			    else\n		    	{\n		     		if(dis[k]==dis[mink]+map[mink][k]&amp;&amp;val[k]&gt;val[mink]+cost[mink][k])\n		     		{\n		     			val[k]=val[mink]+cost[mink][k];\n		     		}\n			    }\n		    }\n		}\n	}\n}\n\nint main()\n{\n	int i,j; \n	int a,b,c,d;\n	while(scanf(\'%d%d\',&amp;n,&amp;m)==2&amp;&amp;n!=0)\n	{\n		for(i=1;i&lt;=n;i++)\n		{\n			for(j=1;j&lt;=n;j++)\n			{\n				map[i][j]=cost[i][j]=9999999;\n			}\n		}\n		memset(book,0,sizeof(book));\n		for(i=1;i&lt;=m;i++)\n		{\n			scanf(\'%d%d%d%d\',&amp;a,&amp;b,&amp;c,&amp;d);\n			if(map[a][b]&gt;c) \n			{\n				map[a][b]=map[b][a]=c;\n				cost[a][b]=cost[b][a]=d;\n			}\n			else\n			{\n				if(map[a][b]==c&amp;&amp;cost[a][b]&gt;d) cost[a][b]=cost[b][a]=d; \n			}\n		}\n		scanf(\'%d%d\',&amp;s,&amp;t);\n		for(i=1;i&lt;=n;i++)\n		{\n			dis[i]=map[s][i];\n			val[i]=cost[s][i];\n		}\n		dis[s]=val[s]=0;\n		book[s]=1;\n		dijstra();\n		cout&lt;&lt;dis[t]&lt;&lt;\' \'&lt;&lt;val[t]&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('72919bb289df2653d2e935c9bb3450be','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU3003 快速幂取模\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   对于这道题，我们可以退出公式（2^(n-1)+1）%n\n  </p>\n  <p>\n   ACD代码如下：再次小心LL的问题\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1754699\' name=\'code\' snippet_file_name=\'blog_20160710_1_6998057\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n\nusing namespace std;\n\nlong long quickmod(long long a,long long b,long long c)\n{\n	long long ans=1;\n	while(b&gt;0)\n	{\n		if(b%2==1) ans=(ans*a)%c;\n		b/=2;\n		a=(a*a)%c;\n	}\n	return (ans+1)%c;\n}\n\nint main()\n{\n	int n;\n	while(scanf(\'%d\',&amp;n)==1&amp;&amp;n!=0)\n	{\n		cout&lt;&lt;quickmod(2,n-1,n)&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('46895068d450af64ed4a902c09517d09','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU1061 快速幂取模\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1754668\' name=\'code\' snippet_file_name=\'blog_20160710_1_5507073\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint quickmod(long long a,long long b,int c)\n{\n	int ans=1;\n	while(b&gt;0)\n	{\n		if(b%2==1) ans=(ans*a)%c;\n		b/=2;\n		a=(a*a)%c; \n	}\n	return ans;\n}\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		int n;\n		cin&gt;&gt;n;\n		if(n==0) cout&lt;&lt;0&lt;&lt;endl;\n		else cout&lt;&lt;quickmod(n,n,10)&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('cddf940503dd4228034a4037e087c9dd','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ3070 斐波那契矩阵快速幂\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1754645\' name=\'code\' snippet_file_name=\'blog_20160710_1_272172\'>&lt;span style=\'font-family: Arial, Helvetica, sans-serif; font-size: 12px;\'&gt;AC代码：&lt;/span&gt;</pre>\n  <pre class=\'cpp\' code_snippet_id=\'1754645\' name=\'code\' snippet_file_name=\'blog_20160710_2_4110610\'>&lt;span style=\'font-family: Arial, Helvetica, sans-serif; font-size: 12px;\'&gt;#include\'iostream\'&lt;/span&gt;</pre>\n  <pre class=\'cpp\' code_snippet_id=\'1754645\' name=\'code\' snippet_file_name=\'blog_20160710_3_8920159\'>#include\'cstdio\'\n#include\'cstdlib\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int a[2][2];\n}point;\n\npoint math(point c,point d)\n{\n	point k;\n	k.a[0][0]=k.a[1][1]=k.a[0][1]=k.a[1][0]=0;\n	for(int i=0;i&lt;2;i++)\n	{\n		for(int j=0;j&lt;2;j++)\n		{\n			for(int z=0;z&lt;2;z++)\n			{\n				k.a[i][j]+=c.a[i][z]*d.a[z][j];\n			}\n			k.a[i][j]=k.a[i][j]%10000;\n		}\n	}\n	return k;\n}\n\nint quickmod(point w,int b)\n{\n	point ans;\n	ans.a[0][0]=ans.a[1][1]=1;\n	ans.a[0][1]=ans.a[1][0]=0;\n	while(b&gt;0)\n	{\n		if(b%2==1) ans=math(ans,w);\n		b=b/2;\n		w=math(w,w);\n	}\n	return ans.a[0][1]%10000;\n}\n\nint main()\n{\n	int k;\n	while(scanf(\'%d\',&amp;k)==1&amp;&amp;k!=-1)\n	{\n		if(k==0) cout&lt;&lt;0&lt;&lt;endl;\n		else \n		{\n			point w;\n			w.a[0][0]=w.a[0][1]=w.a[1][0]=1;w.a[1][1]=0;\n			cout&lt;&lt;quickmod(w,k)&lt;&lt;endl;\n		}\n	}\n	return 0;\n}</pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('aeec3a461ad65408ad98d6d803f6b2f3','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  POJ1995 快速幂取模\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  3\n  <br/>\n  POJ 1995\n  <br/>\n  16\n  <br/>\n  4\n  <br/>\n  2 3\n  <br/>\n  3 4\n  <br/>\n  4 5\n  <br/>\n  5 6\n  <br/>\n  36123\n  <br/>\n  1\n  <br/>\n  2374859 3029382\n  <br/>\n  17\n  <br/>\n  1\n  <br/>\n  3 18132\n  <br/>\n  <br/>\n  <br/>\n  AC代码：   小心第二个用例中要求了int会爆掉所以我们用 long long\n  <br/>\n  <pre class=\'cpp\' code_snippet_id=\'1754557\' name=\'code\' snippet_file_name=\'blog_20160710_1_9372502\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n\n\nusing namespace std;\n\n\nint quickmod(long long a,long long b,long long mod)\n{\n	int ans=1;\n	while(b&gt;0)\n	{\n		if(b%2==1) \n		{\n			ans=(ans*a)%mod;\n			b--;\n		}\n		b=b/2;\n		a=(a*a)%mod; \n	}\n	return ans;\n}\n\n\nint main()\n{\n	int t;\n	int mod;\n	int k;\n	int ans=0;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		ans=0;\n		cin&gt;&gt;mod&gt;&gt;k;\n		for(int i=1;i&lt;=k;i++)\n		{\n			int a,b;\n			cin&gt;&gt;a&gt;&gt;b;\n			ans+=quickmod(a,b,mod)%mod;\n			ans=ans%mod;\n		}\n		cout&lt;&lt;ans&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ecff16d1ff3282f5c3f319f08db3f7a5','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  矩阵快速幂\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   和上一章一样，矩阵快速幂也是利用了乘法的结合律进行的优化\n  </p>\n  <p>\n   唯一的不同就是，数乘转化成矩阵乘法\n  </p>\n  <p>\n   <a href=\'http://http://www.cnblogs.com/yan-boy/archive/2012/11/29/2795294.html\' target=\'_blank\'>\n    点击打开链接\n   </a>\n  </p>\n  <p>\n   大神的笔记真的很通悟\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('6913331d45bac1cca2966c747bfd0d8c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  快速幂详解以及例题解析\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   借鉴两位大神的笔记，略有通悟\n  </p>\n  <p>\n   <a href=\'http://http://www.cnblogs.com/PegasusWang/archive/2013/03/13/2958150.html\' target=\'_blank\'>\n    点击打开链接\n   </a>\n   <br/>\n  </p>\n  <p>\n   <a href=\'http://http://blog.csdn.net/on_1y/article/details/7989603\' target=\'_blank\'>\n    点击打开链接\n   </a>\n   <br/>\n  </p>\n  <p>\n   在这里我总结一下：\n  </p>\n  <p>\n   快速幂算法用来求解大数的取幂操作，这应用的数学知识有两点\n  </p>\n  <p>\n   1.\n   <span style=\'color:rgb(75,75,75); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:20.8px\'>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/434467/201303/14194237-2392c3bffc1f4dae9f3bc51eb9f93f85.jpg\' style=\'border:0px; max-width:900px; color:rgb(75,75,75); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:20.8px\'/>\n  </p>\n  <p>\n   2.\n   <span style=\'color:rgb(51,51,51); font-family:Arial; font-size:18px; line-height:26px\'>\n    算法基础在于模运算的基本性质：  (a*b)%n = ( (a%n) * (b%n) ) %n\n   </span>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:18px; line-height:26px\'>\n     下面我通过代码模板进行详细的解释：\n    </span>\n   </span>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:18px; line-height:26px\'>\n     <br/>\n    </span>\n   </span>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:18px; line-height:26px\'>\n    </span>\n   </span>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1754487\' name=\'code\' snippet_file_name=\'blog_20160710_1_1964868\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\n//首先，每次迭代都有这个公式，所以，只要新的b还是2的倍数用1式，否则用二式 \n//在奇数的情况下，基本性质中应用 \n\n\nint main()\n{\n	int a,b,c;   //a为底数,b为指数,c为模 \n	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n	int ans=1;\n	while(b&gt;0)\n	{\n		if(b%2==1) ans=(ans%c*a%c)%c;    //这里运用了第二点基本性质(a*b)%n = ( (a%n) * (b%n) ) %n \n		b=b/2;\n		a=(a%c*a%c)%c;      //这里运用了迭代的过程，上面的公式中的k（就是这里的a）不断地扩大倍数 \n	    //这里的a*a的意思是，只要b现在是偶数我就可以继续迭代\n		//k^b%c=(k^(b/2)*k^(b/2))%c=((k^2)^(b/2))%c=(k%c*k%c)^(b/2))%c=a^(b/2)%c  (a=k%c*k%c)\n	} \n	//咋循环控制语句中，b=1的步骤是一定会执行的，所以，ans的值时钟控制在c一下，这一点保证了21行的等式，保证了算法的实现 \n	cout&lt;&lt;ans&lt;&lt;endl;\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <p>\n  </p>\n  <p>\n   <span style=\'font-family:Arial; color:#333333\'>\n    <span style=\'font-size:18px; line-height:26px\'>\n     <br/>\n    </span>\n   </span>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9f70d86fb6232f2b5332dd217029e1bc','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  优先队列的应用\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   hdu1896\n   <a href=\'http://http://acm.hdu.edu.cn/showproblem.php?pid=1896\' target=\'_blank\'>\n    点击打开链接\n   </a>\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1750836\' name=\'code\' snippet_file_name=\'blog_20160707_1_3374521\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\n#include\'queue\'\n\nusing namespace std;\n\ntypedef struct node\n{\n	int pos;\n	int weight;\n}point;\n\nstruct cmp\n{\n	bool operator()(const point a,const point b)\n	{\n		if(a.pos!=b.pos) return a.pos&gt;b.pos;   //&gt;后置 \n		else return a.weight&gt;b.weight;   //&gt;后置 \n	}\n};\n\nint main()\n{\n	int t;\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		int n;\n		cin&gt;&gt;n;\n		priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; q;\n		point stone;\n		while(n--)\n		{\n			cin&gt;&gt;stone.pos&gt;&gt;stone.weight;\n			q.push(stone);\n		}\n		stone=q.top();\n		bool is=1;\n		while(!q.empty())\n		{\n			if(is==1)\n			{\n			    stone=q.top();\n			    stone.pos+=stone.weight;\n			    q.push(stone);\n			    q.pop();\n		    }\n		    else\n		    {\n		        stone=q.top();\n			    q.pop();\n		    }\n	       is=!is;\n		}\n		cout&lt;&lt;stone.pos&lt;&lt;endl;\n	}\n	return 0;\n} </pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1d31efa7883668a1477f7cc036189fe7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  牛顿迭代法总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   牛顿迭代法公式：\n  </p>\n  <p>\n   X(n+1)=X(n)-f(Xn)*(X(n)-X(n-1))/(f(X(n))-f(X(n-1)))\n  </p>\n  <p>\n   该公式为了配合求导计算采用了差商代导数的方案，尽量保证了公式的完整性\n  </p>\n  <p>\n  </p>\n  <p>\n   求方程的跟的话我们只需要在邻近的零点附近进行迭代就好了\n  </p>\n  <p>\n  </p>\n  <p>\n   用牛顿迭代法来求方根的方法思路\n  </p>\n  <p>\n   <a href=\'http://wenku.baidu.com/link?url=FsyQLbnxbMF2_GL6ErK4nqhKVFhJDE7eI3pv-SzFBiduBqo0d9mm_nyv3vHOjbG_CAcd_e06C6HkrKGobiEQFYtBqGT0qhlLbloGzTkTJOO\' target=\'_blank\'>\n    <u>\n     <span style=\'color:rgb(0,0,255)\'>\n      http://wenku.baidu.com/link?url=FsyQLbnxbMF2_GL6ErK4nqhKVFhJDE7eI3pv-SzFBiduBqo0d9mm_nyv3vHOjbG_CAcd_e06C6HkrKGobiEQFYtBqGT0qhlLbloGzTkTJOO\n     </span>\n    </u>\n   </a>\n  </p>\n  <p>\n   <a href=\'http://wenku.baidu.com/link?url=IOGE-ko-A6zJN5AOnASOhwD7o0WFZkumYB4_NuL5G69XstDZ0L3pkbtrMjdF8aooq5Gs3jh0VtPuSAPzCjZrl2CN5adLw9ucscloryG_oU_\' target=\'_blank\'>\n    <u>\n     <span style=\'color:rgb(0,0,255)\'>\n      http://wenku.baidu.com/link?url=IOGE-ko-A6zJN5AOnASOhwD7o0WFZkumYB4_NuL5G69XstDZ0L3pkbtrMjdF8aooq5Gs3jh0VtPuSAPzCjZrl2CN5adLw9ucscloryG_oU_\n     </span>\n    </u>\n   </a>\n  </p>\n  <p>\n  </p>\n  <p>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ec153712f4535a801a94e24a0a69ad15','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  数独破解器\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1709912\' name=\'code\' snippet_file_name=\'blog_20160606_1_989799\'>#include\'iostream\' \n#include\'cstdio\'\n#include\'cstdlib\'\n\n\nusing namespace std;\n\n\ntypedef struct node\n{\n	int x,y;\n}pairk;\n\n\nclass alonemath\n{\n	public:\n		alonemath()\n		{\n			memset(map,0,sizeof(map));\n			memset(bookmath,0,sizeof(bookmath));\n		}\n		friend istream&amp; operator&gt;&gt;(istream&amp;,alonemath&amp;);\n		friend ostream&amp; operator&lt;&lt;(ostream&amp;,alonemath&amp;);\n		pairk find();\n		void dfs(pairk);\n	private:\n		int map[10][10];\n		int bookmath[10][10];\n};\n\n\nistream&amp; operator&gt;&gt;(istream&amp; in,alonemath&amp; x)\n{\n	cout&lt;&lt;\'输入你的数独方阵\'&lt;&lt;endl;\n	for(int i=1;i&lt;=9;i++)\n	{\n		for(int j=1;j&lt;=9;j++) \n		{\n			cin&gt;&gt;x.map[i][j];\n			if(x.map[i][j]!=0) x.bookmath[i][j]=1;\n		}\n	}\n	cout&lt;&lt;endl&lt;&lt;endl;\n	return in;\n} \n\n\nostream&amp; operator&lt;&lt;(ostream&amp; out,alonemath&amp; x)\n{\n	for(int i=1;i&lt;=9;i++)\n	{\n		for(int j=1;j&lt;=9;j++)\n		{\n			cout&lt;&lt;x.map[i][j]&lt;&lt;\' \';\n		}\n		cout&lt;&lt;endl;\n	}\n	cout&lt;&lt;\'数独输出完毕\'&lt;&lt;endl; \n	return out;\n}\n\n\npairk alonemath::find()\n{\n	for(int i=1;i&lt;=9;i++)\n	{\n		for(int j=1;j&lt;=9;j++)\n		{\n			if(bookmath[i][j]==0)\n			{\n				pairk k;\n				k.x=i;\n				k.y=j;\n				return k;\n			}\n		}	 \n	}\n	pairk k;\n	k.x=0;\n	k.y=0;\n	return k;\n}\n\n\nvoid alonemath::dfs(pairk k)\n{\n	if(k.x==k.y&amp;&amp;k.x==0)\n	{\n		cout&lt;&lt;*this;\n		exit(0);\n	}\n	int dx,dy;\n	if(k.x%3==0) dx=(k.x/3)*3-3;\n	else dx=(k.x/3)*3;\n	if(k.y%3==0) dy=(k.y/3)*3-3;\n	else dy=(k.y/3)*3;\n	int book[10];\n	memset(book,0,sizeof(book));\n	for(int a=1;a&lt;=9;a++) \n	{\n		if(map[k.x][a]!=0) book[map[k.x][a]]=1;\n		if(map[a][k.y]!=0) book[map[a][k.y]]=1;\n	}\n	for(int b=1;b&lt;=3;b++)\n	{\n		for(int c=1;c&lt;=3;c++) \n            if(map[dx+b][dy+c]!=0) book[map[dx+b][dy+c]]=1;\n	}	\n	for(int d=1;d&lt;=9;d++)\n	{\n		if(book[d]==0)\n		{\n			pairk w;\n			bookmath[k.x][k.y]=1;\n			map[k.x][k.y]=d;\n			w=find();\n			dfs(w);\n			bookmath[k.x][k.y]=0;map[k.x][k.y]=0;\n		}\n	}\n}\n\n\nint main()\n{\n	alonemath my;\n	cin&gt;&gt;my;\n	pairk w;\n	w=my.find();\n	my.dfs(w);\n	getchar();\n	return 0;\n} </pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('e2a43a71b49f143c92d0d1d082d1d56d','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  BM算法详解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p style=\'\'>\n   Boyer-Moore高质量实现代码详解与算法详解\n  </p>\n  <p style=\'\'>\n  </p>\n  <p style=\'\'>\n   鉴于我见到对算法本身分析非常透彻的文章以及实现的非常精巧的文章，所以就转载了，本文的贡献在于将两者结合起来，方便大家了解代码实现！\n  </p>\n  <p style=\'\'>\n  </p>\n  <p align=\'left\' style=\'\'>\n   算法详解转自：\n   <a href=\'http://www.searchtb.com/2011/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89.html\' style=\'color:rgb(0,102,255); text-decoration:none\' target=\'_blank\'>\n    http://www.searchtb.com/2011/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89.html\n   </a>\n  </p>\n  <p align=\'left\' style=\'\'>\n   C语言代码实现转自：\n  </p>\n  <p align=\'left\' style=\'\'>\n   <a href=\'http://www-igm.univ-mlv.fr/~lecroq/string/node14.html\' style=\'color:rgb(0,102,255); text-decoration:none\' target=\'_blank\'>\n    http://www-igm.univ-mlv.fr/~lecroq/string/node14.html\n   </a>\n  </p>\n  <p align=\'left\' style=\'\'>\n   另外，网站\n   <a href=\'http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/fstrpos-example.html\' style=\'color:rgb(0,102,255); text-decoration:none\' target=\'_blank\'>\n    http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/fstrpos-example.html\n   </a>\n   有个关于BM算法的详细例子，看看挺好的。\n  </p>\n  <p align=\'left\' style=\'\'>\n   BM算法的论文在这儿\n   <a href=\'http://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf\' style=\'color:rgb(0,102,255); text-decoration:none\' target=\'_blank\'>\n    http://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf\n   </a>\n  </p>\n  <p align=\'left\' style=\'\'>\n  </p>\n  <p align=\'left\' style=\'\'>\n   BM算法\n  </p>\n  <p align=\'left\' style=\'\'>\n   后缀匹配，是指模式串的比较从右到左，模式串的移动也是从左到右的匹配过程，经典的BM算法其实是对后缀蛮力匹配算法的改进。所以还是先从最简单的后缀蛮力匹配算法开始。下面直接给出伪代码，注意这一行代码：j++；BM算法所做的唯一的事情就是改进了这行代码，即模式串不是每次移动一步，而是根据已经匹配的后缀信息，从而移动更多的距离。\n  </p>\n  <div class=\'cnblogs_code\' style=\'\'>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n   <pre style=\'margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:\'Courier New\'!important; font-size:12px!important\'><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 1</span> j = <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>；\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 2</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 3</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>while</span> (j &lt;= strlen(T) -<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> strlen(P)) {\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 4</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 5</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i = strlen(P) - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span>; i &gt;= <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span> &amp;&amp; P[i] ==T[i + j]; --<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 6</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 7</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>if</span> (i &lt; <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 8</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 9</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>      match；\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>10</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>11</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>else</span>\n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>12</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>13</span>      <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(255,0,0)\'> j++；\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>14</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>15</span> }</pre>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.5\'>\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.5\'>\n    为了实现更快移动模式串，BM算法定义了两个规则，好后缀规则和坏字符规则，如下图可以清晰的看出他们的含义。利用好后缀和坏字符可以大大加快模式串的移动距离，不是简单的++j，而是j+=max (shift(好后缀), shift(坏字符))\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.5\'>\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09153619-376a77e7ff9644c1b229283ec78e4135.png\' style=\'border:0px; max-width:900px\'/>\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   先来看如何根据坏字符来移动模式串，shift(坏字符)分为两种情况：\n  </p>\n  <div style=\'\'>\n   <ul style=\'margin-left:30px; padding-left:0px\'>\n    <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n     坏字符没出现在模式串中，这时可以把模式串移动到坏字符的下一个字符，继续比较，如下图：\n    </li>\n   </ul>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09153646-c82d46cfc44d4d8fb10ad5429d04c610.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <div style=\'\'>\n   <ul style=\'margin-left:30px; padding-left:0px\'>\n    <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n     坏字符出现在模式串中，这时可以把模式串第一个出现的坏字符和母串的坏字符对齐，当然，这样可能造成模式串倒退移动，如下图：\n    </li>\n   </ul>\n  </div>\n  <div style=\'\'>\n   <p align=\'left\' style=\'margin:10px auto; text-indent:0px\'>\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09153814-3c0b1711367545c49957a3bc4ee0e77b.jpg\' style=\'border:0px; max-width:900px\'/>\n   </p>\n   <p align=\'left\' style=\'margin:10px auto; text-indent:0px\'>\n    <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n     此处配的图是不准确的，因为显然加粗的那个b并不是”最靠右的”b。而且也与下面给出的代码冲突！我看了论文，论文的意思是最右边的。当然了，尽管一时大意图配错了，论述还是没有问题的，我们可以把图改正一下，把圈圈中的b改为字母f就好了。接下来的图就不再更改了，大家心里有数就好。\n    </span>\n   </p>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <br/>\n   为了用代码来描述上述的两种情况，设计一个数组bmBc[\'k\']，表示坏字符‘k’在模式串中出现的位置距离模式串末尾的最大长度，那么当遇到坏字符的时候，模式串可以移动距离为： shift(坏字符) = bmBc[T[i]]-（m-1-i)。如下图：\n  </p>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09153929-7b2c607c209143a0bd1530aa18ee565d.png\' style=\'border:0px; max-width:900px\'/>\n   <span style=\'line-height:1.5\'>\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n  </p>\n  <p align=\'left\' style=\'\'>\n   数组bmBc的创建非常简单，直接贴出代码如下：\n  </p>\n  <div class=\'cnblogs_code\' style=\'\'>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n   <pre style=\'margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:\'Courier New\'!important; font-size:12px!important\'><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 1</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>void</span> preBmBc(<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>char</span> *x, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span> m, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> bmBc[]) {\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 2</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 3</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> i;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 4</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 5</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i = <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span>; i &lt; ASIZE; ++<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 6</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 7</span>       bmBc[i] =<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> m;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 8</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 9</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i = <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span>; i &lt; m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span>; ++<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>10</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>11</span>       bmBc[x[i]] = m - i - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>12</span> \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>13</span> }</pre>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    代码分析：\n   </span>\n  </p>\n  <ul style=\'\'>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    <span style=\'color:rgb(255,102,0)\'>\n     ASIZE是指字符种类个数，为了方便起见，就直接把ASCII表中的256个字符全表示了，哈哈，这样就不会漏掉哪个字符了。\n    </span>\n   </li>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    <span style=\'color:rgb(255,102,0)\'>\n     第一个for循环处理上述的第一种情况，这种情况比较容易理解就不多提了。\n    </span>\n   </li>\n  </ul>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    第二个for循环，bmBc[x[i]]中x[i]表示模式串中的第i个字符。\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    bmBc[x[i]] = m - i - 1;也就是计算x[i]这个字符到串尾部的距离。\n   </span>\n  </p>\n  <ul style=\'\'>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    <span style=\'color:rgb(255,102,0)\'>\n     为什么第二个for循环中，i从小到大的顺序计算呢？哈哈，技巧就在这儿了，原因在于就可以在同一字符多次出现的时候以最靠右的那个字符到尾部距离为最终的距离。当然了，如果没在模式串中出现的字符，其距离就是m了。\n    </span>\n   </li>\n  </ul>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.5\'>\n    <br/>\n   </span>\n   再来看如何根据好后缀规则移动模式串，shift（好后缀）分为三种情况：\n  </p>\n  <p align=\'left\' style=\'\'>\n  </p>\n  <div style=\'\'>\n   <ul style=\'margin-left:30px; padding-left:0px\'>\n    <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n     模式串中有子串匹配上好后缀，此时移动模式串，让该子串和好后缀对齐即可，如果超过一个子串匹配上好后缀，则选择最靠左边的子串对齐。\n    </li>\n   </ul>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09154149-9c05b8db6f97471fbdad21b64bc4bde2.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <ul style=\'\'>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    模式串中没有子串匹配上后后缀，此时需要寻找模式串的一个最长前缀，并让该前缀等于好后缀的后缀，寻找到该前缀后，让该前缀和好后缀对齐即可。\n   </li>\n  </ul>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09154211-41c8e6489799466db609f189f462e0d5.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <ul style=\'\'>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    模式串中没有子串匹配上后后缀，并且在模式串中找不到最长前缀，让该前缀等于好后缀的后缀。此时，直接移动模式到好后缀的下一个字符。\n   </li>\n  </ul>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09154321-87b2bed743164804a4118e2b4521f31b.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <p align=\'left\' style=\'\'>\n   为了实现好后缀规则，需要定义一个数组suffix[]，其中suffix[i] = s 表示以i为边界，与模式串后缀匹配的最大长度，如下图所示，用公式可以描述：满足P[i-s, i] == P[m-s, m]的最大长度s。\n   <br/>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09154344-8e021f20cdde4ef1b1e9bd38eeeb4b91.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <p align=\'left\' style=\'\'>\n   构建suffix数组的代码如下：\n  </p>\n  <div class=\'cnblogs_code\' style=\'\'>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n   <pre style=\'margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:\'Courier New\'!important; font-size:12px!important\'><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 1</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>void</span> suffixes(<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>char</span> *x, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span> m, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span> *<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>suff)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 2</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> {\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 3</span> 　　suff[m-<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span>]=<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>m;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 4</span> 　　<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i=m-<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>2</span>；i&gt;=<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span>；--<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i){\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 5</span>     q=<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 6</span>     <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>while</span>(q&gt;=<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span>&amp;&amp;x[q]==x[m-<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span>-i+<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>q])\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 7</span>         --<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>q;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 8</span>     suff[i]=i-<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>q;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 9</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>}\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>10</span> }</pre>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    注解：这一部分代码乏善可陈，都是常规代码，这里就不多说了。\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.5\'>\n    <br/>\n    有了suffix数组，就可以定义bmGs[]数组，bmGs[i] 表示遇到好后缀时，模式串应该移动的距离，其中i表示好后缀前面一个字符的位置（也就是坏字符的位置），构建bmGs数组分为三种情况，分别对应上述的移动模式串的三种情况\n   </span>\n  </p>\n  <div style=\'\'>\n   <ul style=\'margin-left:30px; padding-left:0px\'>\n    <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n     模式串中有子串匹配上好后缀\n    </li>\n   </ul>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09154503-360eb2f05f7d4737befa0845ba3980c1.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <div style=\'\'>\n   <ul style=\'margin-left:30px; padding-left:0px\'>\n    <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n     模式串中没有子串匹配上好后缀，但找到一个最大前缀\n    </li>\n   </ul>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09154513-2a05694522d94aa68e9edda8214ccb90.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <div style=\'\'>\n   <ul style=\'margin-left:30px; padding-left:0px\'>\n    <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n     模式串中没有子串匹配上好后缀，但找不到一个最大前缀\n    </li>\n   </ul>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/465162/201310/09154518-a0d17904f778467680bee9ef472a06d2.png\' style=\'border:0px; max-width:900px\'/>\n  </p>\n  <p align=\'left\' style=\'\'>\n   构建bmGs数组的代码如下：\n  </p>\n  <div class=\'cnblogs_code\' style=\'\'>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n   <pre style=\'margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:\'Courier New\'!important; font-size:12px!important\'><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 1</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>void</span> preBmGs(<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>char</span> *x, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span> m, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> bmGs[]) {\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 2</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> i, j, suff[XSIZE];\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 3</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>   suffixes(x, m, suff);\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 4</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i = <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span>; i &lt; m; ++<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 5</span>       bmGs[i] =<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> m;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 6</span>    j = <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 7</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i = m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span>; i &gt;= <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span>; --<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 8</span>       <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>if</span> (suff[i] == i + <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 9</span>          <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (; j &lt; m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span> - i; ++<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>j)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>10</span>             <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>if</span> (bmGs[j] ==<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> m)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>11</span>                bmGs[j] = m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span> -<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> i;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>12</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i = <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span>; i &lt;= m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>2</span>; ++<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i)\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>13</span>       bmGs[m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span> - suff[i]] = m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span> -<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> i;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>14</span> }</pre>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n  </div>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    注解：\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    这一部分代码挺有讲究，写的很巧妙，这里谈谈我的理解。讲解代码时候是分为三种情况来说明的，其实第二种和第三种可以合并，因为第三种情况相当于与好后缀匹配的最长前缀长度为0。\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    由于我们的目的是获得精确的bmGs[i]，故而若一个字符同时符合上述三种情况中的几种，那么我们选取最小的bmGs[i]。比如当模式传中既有子串可以匹配上好后串，又有前缀可以匹配好后串的后串，那么此时我们应该按照前者来移动模式串，也就是bmGs[i]较小的那种情况。故而每次修改bmGs[i]都应该使其变小，记住这一点，很重要！\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    而在这三种情况中第三种情况获得的bmGs[i]值大于第二种大于第一种。故而写代码的时候我们先计算第三种情况，再计算第二种情况，再计算第一种情况。为什么呢，因为对于同一个位置的多次修改只会使得bmGs[i]越来越小。\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n   </span>\n  </p>\n  <ul style=\'\'>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    <span style=\'color:rgb(255,102,0)\'>\n     代码4-5行对应了第三种情况，7-11行对于第二种情况，12-13对应第三种情况。\n    </span>\n   </li>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    <span style=\'color:rgb(255,102,0)\'>\n     第三种情况比较简单直接赋值m，这里就不多提了。\n    </span>\n   </li>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    <span style=\'color:rgb(255,102,0)\'>\n     第二种情况有点意思，咱们细细的来品味一下。\n    </span>\n   </li>\n  </ul>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    1.\n    <span>\n     为什么从后往前，也就是i从大到小？\n    </span>\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    原因在于如果i,j(i&gt;j)位置同时满足第二种情况，那么m-1-i&lt;m-1-j，而第十行代码保证了每个位置最多只能被修改一次，故而应该赋值为m-1-i，这也说明了为什么要　　　　　从后往前计算。\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n   </span>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    ２. 第8行代码的意思是找到了合适的位置，为什么这么说呢？\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    因为根据suff的定义，我们知道\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    x[i+1-suff[i]…i]＝＝x[m-1-siff[i]…m-1],而suff[i]==i+1，我们知道x[i+1-suff[i]…i]=x[0,i],也就是前缀，满足第二种情况。\n   </span>\n  </p>\n  <p align=\'left\' style=\'\'>\n   <span style=\'line-height:1.5; color:rgb(255,102,0)\'>\n    3. 第9-11行就是在对满足第二种情况下的赋值了。第十行确保了每个位置最多只能被修改一次。\n   </span>\n  </p>\n  <ul style=\'\'>\n   <li style=\'font-size:10pt; font-style:normal; list-style-type:disc\'>\n    <span style=\'color:rgb(255,102,0)\'>\n     第12-13行就是处理第一种情况了。为什么顺序从前到后呢，也就是i从小到大？\n    </span>\n   </li>\n  </ul>\n  <p align=\'left\' style=\'\'>\n  </p>\n  <p style=\'\'>\n   <span style=\'line-height:1.8!important; color:rgb(255,102,0)\'>\n    原因在于如果suff[i]==suff[j]，i&lt;j，那么m-1-i&gt;m-1-j,我们应该取后者作为bmGs[m - 1 - suff[i]]的值。\n   </span>\n  </p>\n  <p style=\'\'>\n   再来重写一遍BM算法：\n  </p>\n  <div class=\'cnblogs_code\' style=\'\'>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n   <pre style=\'margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:\'Courier New\'!important; font-size:12px!important\'><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 1</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>void</span> BM(<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>char</span> *x, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span> m, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>char</span> *y, <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> n) {\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 2</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>int</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> i, j, bmGs[XSIZE], bmBc[ASIZE];\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 3</span>  \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 4</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,0)\'>/*</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,0)\'> Preprocessing </span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,0)\'>*/</span>\n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 5</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>   preBmGs(x, m, bmGs);\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 6</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>   preBmBc(x, m, bmBc);\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 7</span>  \n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 8</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,0)\'>/*</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,0)\'> Searching </span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,0)\'>*/</span>\n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'> 9</span>    j = <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>;\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>10</span>    <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>while</span> (j &lt;= n -<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> m) {\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>11</span>       <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>for</span> (i = m - <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span>; i &gt;= <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span> &amp;&amp; x[i] == y[i + j]; --<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>i);\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>12</span>       <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>if</span> (i &lt; <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>) {\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>13</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>         OUTPUT(j);\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>14</span>          j += bmGs[<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>0</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>];\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>15</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>      }\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>16</span>       <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,255)\'>else</span>\n<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>17</span>          j += MAX(bmGs[i], bmBc[y[i + j]] - m + <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(128,0,128)\'>1</span> +<span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'> i);\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>18</span> <span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,0,0)\'>   }\n</span><span style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; color:rgb(0,128,128)\'>19</span> }</pre>\n   <div class=\'cnblogs_code_toolbar\' style=\'margin:10px auto; background-color:rgb(245,245,245)\'>\n    <span class=\'cnblogs_code_copy\' style=\'font-family:\'Courier New\'!important; font-size:12px!important; line-height:1.5!important; padding-right:5px\'>\n     <a style=\'color:rgb(0,102,255); text-decoration:none; border:none!important; background-color:rgb(245,245,245)!important\' target=\'_blank\' title=\'复制代码\'>\n      <img alt=\'复制代码\' src=\'http://common.cnblogs.com/images/copycode.gif\' style=\'border:none!important; max-width:900px; background-color:rgb(245,245,245)!important\'/>\n     </a>\n    </span>\n   </div>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('eb59a71b0083b133ff2c88f7d57fdeea','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  字符串匹配的BM算法讲解（不含代码）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p style=\'\'>\n   上一篇文章，我介绍了\n   <a href=\'http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:underline; font-weight:normal; font-style:normal; border:none; color:rgb(17,34,51)\' target=\'_blank\'>\n    KMP算法\n   </a>\n   。\n  </p>\n  <p style=\'\'>\n   但是，它并不是效率最高的算法，实际采用并不多。各种文本编辑器的\'查找\'功能（Ctrl+F），大多采用\n   <a href=\'http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:underline; font-weight:normal; font-style:normal; border:none; color:rgb(17,34,51)\' target=\'_blank\'>\n    Boyer-Moore算法\n   </a>\n   。\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050301.jpg\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   Boyer-Moore算法不仅效率高，而且构思巧妙，容易理解。1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。\n  </p>\n  <p style=\'\'>\n   下面，我根据Moore教授自己的\n   <a href=\'http://www.cs.utexas.edu/~moore/best-ideas/string-searching/fstrpos-example.html\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:underline; font-weight:normal; font-style:normal; border:none; color:rgb(17,34,51)\' target=\'_blank\'>\n    例子\n   </a>\n   来解释这种算法。\n  </p>\n  <p style=\'\'>\n   1.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050302.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   假定字符串为\'HERE IS A SIMPLE EXAMPLE\'，搜索词为\'EXAMPLE\'。\n  </p>\n  <p style=\'\'>\n   2.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050303.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   首先，\'字符串\'与\'搜索词\'头部对齐，从尾部开始比较。\n  </p>\n  <p style=\'\'>\n   这是一个很聪明的想法，因为如果尾部字符不匹配，那么只要一次比较，就可以知道前7个字符（整体上）肯定不是要找的结果。\n  </p>\n  <p style=\'\'>\n   我们看到，\'S\'与\'E\'不匹配。这时，\n   <span style=\'font-weight:800\'>\n    \'S\'就被称为\'坏字符\'（bad character），即不匹配的字符。\n   </span>\n   我们还发现，\'S\'不包含在搜索词\'EXAMPLE\'之中，这意味着可以把搜索词直接移到\'S\'的后一位。\n  </p>\n  <p style=\'\'>\n   3.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050304.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   依然从尾部开始比较，发现\'P\'与\'E\'不匹配，所以\'P\'是\'坏字符\'。但是，\'P\'包含在搜索词\'EXAMPLE\'之中。所以，将搜索词后移两位，两个\'P\'对齐。\n  </p>\n  <p style=\'\'>\n   4.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050305.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   我们由此总结出\n   <span style=\'font-weight:800\'>\n    \'坏字符规则\'\n   </span>\n   ：\n  </p>\n  <blockquote style=\'\'>\n   <p style=\'margin:1em 0px 0px 0.8em; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:none; color:rgb(17,17,17); font-size:1.6em; line-height:28.8px\'>\n    后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置\n   </p>\n  </blockquote>\n  <p style=\'\'>\n   如果\'坏字符\'不包含在搜索词之中，则上一次出现位置为 -1。\n  </p>\n  <p style=\'\'>\n   以\'P\'为例，它作为\'坏字符\'，出现在搜索词的第6位（从0开始编号），在搜索词中的上一次出现位置为4，所以后移 6 - 4 = 2位。再以前面第二步的\'S\'为例，它出现在第6位，上一次出现位置是 -1（即未出现），则整个搜索词后移 6 - (-1) = 7位。\n  </p>\n  <p style=\'\'>\n   5.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050306.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   依然从尾部开始比较，\'E\'与\'E\'匹配。\n  </p>\n  <p style=\'\'>\n   6.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050307.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   比较前面一位，\'LE\'与\'LE\'匹配。\n  </p>\n  <p style=\'\'>\n   7.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050308.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   比较前面一位，\'PLE\'与\'PLE\'匹配。\n  </p>\n  <p style=\'\'>\n   8.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050309.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   比较前面一位，\'MPLE\'与\'MPLE\'匹配。\n   <span style=\'font-weight:800\'>\n    我们把这种情况称为\'好后缀\'（good suffix），即所有尾部匹配的字符串。\n   </span>\n   注意，\'MPLE\'、\'PLE\'、\'LE\'、\'E\'都是好后缀。\n  </p>\n  <p style=\'\'>\n   9.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050310.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   比较前一位，发现\'I\'与\'A\'不匹配。所以，\'I\'是\'坏字符\'。\n  </p>\n  <p style=\'\'>\n   10.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050311.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   根据\'坏字符规则\'，此时搜索词应该后移 2 - （-1）= 3 位。问题是，此时有没有更好的移法？\n  </p>\n  <p style=\'\'>\n   11.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050309.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   我们知道，此时存在\'好后缀\'。所以，可以采用\n   <span style=\'font-weight:800\'>\n    \'好后缀规则\'\n   </span>\n   ：\n  </p>\n  <blockquote style=\'\'>\n   <p style=\'margin:1em 0px 0px 0.8em; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:none; color:rgb(17,17,17); font-size:1.6em; line-height:28.8px\'>\n    后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置\n   </p>\n  </blockquote>\n  <p style=\'\'>\n   举例来说，如果字符串\'ABCDAB\'的后一个\'AB\'是\'好后缀\'。那么它的位置是5（从0开始计算，取最后的\'B\'的值），在\'搜索词中的上一次出现位置\'是1（第一个\'B\'的位置），所以后移 5 - 1 = 4位，前一个\'AB\'移到后一个\'AB\'的位置。\n  </p>\n  <p style=\'\'>\n   再举一个例子，如果字符串\'ABCDEF\'的\'EF\'是好后缀，则\'EF\'的位置是5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6位，即整个字符串移到\'F\'的后一位。\n  </p>\n  <p style=\'\'>\n   这个规则有三个注意点：\n  </p>\n  <blockquote style=\'\'>\n   <p style=\'margin:1em 0px 0px 0.8em; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:none; color:rgb(17,17,17); font-size:1.6em; line-height:28.8px\'>\n    （1）\'好后缀\'的位置以最后一个字符为准。假定\'ABCDEF\'的\'EF\'是好后缀，则它的位置以\'F\'为准，即5（从0开始计算）。\n   </p>\n   <p style=\'margin:1em 0px 0px 0.8em; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:none; color:rgb(17,17,17); font-size:1.6em; line-height:28.8px\'>\n    （2）如果\'好后缀\'在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，\'EF\'在\'ABCDEF\'之中只出现一次，则它的上一次出现位置为-1（即未出现）。\n   </p>\n   <p style=\'margin:1em 0px 0px 0.8em; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:none; color:rgb(17,17,17); font-size:1.6em; line-height:28.8px\'>\n    （3）如果\'好后缀\'有多个，则除了最长的那个\'好后缀\'，其他\'好后缀\'的上一次出现位置必须在头部。比如，假定\'BABCDAB\'的\'好后缀\'是\'DAB\'、\'AB\'、\'B\'，请问这时\'好后缀\'的上一次出现位置是什么？回答是，此时采用的好后缀是\'B\'，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个\'好后缀\'只出现一次，则可以把搜索词改写成如下形式进行位置计算\'(DA)BABCDAB\'，即虚拟加入最前面的\'DA\'。\n   </p>\n  </blockquote>\n  <p style=\'\'>\n   回到上文的这个例子。此时，所有的\'好后缀\'（MPLE、PLE、LE、E）之中，只有\'E\'在\'EXAMPLE\'还出现在头部，所以后移 6 - 0 = 6位。\n  </p>\n  <p style=\'\'>\n   12.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050312.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   可以看到，\'坏字符规则\'只能移3位，\'好后缀规则\'可以移6位。所以，\n   <span style=\'font-weight:800\'>\n    Boyer-Moore算法的基本思想是，每次后移这两个规则之中的较大值。\n   </span>\n  </p>\n  <p style=\'\'>\n   更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。\n  </p>\n  <p style=\'\'>\n   13.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050313.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   继续从尾部开始比较，\'P\'与\'E\'不匹配，因此\'P\'是\'坏字符\'。根据\'坏字符规则\'，后移 6 - 4 = 2位。\n  </p>\n  <p style=\'\'>\n   14.\n  </p>\n  <p style=\'\'>\n   <img alt=\'\' src=\'http://image.beekka.com/blog/201305/bg2013050314.png\' style=\'margin:0px; padding:0px; list-style-type:none; text-align:left; text-decoration:none; font-weight:normal; font-style:normal; border:0.3em solid rgb(224,223,204); color:rgb(17,17,17)\'/>\n  </p>\n  <p style=\'\'>\n   从尾部开始逐位比较，发现全部匹配，于是搜索结束。如果还要继续查找（即找出全部匹配），则根据\'好后缀规则\'，后移 6 - 0 = 6位，即头部的\'E\'移到尾部的\'E\'的位置。\n  </p>\n  <p style=\'\'>\n   （完）\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4e0744fe8004854eee70a7ab98176c3c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  KMP算法简单实现\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   上期数据结构专栏中我分享了大神的对KMP算法的讲解\n  </p>\n  <p>\n   but talk is cheap,show me the code\n  </p>\n  <p>\n   我分享我的简单代码\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1690417\' name=\'code\' snippet_file_name=\'blog_20160520_1_9626332\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstring\'\n\nusing namespace std;\n\nchar part[100];\nchar impo[100];\nint next[100];\n\nvoid getnext()\n{\n	int k=0;\n	next[0]=0;\n	for(int i=1;i&lt;strlen(part);i++)\n	{\n		while(k&gt;0&amp;&amp;part[i]!=part[k])\n		{\n			k=next[k-1];\n		}\n		if(part[i]==part[k])\n		{\n			k++;\n		}\n		next[i]=k;\n	}\n}\n\nint kmp()\n{\n	for(int i=0;i&lt;=strlen(impo);)\n	{\n		int j;\n		int w=i;\n		for(j=0;j&lt;strlen(part);)\n		{\n			if(impo[i]==part[j])\n			{\n				i++;\n				j++;\n			}\n			else\n			{\n				i+=j-1-next[j-1]-1;\n				break;\n			}\n		}\n		if(j==strlen(part)) return w;\n	}\n	return -1;\n}\n\nint main()\n{\n	gets(part);\n	gets(impo);\n	getnext();\n	cout&lt;&lt;kmp()&lt;&lt;endl;\n	return 0;\n}</pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1d7ef6ea8780bb316904ba16a7d01c2c','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  KMP算法 串的模式匹配算法优秀总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   转载大神的博客受益匪浅\n  </p>\n  <p>\n  </p>\n  <p>\n   这几天学习kmp算法，解决字符串的匹配问题，开始的时候都是用到BF算法，（BF(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符;若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。）虽然也能解决一些问题，但是这是常规思路，在内存大，数据量小，时间长的情况下，还能解决一些问题，但是如果遇到一些限制时间和内存的字符串问题，肯定会超时，这是我们就想到了kmp算法，（KMP算法是一种改进的字符串匹配算法，由D.E.Knuth与V.R.Pratt和J.H.Morris同时发现，因此人们称它为克努特--莫里斯--普拉特操作(简称KMP算法)。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。）kmp算法的难点是kmp中的next数组的了解和求法。上网查了很多资料，发现参差不齐，研究了很久，才觉得豁然开朗，，借鉴网上资源以及自己的了解，现总结如下，存在很多不足之处，希望大家能批评指正！！\n  </p>\n  <p>\n  </p>\n  <p>\n   一、模拟字符串比较过程如下：\n  </p>\n  <p>\n   1.\n  </p>\n  <p>\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093038678.png\' style=\'width:590px; height:146px\'/>\n  </p>\n  <p>\n   首先，字符串\'BBC ABCDAB ABCDABCDABDE\'的第一个字符与搜索词\'ABCDABD\'的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。\n  </p>\n  <p>\n   2.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093038679.png\' style=\'width:604px; height:137px\'/>\n  </p>\n  <p>\n   因为B与A不匹配，搜索词再往后移。\n  </p>\n  <p>\n   3.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093039683.png\' style=\'width:577px; height:137px\'/>\n  </p>\n  <p>\n   就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。\n  </p>\n  <p>\n   4.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093039692.png\' style=\'width:584px; height:122px\'/>\n  </p>\n  <p>\n   接着比较字符串和搜索词的下一个字符，还是相同。\n  </p>\n  <p>\n   5.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093039694.png\' style=\'width:577px; height:130px\'/>\n  </p>\n  <p>\n   直到字符串有一个字符，与搜索词对应的字符不相同为止。\n  </p>\n  <p>\n   6.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093045698.png\' style=\'width:588px; height:158px\'/>\n  </p>\n  <p>\n   这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把\'搜索位置\'移到已经比较过的位置，重比一遍。\n  </p>\n  <p>\n   7.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093039694.png\' style=\'width:577px; height:130px\'/>\n  </p>\n  <p>\n   一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是\'ABCDAB\'。KMP算法的想法是，设法利用这个已知信息，不要把\'搜索位置\'移回已经比较过的位置，继续把它向后移，这样就提高了效率。\n  </p>\n  <p>\n   8.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093045699.png\' style=\'width:630px; height:184.6px\'/>\n  </p>\n  <p>\n   怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。\n  </p>\n  <p>\n   9.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093039694.png\' style=\'width:577px; height:130px\'/>\n  </p>\n  <p>\n   已知空格与D不匹配时，前面六个字符\'ABCDAB\'是匹配的。查表可知，最后一个匹配字符B对应的\'部分匹配值\'为2，因此按照下面的公式算出向后移动的位数：\n  </p>\n  <blockquote>\n   <p>\n    移动位数 = 已匹配的字符数 - 对应的部分匹配值\n   </p>\n  </blockquote>\n  <p>\n   因为 6 - 2 等于4，所以将搜索词向后移动4位。\n  </p>\n  <p>\n   10.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093046704.png\' style=\'width:581px; height:137px\'/>\n  </p>\n  <p>\n   因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（\'AB\'），对应的\'部分匹配值\'为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。\n  </p>\n  <p>\n   11.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093046711.png\' style=\'width:569px; height:136px\'/>\n  </p>\n  <p>\n   因为空格与A不匹配，继续后移一位。\n  </p>\n  <p>\n   12.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093046715.png\' style=\'width:590px; height:142px\'/>\n  </p>\n  <p>\n   逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。\n  </p>\n  <p>\n   13.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093047716.png\' style=\'width:576px; height:135px\'/>\n  </p>\n  <p>\n   逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。\n  </p>\n  <p>\n   14.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093047717.png\' style=\'width:551px; height:202px\'/>\n  </p>\n  <p>\n   下面介绍《部分匹配表》是如何产生的。\n  </p>\n  <p>\n   首先，要了解两个概念：\'前缀\'和\'后缀\'。 \'前缀\'指除了最后一个字符以外，一个字符串的全部头部组合；\'后缀\'指除了第一个字符以外，一个字符串的全部尾部组合。\n  </p>\n  <p>\n   15.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093045699.png\' style=\'width:630px; height:184.6px\'/>\n  </p>\n  <p>\n   \'部分匹配值\'就是\'前缀\'和\'后缀\'的最长的共有元素的长度。以\'ABCDABD\'为例，\n  </p>\n  <blockquote>\n   <p>\n    －　\'A\'的前缀和后缀都为空集，共有元素的长度为0；\n   </p>\n   <p>\n    －　\'AB\'的前缀为[A]，后缀为[B]，共有元素的长度为0；\n   </p>\n   <p>\n    －　\'ABC\'的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；\n   </p>\n   <p>\n    －　\'ABCD\'的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；\n   </p>\n   <p>\n    －　\'ABCDA\'的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为\'A\'，长度为1；\n   </p>\n   <p>\n    －　\'ABCDAB\'的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为\'AB\'，长度为2；\n   </p>\n   <p>\n    －　\'ABCDABD\'的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。\n   </p>\n  </blockquote>\n  <p>\n   16.\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093046715.png\' style=\'width:590px; height:142px\'/>\n  </p>\n  <p>\n   \'部分匹配\'的实质是，有时候，字符串头部和尾部会有重复。比如，\'ABCDAB\'之中有两个\'AB\'，那么它的\'部分匹配值\'就是2（\'AB\'的长度）。搜索词移动的时候，第一个\'AB\'向后移动4位（字符串长度-部分匹配值），就可以来到第二个\'AB\'的位置。\n  </p>\n  <p>\n  </p>\n  二、next数组实现的代码:\n  <p>\n   代码：\n  </p>\n  <p>\n  </p>\n  <div>\n   <div class=\'syntaxhighlighter java\' id=\'highlighter_964295\'>\n    <div class=\'toolbar\'>\n     <span>\n      <a class=\'toolbar_item command_help help\' href=\'http://www.2cto.com/kf/201604/497086.html#\' target=\'_blank\'>\n       ?\n      </a>\n     </span>\n    </div>\n    <table border=\'0\' cellpadding=\'0\' cellspacing=\'0\'>\n     <tbody>\n      <tr>\n       <td class=\'gutter\'>\n        <div class=\'line number1 index0 alt2\'>\n         1\n        </div>\n        <div class=\'line number2 index1 alt1\'>\n         2\n        </div>\n        <div class=\'line number3 index2 alt2\'>\n         3\n        </div>\n        <div class=\'line number4 index3 alt1\'>\n         4\n        </div>\n        <div class=\'line number5 index4 alt2\'>\n         5\n        </div>\n        <div class=\'line number6 index5 alt1\'>\n         6\n        </div>\n        <div class=\'line number7 index6 alt2\'>\n         7\n        </div>\n        <div class=\'line number8 index7 alt1\'>\n         8\n        </div>\n        <div class=\'line number9 index8 alt2\'>\n         9\n        </div>\n        <div class=\'line number10 index9 alt1\'>\n         10\n        </div>\n        <div class=\'line number11 index10 alt2\'>\n         11\n        </div>\n        <div class=\'line number12 index11 alt1\'>\n         12\n        </div>\n        <div class=\'line number13 index12 alt2\'>\n         13\n        </div>\n        <div class=\'line number14 index13 alt1\'>\n         14\n        </div>\n        <div class=\'line number15 index14 alt2\'>\n         15\n        </div>\n        <div class=\'line number16 index15 alt1\'>\n         16\n        </div>\n       </td>\n       <td class=\'code\'>\n        <div class=\'container\'>\n         <div class=\'line number1 index0 alt2\'>\n          <code class=\'java plain\'>\n           &lt;span style=\n          </code>\n          <code class=\'java string\'>\n           \'font-size: 18px\'\n          </code>\n          <code class=\'java plain\'>\n           &gt;\n          </code>\n          <code class=\'java keyword\'>\n           void\n          </code>\n          <code class=\'java plain\'>\n           makeNext(\n          </code>\n          <code class=\'java keyword\'>\n           const\n          </code>\n          <code class=\'java keyword\'>\n           char\n          </code>\n          <code class=\'java plain\'>\n           P[],\n          </code>\n          <code class=\'java keyword\'>\n           int\n          </code>\n          <code class=\'java plain\'>\n           next[])\n          </code>\n         </div>\n         <div class=\'line number2 index1 alt1\'>\n          <code class=\'java plain\'>\n           {\n          </code>\n         </div>\n         <div class=\'line number3 index2 alt2\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java keyword\'>\n           int\n          </code>\n          <code class=\'java plain\'>\n           q,k;\n          </code>\n          <code class=\'java comments\'>\n           //q:模版字符串下标；k:最大前后缀长度\n          </code>\n         </div>\n         <div class=\'line number4 index3 alt1\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java keyword\'>\n           int\n          </code>\n          <code class=\'java plain\'>\n           m = strlen(P);\n          </code>\n          <code class=\'java comments\'>\n           //模版字符串长度\n          </code>\n         </div>\n         <div class=\'line number5 index4 alt2\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           next[\n          </code>\n          <code class=\'java value\'>\n           0\n          </code>\n          <code class=\'java plain\'>\n           ] =\n          </code>\n          <code class=\'java value\'>\n           0\n          </code>\n          <code class=\'java plain\'>\n           ;\n          </code>\n          <code class=\'java comments\'>\n           //模版字符串的第一个字符的最大前后缀长度为0\n          </code>\n         </div>\n         <div class=\'line number6 index5 alt1\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java keyword\'>\n           for\n          </code>\n          <code class=\'java plain\'>\n           (q =\n          </code>\n          <code class=\'java value\'>\n           1\n          </code>\n          <code class=\'java plain\'>\n           ,k =\n          </code>\n          <code class=\'java value\'>\n           0\n          </code>\n          <code class=\'java plain\'>\n           ; q &lt; m; ++q)\n          </code>\n          <code class=\'java comments\'>\n           //for循环，从第二个字符开始，依次计算每一个字符对应的next值\n          </code>\n         </div>\n         <div class=\'line number7 index6 alt2\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           {\n          </code>\n         </div>\n         <div class=\'line number8 index7 alt1\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java keyword\'>\n           while\n          </code>\n          <code class=\'java plain\'>\n           (k &gt;\n          </code>\n          <code class=\'java value\'>\n           0\n          </code>\n          <code class=\'java plain\'>\n           &amp;&amp; P[q] != P[k])\n          </code>\n          <code class=\'java comments\'>\n           //递归的求出P[0]···P[q]的最大的相同的前后缀长度k\n          </code>\n         </div>\n         <div class=\'line number9 index8 alt2\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           k = next[k-\n          </code>\n          <code class=\'java value\'>\n           1\n          </code>\n          <code class=\'java plain\'>\n           ];\n          </code>\n          <code class=\'java comments\'>\n           //不理解没关系看下面的分析，这个while循环是整段代码的精髓所在，确实不好理解\n          </code>\n         </div>\n         <div class=\'line number10 index9 alt1\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java keyword\'>\n           if\n          </code>\n          <code class=\'java plain\'>\n           (P[q] == P[k])\n          </code>\n          <code class=\'java comments\'>\n           //如果相等，那么最大相同前后缀长度加1\n          </code>\n         </div>\n         <div class=\'line number11 index10 alt2\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           {\n          </code>\n         </div>\n         <div class=\'line number12 index11 alt1\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           k++;\n          </code>\n         </div>\n         <div class=\'line number13 index12 alt2\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           }\n          </code>\n         </div>\n         <div class=\'line number14 index13 alt1\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           next[q] = k;\n          </code>\n         </div>\n         <div class=\'line number15 index14 alt2\'>\n          <code class=\'java spaces\'>\n          </code>\n          <code class=\'java plain\'>\n           }\n          </code>\n         </div>\n         <div class=\'line number16 index15 alt1\'>\n          <code class=\'java plain\'>\n           }&lt;/span&gt;\n          </code>\n         </div>\n        </div>\n       </td>\n      </tr>\n     </tbody>\n    </table>\n   </div>\n  </div>\n  <p>\n  </p>\n  <p>\n  </p>\n  <p>\n  </p>\n  <p>\n   现在我着重讲解一下while循环所做的工作：\n  </p>\n  <ol>\n   <li>\n    已知前一步计算时最大相同的前后缀长度为k（k&gt;0），即P[0]···P[k-1]；\n   </li>\n   <li>\n    此时比较第k项P[k]与P[q],如图1所示\n   </li>\n   <li>\n    如果P[K]等于P[q]，那么很简单跳出while循环;\n   </li>\n   <li>\n    关键！关键有木有！关键如果不等呢？？？那么我们应该利用已经得到的next[0]···next[k-1]来求P[0]···P[k-1]这个子串中最大相同前后缀，可能有同学要问了——为什么要求P[0]···P[k-1]的最大相同前后缀呢？？？是啊！为什么呢？原因在于P[k]已经和P[q]失配了，而且P[q-k] ···P[q-1]又与P[0] ···P[k-1]相同，看来P[0]···P[k-1]这么长的子串是用不了了，那么我要找个同样也是P[0]打头、P[k-1]结尾的子串即P[0]···P[j-1](j==next[k-1])，看看它的下一项P[j]是否能和P[q]匹配。如图2所示\n    <p>\n    </p>\n    <p>\n     <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093047718.png\' style=\'width:419px; height:288px\'/>\n     <img alt=\'\' src=\'http://www.2cto.com/uploadfile/Collfiles/20160402/20160402093047719.png\' style=\'width:451px; height:288px\'/>\n    </p>\n    <br/>\n    <p>\n     三、next数组的优化代码：\n    </p>\n    <p>\n    </p>\n    <div>\n     <div class=\'syntaxhighlighter java\' id=\'highlighter_311061\'>\n      <div class=\'toolbar\'>\n       <span>\n        <a class=\'toolbar_item command_help help\' href=\'http://www.2cto.com/kf/201604/497086.html#\' target=\'_blank\'>\n         ?\n        </a>\n       </span>\n      </div>\n      <table border=\'0\' cellpadding=\'0\' cellspacing=\'0\'>\n       <tbody>\n        <tr>\n         <td class=\'gutter\'>\n          <div class=\'line number1 index0 alt2\'>\n           1\n          </div>\n          <div class=\'line number2 index1 alt1\'>\n           2\n          </div>\n          <div class=\'line number3 index2 alt2\'>\n           3\n          </div>\n          <div class=\'line number4 index3 alt1\'>\n           4\n          </div>\n          <div class=\'line number5 index4 alt2\'>\n           5\n          </div>\n         </td>\n         <td class=\'code\'>\n          <div class=\'container\'>\n           <div class=\'line number1 index0 alt2\'>\n            <code class=\'java plain\'>\n             &lt;span style=\n            </code>\n            <code class=\'java string\'>\n             \'font-size: 18px\'\n            </code>\n            <code class=\'java plain\'>\n             &gt;\n            </code>\n            <code class=\'java keyword\'>\n             void\n            </code>\n            <code class=\'java plain\'>\n             get_next()\n            </code>\n           </div>\n           <div class=\'line number2 index1 alt1\'>\n            <code class=\'java plain\'>\n             {\n            </code>\n           </div>\n           <div class=\'line number3 index2 alt2\'>\n            <code class=\'java spaces\'>\n            </code>\n            <code class=\'java keyword\'>\n             int\n            </code>\n            <code class=\'java plain\'>\n             i=\n            </code>\n            <code class=\'java value\'>\n             0\n            </code>\n            <code class=\'java plain\'>\n             ,j=-\n            </code>\n            <code class=\'java value\'>\n             1\n            </code>\n            <code class=\'java plain\'>\n             ;\n            </code>\n           </div>\n           <div class=\'line number4 index3 alt1\'>\n            <code class=\'java spaces\'>\n            </code>\n            <code class=\'java plain\'>\n             next[\n            </code>\n            <code class=\'java value\'>\n             0\n            </code>\n            <code class=\'java plain\'>\n             ]=-\n            </code>\n            <code class=\'java value\'>\n             1\n            </code>\n            <code class=\'java plain\'>\n             ;\n            </code>\n           </div>\n           <div class=\'line number5 index4 alt2\'>\n            <code class=\'java spaces\'>\n            </code>\n            <code class=\'java keyword\'>\n             while\n            </code>\n            <code class=\'java plain\'>\n             (i&lt;len2) span=\n            </code>\n            <code class=\'java string\'>\n             \'\'\n            </code>\n            <code class=\'java plain\'>\n             j=\n            </code>\n            <code class=\'java string\'>\n             \'=-1||s2[i]==s2[j])\'\n            </code>\n            <code class=\'java keyword\'>\n             else\n            </code>\n            <code class=\'java plain\'>\n             =\n            </code>\n            <code class=\'java string\'>\n             \'\'\n            </code>\n            <code class=\'java plain\'>\n             &gt;&lt;/len2)&gt;&lt;/span&gt;\n            </code>\n           </div>\n          </div>\n         </td>\n        </tr>\n       </tbody>\n      </table>\n     </div>\n    </div>\n    <br/>\n    <span style=\'font-size:18px\'>\n     附件：kmp算法完整代码：\n    </span>\n    <p>\n    </p>\n    <p>\n    </p>\n    <div>\n     <div class=\'syntaxhighlighter java\' id=\'highlighter_161397\'>\n      <div class=\'toolbar\'>\n       <span>\n        <a class=\'toolbar_item command_help help\' href=\'http://www.2cto.com/kf/201604/497086.html#\' target=\'_blank\'>\n         ?\n        </a>\n       </span>\n      </div>\n      <table border=\'0\' cellpadding=\'0\' cellspacing=\'0\'>\n       <tbody>\n        <tr>\n         <td class=\'gutter\'>\n          <div class=\'line number1 index0 alt2\'>\n           1\n          </div>\n          <div class=\'line number2 index1 alt1\'>\n           2\n          </div>\n          <div class=\'line number3 index2 alt2\'>\n           3\n          </div>\n          <div class=\'line number4 index3 alt1\'>\n           4\n          </div>\n          <div class=\'line number5 index4 alt2\'>\n           5\n          </div>\n          <div class=\'line number6 index5 alt1\'>\n           6\n          </div>\n          <div class=\'line number7 index6 alt2\'>\n           7\n          </div>\n          <div class=\'line number8 index7 alt1\'>\n           8\n          </div>\n          <div class=\'line number9 index8 alt2\'>\n           9\n          </div>\n          <div class=\'line number10 index9 alt1\'>\n           10\n          </div>\n          <div class=\'line number11 index10 alt2\'>\n           11\n          </div>\n          <div class=\'line number12 index11 alt1\'>\n           12\n          </div>\n          <div class=\'line number13 index12 alt2\'>\n           13\n          </div>\n         </td>\n         <td class=\'code\'>\n          <div class=\'container\'>\n           <div class=\'line number1 index0 alt2\'>\n            <code class=\'java plain\'>\n             &lt;span style=\n            </code>\n            <code class=\'java string\'>\n             \'font-size: 18px\'\n            </code>\n            <code class=\'java plain\'>\n             &gt;&lt;span style=\n            </code>\n            <code class=\'java string\'>\n             \'font-size: 18px\'\n            </code>\n            <code class=\'java plain\'>\n             &gt;#include&lt;stdio.h&gt;&lt;len2)\r\n span=\n            </code>\n            <code class=\'java string\'>\n             \'\'\n            </code>\n            <code class=\'java plain\'>\n             j=\n            </code>\n            <code class=\'java string\'>\n             \'=-1||s2[i]==s2[j])\'\n            </code>\n            <code class=\'java keyword\'>\n             else\n            </code>\n            <code class=\'java plain\'>\n             =\n            </code>\n            <code class=\'java string\'>\n             \'\'\n            </code>\n            <code class=\'java plain\'>\n             &gt;\n            </code>\n           </div>\n           <div class=\'line number2 index1 alt1\'>\n            <code class=\'java plain\'>\n             #include&lt;string.h&gt;\n            </code>\n           </div>\n           <div class=\'line number3 index2 alt2\'>\n            <code class=\'java plain\'>\n             #define N\n            </code>\n            <code class=\'java value\'>\n             100005\n            </code>\n           </div>\n           <div class=\'line number4 index3 alt1\'>\n            <code class=\'java keyword\'>\n             char\n            </code>\n            <code class=\'java plain\'>\n             s[\n            </code>\n            <code class=\'java value\'>\n             2\n            </code>\n            <code class=\'java plain\'>\n             *N];\n            </code>\n           </div>\n           <div class=\'line number5 index4 alt2\'>\n            <code class=\'java keyword\'>\n             char\n            </code>\n            <code class=\'java plain\'>\n             s1[N];\n            </code>\n           </div>\n           <div class=\'line number6 index5 alt1\'>\n            <code class=\'java keyword\'>\n             char\n            </code>\n            <code class=\'java plain\'>\n             s2[N];\n            </code>\n           </div>\n           <div class=\'line number7 index6 alt2\'>\n            <code class=\'java keyword\'>\n             int\n            </code>\n            <code class=\'java plain\'>\n             next[N];\n            </code>\n           </div>\n           <div class=\'line number8 index7 alt1\'>\n            <code class=\'java keyword\'>\n             int\n            </code>\n            <code class=\'java plain\'>\n             len1,len2,len;\n            </code>\n           </div>\n           <div class=\'line number9 index8 alt2\'>\n            <code class=\'java keyword\'>\n             void\n            </code>\n            <code class=\'java plain\'>\n             get_next()\n            </code>\n           </div>\n           <div class=\'line number10 index9 alt1\'>\n            <code class=\'java plain\'>\n             {\n            </code>\n           </div>\n           <div class=\'line number11 index10 alt2\'>\n            <code class=\'java spaces\'>\n            </code>\n            <code class=\'java keyword\'>\n             int\n            </code>\n            <code class=\'java plain\'>\n             i=\n            </code>\n            <code class=\'java value\'>\n             0\n            </code>\n            <code class=\'java plain\'>\n             ,j=-\n            </code>\n            <code class=\'java value\'>\n             1\n            </code>\n            <code class=\'java plain\'>\n             ;\n            </code>\n           </div>\n           <div class=\'line number12 index11 alt1\'>\n            <code class=\'java spaces\'>\n            </code>\n            <code class=\'java plain\'>\n             next[\n            </code>\n            <code class=\'java value\'>\n             0\n            </code>\n            <code class=\'java plain\'>\n             ]=-\n            </code>\n            <code class=\'java value\'>\n             1\n            </code>\n            <code class=\'java plain\'>\n             ;\n            </code>\n           </div>\n           <div class=\'line number13 index12 alt2\'>\n            <code class=\'java spaces\'>\n            </code>\n            <code class=\'java keyword\'>\n             while\n            </code>\n            <code class=\'java plain\'>\n             (i&lt;len2) span=\n            </code>\n            <code class=\'java string\'>\n             \'\'\n            </code>\n            <code class=\'java plain\'>\n             j=\n            </code>\n            <code class=\'java string\'>\n             \'=-1||s2[i]==s2[j])\'\n            </code>\n            <code class=\'java keyword\'>\n             else\n            </code>\n            <code class=\'java plain\'>\n             =\n            </code>\n            <code class=\'java string\'>\n             \'\'\n            </code>\n            <code class=\'java keyword\'>\n             void\n            </code>\n            <code class=\'java plain\'>\n             =\n            </code>\n            <code class=\'java string\'>\n             \'\'\n            </code>\n            <code class=\'java keyword\'>\n             return\n            </code>\n            <code class=\'java plain\'>\n            </code>\n           </div>\n          </div>\n         </td>\n        </tr>\n       </tbody>\n      </table>\n     </div>\n    </div>\n   </li>\n  </ol>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('bc7d1e782762b3aabb2cb292572b0ad0','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  离散数学 求偏序集极大极小元第三种思路 假链式前向星\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   链式前向星存储点集的关系\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1689915\' name=\'code\' snippet_file_name=\'blog_20160519_1_5298595\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'cstring\'\nusing namespace std;\n\nint first[30];\nint nextk[30];\nint num=0;\nint charp[30];\nint agminest[30];\nint maxest[30];\nint agminnum=0;\nint k=0;\nint j=0;\nint book[30];\nint maxnum=0;\n\nint main()\n{\n	memset(first,-1,sizeof(first));\n	char c;\n	while(1)\n	{\n		c=getchar();\n		if(c==\'\n\') break;\n		else\n		{\n			if(c==\',\') continue;\n			else\n			{\n				num++;\n				charp[num]=c-96;\n			}\n		}\n	}\n	int n=0;\n	int m=0;\n	while(1)\n	{\n		c=getchar();\n		c=getchar();\n		n=c-96;\n		c=getchar();\n		c=getchar();\n		m=c-96;\n			if(n==m);\n			else\n			{\n				agminnum++;\n	            agminest[agminnum]=m;	\n	            book[m]=1;\n				nextk[m]=first[n];\n				first[n]=m;\n			}\n		c=getchar();\n		c=getchar();\n		if(c==\'\n\') break;\n	}\n	for(int i=1;i&lt;=num;i++)\n	{\n		if(book[i]==0) k=i;\n	}\n	for(int i=num;i&gt;=1;i--)\n	{\n		if(first[i]==-1)\n		{\n			j=i;\n			break;\n		}\n	}\n	for(int i=1;i&lt;k;i++)\n	{\n		if(book[i]==0) printf(\'%c,\',i+96);\n	}\n	printf(\'%c\n\',k+96);\n	for(int i=1;i&lt;j;i++)\n	{\n		if(first[i]==-1) printf(\'%c,\',i+96); \n	}\n	printf(\'%c\n\',j+96);\n	return 0;\n} </pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('a9f333bf4fc28d0ac4d873ae06374600','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  离散数学 求偏序关系极大极小元的两种思路\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.传递闭包\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1689402\' name=\'code\' snippet_file_name=\'blog_20160519_1_6917019\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\n#include\'algorithm\'\n\nusing namespace std;\n\nint minest[30];\nint maxest[30];\nint charnum[30];\nint num=0;\nint minnum=0;\nint maxnum=0;\nint jieguo1[30];\nint jieguo2[30];\nint jieguo1num=0;\nint jieguo2num=0;\nint map[30][30];\nint beiyong[30];\n\nbool judge(int k,int i)\n{\n	if(i==1)\n	{\n		for(int j=1;j&lt;=minnum;j++)\n		{\n			if(k==minest[j]) return 1;\n		}\n		return 0;\n	}\n	else\n	{\n		for(int j=1;j&lt;=maxnum;j++)\n		{\n			if(k==maxest[j]) return 1;\n		}\n		return 0;\n	}\n}\n\nint main()\n{\n	for(num=0;;)\n	{\n		char c=getchar();\n		if(c==\'\n\') break; \n		if(c==\',\') continue;\n		else\n		{\n			if(c==\'\n\') break;\n			else\n			{\n				num++;\n				charnum[num]=c-96;\n			}\n		}\n	}\n	for(int i=1;;i++)\n	{\n		char c;\n		int n,m;\n		c=getchar();\n		if(c==\'\n\') break;\n		c=getchar();\n		n=c-96;\n		c=getchar();\n		c=getchar();\n		m=c-96;\n		if(n==m);\n		else\n		{	\n		    if(judge(m,2)==1&amp;&amp;judge(n,1)==1);\n		    else\n	    	{\n                if(judge(m,2)==1&amp;&amp;judge(n,1)==0)\n		    	 {\n			     	minnum++;\n			     	minest[minnum]=n;\n			     }\n			     else\n			     {\n			   	    if(judge(m,2)==0&amp;&amp;judge(n,1)==1)\n			     	{\n			 	    	maxnum++;\n			 	    	maxest[maxnum]=m;\n			    	}\n			     	else\n			     	{\n			 	    	maxnum++; \n				    	maxest[maxnum]=m;\n				    	minnum++;\n				    	minest[minnum]=n; \n			    	}\n			     }		\n		    }\n		}\n        map[n][m]=1;\n        map[m][n]=-1;\n		c=getchar();\n		c=getchar();\n		if(c==\',\') continue;\n	    else break;\n	}\n	for(int k=1;k&lt;=num;k++)\n    {\n    	for(int i=1;i&lt;=num;i++)\n    	{\n    		for(int j=1;j&lt;=num;j++)\n    		{\n    			if(map[i][k]==-1&amp;&amp;map[k][j]==-1)\n    			{\n    				map[i][j]=-11;\n    			} \n    		}\n    	}\n    }\n    for(int k=1;k&lt;=num;k++)\n    {\n    	for(int i=1;i&lt;=num;i++)\n    	{\n    		for(int j=1;j&lt;=num;j++)\n    		{\n    			if(map[i][k]==1&amp;&amp;map[k][j]==1)\n    			{\n    				map[i][j]=1;\n    			} \n    		}\n    	}\n    }\n    sort(maxest+1,maxest+maxnum+1);\n	sort(minest+1,minest+minnum+1);\n	for(int i=1;i&lt;=minnum;i++)\n	{\n		int flag=0;\n		for(int j=1;j&lt;=30;j++)\n		{\n			if(j==i) continue;\n			else\n			{\n				if(map[minest[i]][j]==-1) \n				{\n					flag=1;\n					break;\n				}\n			}\n		}\n		if(flag==0) \n		{\n			jieguo1num++;\n			jieguo1[jieguo1num]=minest[i];\n		}\n	}\n	for(int i=1;i&lt;=maxnum;i++)\n	{\n		int flag=0;\n		for(int j=1;j&lt;=30;j++)\n		{\n			if(i==j) continue;\n			else\n			{\n				if(map[maxest[i]][j]==1)\n				{\n					flag=1;\n					break;\n				}\n			}\n		}\n		if(flag==0)\n		{\n			jieguo2num++;\n			jieguo2[jieguo2num]=maxest[i];\n		}\n	}\n	for(int i=1;i&lt;=num;i++)\n	{\n		if(judge(i,1)==0&amp;&amp;judge(i,2)==0)\n		{\n			jieguo1num++;\n			jieguo1[jieguo1num]=i;\n			jieguo2num++;\n			jieguo2[jieguo2num]=i;\n		}\n	}\n	if(num==0) cout&lt;&lt;endl&lt;&lt;endl;\n	else\n	{ \n	sort(jieguo1+1,jieguo1+jieguo1num+1);\n	sort(jieguo2+1,jieguo2+jieguo2num+1);\n	for(int i=1;i&lt;jieguo1num;i++) printf(\'%c,\',jieguo1[i]+96);\n	printf(\'%c\n\',jieguo1[jieguo1num]+96);\n	for(int i=1;i&lt;jieguo2num;i++) printf(\'%c,\',jieguo2[i]+96);\n	printf(\'%c\n\',jieguo2[jieguo2num]+96);\n	} \n	return 0;\n}</pre>\n  2.\n  <p>\n   记录数组保留\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1689402\' name=\'code\' snippet_file_name=\'blog_20160519_2_9108846\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint charp[30];\nint num=0;\nbool bookmin[30];\nbool bookmax[30];\nint minest=0;\nint maxest=0;\nchar c;\nint n,m;\n\nint main()\n{\n	memset(bookmin,1,sizeof(bookmin));\n	memset(bookmax,1,sizeof(bookmax));\n	while(1)\n	{\n		c=getchar();\n		if(c==\'\n\') break; \n		if(c==\',\') continue;\n		else\n		{\n			num++;\n			charp[num]=c-96;\n		}\n	}\n	while(1)\n	{\n		c=getchar();\n		c=getchar();\n		n=c-96;\n		c=getchar();\n		c=getchar();\n		m=c-96;\n		c=getchar();\n		c=getchar();\n		if(n==m);\n		else\n		{\n			bookmin[m]=0;\n			bookmax[n]=0;\n		}\n		if(c==\'\n\') break;\n	}\n	for(int i=num;i&gt;=1;i--) \n	{\n		if(bookmin[i]==1)\n		{\n			minest=i;\n			break;\n		}\n	}\n	for(int i=num;i&gt;=1;i--)\n	{\n		if(bookmax[i]==1)\n		{\n			maxest=i;\n			break;\n		}\n	}\n	for(int i=1;i&lt;minest;i++)\n	    if(bookmin[i]==1) printf(\'%c,\',i+96);\n	printf(\'%c\n\',minest+96);\n	for(int i=1;i&lt;maxest;i++)\n	    if(bookmax[i]==1) printf(\'%c,\',i+96);\n	printf(\'%c\n\',maxest+96);\n	return 0;\n} </pre>\n  <br/>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('d4a596e8aa41bc4b4f1424e71029fca7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU2141 真：自己源码\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   我的AC代码\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1685803\' name=\'code\' snippet_file_name=\'blog_20160516_1_4986476\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\nusing namespace std;\n\nint a[505],b[505],c[505],ab[250005];\nint l,m,n,s;\nint num=0;\nint countk=0;\n\nbool judge(int sum)\n{\n	int left=1;\n	int right=countk;\n	int mid;\n	while(left&lt;=right)\n	{\n		mid=(left+right)&gt;&gt;1;\n		if(ab[mid]==sum) return 1;\n		else\n		{\n			if(ab[mid]&gt;sum) right=mid-1;\n			else left=mid+1;\n		}\n	}\n	return 0;\n}\n\nint cmp(const void *a,const void *b)\n{\n	return *(int*)a-*(int*)b;\n}\n\nint main()\n{\n	while(scanf(\'%d%d%d\',&amp;l,&amp;m,&amp;n)!=-1)\n	{\n		num++;\n		countk=0;\n		for(int i=1;i&lt;=l;i++) cin&gt;&gt;a[i];\n		for(int i=1;i&lt;=m;i++) cin&gt;&gt;b[i];\n		for(int i=1;i&lt;=n;i++) cin&gt;&gt;c[i];\n		for(int i=1;i&lt;=l;i++)\n		{\n			for(int j=1;j&lt;=m;j++)\n			{\n				countk++;\n				ab[countk]=a[i]+b[j];\n			}\n		}\n		cin&gt;&gt;s;\n		cout&lt;&lt;\'Case \'&lt;&lt;num&lt;&lt;\':\'&lt;&lt;endl;\n		qsort(ab+1,countk,sizeof(int),cmp);\n		qsort(c+1,n,sizeof(int),cmp);\n		while(s--)\n		{\n			int x;\n			cin&gt;&gt;x;\n			int i;\n			for(i=1;i&lt;=n;i++)\n			{\n				int sum=x-c[i];\n				if(judge(sum))\n				{\n					cout&lt;&lt;\'YES\'&lt;&lt;endl;\n					break;\n				}\n			}\n			if(i==n+1) cout&lt;&lt;\'NO\'&lt;&lt;endl;\n		}\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('06943e11e2090ecfd4fb9cb24dad81bc','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU2141 二分查找\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   在讲解题目之前先复习一下qsort函数，因为二分法针对的是有序表，所以经常要涉及到排序，在比赛中，我们时经常要用到排序函数的\n  </p>\n  <p>\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   qsort函数，原谅我无耻的粘贴\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   功 能: 使用快速排序例程进行排序\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   头文件:stdlib.h\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   用 法: void qsort(void *base,int nelem,int width,int (*fcmp)(const void *,const void *));\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   参数: 1 待排序\n   <a href=\'http://baike.so.com/doc/5545345-5760453.html\' style=\'color:rgb(19,110,194); text-decoration:none\' target=\'_blank\'>\n    数组\n   </a>\n   首地址\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   2 数组中待排序元素数量\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   3 各元素的占用空间大小\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   4 指向函数的指针，用于确定排序的顺序\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n  </p>\n  <p align=\'left\' style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span color=\'#ff0000\' size=\'3\' style=\'margin:0px; padding:0px; color:rgb(255,0,0); font-size:12px\'>\n    <span style=\'margin:0px; padding:0px\'>\n     一、对int类型数组排序\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   int num[100];\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   Sample: int cmp ( const void *a , const void *b )\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   { return\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     *(int *)a - *(int *)b;\n    </span>\n   </span>\n   }\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   qsort(num,100,\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     sizeof(num[0]),\n    </span>\n   </span>\n   cmp);\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' size=\'3\' style=\'margin:0px; padding:0px; color:rgb(255,0,0); font-size:12px\'>\n     二、对char类型数组排序（同int类型）\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   char word[100];\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   Sample: int cmp( const void *a , const void *b )\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   { return\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     *(char *)a - *(int *)b\n    </span>\n   </span>\n   ; }\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   qsort(word,100,sizeof(word[0]),cmp);\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' size=\'3\' style=\'margin:0px; padding:0px; color:rgb(255,0,0); font-size:12px\'>\n     三、对double类型数组排序（特别要注意）\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   double in[100];\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   int cmp( const void *a , const void *b )\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   { return\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     *(double *)a &gt; *(double *)b ? 1 : -1;\n    </span>\n   </span>\n   }\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   qsort(in,100,sizeof(in[0]),cmp)；\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' size=\'3\' style=\'margin:0px; padding:0px; color:rgb(255,0,0); font-size:12px\'>\n     四、对结构体一级排序\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   struct In { double data; int other; }s[100]\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   //按照data的值从小到大将结构体排序,关于结构体内的排序关键数据data的类型可以很多种，\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   //参考上面的例子写\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   int cmp( const void *a ,const void *b)\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     { return (*(In *)a).data &gt; (*(In *)b).data ? 1 : -1; }\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   qsort(s,100,\n   <span style=\'margin:0px; padding:0px\'>\n    sizeof(s[0]),\n   </span>\n   cmp);\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     五、对结构体二级排序\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   struct In { int x; int y; }s[100];\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   //按照x从小到大排序，当x相等时按照y从大到小排序\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     int cmp( const void *a , const void *b )\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     {\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     struct In *c = (In *)a; struct In *d = (In *)b;\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     if(c-&gt;x != d-&gt;x)\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     return c-&gt;x - d-&gt;x;\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     else\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     return d-&gt;y - c-&gt;y;\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     }\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   qsort(s,100,sizeof(s[0]),cmp);\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    <span color=\'#ff0000\' style=\'margin:0px; padding:0px; color:rgb(255,0,0)\'>\n     六、对字符串进行排序\n    </span>\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   struct In { int data; char str[100]; }s[100];\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   //按照结构体中字符串str的字典顺序排序\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   int cmp ( const void *a , const void *b )\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   {\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   <span style=\'margin:0px; padding:0px\'>\n    return strcmp( (*(In *)a)-&gt;str , (*(In *)b)-&gt;str );\n   </span>\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   }\n  </p>\n  <p style=\'margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px\'>\n   qsort(s,100,sizeof(s[0]),cmp);\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   <a href=\'http://acm.hdu.edu.cn/showproblem.php?pid=2141\' target=\'_blank\'>\n    HDU2141\n   </a>\n   <br/>\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n   这里我们对于三个数组来进行三重循环的话会超时，但是我们可以将两个数组进行合并，对于任意其中元素我们在第三个数组中进行二分搜索来寻找看存不存在对应的值即可\n  </p>\n  <p style=\'margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px; line-height:24px; text-indent:2em; zoom:1; color:rgb(51,51,51); font-family:arial,sans-serif; font-size:14px\'>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1685792\' name=\'code\' snippet_file_name=\'blog_20160516_1_2927671\'>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;math.h&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt; \nusing namespace std;\nint a[505],b[505],c[505];\nint sum[505*505];\nint l,n,m,k;\nint flag;\nvoid binary(int x)\n{\n	int left,right,mid;\n	left=0,right=k-1;\n	while(left&lt;=right)\n	{\n		mid=(left+right)&gt;&gt;1;\n		if(sum[mid]&gt;x)\n			right=mid-1;\n		else if(sum[mid]&lt;x)\n			left=mid+1;\n		else\n			{flag=1;return ;}\n	}\n	return ;\n}\n\nint main()\n{\n	int i,j,q,x,cnt=1;\n	while(cin&gt;&gt;l&gt;&gt;n&gt;&gt;m)\n	{\n		for(i=0;i&lt;l;i++)\n			scanf(\'%d\',&amp;a[i]);\n		for(i=0;i&lt;n;i++)\n			scanf(\'%d\',&amp;b[i]);\n		for(i=0;i&lt;m;i++)\n			scanf(\'%d\',&amp;c[i]);\n		k=0;\n		for(i=0;i&lt;l;i++)\n			for(j=0;j&lt;n;j++)\n			{\n				sum[k++]=a[i]+b[j];\n			}\n		sort(sum,sum+k);\n		scanf(\'%d\',&amp;q);\n		printf(\'Case %d:\n\',cnt++);\n		while(q--)\n		{\n			scanf(\'%d\',&amp;x);\n		    flag=0;\n			for(i=0;i&lt;m;i++)\n			{\n				binary(x-c[i]);\n				if(flag){\n					printf(\'YES\n\');\n					break;\n				}		\n			}\n			if(!flag)\n				printf(\'NO\n\');\n		}\n	}\n	return 0;\n}</pre>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('8efde626072fa85e0f24e07fa382d6c6','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  HDU1597二分查找\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   <a href=\'http://http://acm.hdu.edu.cn/status.php\' target=\'_blank\'>\n    HDU1597\n   </a>\n  </p>\n  <p>\n   首先这道题的思路是二分查找\n  </p>\n  <p>\n   我们先开一个数组sto,sto[i]用来记录Si之前（包括Si）的总共的数字的个数，一个for循环即可实现\n  </p>\n  <p>\n   然后我们根据输入的n在sto[i]区间的对比情况就可以判断出n所在对应的S的下标\n  </p>\n  <p>\n   然后剩下都就是取余运算就可以了\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   二分法思想简单，但是判断辩解是十分困难的，参考了网上大神们的建议，我总结了一下相对好理解的边界判定情况\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   1.n&gt;sto[mid]&amp;&amp;n&lt;=sto[mid+1]\n  </p>\n  <p>\n   当n满足上面式子的时候，n刚好在sto[mid]之后，sto[mid+1]之前，所以n前有mid个S串\n  </p>\n  <p>\n   2.n&lt;=sto[mid]&amp;&amp;n&gt;sto[mid-1]\n  </p>\n  <p>\n   当n满足上面式子的时候，n刚好在sto[mid-1]之前，sto[mid]之后，所以n前有mid-1个串\n  </p>\n  <p>\n   3.身下的边界很好理解，主要是上面两个\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   附上AC代码\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1685385\' name=\'code\' snippet_file_name=\'blog_20160516_1_1831006\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint sto[80000];\nint n;\nint w;\n\nvoid mybin(int left,int right)\n{\n	int mid=(left+right)/2;\n	if(n&gt;sto[mid]&amp;&amp;n&lt;=sto[mid+1]) \n	{\n		w=mid;\n		return ;\n	}\n	else\n	{\n		if(n&lt;=sto[mid]&amp;&amp;n&gt;sto[mid-1]) \n		{\n			w=mid-1;\n			return ;\n		}\n		else \n		{\n			if(n&lt;=sto[mid-1]) mybin(left,mid-1);\n			else mybin(mid+1,right);\n		}\n	}\n}\n\nint main()\n{\n	int t;\n	for(int i=1;i&lt;=65536;i++)\n	{\n		sto[i]=sto[i-1]+i;\n	}\n	cin&gt;&gt;t;\n	while(t--)\n	{\n		cin&gt;&gt;n;\n		mybin(1,65536);\n		int t=n-sto[w];\n		t=t%9;\n		if(t==0) cout&lt;&lt;9&lt;&lt;endl;\n		else cout&lt;&lt;t&lt;&lt;endl; \n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <p>\n   <br/>\n   <br/>\n  </p>\n  <p>\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('a07f8c70135a5b6963a734468f06483e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  二分插入排序\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   二分插入排序也是一种插入排序，原理和插入排序是一样的，但是之所以二分是快速查找出要插入的位置\n  </p>\n  <p>\n   下面附上代码和图示解析\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1685112\' name=\'code\' snippet_file_name=\'blog_20160516_1_7152475\'>#include\'iostream\'\n#include\'cstdio\'\n\n\nusing namespace std;\n\n\nint a[]={0,12,324,5,6768,78,79,7};\nint length=0;\n\n\nint main()\n{\n	length=sizeof(a)/sizeof(int);\n	for(int i=2;i&lt;=length-1;i++)\n	{\n		a[0]=a[i];\n		int left=1;\n		int right=i-1;\n		int mid=0;\n		while(left&lt;=right)\n		{\n			mid=(left+right)/2;\n			if(a[mid]&gt;a[0])\n			{\n				right=mid-1;\n			}\n			else\n			{\n				left=mid+1;\n			}\n		}\n		for(int j=i;j&gt;left;j--)\n		{\n			a[j]=a[j-1];\n		}\n		a[left]=a[0];\n	}\n	for(int i=1;i&lt;=length-1;i++)\n	{\n		printf(\'%d \',a[i]);\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ea524f84b71248416a312360155e8a73','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  二分查找小总结\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    <span style=\'font-size:18px; color:#0000ff; line-height:31.5px\'>\n     <u>\n      <strong>\n       1、二分查找(Binary Search)\n      </strong>\n     </u>\n    </span>\n    <br/>\n    二分查找又称折半查找，它是一种效率较高的查找方法。\n    <br/>\n    二分查找要求：线性表是有序表，即表中结点按关键字有序，并且要用向量作为表的存储结构。不妨设有序表是递增有序的。\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    <span style=\'font-size:18px; color:#0000ff; line-height:31.5px\'>\n     <u>\n      <strong>\n       2、二分查找的基本思想\n      </strong>\n     </u>\n    </span>\n    <br/>\n    二分查找的基本思想是：（设R[low..high]是当前的查找区间）\n    <br/>\n    （1）首先确定该区间的中点位置：\n    <br/>\n    <br/>\n    （2）然后将待查的K值与R[mid].key比较：若相等，则查找成功并返回此位置，否则须确定新的查找区间，继续二分查找，具体方法如下：\n    <br/>\n    ①若R[mid].key&gt;K，则由表的有序性可知R[mid..n].keys均大于K，因此若表中存在关键字等于K的结点，则该结点必定是在位置mid左边的子表R[1..mid-1]中，故新的查找区间是左子表R[1..mid-1]。\n    <br/>\n    ②类似地，若R[mid].key&lt;K，则要查找的K必在mid的右子表R[mid+1..n]中，即新的查找区间是右子表R[mid+1..n]。下一次查找是针对新的查找区间进行的。\n    <br/>\n    因此，从初始的查找区间R[1..n]开始，每经过一次与当前查找区间的中点位置上的结点关键字的比较，就可确定查找是否成功，不成功则当前的查找区间就缩小一半。这一过程重复直至找到关键字为K的结点，或者直至当前的查找区间为空(即查找失败)时为止。\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    <span style=\'font-size:18px; color:#0000ff; line-height:31.5px\'>\n     <u>\n      <strong>\n       3、二分查找算法\n       <br/>\n      </strong>\n     </u>\n    </span>\n    int BinSearch(SeqList R，KeyType K)\n    <br/>\n    { //在有序表R[1..n]中进行二分查找，成功时返回结点的位置，失败时返回零\n    <br/>\n    int low=1，high=n，mid； //置当前查找区间上、下界的初值\n    <br/>\n    while(low&lt;=high){ //当前查找区间R[low..high]非空\n    <br/>\n    mid=(low+high)/2；\n    <br/>\n    if(R[mid].key==K) return mid； //查找成功返回\n    <br/>\n    if(R[mid].kdy&gt;K)\n    <br/>\n    high=mid-1; //继续在R[low..mid-1]中查找\n    <br/>\n    else\n    <br/>\n    low=mid+1； //继续在R[mid+1..high]中查找\n    <br/>\n    }\n    <br/>\n    return 0； //当low&gt;high时表示查找区间为空，查找失败\n    <br/>\n    } //BinSeareh\n    <br/>\n    二分查找算法亦很容易给出其递归程序【参见练习】\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    <span style=\'font-size:18px; color:#0000ff; line-height:31.5px\'>\n     <strong>\n      <u>\n       4、 二分查找算法的执行过程\n       <br/>\n      </u>\n     </strong>\n    </span>\n    设算法的输入实例中有序的关键字序列为\n    <br/>\n    (05，13，19，21，37，56，64，75，80，88，92)\n    <br/>\n    要查找的关键字K分别是21和85。具体查找过程【参见动画演示】\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    <strong>\n     <u>\n      <span style=\'font-size:18px; color:#0000ff; line-height:31.5px\'>\n       5、二分查找判定树\n      </span>\n     </u>\n    </strong>\n    <br/>\n    二分查找过程可用二叉树来描述：把当前查找区间的中间位置上的结点作为根，左子表和右子表中的结点分别作为根的左子树和右子树。由此得到的二叉树，称为描述二分查找的判定树(Decision Tree)或比较树(Comparison Tree)。\n    <br/>\n    注意：\n    <br/>\n    判定树的形态只与表结点个数n相关，而与输入实例中R[1..n].keys的取值无关。\n    <br/>\n    【例】具有11个结点的有序表可用下图所示的判定树来表示。\n    <br/>\n    <br/>\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    （1）二分查找判定树的组成\n    <br/>\n    ①圆结点即树中的内部结点。树中圆结点内的数字表示该结点在有序表中的位置。\n    <br/>\n    ②外部结点：圆结点中的所有空指针均用一个虚拟的方形结点来取代，即外部结点。\n    <br/>\n    ③树中某结点i与其左(右)孩子连接的左(右)分支上的标记\'&lt;\'、\'(\'、\'&gt;\'、\')\'表示：当待查关键字 K&lt;R[i].key(K&gt;R[i].key)时，应走左(右)分支到达i的左(右)孩子，将该孩子的关键字进一步和K比较。若相等，则查找 过程结束返回，否则继续将K与树中更下一层的结点比较。\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    （2）二分查找判定树的查找\n    <br/>\n    二分查找就是将给定值K与二分查找判定树的根结点的关键字进行比较。若相等，成功。否则若小于根结点的关键字，到左子树中查找。若大于根结点的关键字，则到右子树中查找。\n    <br/>\n    【例】对于有11个结点的表，若查找的结点是表中第6个结点，则只需进行一次比较；若查找的结点是表中第3或第9个结点，则需进行二次比较；找第1，4，7，10个结点需要比较三次；找到第2，5，8，11个结点需要比较四次。\n    <br/>\n    由此可见，成功的二分查找过程恰好是走了一条从判定树的根到被查结点的路径，经历比较的关键字次数恰为该结点在树中的层数。若查找失败，则其比较过程是经历了一条从判定树根到某个外部结点的路径，所需的关键字比较次数是该路径上内部结点的总数。\n    <br/>\n    【例】待查表的关键字序列为：(05，13，19，21，37，56，64，75，80，88，92)，若要查找K=85的记录，所经过的内部结点为6、9、10，最后到达方形结点\'9-10\'，其比较次数为3。\n    <br/>\n    实际上方形结点中\'i-i+1\'的含意为被查找值K是介于R[i].key和R[i+1].key之间的，即R[i].key&lt;K&lt;R[i+1].key。\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    （3）二分查找的平均查找长度\n    <br/>\n    设内部结点的总数为n=2h-1，则判定树是深度为h=lg(n+1)的满二叉树(深度h不计外部结点)。树中第k层上的结点个数为2k-1，查找它们所需的比较次数是k。因此在等概率假设下，二分查找成功时的平均查找长度为：\n    <br/>\n    ASLbn≈lg(n+1)-1\n    <br/>\n    二分查找在查找失败时所需比较的关键字个数不超过判定树的深度，在最坏情况下查找成功的比较次数也不超过判定树的深度。即为：\n    <br/>\n    <br/>\n    二分查找的最坏性能和平均性能相当接近。\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    <span style=\'font-size:18px; color:#0000ff; line-height:31.5px\'>\n     <u>\n      <strong>\n       6、二分查找的优点和缺点\n      </strong>\n     </u>\n    </span>\n    <br/>\n    虽然二分查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算。既使采用高效率的排序方法也要花费O(nlgn)的时间。\n    <br/>\n    二分查找只适用顺序存储结构。为保持表的有序性，在顺序结构里插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动、而又经常需要查找的线性表。\n    <br/>\n    对那些查找少而又经常需要改动的线性表，可采用链表作存储结构，进行顺序查找。链表上无法实现二分查找。\n   </span>\n  </p>\n  <h2 style=\'line-height:42px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(249,247,241)\'>\n   <span style=\'color:#993366; background-color:rgb(204,255,204)\'>\n    二分法排序\n   </span>\n  </h2>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    #include &lt;stdlib.h&gt;\n    <br/>\n    #include &lt;stdio.h&gt;\n    <br/>\n    void TwoInsertSort(int array[],int n)\n    <br/>\n    {\n    <br/>\n    int left,right,num;\n    <br/>\n    int middle,j,i;\n    <br/>\n    for(i = 1;i &lt; n;i++)\n    <br/>\n    {\n    <br/>\n    left = 0;// 准备\n    <br/>\n    right = i-1;\n    <br/>\n    num = array[i];\n    <br/>\n    while( right &gt;= left)// 二分法查找插入位置\n    <br/>\n    {\n    <br/>\n    middle = ( left + right ) / 2; //　指向已排序好的中间位置\n    <br/>\n    if( num &lt; array[middle] )// 即将插入的元素应当在在左区间\n    <br/>\n    right = middle-1;\n    <br/>\n    else                    //　即将插入的元素应当在右区间\n    <br/>\n    left = middle+1;\n    <br/>\n    }\n    <br/>\n    for( j = i-1;j &gt;= left;j-- )//　后移排序码大于R[i]的记录\n    <br/>\n    array[j+1] = array[j];\n    <br/>\n    array[left] = num;// 插入\n    <br/>\n    }\n    <br/>\n    }\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    int rcmp( const int *a, const int *b)\n    <br/>\n    {\n    <br/>\n    return (*a-*b);\n    <br/>\n    }\n    <br/>\n    void main()\n    <br/>\n    {\n    <br/>\n    int array[50];\n    <br/>\n    int i;\n    <br/>\n    printf(\'The original array is :\n\');\n    <br/>\n    for( i=0; i&lt;50; i++ )//数组初始化并显示\n    <br/>\n    {\n    <br/>\n    array[i] = 50-i;\n    <br/>\n    printf(\'array[%d]:%d\n\', i, array[i]);\n    <br/>\n    }\n    <br/>\n    TwoInsertSort(array,sizeof(array)/sizeof(int));//二分法排序\n    <br/>\n    printf(\'\nAfter sorted :\n\');\n    <br/>\n    for( i=0; i&lt;50; i++ )\n    <br/>\n    printf(\'array[%d]:%d\n\', i, array[i]);\n   </span>\n  </p>\n  <p style=\'line-height:28px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(249,247,241)\'>\n   <span style=\'background-color:rgb(204,255,204)\'>\n    //库函数bsearch用二分法查找一个有序数组中的一个特定数，并返回该数的地址\n   </span>\n  </p>\n  <span style=\'line-height:28px; color:rgb(68,62,57); font-family:\'Hiragino Sans GB W3\',\'Hiragino Sans GB\',Arial,Helvetica,simsun,u5b8bu4f53; font-size:16px; background-color:rgb(204,255,204)\'>\n   a = (int *)bsearch(&amp;b, numarray, sizeof(numarray)/sizeof(numarray[0]),\r\n sizeof(int),rcmp);\n   <br/>\n   <br/>\n   }\n  </span>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4fce2e74c13f013b65f08ad07f8b0097','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  最大子数组 两个经典解法（动态规划，分治法）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   最大子数组：数组中子序列和最大的子数组的和求解\n  </p>\n  <p>\n   1.分治法：将问题的分割分成三部分进行考虑leftsum，rightsum和crosssum进行综合考虑\n  </p>\n  <p>\n   分治法代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1682970\' name=\'code\' snippet_file_name=\'blog_20160514_1_3144343\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint a[] = {0, 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7};\nint length=0;\nint sum=0;\nint inf=-99999999;\n\nint maxcross(int left,int mid,int right)\n{\n	int leftsum=inf;\n	int rightsum=inf;\n	int sum=0;\n	for(int i=mid;i&gt;=left;i--)\n	{\n		sum+=a[i];\n		if(sum&gt;leftsum) leftsum=sum;\n	}\n	sum=0;\n	for(int j=mid+1;j&lt;=right;j++)\n	{\n		sum+=a[j];\n		if(sum&gt;rightsum) rightsum=sum;\n	}\n	return leftsum+rightsum;\n}\n\nint maxsub(int left,int right)\n{\n	int mid=(left+right)/2;\n	if(left==right) return a[left];\n	else\n	{\n		int leftsum=0,rightsum=0,crosssum=0;\n		leftsum=maxsub(left,mid);\n		rightsum=maxsub(mid+1,right);\n		crosssum=maxcross(left,mid,right);\n		if(leftsum&gt;=rightsum&amp;&amp;leftsum&gt;=crosssum) return leftsum;\n		else\n		{\n			if(rightsum&gt;=leftsum&amp;&amp;rightsum&gt;=crosssum) return rightsum;\n			else return crosssum;\n		} \n	}\n}\n\nint main()\n{\n	length=sizeof(a)/sizeof(int);\n	cout&lt;&lt;maxsub(1,length-1)&lt;&lt;endl;\n	return 0;\n} </pre>\n  2.动态规划\n  <p>\n   思想和考虑：\n  </p>\n  <p>\n   状态：dp[i]用来记录以a[i]结尾的子数组中最大的数组和\n  </p>\n  <p>\n   有两种情况：\n  </p>\n  <p>\n   当dp[i-1]&gt;=0时dp[i]=dp[i-1]+a[i];\n  </p>\n  <p>\n   当dp[i-1]&lt;0时，dp[i]=a[i];\n  </p>\n  <p>\n   上述就是状态转移方程。\n  </p>\n  <p>\n   最后我们从dp[i]中选取最大的就是要求得值\n  </p>\n  <p>\n   talk is cheap，show me the code\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1682970\' name=\'code\' snippet_file_name=\'blog_20160514_2_8411240\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint a[] = {0, 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7};\nint length=0;\nint sum=0;\nint dp[100];\n\nint main()\n{\n	length=sizeof(a)/sizeof(int);\n	for(int i=1;i&lt;=length-1;i++)\n	{\n		dp[i]=1;\n		if(dp[i-1]&lt;0) dp[i]=a[i];\n		else dp[i]=dp[i-1]+a[i];\n		if(sum&lt;dp[i]) sum=dp[i]; \n	}\n	cout&lt;&lt;sum&lt;&lt;endl;\n	return 0;\n}</pre>\n  <br/>\n  很显然，虽然动态规划相比分治法要更好实现，并且思路更为简洁\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1e9329951b5ae5322faad6837db08f8e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  阶梯问题 动态规划浅析\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <span style=\'font-size:13.3333px\'>\n  </span>\n  有一个台阶，我们每次只能一次上一个或者一次上两个台阶，请问到第n个台阶有几种走法\n  <br/>\n  动态规划：\n  <br/>\n  首先我们将问题规模进行缩小，直到最后两节台阶，第一节台阶只有一种走法，第二节台阶有两种走法\n  <br/>\n  每一节台阶可以看做有前一个台阶走一步到的，和前两个台阶走两步到的，所以是前面两者的和\n  <br/>\n  所以：状态转移方程也就很好描述了\n  <br/>\n  dp数组记录到第i阶台阶可以的方法\n  <br/>\n  下面附上代码及解析\n  <br/>\n  <pre class=\'cpp\' code_snippet_id=\'1682890\' name=\'code\' snippet_file_name=\'blog_20160514_1_113509\'>#include\'iostream\'\n#include\'cstdio\'\n\n\nusing namespace std;\n\n\nint dp[100];\nint n;\n\n\nint main()\n{\n	cin&gt;&gt;n;\n	dp[1]=1;\n	dp[2]=2;\n	for(int i=3;i&lt;=n;i++)\n	{\n		dp[i]=dp[i-1]+dp[i-2];\n	}\n	cout&lt;&lt;dp[n]&lt;&lt;endl;\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  我们在考虑完之后回头发现，其实这是一段斐波那契数列，课件动态规划算法可以解决很多实际的问题\n  <br/>\n  所以，动态规划可以解决这类问题：目前规模的解可以有小规模的问题的解求出（求的方法就是状态转移方程）\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  当然让我们在扩展一下，如果不止跨一和两步呢（感觉和凑硬币的问题很像）\n  <br/>\n  <br/>\n  <br/>\n  下面附上代码\n  <br/>\n  <div>\n   <span style=\'font-size:13.3333px\'>\n   </span>\n   <pre class=\'cpp\' code_snippet_id=\'1682890\' name=\'code\' snippet_file_name=\'blog_20160514_2_953324\'>#include\'iostream\'\n#include\'cstdio\'\n\n\nusing namespace std;\n\n\nint dp[100];\nint n,m;\nint sto[100];\n\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=m;i++)\n	{\n		cin&gt;&gt;sto[i];\n	}\n    dp[1]=1;\n    dp[0]=1;    //c此处dp[0]=1的作用是当第一次遇到sto里面的书的时候，i-sto[j]=0此时应该算上一种方法，所以dp[0]=1是必需的\n    for(int i=2;i&lt;=n;i++)\n    {\n    	dp[i]=0;\n    	for(int j=1;j&lt;=m;j++)\n    	{\n    		if(i-sto[j]&gt;=0) dp[i]+=dp[i-sto[j]];\n    	}\n    }\n    cout&lt;&lt;dp[n]&lt;&lt;endl;\n	return 0;\n}\n</pre>\n   <br/>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1fdeb48d4c08a5e1e6620597c802064b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  动态规划 中级题解 路径记录\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  对于上一篇的记录路径的问题，达神教我可以再开一个二维数组进行路径记录，最后用栈进行输出格式调整\n  <br/>\n  首先再码一遍那个收集苹果的二维动态规划问题\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  #include\'cstdlib\'\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  struct node\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int x,y;\n  <br/>\n  };\n  <br/>\n  typedef struct node k;\n  <br/>\n  k stack[205];\n  <br/>\n  int top=0;\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  int map[100][100];\n  <br/>\n  int dp[100][100];\n  <br/>\n  int n,m;\n  <br/>\n  int startx,starty,endx,endy;\n  <br/>\n  int read[6][6];    //1代表向左回溯，-1代表向上回溯\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;n&gt;&gt;m;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=1;j&lt;=m;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;map[i][j];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;endx&gt;&gt;endy;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=startx;i&lt;=endx;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=starty;j&lt;=endy;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int left=0;int down=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(i==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i][j]=dp[i][j-1]+map[i][j];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  read[i][j]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(j==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i][j]=dp[i-1][j]+map[i][j];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  read[i][j]=-1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dp[i-1][j]&gt;dp[i][j-1])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i][j]=dp[i-1][j]+map[i][j];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  read[i][j]=-1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i][j]=dp[i][j-1]+map[i][j];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  read[i][j]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  read[startx][starty]=2;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;dp[endx][endy]&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].x=endx;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].y=endy;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=endx,j=endy;read[i][j]!=2;)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(read[i][j]==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  j--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].x=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].y=j;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(read[i][j]==-1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  i--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].x=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].y=j;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=top;i&gt;1;i--)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  printf(\'(%d,%d)-&gt;\',stack[i].x,stack[i].y);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  printf(\'(%d,%d)\n\',endx,endy);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  在这里，我们利用新的二维数组read用来记录前驱，下次返回的时候就直接导引就可以了\n  <br/>\n  在这里，纠正一下我上一篇的一个错误，因为在回溯的时候会出现越界的问题，所以在回溯的代码中，我们必须要重新写一下动态规划的状态转移方程，详情见上面的代码段\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('2af62b2fd05e3ac6c88a4dc3c247a79b','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  动态规划中级题解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   二维的动态规划解决\n  </p>\n  <p>\n   题目：假设在一个N*M的平面上，有N*M个格子，每个格子中都有一定数量的苹果，每次我们只能从某个格子处向右或者向下走，注意不能超过地图的限制，请问如何设计路径才可以保证最后从起点到终点后获得的苹果数量最多\n  </p>\n  <p>\n   动态规划解析：建立二维的dp数组dp[i][j]表示走到map[i][j]格的时候能够获得的最多的苹果数目\n  </p>\n  <p>\n   最后将问题进行分解，不断缩小规模，直到dp[startx][starty]=map[startx][starty]表示最开始的初始状态\n  </p>\n  <p>\n   附上代码：\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1681915\' name=\'code\' snippet_file_name=\'blog_20160513_1_8280364\'>#include\'iostream\'\n#include\'cstdio\'\n\n\nusing namespace std;\n\n\nint map[100][100];\nint dp[100][100];\nint n,m;\nint startx,starty,endx,endy;\nint sum=0;\nint rightk=0,down=0;\nint maxk=0;\n\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=n;i++)\n	{\n		for(int j=1;j&lt;=m;j++)\n		{\n			cin&gt;&gt;map[i][j];\n		}\n	}\n	cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;endx&gt;&gt;endy;\n	sum=dp[startx][starty]=map[startx][starty];\n	for(int i=startx;i&lt;=endx;i++)\n	{\n		for(int j=startx;j&lt;=endx;j++)\n		{\n			rightk=0;down=0;   //注意此处一定要初始化，因为一旦出现j&lt;=1或者i&lt;=1的时候rightk与down必须应该重置为零\n			if(j&gt;1) rightk=dp[i][j-1];\n			if(i&gt;1) down=dp[i-1][j];\n			if(rightk&gt;down) maxk=rightk;\n			else maxk=down;\n			dp[i][j]=map[i][j]+maxk;\n		}\n	}\n	cout&lt;&lt;dp[endx][endy]&lt;&lt;endl;\n	return 0;\n}</pre>\n  <br/>\n  ok，我们上述代码解决了找到最多的数目，请再次解决问题，不止找到最多的数目，我们还要输出最优路径\n  <p>\n   看着没有难度，实际细思极恐，待解问题\n  </p>\n  <p>\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('61c4f254f85eb0d64aec038524eb54d0','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  动态规划初级题解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  1.在这里我们先首先声明一下什么是最大上升子序列，因为在自学过程中被莫名奇妙的坑了一下\n  <br/>\n  5，3，4，8，6，7在这里最大上升子序列是3 4 6 7而不是3 4 8,3 4 8称作最大连续上升子序列（一会我们也用动态规划来解决一下）\n  <br/>\n  2.开始算法分析\n  <br/>\n  1）暴力搜索：想想都觉得很麻烦\n  <br/>\n  2）动态规划算法：我们将原问题进行拆解，拆解成性质一样但是规模缩小的子问题来看，首先用dp数组来记录子问题的最优解，dp[i]的含义是以A[I]结尾的子串的最长的上升子序列然后当整个序列都求完之后，我们取最大的就可以（实际上，我们分析算法后会发现，越往后的上升子序列会越大并且是只会大不会小，所以实际上我们只需要将整个序列都求一边，用已知的子问题的最优解来求解下一个规模稍微大一点的问题的最优解就可以了）\n  <br/>\n  下面附上代码\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  int A[]={0,5,3,4,8,6,7};\n  <br/>\n  int length=0;\n  <br/>\n  int len=0;\n  <br/>\n  int dp[100];\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  length=sizeof(A)/sizeof(int);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=length-1;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i]=1;    //刚开始都是1的原因是，本身构成一个最大上升子序列\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=1;j&lt;i;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(A[j]&lt;A[i]&amp;&amp;dp[j]+1&gt;dp[i]) dp[i]=dp[j]+1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(len&lt;dp[i]) len=dp[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;len&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  当然我们对问题还是要理解的更为深刻一点\n  <br/>\n  请再解决一下如何把满足最长的最大上升子序列输出\n  <br/>\n  代码如下\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  int A[]={0,5,3,4,8,6,7};\n  <br/>\n  int dp[100];\n  <br/>\n  int len=0;\n  <br/>\n  int length=0;\n  <br/>\n  int remember[100];\n  <br/>\n  int flag=0;\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  length=sizeof(A)/sizeof(int);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=length-1;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=1;j&lt;i;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(A[j]&lt;=A[i]&amp;&amp;dp[j]+1&gt;dp[i])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i]=dp[j]+1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(len&lt;dp[i]) len=dp[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(flag==0)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  remember[1]=A[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  remember[len]=A[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;len&lt;&lt;\'	\';\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=len;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  printf(\'%d \',remember[i]);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  好了，最大上升子序列的问题解决了，我们来余兴一下，求最大连续上升子序列\n  <br/>\n  动态规划算法：\n  <br/>\n  这个比起刚才的算法更好理解\n  <br/>\n  首先：状态dp[i]保存已A[i]结尾的子序列的最大连续\n  <br/>\n  其次：状态转移方程\n  <br/>\n  代码如下\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int A[]={0,5,3,4,8,6,7};\n  <br/>\n  int length=0;\n  <br/>\n  int len=0;\n  <br/>\n  int dp[100];\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  length=sizeof(A)/sizeof(int);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=length-1;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dp[i]=1;//此处都是1，保证了一旦出现由增到减的情况的时候，可以从转折点处再次从头开始计数，反正len保留最大值，不会影响结果\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(A[i]&gt;A[i-1]) dp[i]=dp[i-1]+1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else dp[i]=dp[i-1];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(len&lt;dp[i]) len=dp[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;len&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  再次思考问题，如何保存最大连续子序列的子序列，求教大神\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('176b8ec67b0282bf3081b3ab9884ad45','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  急求大神帮忙解决的问题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   上一篇的动态规划入门题我引申了几个问题不会解决求大神帮忙\n  </p>\n  <p>\n   1：如何判断对于给定的硬币的种类对某个特定的值不存在任何一个可以满足的情况\n  </p>\n  <p>\n   2：如何将所有可能的凑出来的情况都进行保存\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('9fe0592ffa6a5a02209a1d41300ea5b7','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  动态规划入门题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   求出凑够value的1,3,5供多少枚硬币，当然是最小值\n  </p>\n  <p>\n   思路：（动态规划）\n  </p>\n  <p>\n   首先：动态规划和分治法的一个区别就是，分治法把问题分成独立的子问题，子问题之间独立性很强，最后将子问题的解合并\n  </p>\n  <p>\n   动态规划解决最优化问题，往往将问题的规模缩小之后，会发现子问题之间的练习是非常的密切，我们这时候就要注意列表记录历史中上次的求出                         的最优值，进行优化判断（分治法是无法进行优化判断的），下次直接常数时间查找可以避免重复计算\n  </p>\n  <p>\n   我们先从头慢慢来考虑，先将问题进行分解，分解实际上是把问题的规模缩小，当题中的value是确定值，那么我们发现可以不断缩小规模直到凑够0时需要多少硬币数量，我们用dp数组来存储小规模子问题的优值。\n  </p>\n  <p>\n   我们可以发现显然，dp[0]=0;即凑够0只用0枚硬币\n  </p>\n  <p>\n   剩下的详细的过程我们在代码中进行解析\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1680844\' name=\'code\' snippet_file_name=\'blog_20160512_1_5591115\'>#include\'iostream\'\n#include\'cstdio\'\n\n\nusing namespace std;\n\n\nint dp[100];\nint value;\n\n\nint main()\n{\n	cin&gt;&gt;value;\n	dp[0]=0;\n	for(int i=1;i&lt;=value;i++)\n	{\n		int minnum=dp[i-1];\n		if(i-3&gt;=0&amp;&amp;minnum&gt;dp[i-3])    //必须满足条件才可以 \n		{\n			minnum=dp[i-3];\n		}\n		if(i-5&gt;=0&amp;&amp;minnum&gt;dp[i-5])\n		{\n			minnum=dp[i-5];\n		}\n		dp[i]=minnum+1;        //加一是因为比起i-1规模的问题，我们最少只用加一就好 \n		cout&lt;&lt;\'value:\'&lt;&lt;i&lt;&lt;\'	\'&lt;&lt;\'num:\'&lt;&lt;dp[i]&lt;&lt;endl; \n	}\n	return 0;\n}</pre>\n  <br/>\n  当然我们不止可以求1,3,5,     1,,2,3,5我们也可以求\n  <p>\n   下面附上源码\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1680844\' name=\'code\' snippet_file_name=\'blog_20160512_2_6397910\'>#include\'iostream\'\n#include\'cstdio\'\n\n\nusing namespace std;\n\n\nint dp[100];\nint value=0;\n\n\nint main()\n{\n	cin&gt;&gt;value;\n	dp[0]=0;\n	for(int i=1;i&lt;=value;i++)\n	{\n		int minnum=dp[i-1];\n		if(i-2&gt;=0&amp;&amp;minnum&gt;dp[i-2]) minnum=dp[i-2];\n		if(i-3&gt;=0&amp;&amp;minnum&gt;dp[i-3]) minnum=dp[i-3];\n		if(i-5&gt;=0&amp;&amp;minnum&gt;dp[i-5]) minnum=dp[i-5];\n		dp[i]=minnum+1;\n		cout&lt;&lt;\'value:\'&lt;&lt;i&lt;&lt;\'	\'&lt;&lt;\'num:\'&lt;&lt;dp[i]&lt;&lt;endl; \n	}\n	return 0;\n} </pre>\n  <br/>\n  并不会就仅仅因为这么一点就开始欣喜？如果是给你若干种可选择的硬币呢\n  <p>\n   value ，n，之后输入n种硬币的面值，开始选择\n  </p>\n  <p>\n   下面附上源码\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1680844\' name=\'code\' snippet_file_name=\'blog_20160512_3_3715715\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint dp[100];\nint value=0;\nint n;\nint ston[10];\n\nint main()\n{\n	cin&gt;&gt;value&gt;&gt;n;\n	for(int i=1;i&lt;=n;i++)\n    {\n    	cin&gt;&gt;ston[i];\n    }\n    dp[0]=0;\n    for(int i=1;i&lt;=value;i++)\n    {\n    	int minnum=dp[i-1];\n    	for(int j=1;j&lt;=n;j++)\n    	{\n    		if(i-ston[j]&gt;=0&amp;&amp;minnum&gt;dp[i-ston[j]]) minnum=dp[i-ston[j]];\n    	}\n    	dp[i]=minnum+1;\n    	cout&lt;&lt;\'value:\'&lt;&lt;i&lt;&lt;\'	\'&lt;&lt;\'num:\'&lt;&lt;dp[i]&lt;&lt;endl;\n    }\n	return 0;\n}</pre>\n  当然，为了动态规划学习的更好，这个问题必须要了解的更为透彻，那么再次请问，如何不仅输出最少个数，还可以将最优的情况表示出来，当然如果有多种的话，随便表示一个就好（真的有点头疼了，如果我要全部表示出来呢）//这个问题有待解决\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1680844\' name=\'code\' snippet_file_name=\'blog_20160512_4_1872552\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint dp[100];\nint value;\nint n;\nint sto[10];\nint remember[100][10];\nint flag=0;\n\nint main()\n{\n	cin&gt;&gt;value&gt;&gt;n;\n	for(int i=1;i&lt;=n;i++)\n	{\n		cin&gt;&gt;sto[i];\n	}\n	dp[0]=0;\n	for(int i=1;i&lt;=value;i++)\n	{\n		flag=0;\n		int minnum=dp[i-1];\n		for(int j=1;j&lt;=n;j++)\n		{\n			if(i-sto[j]&gt;=0&amp;&amp;minnum&gt;dp[i-sto[j]])\n			{\n				minnum=dp[i-sto[j]];\n				for(int k=1;k&lt;=10;k++)\n				{\n					remember[i][k]=remember[i-sto[j]][k];\n				}\n	            remember[i][sto[j]]++;\n	            flag=1;\n			}\n		}\n		if(flag==0)\n		{\n		    for(int k=1;k&lt;=10;k++)\n		    {\n		    	remember[i][k]=remember[i-1][k];\n		    }\n		    remember[i][1]++;   //加1的原因是，当flag为零时，代表此时我们并没有通过其他硬币进行优化，只能是用1来弥补，当然前提是有一在可选的硬币种类内 \n		}       //那么这里就会有人问了，在上述的上述循环中也有sto[j]=1的情况，不会影响吗，当然不会，应为我们的限制条件是minnum&gt;dp[i-sto[1]],二者相等 \n		dp[i]=minnum+1;\n		cout&lt;&lt;\'value:\'&lt;&lt;i&lt;&lt;\'	\'&lt;&lt;\'num:\'&lt;&lt;dp[i]&lt;&lt;endl;\n		cout&lt;&lt;\'	\';\n		for(int j=1;j&lt;=n;j++)\n		{\n			cout&lt;&lt;sto[j]&lt;&lt;\':\'&lt;&lt;remember[i][sto[j]]&lt;&lt;\'	\';\n		}\n		cout&lt;&lt;endl;\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <br/>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('cb69f71f7ce5f4d8c2099e45d065091f','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  快速排序以及堆排序在查找数方面的主要应用 即将引出线性查找BFPRT算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1677854\' name=\'code\' snippet_file_name=\'blog_20160510_1_1899603\'>&lt;span style=\'font-size: 13.3333px;\'&gt;&lt;span style=\'font-size: 13.3333px;\'&gt;应用解释：要求找出一组数中的第n大的数字&lt;/span&gt;&lt;/span&gt;</pre>\n  <pre class=\'cpp\' code_snippet_id=\'1677854\' name=\'code\' snippet_file_name=\'blog_20160510_2_2488247\'>&lt;span style=\'font-size: 13.3333px;\'&gt;1.快速排序改进-1（快速选择算法）&lt;/span&gt;&lt;p style=\'font-size: 13.3333px;\'&gt;&lt;/p&gt;&lt;p style=\'font-size: 13.3333px;\'&gt;快速选择算法在于排除，因为一次快排之后便可以确定要找的数在那个子区间，然后不断递归知道找到解，如果没有解最终会导致left&gt;right,从而返回-1,代表输入的要找的数比容量要大当然为了简化的话，是一定要进行剪枝，即当输入的数比容量大的时候直接返回error&lt;/p&gt;</pre>\n  <pre class=\'cpp\' code_snippet_id=\'1677854\' name=\'code\' snippet_file_name=\'blog_20160510_3_918084\'>#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint a[]={0,1,32,43,6,5,67,6,765,7};\nint length=0;\n\nvoid swap(int x,int y)\n{\n	int t;\n	t=a[x];\n	a[x]=a[y];\n	a[y]=t;\n}\n\nint quicksort(int left,int right,int num)\n{\n	if(left&gt;right) return -1;       //查找不到 \n	else\n	{\n		int i,j,t,temp;\n		i=left;\n		j=right;\n		temp=a[left];\n		while(i!=j)\n		{\n		     while(i&lt;j&amp;&amp;a[j]&gt;=temp)\n		     {\n		     	j--;\n		     }\n		     while(i&lt;j&amp;&amp;a[i]&lt;=temp)\n		     {\n		     	i++;\n		     }\n		     if(i&lt;j)\n		     {\n		     	swap(i,j);\n		     }\n		}\n		a[left]=a[i];\n		a[i]=temp;\n		if(i==num)\n		{\n			return a[i];    \n		}\n		else\n		{\n			if(i&gt;num) return quicksort(left,i-1,num);\n			else return quicksort(i+1,right,num); \n		}\n	}\n}\n\nint main()\n{\n	int n;\n	cin&gt;&gt;n;\n	length=sizeof(a)/sizeof(int);\n	cout&lt;&lt;quicksort(1,length-1,n)&lt;&lt;endl;\n	return 0;\n}</pre>\n  <p>\n   <span style=\'font-size:12px\'>\n    2.堆排序（构建大根堆，不断进行选择，录入结束，即求出了该数）\n   </span>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1677854\' name=\'code\' snippet_file_name=\'blog_20160510_4_9347920\'>&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre name=\'code\' class=\'cpp\'&gt;#include\'iostream\'\n#include\'cstdio\'\n\nusing namespace std;\n\nint a[]={0,1,33,5,57,2,456,76,354};\nint n;\n\nvoid swap(int x,int y)\n{\n	int t=a[x];\n	a[x]=a[y];\n	a[y]=t;\n}\n\nvoid siftdown(int i)\n{\n	int t,flag=0;\n	while(flag==0&amp;&amp;i*2&lt;=n)\n	{\n		if(a[i]&lt;a[i*2])\n		{\n			t=i*2;\n		}\n		else\n		{\n			t=i;\n		}\n		if(i*2+1&lt;=n)\n		{\n			if(a[t]&lt;a[i*2+1])\n			{\n				t=i*2+1; \n			}\n		}\n		if(t!=i)\n		{\n			swap(i,t);\n		}\n		else\n		{\n			flag=1;\n		}\n	}\n}\n\nint main()\n{\n	cin&gt;&gt;n;\n	for(int i=1;i&lt;=n;i++)\n	{\n		cin&gt;&gt;a[i];\n	}\n	for(int i=n/2;i&gt;=1;i--)\n	{\n		siftdown(i);\n	}\n	int p;\n	cin&gt;&gt;p;\n	while(p!=-1)\n	{\n		if(a[1]&gt;p)\n		{\n			a[1]=p;\n			siftdown(1);\n		}\n		cin&gt;&gt;p;\n	}\n	cout&lt;&lt;a[1]&lt;&lt;endl;;\n	return 0;\n}</pre>\n  <br/>\n  <p>\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('a02be56adafc2065faaa9cd55ca05956','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  栈的回退思想实现深度优先搜索\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  迷宫问题求解(引用了深度优先搜索的回退的思想，只不过用循环和栈代替递归实现)\n  <br/>\n  因此也有深搜的一个缺点，深搜在第一次找到终点的时候会结束，但是难以求解最少步数，因此再求最小步数的时候，我们常用广度优先搜索\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  #include\'cstdlib\'\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  struct node\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int dir;\n  <br/>\n  };\n  <br/>\n  typedef struct node p;\n  <br/>\n  p stack[100];\n  <br/>\n  int top=0;\n  <br/>\n  p mo;\n  <br/>\n  <br/>\n  <br/>\n  int sum=0;\n  <br/>\n  int book[100][100];\n  <br/>\n  char map[100][100];\n  <br/>\n  p start,end;\n  <br/>\n  int n,m;\n  <br/>\n  <br/>\n  <br/>\n  bool empty()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(top==0)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  void show()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=top;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  printf(\'(%d,%d) \',stack[i].x,stack[i].y);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  p nextpos(p mo,int dir)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  p k;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dir==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.y=mo.y+1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.x=mo.x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.dir=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dir==2)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.x=mo.x+1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.y=mo.y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.dir=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dir==3)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.y=mo.y-1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.x=mo.x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.dir=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dir==4)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.x=mo.x-1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.y=mo.y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k.dir=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return k;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  bool pass(p mo)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(mo.x&gt;n||mo.y&gt;m||map[mo.x][mo.y]==\'#\'||book[mo.x][mo.y]==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return false;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return true;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  void init()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=100;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=1;j&lt;=100;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  map[i][j]=\'#\';\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;n&gt;&gt;m;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=1;j&lt;=m;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;map[i][j];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;start.x&gt;&gt;start.y&gt;&gt;end.x&gt;&gt;end.y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  start.dir=1;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  init();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  mo=start;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  do\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(pass(mo))\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top]=mo;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  book[mo.x][mo.y]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  mo.dir=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(mo.x==end.x&amp;&amp;mo.y==end.y)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  exit(0);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  mo=nextpos(mo,mo.dir);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(stack[top].dir&lt;4)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].dir++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  mo=nextpos(stack[top],stack[top].dir);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(stack[top].dir&gt;=4)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  //book[stack[top+1].x][stack[top+1].y]=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack[top].dir++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  mo=nextpos(stack[top],stack[top].dir);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }while(!empty());\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'no way to go out!\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('59274bdf3fa29047debbc2df9a12e6bb','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  二分搜索\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p style=\'font-size:13.3333px\'>\n   二分算法注意点\n  </p>\n  <p style=\'font-size:13.3333px\'>\n   我们最后的精度误差是被求值之间的精度误差（是因变量的精度误差）\n  </p>\n  <p style=\'font-size:13.3333px\'>\n   还有要注意小心适用于单调函数\n  </p>\n  <p style=\'font-size:13.3333px\'>\n   以下是HDU类似的题组\n  </p>\n  <p style=\'font-size:13.3333px\'>\n   HDU\n   <a href=\'http://http//acm.hdu.edu.cn/showproblem.php?pid=2199\' target=\'_blank\'>\n    2199题目\n   </a>\n  </p>\n  <p style=\'font-size:13.3333px\'>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1669258\' name=\'code\' snippet_file_name=\'blog_20160502_2_9363643\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cmath\'\n\nusing namespace std;\n\ndouble y;\n\ndouble cal(double y)\n{\n	return 8*pow(y,4)+7*pow(y,3)+2*y*y+3*y+6;\n}\n\nbool judge(double mid)\n{\n	return cal(mid)&lt;y;\n}\n\nint main()\n{\n	int n;\n	double high,low,mid,res=0;\n	cin&gt;&gt;n;\n	while(n--)\n	{\n		cin&gt;&gt;y;\n		if(cal(0)&gt;y||cal(100)&lt;y)\n		{\n			cout&lt;&lt;\'No solution!\'&lt;&lt;endl;\n		}\n		else\n		{\n			high=100;\n			low=0;\n			while(cal(mid)-y&gt;=1e-5||y-cal(mid)&gt;=1e-5)\n			{\n				mid=(high+low)/2;\n				if(judge(mid))\n				{\n					low=mid;\n					res=low;\n				}\n				else\n				{\n				    high=mid;\n				    res=mid;\n				}\n			}\n			printf(\'%.4lf\n\',res);\n		}\n	}\n	return 0;\n}</pre>\n  <br/>\n  <br/>\n  <p>\n  </p>\n  <div style=\'top:0px\'>\n   <p style=\'font-size:13.3333px\'>\n    二分算法注意点\n   </p>\n   <p style=\'font-size:13.3333px\'>\n    我们最后的精度误差是被求值之间的精度误差（是因变量的精度误差）\n   </p>\n   <p style=\'font-size:13.3333px\'>\n    还有要注意小心适用于单调函数\n   </p>\n   <p style=\'font-size:13.3333px\'>\n    以下是HDU类似的题组\n   </p>\n   <p style=\'font-size:13.3333px\'>\n    HDU\n    <a href=\'http://http://acm.hdu.edu.cn/showproblem.php?pid=2199\' target=\'_blank\'>\n     2199题目\n    </a>\n   </p>\n   <p style=\'font-size:13.3333px\'>\n   </p>\n   <pre class=\'cpp\' code_snippet_id=\'1669258\' name=\'code\' snippet_file_name=\'blog_20160502_2_9363643\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cmath\'\n\nusing namespace std;\n\ndouble y;\n\ndouble cal(double y)\n{\n	return 8*pow(y,4)+7*pow(y,3)+2*y*y+3*y+6;\n}\n\nbool judge(double mid)\n{\n	return cal(mid)&lt;y;\n}\n\nint main()\n{\n	int n;\n	double high,low,mid,res=0;\n	cin&gt;&gt;n;\n	while(n--)\n	{\n		cin&gt;&gt;y;\n		if(cal(0)&gt;y||cal(100)&lt;y)\n		{\n			cout&lt;&lt;\'No solution!\'&lt;&lt;endl;\n		}\n		else\n		{\n			high=100;\n			low=0;\n			while(cal(mid)-y&gt;=1e-5||y-cal(mid)&gt;=1e-5)\n			{\n				mid=(high+low)/2;\n				if(judge(mid))\n				{\n					low=mid;\n					res=low;\n				}\n				else\n				{\n				    high=mid;\n				    res=mid;\n				}\n			}\n			printf(\'%.4lf\n\',res);\n		}\n	}\n	return 0;\n}</pre>\n   <br/>\n   <br/>\n   <p>\n   </p>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('8ded2c60f7323d361a1d1302a5a26849','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  浅析最大二分图匹配算法中记录数组book的真实作用\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <pre class=\'cpp\' code_snippet_id=\'1659457\' name=\'code\' snippet_file_name=\'blog_20160424_1_5114610\'>#include\'iostream\'\n#include\'cstdio\'\n#include\'cstdlib\'\nusing namespace std;\n\n\nint u[100];\nint v[100];\nint w[100];\nint first[100];\nint next[100];\nint n,m;\nint match[100];\nint book[100];\nint sum=0;\n\n\nbool dfs(int u)\n{\n	int t=first[u];\n	while(t!=-1)\n	{\n		if(book[v[t]]==0)\n		{\n		book[v[t]]=1;	\n		if(match[v[t]]==0||dfs(match[v[t]]))\n		{\n			match[u]=v[t];\n			match[v[t]]=u;\n			return 1;\n		}\n	    }\n		t=next[t];\n	}\n	return 0;\n}\n\n\nint main()\n{\n	cin&gt;&gt;n&gt;&gt;m;\n	for(int i=1;i&lt;=n;i++)\n	{\n		first[i]=-1;\n	}\n	for(int i=1;i&lt;=m;i++)\n	{\n		cin&gt;&gt;u[i]&gt;&gt;v[i];\n		w[i]=1;\n	}\n	for(int i=m+1;i&lt;=2*m;i++)\n	{\n		u[i]=v[i-m];\n		v[i]=u[i-m];\n		w[i]=w[i-m];\n	}\n	for(int i=1;i&lt;=2*m;i++)\n	{\n		next[i]=first[u[i]];\n		first[u[i]]=i;\n	}\n	for(int i=1;i&lt;=n;i++)\n	{\n		memset(book,0,sizeof(book));\n		if(dfs(i))\n		{\n			sum++;\n		}\n	}\n	cout&lt;&lt;sum&lt;&lt;endl;\n	return 0;\n} </pre>\n  <p>\n   以上是加上book数组的源码，我仔细考虑了一下book数组的真实作用\n  </p>\n  <p>\n   如果没有book数组\n  </p>\n  <p>\n   如图\n  </p>\n  <p>\n   当以4为原点开始搜索，当搜索到7的时候，7和2其实已经有了连接关系，但是我们尝试4和7之间的增广路\n  </p>\n  <p>\n   应为match[7]=2，所以进入dfs(match[7])就是dfs(2)函数，再次以2为原点进行搜索\n  </p>\n  <p>\n   在这时，请注意我们的目的\n  </p>\n  <p>\n   我们是想再找到一条2不和7相连和其他点相连从而促进4和7相连，从而增加增广路。\n  </p>\n  <p>\n   所以，我们是不希望2再次和7匹配的\n  </p>\n  <p>\n   但是如果没有book数组进行判重，那么2必然会再次搜索到7，此时会成为无限循环，不断重复以2为原点开始搜索的情况\n  </p>\n  <p>\n   所以程序是有问题的。\n  </p>\n  <p>\n   综上，book数组是绝对有必要的，是匈牙利算法深度优先搜索的必要成分，绝对不能轻而易举的删去\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4acffe82b905c42d794404212f8e3daf','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  查找图的割点 邻接表优化\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int u[100];\n  <br/>\n  int v[100];\n  <br/>\n  int w[100];\n  <br/>\n  int first[100];\n  <br/>\n  int next[100];\n  <br/>\n  int n,m;\n  <br/>\n  int sum[100];\n  <br/>\n  int flag[100];\n  <br/>\n  int root;\n  <br/>\n  int index=0;\n  <br/>\n  int num[100];\n  <br/>\n  int low[100];\n  <br/>\n  <br/>\n  <br/>\n  void dfs(int cur,int father)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int child=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  index++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  num[cur]=low[cur]=index;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t=first[cur];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(t!=-1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(num[v[t]]==0)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  child++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dfs(v[t],cur);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  low[cur]=min(low[v[t]],num[cur]);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(cur!=root&amp;&amp;low[v[t]]&gt;=num[cur])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum[cur]++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag[cur]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(cur==root&amp;&amp;child&gt;=2)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum[cur]++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag[cur]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(v[t]!=father)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  low[cur]=min(low[cur],num[v[t]]);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=next[t];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;n&gt;&gt;m;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  first[i]=-1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum[i]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=m;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;u[i]&gt;&gt;v[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  w[i]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1+m;i&lt;=2*m;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  u[i]=v[i-m];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  v[i]=u[i-m];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  w[i]=w[i-m];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=2*m;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  next[i]=first[u[i]];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  first[u[i]]=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  root=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dfs(1,root);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(flag[i]==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;i&lt;&lt;\' \'&lt;&lt;sum[i]&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('fdb22e25a2d0703f9a32876e7a3ee5a5','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  查找图的割点的算法 基本算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   //额外增加sum数组记录最后可以生成的独立的子树的个数\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   #include\'iostream\'\n  </p>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int low[100];\n  <br/>\n  int num[100];\n  <br/>\n  int n,m;\n  <br/>\n  int flag[100];\n  <br/>\n  int root;\n  <br/>\n  int index=0;\n  <br/>\n  int sum[100];\n  <br/>\n  int map[100][100];\n  <br/>\n  <br/>\n  <br/>\n  void dfs(int cur,int father)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int child=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  index++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  num[cur]=low[cur]=index;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(map[cur][i]==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(num[i]==0)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  child++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dfs(i,cur);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  low[cur]=min(low[cur],low[i]);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(cur!=root&amp;&amp;low[i]&gt;=num[cur])     //此处选取等于的含义是当cur的下一个顶点的出边最终指向仍然是cur的时候，显然cur也是割点\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag[cur]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum[cur]++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(cur==root&amp;&amp;child&gt;=2)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag[cur]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum[cur]++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(i!=father)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  low[cur]=min(low[cur],num[i]);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;n&gt;&gt;m;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sum[i]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=m;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int x,y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;x&gt;&gt;y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  map[y][x]=map[x][y]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  root=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dfs(1,root);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(flag[i]==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;i&lt;&lt;\' \'&lt;&lt;sum[i]&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('350c96b4188f8961c93d4714c3a7516e','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  堆优化 Dijstra单源最短路径算法 2（邻接表）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int u[100];\n  <br/>\n  int v[100];\n  <br/>\n  int w[100];\n  <br/>\n  int first[100];\n  <br/>\n  int next[100];\n  <br/>\n  int n,m;\n  <br/>\n  int dis[100];\n  <br/>\n  int heap[100];\n  <br/>\n  int k;\n  <br/>\n  int minpoint;\n  <br/>\n  int inf=9999999;\n  <br/>\n  <br/>\n  <br/>\n  void swap(int x,int y)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t=heap[x];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[x]=heap[y];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[y]=t;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  void siftdown(int i)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t,flag=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(flag==0&amp;&amp;i*2&lt;=n)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dis[heap[i]]&gt;dis[heap[i*2]])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=i*2;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(i*2+1&lt;=n)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dis[heap[t]]&gt;dis[heap[i*2+1]])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=i*2+1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(i!=t)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  swap(i,t);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  i=t;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int pop()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t=heap[1];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[1]=heap[n];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  n--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  siftdown(1);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return t;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;n&gt;&gt;m;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k=n;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  first[i]=-1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[i]=inf;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[1]=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=m;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  next[i]=first[u[i]];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  first[u[i]]=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(u[i]==1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[v[i]]=w[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[i]=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=n/2;i&gt;=1;i--)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  siftdown(i);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int z=pop();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=k-1;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  minpoint=pop();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t=first[minpoint];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(t!=-1)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dis[v[t]]&gt;dis[u[t]]+w[t])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[v[t]]=dis[u[t]]+w[t];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=next[t];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=n/2;i&gt;=1;i--)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  siftdown(i);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=k;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  printf(\'%d \',dis[i]);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  <p>\n   }\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   无需赘语，需要注意的要点和邻接矩阵的堆优化dijstra算法是一样的，我们都必须小心再松弛操作完了之后，对堆进行一次重新调整\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('939cfe2513c87864203c802b94b3b345','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Dijstra 单源最短路径算法 堆优化-1（二维数组存储数据）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  #include\'cstdlib\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int map[100][100];\n  <br/>\n  int dis[100];\n  <br/>\n  int n,m;\n  <br/>\n  int heap[100];\n  <br/>\n  int sum;\n  <br/>\n  int minpoint;\n  <br/>\n  int inf=99999999;\n  <br/>\n  int x,y,z;\n  <br/>\n  <br/>\n  <br/>\n  void swap(int x,int y)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=heap[x];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[x]=heap[y];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[y]=t;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  void siftdown(int i)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t,flag=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(flag==0&amp;&amp;i*2&lt;=n)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dis[heap[i]]&gt;dis[heap[i*2]])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=i*2;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(i*2+1&lt;=n)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dis[heap[t]]&gt;dis[heap[i*2+1]])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  t=i*2+1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(t!=i)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  swap(i,t);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  i=t;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  flag=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int pop()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int t=heap[1];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[1]=heap[n];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  n--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  siftdown(1);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return t;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;n&gt;&gt;m;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int k=n;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=1;j&lt;=n;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(i==j)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  map[i][j]=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  else\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  map[i][j]=inf;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=m;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  map[x][y]=z;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[i]=map[1][i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  heap[i]=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int w=pop();\n  <br/>\n  for(int i=k/2;i&gt;=1;i--)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  siftdown(i);\n  <br/>\n  }\n  <br/>\n  for(int i=1;i&lt;=k-1;i++)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  minpoint=pop();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int j=1;j&lt;=k;j++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dis[j]&gt;dis[minpoint]+map[minpoint][j])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[j]=dis[minpoint]+map[minpoint][j];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=k/2;i&gt;=1;i--)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  siftdown(i);\n  <br/>\n  }\n  <br/>\n  }\n  <br/>\n  for(int i=1;i&lt;=k;i++)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  printf(\'%d \',dis[i]);\n  <br/>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  <p>\n   }\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   本优化算法的实现会有几个很容易犯的错误\n  </p>\n  <p>\n   现已个人亲身经历来简单谈一下几个很容易出现的错误\n  </p>\n  <p>\n   1.\n  </p>\n  <p>\n   siftdown函数的比较标准，是dis数组的权值\n  </p>\n  <p>\n   2.\n  </p>\n  <p>\n   dijstra每轮松弛结束之后，我们都要整体对堆进行一次调整，因为松弛过后会导致堆不满足最小堆的状态，我们的调整是必须的\n  </p>\n  <p>\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('4db3cb31e39db0f7db287a1422cb80bf','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Bellman flod SPFA算法再解\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   SPFA（Bellman flod队列优化）\n  </p>\n  <p>\n   #include\'iostream\'\n  </p>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int u[100];\n  <br/>\n  int v[100];\n  <br/>\n  int w[100];\n  <br/>\n  int first[100];\n  <br/>\n  int next[100];\n  <br/>\n  int n,m,k;\n  <br/>\n  int dis[100];\n  <br/>\n  int book[100];\n  <br/>\n  int queue[100];\n  <br/>\n  int head=1;\n  <br/>\n  int tail=1;\n  <br/>\n  int inf=999999999;\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;n&gt;&gt;m;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)      //邻接表初始化\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  first[i]=-1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)     //dis初始化\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[i]=inf;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[1]=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=m;i++)           //边输入\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  next[i]=first[u[i]];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  first[u[i]]=i;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  queue[1]=1;             //起点入队列\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  tail++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  book[1]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n-1;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k=first[queue[head]];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(k!=-1)                      //\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(dis[v[k]]&gt;dis[u[k]]+w[k])\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  dis[v[k]]=dis[u[k]]+w[k];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(book[v[k]]==0)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  queue[tail]=v[k];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  book[v[k]]=1;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  tail++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  k=next[k];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  book[queue[head]]=0;        //只对已经进行过边的优化的点入队列\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  head++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=n;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  printf(\'%d \',dis[i]);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  <p>\n   }\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   <br/>\n  </p>\n  <p>\n   Bellman flod\n  </p>\n  <p>\n   #include\'iostream\'\n   <br/>\n   #include\'cstdio\'\n   <br/>\n   <br/>\n   <br/>\n   using namespace std;\n   <br/>\n   <br/>\n   <br/>\n   int u[100];\n   <br/>\n   int v[100];\n   <br/>\n   int w[100];\n   <br/>\n   int first[100];\n   <br/>\n   int next[100];\n   <br/>\n   int n,m,k;\n   <br/>\n   int book[100];\n   <br/>\n   int dis[100];\n   <br/>\n   int inf=99999999;\n   <br/>\n   <br/>\n   <br/>\n   int main()\n   <br/>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;n&gt;&gt;m;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   first[i]=-1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   dis[i]=inf;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   dis[1]=0;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   next[i]=first[u[i]];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   first[u[i]]=i;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n-1;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int j=1;j&lt;=m;j++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(dis[v[j]]&gt;dis[u[j]]+w[j])\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   dis[v[j]]=dis[u[j]]+w[j];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   printf(\'%d \',dis[i]);\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 0;\n   <br/>\n   }\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('d1bbeb3766f7eec9c92a7a7033b78378','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  C++自学摘要\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  1.void类型指针（随机类型指针）的抽象化应用\n  <br/>\n  memcpy内存拷贝函数\n  <br/>\n  void *memcpy(void *dest,const void *src,size)\n  <br/>\n  因为memcpy函数是对内存进行处理的，起始地址是src指针对应的首地址，要拷贝的内容长度是size\n  <br/>\n  拷贝的目的地是dest随机指针，在这里使用void指针的一大好处就是，我们无需考虑src首地址的具体数据结构\n  <br/>\n  只需要拷贝其内容就可以了，我们最后只需要对dest进行强制类型转换就可以输出我们拷贝的内容了\n  <br/>\n  <br/>\n  <br/>\n  2.用引用，可以使函数调用作为左值．引用表达式是一个左值表达式，因此它可以出现在形、实参数的任何一方。若一个函数返回了引用，那么该函数的调用也可以被赋值。一般，当返搜索回值不是本函数内定义的局部变量时就可以返回一个引用。在通常情况下，引用返回值只用在需要对函数的调用重新赋值的场合，也就是对函数的返回值重新赋值的时候。避免将局部作用域中变时的地址返回，就使用函数调用表达式全为左值来使用。\n  <br/>\n  <br/>\n  <br/>\n  3.复制构造函数的一些小细节\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  #include\'cstring\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  class Person\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Person(Person &amp;personbud);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Person(char *k,int p);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ~Person();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void show()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'name:\'&lt;&lt;name&lt;&lt;endl;          //cout&lt;&lt;p;输出完整的字符串，而cout&lt;&lt;*p;输出字符串首字符\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'age:\'&lt;&lt;age&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int age;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char *name;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  Person::Person(Person &amp;person0)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  age=person0.age;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  name=new char[strlen(person0.name)+1];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  strcpy(name,person0.name);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'对象成员赋值成功\'&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  Person::Person(char *k,int p)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  name=new char[strlen(k)+1];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  strcpy(name,k);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  age=p;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'成功调用构造函数\'&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  Person::~Person()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  delete name;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'成功调用析构函数\'&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  Person person1(\'zhangsan\',18),person2(person1);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  person1.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  person2.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  4.关于公有函数作为对外接口的一点小认识\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  class T\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int get()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  };\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  T(int w):x(w){};\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  T(const T &amp;t)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x=t.x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'复制对象成功\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int x;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  void show(T &amp;t)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;t.get()&lt;&lt;endl;             //此时如果输出t.x则报错，毕竟外部成员函数无法访问私有成员，但是可以用共有函数作为输出接口\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  T t(5);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  show(t);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  5.\n  <br/>\n  在C++的继承方式上来说，我们可以这么理解，继承方式确定之后，成员类型权限不增但是会减，相同的会保持\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  6.\n  <br/>\n  我们一旦限制继承权限是私有继承的时候，原基类的所有成员在派生类中全部视为私有成员\n  <br/>\n  也就是说我们可以通过派生类中的公有成员函数来对其进行访问，但是我们在派生类外进行访问则是非法的\n  <br/>\n  eg：obj.setx()//setx是私有继承基类中的成员变量，这种写法是错误的\n  <br/>\n  obj.set()//set(){return setx()}//这是可以的\n  <br/>\n  <br/>\n  <br/>\n  7.私有类成员和保护类成员的主要区别在于\n  <br/>\n  私有类成员无论是在基类还是在派生类中属性都是私有的，都是不能被基类和派生类直接访问的，但是保护类成员的含义就是\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  8.在继承中，私有成员无论是何种继承方式均变成不可访问，我们获取不可访问的变量的信息唯一的方法就是通过基类中的公有或者受保护类成员作为接口间接输出或者间接修改他的值（是可以修改的）。但是受保护成员在派生类中对外而言有私有成员不可访问的性质，但是在对内而言受保护成员在派生类中可以被访问。（这是核心的区别）\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  9.举例，基类中的基类私有变量虽然在派生类中我们是无法直接访问的，但是我们可以通过派生类中的公有成员函数调用基类中的公有成员函数（虽然此时在派生类中此共有函数如果是私有继承的话是私有变量，但是公有成员函数可以调用私有成员，所以，是成立的），通过基类的公有成员函数实现对此时在派生类中不可访问的变量进行个访问和修改。\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  class math\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  math()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'构造函数开始调用\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ~math()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'析构函数开始调用\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void setx(int y)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x=y;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void showx()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;x&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int getx()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  class m:private math\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  m()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'派生类默认构造函数开始调用\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  m(int w)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  set(w);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'派生类构造函数开始调用\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void show()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;getx()&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void set(int a)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  setx(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  m h;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  h.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  m z(10);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  z.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  h.set(20);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  h.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  10.\n  <br/>\n  记住派生类和基类的构造函数和析构函数调用的顺序\n  <br/>\n  开始的时候：先调用基类的构造函数在调用派生类的构造函数\n  <br/>\n  结束的时候：先调用派生类的析构函数在调用基类的构造函数\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  11.\n  <br/>\n  虚函数和虚析构函数的意义\n  <br/>\n  1.为什么基类的析构函数是虚函数？\n  <br/>\n  <br/>\n  <br/>\n  在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。\n  <br/>\n  （因为此时使用基类指针声明派生类对象，所以析构的时候，只析构基类的类型，而构造的派生类并不析构）\n  <br/>\n  下面转自网络：源地址 http://blog.sina.com.cn/s/blog_7c773cc50100y9hz.html\n  <br/>\n  <br/>\n  <br/>\n  a.第一段代码\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  复制代码\n  <br/>\n  复制代码\n  <br/>\n  #include&lt;iostream&gt;\n  <br/>\n  using namespace std;\n  <br/>\n  class ClxBase{\n  <br/>\n  public:\n  <br/>\n  ClxBase() {};\n  <br/>\n  ~ClxBase() {cout &lt;&lt; \'Output from the destructor of class ClxBase!\' &lt;&lt; endl;};\n  <br/>\n  <br/>\n  <br/>\n  void DoSomething() { cout &lt;&lt; \'Do something in class ClxBase!\' &lt;&lt; endl; };\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  class ClxDerived : public ClxBase{\n  <br/>\n  public:\n  <br/>\n  ClxDerived() {};\n  <br/>\n  ~ClxDerived() { cout &lt;&lt; \'Output from the destructor of class ClxDerived!\' &lt;&lt; endl; };\n  <br/>\n  <br/>\n  <br/>\n  void DoSomething() { cout &lt;&lt; \'Do something in class ClxDerived!\' &lt;&lt; endl; };\n  <br/>\n  };\n  <br/>\n  int   main(){\n  <br/>\n  ClxDerived *p =  new ClxDerived;\n  <br/>\n  p-&gt;DoSomething();\n  <br/>\n  delete p;\n  <br/>\n  return 0;\n  <br/>\n  }\n  <br/>\n  复制代码\n  <br/>\n  复制代码\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  运行结果：\n  <br/>\n  <br/>\n  <br/>\n  Do something in class ClxDerived!\n  <br/>\n  <br/>\n  <br/>\n  Output from the destructor of class ClxDerived!\n  <br/>\n  <br/>\n  <br/>\n  Output from the destructor of class ClxBase!\n  <br/>\n  <br/>\n  <br/>\n  这段代码中基类的析构函数不是虚函数,在main函数中用继承类的指针去操作继承类的成员,释放指针P的过程是:先释放继承类的资源,再释放基类资源.\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  b.第二段代码\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  复制代码\n  <br/>\n  复制代码\n  <br/>\n  #include&lt;iostream&gt;\n  <br/>\n  using namespace std;\n  <br/>\n  class ClxBase{\n  <br/>\n  public:\n  <br/>\n  ClxBase() {};\n  <br/>\n  ~ClxBase() {cout &lt;&lt; \'Output from the destructor of class ClxBase!\' &lt;&lt; endl;};\n  <br/>\n  <br/>\n  <br/>\n  void DoSomething() { cout &lt;&lt; \'Do something in class ClxBase!\' &lt;&lt; endl; };\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  class ClxDerived : public ClxBase{\n  <br/>\n  public:\n  <br/>\n  ClxDerived() {};\n  <br/>\n  ~ClxDerived() { cout &lt;&lt; \'Output from the destructor of class ClxDerived!\' &lt;&lt; endl; };\n  <br/>\n  <br/>\n  <br/>\n  void DoSomething() { cout &lt;&lt; \'Do something in class ClxDerived!\' &lt;&lt; endl; }\n  <br/>\n  };\n  <br/>\n  int   main(){\n  <br/>\n  ClxBase *p =  new ClxDerived;\n  <br/>\n  p-&gt;DoSomething();\n  <br/>\n  delete p;\n  <br/>\n  return 0;\n  <br/>\n  }\n  <br/>\n  复制代码\n  <br/>\n  复制代码\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  输出结果：\n  <br/>\n  <br/>\n  <br/>\n  Do something in class ClxBase!\n  <br/>\n  Output from the destructor of class ClxBase!\n  <br/>\n  <br/>\n  <br/>\n  这段代码中基类的析构函数同样不是虚函数,不同的是在main函数中用基类的指针去操作继承类的成员,释放指针P的过程是:只是释放了基类的资源,而没有调用继承类的析构函数.调用　　dosomething()函数执行的也是基类定义的函数.\n  <br/>\n  <br/>\n  <br/>\n  一般情况下,这样的删除只能够删除基类对象,而不能删除子类对象,形成了删除一半形象,造成内存泄漏.\n  <br/>\n  <br/>\n  <br/>\n  在公有继承中,基类对派生类及其对象的操作,只能影响到那些从基类继承下来的成员.如果想要用基类对非继承成员进行操作,则要把基类的这个函数定义为虚函数.\n  <br/>\n  <br/>\n  <br/>\n  ********析构函数自然也应该如此:如果它想析构子类中的*重新定义或新的成员及对象*,当然也应该声明为虚的.\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  c.第三段代码：\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  复制代码\n  <br/>\n  复制代码\n  <br/>\n  #include&lt;iostream&gt;\n  <br/>\n  using namespace std;\n  <br/>\n  class ClxBase{\n  <br/>\n  public:\n  <br/>\n  ClxBase() {};\n  <br/>\n  virtual ~ClxBase() {cout &lt;&lt; \'Output from the destructor of class ClxBase!\' &lt;&lt; endl;};\n  <br/>\n  virtual void DoSomething() { cout &lt;&lt; \'Do something in class ClxBase!\' &lt;&lt; endl; };\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  class ClxDerived : public ClxBase{\n  <br/>\n  public:\n  <br/>\n  ClxDerived() {};\n  <br/>\n  ~ClxDerived() { cout &lt;&lt; \'Output from the destructor of class ClxDerived!\' &lt;&lt; endl; };\n  <br/>\n  void DoSomething() { cout &lt;&lt; \'Do something in class ClxDerived!\' &lt;&lt; endl; };\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  int   main(){\n  <br/>\n  ClxBase *p =  new ClxDerived;\n  <br/>\n  p-&gt;DoSomething();\n  <br/>\n  delete p;\n  <br/>\n  return 0;\n  <br/>\n  }\n  <br/>\n  复制代码\n  <br/>\n  复制代码\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  运行结果：\n  <br/>\n  <br/>\n  <br/>\n  Do something in class ClxDerived!\n  <br/>\n  Output from the destructor of class ClxDerived!\n  <br/>\n  Output from the destructor of class ClxBase!\n  <br/>\n  <br/>\n  <br/>\n  这段代码中基类的析构函数被定义为虚函数,在main函数中用基类的指针去操作继承类的成员,释放指针P的过程是:只是释放了继承类的资源,再调用基类的析构函数.调用dosomething()函数执行的也是继承类定义的函数.\n  <br/>\n  <br/>\n  <br/>\n  如果不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销.当类里面有定义虚函数的时候,编译器会给类添加一个虚函数表,里面来存放虚函数指针,这样就会增加类的存储空间.所以,只有当一个类被用来作为基类的时候,才把析构函数写成虚函数.\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  C++编程语言是一款应用广泛，支持多种程序设计的计算机编程语言。我们今天就会为大家详细介绍其中C++多态性的一些基本知识，以方便大家在学习过程中对此能够有一个充分的掌握。\n  <br/>\n  多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。\n  <br/>\n  C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。\n  <br/>\n  ***************重载和多态有区别，前者是同时存在多种状态，应用时选择一个，后者是在应用时覆盖，屏蔽原有的**********\n  <br/>\n  多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。\n  <br/>\n  那么多态的作用是什么呢，封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。\n  <br/>\n  最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  13。类内函数调用数据成员合法\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  14.对于等于运算符的重载，有些许注意要点\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  class math\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void show()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;*p&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  math()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  p=new int(0);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'默认构造函数调用成功\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  math(int x)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  p=new int;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  *p=x;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'构造函数调用成功\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ~math()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  delete p;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'析构函数调用成功\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  math&amp; operator=(math k)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  *p=*k.p;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return *this;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int *p;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  math x,y(1),z(4);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x=y;y\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  x.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  如果使用引用接收引用返回值，则返回的引用必须具有较长的生存期，不可以引用局部变量。\n  <br/>\n  如果使用引用接收值返回值，则引用了一个临时对象，该对象的生存期将延长到和这个引用相同\n  <br/>\n  C:UsersasuspcAppDataRoaming360se6Application360se.exe  http://blog.csdn.net/duanruibupt/article/details/6881018      /////该网址成功解释了引用的区别\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  15.\n  <br/>\n  C++的流插入运算符“&lt;&lt;”和流提取运算符“&gt;&gt;”是C++在类库中提供的，所有C++编译系统都在类库中提供输入流类istream和输出流类ostream。cin和cout分别是istream类和ostream类的对象。在类库提供的头文件中已经对“&lt;&lt;”和“&gt;&gt;”进行了重载，使之作为流插入运算符和流提取运算符，能用来输出和输入C++标准类型的数据。因此，凡是用“cout&lt;&lt;”和“cin&gt;&gt;”对标准类型数据进行输入输出的，都要用#include 把头文件包含到本程序文件中。\n  <br/>\n  <br/>\n  <br/>\n  用户自己定义的类型的数据，是不能直接用“&lt;&lt;”和“&gt;&gt;”来输出和输入的。如果想用它们输出和输入自己声明的类型的数据，必须对它们重载。\n  <br/>\n  <br/>\n  <br/>\n  对“&lt;&lt;”和“&gt;&gt;”重载的函数形式如下：\n  <br/>\n  istream &amp; operator &gt;&gt; (istream &amp;, 自定义类 &amp;);\n  <br/>\n  ostream &amp; operator &lt;&lt; (ostream &amp;, 自定义类 &amp;);\n  <br/>\n  即重载运算符“&gt;&gt;”的函数的第一个参数和函数的类型都必须是istream&amp;类型，第二个参数是要进行输入操作的类。重载“&lt;&lt;”的函数的第一个参数和函数的类型都必须是ostream&amp;类型，第二个参数是要进行输出操作的类。因此，只能将重载“&gt;&gt;”和“&lt;&lt;”的函数作为友元函数或普通的函数，而不能将它们定义为成员函数。\n  <br/>\n  <br/>\n  <br/>\n  16.\n  <br/>\n  请思考，return  output的作用是什么？回答是能*连续向输出流插入信息*。output是ostream类的对象，它是实参cout的引用，也就是cout通过传送地址给output，使它们二者共享同一段存储单元，或者说output是cout的别名。因此，return output就是return cout，将输出流cout的现状返回，即保留输出流的现状。\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  还有一点要说明，在本程序中，在Complex类中定义了运算符“&lt;&lt;”重载函数为友元函数，因此只有在输出Complex类对象时才能使用重载的运算符，对其他类型的对象是无效的。如\n  <br/>\n  cout&lt;&lt;time1;  //time1是Time类对象，不能使用用于Complex类的重载运算符\n  <br/>\n  <br/>\n  <br/>\n  17.\n  <br/>\n  可以看到，在运算符重载中使用引用(reference)的重要性。利用引用作为函数的形参可以在调用函数的过程中不是用传递值的方式进行虚实结合，而是通过传址方式使形参成为实参的别名，因此不生成临时变量(实参的副本)，减少了时间和空间的开销。此外，如果重载函数的返回值是对象的引用时，返回的不是常量，而是引用所代表的对象，它可以出现在赋值号的左侧而成为左值(left value)，可以被赋值或参与其他操作(如保留cout流的当前值以便能连续使用“&lt;&lt;”输出)。但使用引用时要特别小心，因为修改了引用就等于修改了它所代表的对象。\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  18.\n  <br/>\n  在进行类型转换的重载运算符的时候，我们不要在行参中用引用，因为一旦要对其他基本的数据类型转换为类的类型的时候，引用的对象有可能是基本的数据类型，但是引用代表的含义是对类进行取地址，但是此时数据类型不是类，就会报错\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  19.\n  <br/>\n  多参数模板的返回值可能会出出现结果错误，但不是程序引起的，而是返回值的类型决定的\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  20.\n  <br/>\n  模板必须是要有顺序的，是按顺序排列的\n  <br/>\n  争取代码示例：\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  template&lt;class T,int size&gt;\n  <br/>\n  <br/>\n  <br/>\n  void sort(T a[size])\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'yes\'&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int a[]={0,1,2,3,4,5,6,7,8,9};\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sort&lt;int ,10&gt;(a);           //核心\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  错误代码示例：\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  template&lt;class T,int size&gt;\n  <br/>\n  <br/>\n  <br/>\n  void sort(T a[size])\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'yes\'&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int a[]={0,1,2,3,4,5,6,7,8,9};\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sort&lt;10,int&gt;(a);           //核心\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  应用引用的方式就可以不用显式的指定参数了\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  template&lt;class T,int size&gt;\n  <br/>\n  <br/>\n  <br/>\n  void sort(T (&amp;a)[size])\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'yes\'&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int a[]={0,1,2,3,4,5,6,7,8,9};\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  sort(a);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  21.\n  <br/>\n  模板类型基本数据类型或者自己定义的类\n  <br/>\n  <br/>\n  <br/>\n  22.\n  <br/>\n  string类型变量在C++的#include\'string\'头文件里面\n  <br/>\n  <br/>\n  <br/>\n  23.\n  <br/>\n  用模板类实现栈\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  template&lt;class T&gt;\n  <br/>\n  <br/>\n  <br/>\n  class stack\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  bool stackempty()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return top==0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  bool stackfull()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return top==99;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void stackpush(T a)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  data[top]=a;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  T stackpop()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return data[top+1];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int top;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  T data[100];\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack&lt;int&gt; int_stack;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack&lt;char&gt; char_stack;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=1;i&lt;=10;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int_stack.stackpush(i);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(!int_stack.stackempty())\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;int_stack.stackpop()&lt;&lt;\' \';\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char_stack.stackpush(\'A\');\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char_stack.stackpush(\'B\');\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char_stack.stackpush(\'C\');\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  while(!char_stack.stackempty())\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;char_stack.stackpop()&lt;&lt;\' \';\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'End\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  23\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  template&lt;class T,size_t size&gt;\n  <br/>\n  <br/>\n  <br/>\n  class stack\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  bool stackempty()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return top==0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  bool stackfull()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return top==size;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  T stackpop()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top--;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return data[top+1];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void stackpush(T a)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  top++;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return data[top]=a;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  T data[size];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  size_t top;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  template&lt;class T,size_t size,template&lt;class U,size_t len&gt; class stack&gt;\n  <br/>\n  <br/>\n  <br/>\n  class container\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void show()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;kstack.stackpop()&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  stack&lt;T,size&gt; kstack;\n  <span style=\'white-space:pre\'>\n  </span>\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  container&lt;int,10,stack&gt; contain;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  contain.show();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  以上是在container模板类中声明了一个固定模板参数表的私有成员的模板类成员，并用前面定义的stack来替换contanier中的模板参数类，实现对container的实例化\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  24.\n  <br/>\n  组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、\n  <br/>\n  <br/>\n  <br/>\n  &lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt;和&lt;utility&gt;。\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  &lt;algorithm&gt;是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  &lt;functional&gt;中则定义了一些模板类，用以声明函数对象。\n  <br/>\n  <br/>\n  <br/>\n  25.\n  <br/>\n  50条忠告：（其中有几条觉得写的不够贴切，所以删了，发了余下的部分）\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  1.把C++当成一门新的语言学习；\n  <br/>\n  <br/>\n  <br/>\n  2.看《Thinking In C++》，不要看《C++变成死相》；\n  <br/>\n  <br/>\n  <br/>\n  3.看《The C++ Programming Language》和《Inside The C++ Object Model》,不要因为他们很难而我们自己是初学者所以就不看；\n  <br/>\n  <br/>\n  <br/>\n  4.不要被VC、BCB、BC、MC、TC等词汇所迷惑——他们都是集成开发环境，而我们要学的是一门语言；\n  <br/>\n  <br/>\n  <br/>\n  5.不要放过任何一个看上去很简单的小编程问题——他们往往并不那么简单，或者可以引伸出很多知识点；\n  <br/>\n  <br/>\n  <br/>\n  6.会用Visual C++，并不说明你会C++；\n  <br/>\n  <br/>\n  <br/>\n  7.学class并不难，template、STL、generic programming也不过如此——难的是长期坚持实践和不遗余力的博览群书；\n  <br/>\n  <br/>\n  <br/>\n  8.如果不是天才的话，想学编程就不要想玩游戏——你以为你做到了，其实你的C++水平并没有和你通关的能力一起变高——其实可以时刻记住：学C++是为了编游戏的；\n  <br/>\n  <br/>\n  <br/>\n  9.看Visual C++的书，是学不了C++语言的；\n  <br/>\n  <br/>\n  <br/>\n  16.把时髦的技术挂在嘴边，还不如把过时的技术记在心里；\n  <br/>\n  <br/>\n  <br/>\n  18.学习编程最好的方法之一就是阅读源代码；\n  <br/>\n  <br/>\n  <br/>\n  19.在任何时刻都不要认为自己手中的书已经足够了；\n  <br/>\n  <br/>\n  <br/>\n  20.请阅读《The Standard C++ Bible》(中文版：标准C++宝典)，掌握C++标准；\n  <br/>\n  <br/>\n  <br/>\n  21.看得懂的书，请仔细看；看不懂的书，请硬着头皮看；\n  <br/>\n  <br/>\n  <br/>\n  22.别指望看第一遍书就能记住和掌握什么——请看第二遍、第三遍；\n  <br/>\n  <br/>\n  <br/>\n  23.请看《Effective C++》和《More Effective C++》以及《Exceptional C++》；\n  <br/>\n  <br/>\n  <br/>\n  24.不要停留在集成开发环境的摇篮上，要学会控制集成开发环境，还要学会用命令行方式处理程序；\n  <br/>\n  <br/>\n  <br/>\n  25.和别人一起讨论有意义的C++知识点，而不是争吵XX行不行或者YY与ZZ哪个好；\n  <br/>\n  <br/>\n  <br/>\n  26.请看《程序设计实践》，并严格的按照其要求去做；\n  <br/>\n  <br/>\n  <br/>\n  27.不要因为C和C++中有一些语法和关键字看上去相同，就认为它们的意义和作用完全一样；\n  <br/>\n  <br/>\n  <br/>\n  28.C++绝不是所谓的C的“扩充”——如果C++一开始就起名叫Z语言，你一定不会把C和Z语言联系得那么紧密；\n  <br/>\n  <br/>\n  <br/>\n  29.请不要认为学过XX语言再改学C++会有什么问题——你只不过又在学一门全新的语言而已；\n  <br/>\n  <br/>\n  <br/>\n  30.读完了《Inside The C++ Object Model》以后再来认定自己是不是已经学会了C++；\n  <br/>\n  <br/>\n  <br/>\n  31.学习编程的秘诀是：编程，编程，再编程；\n  <br/>\n  <br/>\n  <br/>\n  32.请留意下列书籍：《C++面向对象高效编程（C++ Effective Object-Oriented Software Construction）》《面向对象软件构造(Object-Oriented Software Construction)》《设计模式（Design Patterns）》《The Art of Computer Programming》；\n  <br/>\n  <br/>\n  <br/>\n  34.请把书上的程序例子亲手输入到电脑上实践，即使配套光盘中有源代码；\n  <br/>\n  <br/>\n  <br/>\n  35.把在书中看到的有意义的例子扩充；\n  <br/>\n  <br/>\n  <br/>\n  36.请重视C++中的异常处理技术，并将其切实的运用到自己的程序中；\n  <br/>\n  <br/>\n  <br/>\n  37.经常回顾自己以前写过的程序，并尝试重写，把自己学到的新知识运用进去；\n  <br/>\n  <br/>\n  <br/>\n  38.不要漏掉书中任何一个练习题——请全部做完并记录下解题思路；\n  <br/>\n  <br/>\n  <br/>\n  39.C++语言和C++的集成开发环境要同时学习和掌握；\n  <br/>\n  <br/>\n  <br/>\n  40.既然决定了学C++,就请坚持学下去，因为学习程序设计语言的目的是掌握程序设计技术，而程序设计技术是跨语言的；\n  <br/>\n  <br/>\n  <br/>\n  41.就让C++语言的各种平台和开发环境去激烈的竞争吧，我们要以学习C++语言本身为主；\n  <br/>\n  <br/>\n  <br/>\n  42.当你写C++程序写到一半却发现自己用的方法很拙劣时，请不要马上停手；请尽快将余下的部分粗略的完成以保证这个设计的完整性，然后分析自己的错误并重新设计和编写（参见43）；\n  <br/>\n  <br/>\n  <br/>\n  43.别心急，设计C++的class确实不容易；自己程序中的class和自己的class设计水平是在不断的编程实践中完善和发展的；\n  <br/>\n  <br/>\n  <br/>\n  44.决不要因为程序“很小”就不遵循某些你不熟练的规则——好习惯是培养出来的，而不是一次记住的；\n  <br/>\n  <br/>\n  <br/>\n  45.每学到一个C++难点的时候，尝试着对别人讲解这个知识点并让他理解——你能讲清楚才说明你真的理解了；\n  <br/>\n  <br/>\n  <br/>\n  46.记录下在和别人交流时发现的自己忽视或不理解的知识点；\n  <br/>\n  <br/>\n  <br/>\n  47.请不断的对自己写的程序提出更高的要求,哪怕你的程序版本号会变成Version 100.XX；\n  <br/>\n  <br/>\n  <br/>\n  48.保存好你写过的所有的程序——那是你最好的积累之一；\n  <br/>\n  <br/>\n  <br/>\n  49.请不要做浮躁的人；\n  <br/>\n  <br/>\n  <br/>\n  50.请热爱C++!\n  <br/>\n  <br/>\n  <br/>\n  第四部分：\n  <br/>\n  <br/>\n  <br/>\n  C++头文件一览\n  <br/>\n  C、传统 C++\n  <br/>\n  <br/>\n  <br/>\n  #include &lt;assert.h&gt;　　　　设定插入点\n  <br/>\n  #include &lt;ctype.h&gt;　　　　字符处理\n  <br/>\n  #include &lt;errno.h&gt;　　　　 定义错误码\n  <br/>\n  #include &lt;float.h&gt;　　　　浮点数处理\n  <br/>\n  #include &lt;fstream.h&gt;　　　文件输入／输出\n  <br/>\n  #include &lt;iomanip.h&gt;　　　 参数化输入／输出\n  <br/>\n  #include &lt;iostream.h&gt;　　　数据流输入／输出\n  <br/>\n  #include &lt;limits.h&gt;　　　　定义各种数据类型最值常量\n  <br/>\n  #include &lt;locale.h&gt;　　　　定义本地化函数\n  <br/>\n  #include &lt;math.h&gt;　　　　　定义数学函数\n  <br/>\n  #include &lt;stdio.h&gt;　　　　定义输入／输出函数\n  <br/>\n  #include &lt;stdlib.h&gt;　　　　定义杂项函数及内存分配函数\n  <br/>\n  #include &lt;string.h&gt;　　　　字符串处理\n  <br/>\n  #include &lt;strstrea.h&gt;　　　基于数组的输入／输出\n  <br/>\n  #include &lt;time.h&gt;　　　　　定义关于时间的函数\n  <br/>\n  #include &lt;wchar.h&gt;　　　　 宽字符处理及输入／输出\n  <br/>\n  #include &lt;wctype.h&gt;　　　　宽字符分类\n  <br/>\n  <br/>\n  <br/>\n  标准 C++\n  <br/>\n  <br/>\n  <br/>\n  #include &lt;algorithm&gt;　　　  通用算法\n  <br/>\n  #include &lt;bitset&gt;　　　　　 位集容器\n  <br/>\n  #include &lt;cctype&gt;\n  <br/>\n  #include &lt;cerrno&gt;\n  <br/>\n  #include &lt;clocale&gt;\n  <br/>\n  #include &lt;cmath&gt;\n  <br/>\n  #include &lt;complex&gt;　　　　 复数类\n  <br/>\n  #include &lt;cstdio&gt;\n  <br/>\n  #include &lt;cstdlib&gt;\n  <br/>\n  #include &lt;cstring&gt;\n  <br/>\n  #include &lt;ctime&gt;\n  <br/>\n  #include &lt;deque&gt;　　　　　 双端队列容器\n  <br/>\n  #include &lt;exception&gt;　　　 异常处理类\n  <br/>\n  #include &lt;fstream&gt;\n  <br/>\n  #include &lt;functional&gt;　　　 定义运算函数（代替运算符）\n  <br/>\n  #include &lt;limits&gt;\n  <br/>\n  #include &lt;list&gt;　　　　　　 线性列表容器\n  <br/>\n  #include &lt;map&gt;　　　　　　 映射容器\n  <br/>\n  #include &lt;iomanip&gt;\n  <br/>\n  #include &lt;ios&gt;　　　　　　基本输入／输出支持\n  <br/>\n  #include &lt;iosfwd&gt;　　　　输入／输出系统使用的前置声明\n  <br/>\n  #include &lt;iostream&gt;\n  <br/>\n  #include &lt;istream&gt;　　　　 基本输入流\n  <br/>\n  #include &lt;ostream&gt;　　　　 基本输出流\n  <br/>\n  #include &lt;queue&gt;　　　　　  队列容器\n  <br/>\n  #include &lt;set&gt;　　　　　　 集合容器\n  <br/>\n  #include &lt;sstream&gt;　　　　 基于字符串的流\n  <br/>\n  #include &lt;stack&gt;　　　　　 堆栈容器\n  <br/>\n  #include &lt;stdexcept&gt;　　　 标准异常类\n  <br/>\n  #include &lt;streambuf&gt;　　　底层输入／输出支持\n  <br/>\n  #include &lt;string&gt;　　　　　字符串类\n  <br/>\n  #include &lt;utility&gt;　　　　 通用模板类\n  <br/>\n  #include &lt;vector&gt;　　　　 动态数组容器\n  <br/>\n  #include &lt;cwchar&gt;\n  <br/>\n  #include &lt;cwctype&gt;\n  <br/>\n  <br/>\n  <br/>\n  C99 增加\n  <br/>\n  <br/>\n  <br/>\n  #include &lt;complex.h&gt;　　复数处理\n  <br/>\n  #include &lt;fenv.h&gt;　　　　浮点环境\n  <br/>\n  #include &lt;inttypes.h&gt;　　整数格式转换\n  <br/>\n  #include &lt;stdbool.h&gt;　　 布尔环境\n  <br/>\n  #include &lt;stdint.h&gt;　　　整型环境\n  <br/>\n  #include &lt;tgmath.h&gt;　　通用类型数学宏\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  25.流式输入输出常用的函数\n  <br/>\n  cout.put()将单个字符插入到缓存中，可以实现连续的插入\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout.put(65).put(78).put(45)&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  cout.write(字符串首地址,输出长度)将字符串整体输出或者输出字符串的部分内容\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char a[]=\'lantian\';\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout.write(a,7)&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout.write(a+1,6);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  26.C++缓存和流式输入输出\n  <br/>\n  实际上，在内存中为每一个数据流开辟一个内存缓冲区，用来存放流中的数据。当用cout和插入运算符“&lt;&lt;”向显示器输出数据时，先将这些数据送到程序中的输出缓冲区保存，直到缓冲区满了或遇到endl，就将缓冲区中的全部数据送到显示器显示出来。在输入时，从键盘输入的数据先放在键盘缓冲区中，当按回车键时，键盘缓冲区中的数据输入到程序中的输入缓冲区，形成cin流，然后用提取运算符“&gt;&gt;”从输入缓冲区中提取数据送给程序中的有关变量。总之，流是与内存缓冲区相对应的，或者说，缓冲区中的数据就是流。\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  27.文件读取和写入实例\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  #include\'cstdlib\'\n  <br/>\n  #include\'fstream\'\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  struct node\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char name[20];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char sex[10];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int age;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  typedef struct node p;\n  <br/>\n  <br/>\n  <br/>\n  p student[3]={\'lantian\',\'man\',19,\'baba\',\'man\',45,\'mama\',\'woman\',46};\n  <br/>\n  p stud;\n  <br/>\n  <br/>\n  <br/>\n  ostream&amp; operator&lt;&lt;(ostream&amp; out,p stu)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  out&lt;&lt;stu.name&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  out&lt;&lt;stu.sex&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  out&lt;&lt;stu.age&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return out;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ofstream outfile(\'student.txt\',ios::trunc);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=0;i&lt;=2;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  outfile.write((char*)&amp;student[i],sizeof(student[i]));\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  outfile.close();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ifstream infile(\'student.txt\',ios::in);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=0;i&lt;=2;i++)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  infile.read((char*)&amp;stud,sizeof(stud));\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;stud&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  infile.close();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  27.对于二进制文件的重要应用函数，指针转移函数\n  <br/>\n  输入：seekg(偏移量，正代表向右，负代表向左,ios::beg(指针移到起点)//ios::cur(指针在原处)//ios::end(指针在终点))\n  <br/>\n  tellg()\n  <br/>\n  输出：seekp()同上\n  <br/>\n  tellp()\n  <br/>\n  <br/>\n  <br/>\n  28.文件读取综合实例\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  #include\'fstream\'\n  <br/>\n  #include\'cstdlib\'\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  struct node\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char name[20];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char sex[10];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int age;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  typedef struct node point;\n  <br/>\n  point student[3]={\'lantian\',\'man\',19,\'mama\',\'woman\',46,\'baba\',\'man\',45};\n  <br/>\n  point stud[2];\n  <br/>\n  point k;\n  <br/>\n  <br/>\n  <br/>\n  ostream&amp; operator&lt;&lt;(ostream&amp; out,point k)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;k.name&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;k.sex&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;k.age&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return out;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  fstream iofile(\'student.txt\',ios::in|ios::out|ios::trunc|ios::binary);\n  <br/>\n  if(!iofile)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cerr&lt;&lt;\'error!\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  exit(0);\n  <br/>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=0;i&lt;=2;i++)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  iofile.write((char*)&amp;student[i],sizeof(student[i]));\n  <br/>\n  }\n  <br/>\n  for(int i=0;i&lt;=2;i++)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  iofile.seekg(0,ios::beg);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  iofile.read((char*)&amp;k,sizeof(k));\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;k&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  cout&lt;&lt;\'***********************\'&lt;&lt;endl;\n  <br/>\n  iofile.seekg(0,ios::beg);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  for(int i=0,t=0;i&lt;=2;i=i+2,t++)\n  <br/>\n  {\n  <br/>\n  iofile.seekg(i*sizeof(k),ios::beg);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  iofile.read((char*)&amp;stud[t],sizeof(k));\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;stud[t]&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'begin to change!\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin&gt;&gt;stud[t].name&gt;&gt;stud[t].sex&gt;&gt;stud[t].age;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  iofile.seekp(i*sizeof(k),ios::beg);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  iofile.write((char*)&amp;stud[t],sizeof(k));\n  <br/>\n  }\n  <br/>\n  iofile.seekg(0,ios::beg);\n  <br/>\n  for(int i=0;i&lt;=2;i++)\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  iofile.read((char*)&amp;k,sizeof(k));\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;k&lt;&lt;endl;\n  <br/>\n  }\n  <br/>\n  iofile.close();\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  27.流式输入\n  <br/>\n  ch=cin.get()从输入流中获取一个字符，返回值是读入的字符，文件结束返回EOF\n  <br/>\n  cin.get(char (&amp;(可有可无))ch)将从流中提取的字符赋值给指定的字符变量\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  char a[20];\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cin.get(a,5,\'x\');    //读取5-1个字符，x为结束标志，如果扫描到x提前读入结束\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;a&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  cin.getline(char *buf,int limit,deline=\'\n\'(默认的结束符))   与上面的类似，读取一行的内容\n  <br/>\n  cin.read(char *buf,int size)   //向指定的内容中输入固定数目的内容\n  <br/>\n  <br/>\n  <br/>\n  cin.eof()文件判空\n  <br/>\n  cin.peek()检查该字符的下一个字符，但是注意指针并没有移动，只是检查下一个字符，指针仍停留在当前字符处\n  <br/>\n  cin.putback(ch)将字符ch重新插入到缓冲区的指针位置\n  <br/>\n  cin.ignore(int n=1,char ch=EOF) 等号是默认字符和值的意思，在没有函数的参数的时候，应用默认值，否则应用函数的参数的值，代表跳过n个字符或者知道遇到ch字符的时候，提起包括ch字符都跳过（此跳过值得是指针的移动）\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  28.\n  <br/>\n  try-catch语句的调用规则，如果在同一函数中的话，直接找本函数，如果本函数没，返回他的调用层继续找，知道最后还没有找到的话，返回程序报错异常处理机制\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  29.析构函数和异常处理\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  class aa\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  aa()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'construct\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ~aa()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'destruct\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void setdata(int k)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(k&gt;=100) throw k;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=k;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'change successfully\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int a;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  aa wa;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  try\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  wa.setdata(111);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  catch(int d)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'error!\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'throw:\'&lt;&lt;d&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  #include\'iostream\'\n  <br/>\n  #include\'cstdio\'\n  <br/>\n  <br/>\n  <br/>\n  using namespace std;\n  <br/>\n  <br/>\n  <br/>\n  class aa\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  public:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  aa()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=0;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'construct\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  ~aa()\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'destruct\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  void setdata(int k)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  if(k&gt;=100) throw k;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  a=k;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'change successfully\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  private:\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  int a;\n  <br/>\n  };\n  <br/>\n  <br/>\n  <br/>\n  int main()\n  <br/>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  try\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  aa wa;     //如果类对象是在try语句块中进行定义的，那么在出现异常情况的时候，立即离开try语句块（如果是函数且对象在try内定义，那么立即进入catch语句块进行一场处理）\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  wa.setdata(111);\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  catch(int d)\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  {\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'error!\'&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  cout&lt;&lt;\'throw:\'&lt;&lt;d&lt;&lt;endl;\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  }\n  <br/>\n  <span style=\'white-space:pre\'>\n  </span>\n  return 0;\n  <br/>\n  }\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  简而言之，只要try语句块中出现了对对象的声明的话，只要出现了一场（只要开始throw）必须要调用先调用析构函数然后再转入catch语句块中进行一场处理\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  30.\n  <br/>\n  在符合继承关系中要小心这么一种情况\n  <br/>\n  base1\n  <br/>\n  base2        base3\n  <br/>\n  base4\n  <br/>\n  base2，3分别从base1中继承，而base4从base2和base3中继承，这时候在base4的构建时\n  <br/>\n  我们先调用base1的构造函数在调用base2，3的构造函数，最后调用base4的构造函数，所以如果base4中没有对base1进行初始化操作，那么会导致base1先调用默认的构造函数，在调用base2，base3的构造函数，但是base2，3中的构造函数会先调用base1的构造函数，这时候和之前就会出现矛盾，所以我们规定，在这种情况的时候base4中也要写出base1的构造函数的调用语句\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  <br/>\n  31.\n  <br/>\n  私有成员\n  <br/>\n  1.在基类的作用域中私有始终是私有，其他的类型变量也都不会改变属性\n  <br/>\n  2.在派生类的作用域中基类的私有是不可访问\n  <br/>\n  3.但是，我们可以通过基类的公有函数作为接口来间接的调用所谓的不可访问变量\n  <br/>\n  再者，对于私有继承\n  <br/>\n  虽然基类的共有函数变成派生类中的私有函数，但是派生类中的共有函数可以调用私有成员，并且在基类的作用域中，共有函数还是公有，还是可以调用私有成员变量的，所以，这种情况下我门还是可以以基类的共有函数做接口调用到在派生类中视为不可访问变量的私有成员\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('42138e54874de4fe9a8fccb7da3b2703','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  最大二分图匹配  邻接表优化\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   我们利用邻接表虽然牺牲了部分的空间，但是我们换取了，在二分图查找出边的操作，可以降低算法的复杂度\n  </p>\n  <p>\n   下面我们在代码中进行解析\n  </p>\n  <p>\n   #include\'iostream\'\n   <br/>\n   #include\'cstdio\'\n   <br/>\n   <br/>\n   <br/>\n   using namespace std;\n   <br/>\n   <br/>\n   <br/>\n   int u[100];\n   <br/>\n   int v[100];\n   <br/>\n   int w[100];\n   <br/>\n   int first[100];\n   <br/>\n   int next[100];\n   <br/>\n   int match[100];\n   <br/>\n   int book[100];\n   <br/>\n   int n,m;\n   <br/>\n   int x,y;\n   <br/>\n   <br/>\n   <br/>\n   int dfs(int u)\n   <br/>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   int k;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   k=first[u];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   while(k!=-1)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(book[v[k]]==0)                      //省略了我们查边的操作\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   book[v[k]]=1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(match[v[k]]==0||dfs(match[v[k]]))\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   match[v[k]]=u;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   match[u]=v[k];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   k=next[k];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 0;\n   <br/>\n   }\n   <br/>\n   <br/>\n   <br/>\n   int main()\n   <br/>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   int sum=0;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;n&gt;&gt;m;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)                          //邻接表初始化\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   first[i]=-1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;x&gt;&gt;y;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   u[i]=x;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   v[i]=y;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   w[i]=1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=m+1;i&lt;=2*m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   u[i]=v[i-m];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   v[i]=u[i-m];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   w[i]=w[i-m];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=2*m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   next[i]=first[u[i]];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   first[u[i]]=i;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }                                                      //邻接表对变的保存完成\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   memset(book,0,sizeof(book));\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(dfs(i))\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   sum++;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cout&lt;&lt;sum&lt;&lt;endl;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 0;\n   <br/>\n   }\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('218cc79b7919eb44b8eba304e8378bf1','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  二分图的最大匹配\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   二分图的最大匹配算法的核心在于扩展增广路，每次只有两个选择，如果当前查找的点没有匹配，那么直接匹配成功\n  </p>\n  <p>\n   否则我们再来看是否我们可以对这个已经匹配的点的已匹配的点的其他出边在进行匹配，使得我们当前这个新的点可以成为被匹配的点，那么\n  </p>\n  <p>\n   我们很容易就可以得到一条新的增广路（匹配的边），那么匹配的边数就加一，直到所有的边我们都已经扫描完毕，此时得到的已匹配的边数就是二分图的最大匹配数\n  </p>\n  <p>\n   其他细节我们在下面的代码中进行解析\n  </p>\n  <p>\n   #include\'iostream\'\n   <br/>\n   #include\'cstdio\'\n   <br/>\n   <br/>\n   <br/>\n   using namespace std;\n   <br/>\n   <br/>\n   <br/>\n   int map[100][100];\n   <br/>\n   int book[100];                        //记录我们在对每个点进行扫描的时候，记录已经被我们访问到的点的\n   <br/>\n   int match[100];                     //记录匹配关系，最终我们的所有的匹配关系都保存在match数组里面\n   <br/>\n   int n,m;\n   <br/>\n   int x,y;\n   <br/>\n   <br/>\n   <br/>\n   int dfs(int u)\n   <br/>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)            //对每一个点进行访问判断\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(book[i]==0&amp;&amp;map[u][i]==1)                      //如果当前的点没有被访问过，并且与其有边\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   book[i]=1;                                //我们将该点进行标记，以防止下一次遇到\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(match[i]==0||dfs(match[i]))                               //两个选择，如果没有匹配，直接匹配成功，如果已经被匹配了，我们以其被匹配的另一个点为源头再次进行增广路的判断，看看是否还可以与其他的点形成匹配，从而腾空当前的i点和u点进行匹配\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   match[i]=u;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   match[u]=i;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 0;\n   <br/>\n   }\n   <br/>\n   <br/>\n   <br/>\n   int main()\n   <br/>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   int sum=0;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;n&gt;&gt;m;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;x&gt;&gt;y;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   map[x][y]=map[y][x]=1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   memset(book,0,sizeof(book));              //我们每次扫描完一个点我们就要重新将book数组重新清零\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(dfs(i))                       //如果我们成功找到了增广路，数值加一\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   sum++;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cout&lt;&lt;sum&lt;&lt;endl;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 0;\n   <br/>\n   }\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('32c0a17d888e6bfb5e9a50831f90d41a','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  寻找图的最少割边的算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  寻找图的最少割边的算法\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('78b1316b0e33e35bfe43031e89134efd','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  图的割边（有缺陷的算法）\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   本算法只能求割一次的情况，如果要求最少的割边次数，本算法毫无用武之地\n  </p>\n  <p>\n   下面是代码段\n  </p>\n  <p>\n   #include\'iostream\'\n   <br/>\n   #include\'cstdio\'\n   <br/>\n   <br/>\n   <br/>\n   using namespace std;\n   <br/>\n   <br/>\n   <br/>\n   int u[100];\n   <br/>\n   int v[100];\n   <br/>\n   int w[100];\n   <br/>\n   int first[100];\n   <br/>\n   int next[100];\n   <br/>\n   int n,m;\n   <br/>\n   int x,y;\n   <br/>\n   int index=0;\n   <br/>\n   int root=1;\n   <br/>\n   int num[100];\n   <br/>\n   int low[100];\n   <br/>\n   <br/>\n   <br/>\n   void dfs(int cur,int father)\n   <br/>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   int child=0;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   int k=first[cur];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   index++;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   num[cur]=low[cur]=index;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   while(k!=-1)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(num[v[k]]==0)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   child++;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   dfs(v[k],cur);\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   low[cur]=min(low[cur],low[v[k]]);\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(cur!=root&amp;&amp;low[v[k]]&gt;num[cur])                                   //相对于割点的算法而言，这个算法的唯一区别就是low[v[k]&gt;num[cur],没有等于号，代表这个点存在不能回到父亲和祖先的所有情况，所以只能是割边了\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   printf(\'%d--%d\n\',cur,v[k]);\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(cur==root&amp;&amp;child&gt;=2)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   printf(\'%d--%d\n\',root,cur);\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   else\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   if(v[k]!=father)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   low[cur]=min(low[cur],num[v[k]]);\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   k=next[k];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   }\n   <br/>\n   <br/>\n   <br/>\n   int main()\n   <br/>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;n&gt;&gt;m;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=n;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   first[i]=-1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   cin&gt;&gt;x&gt;&gt;y;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   u[i]=x;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   v[i]=y;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   w[i]=1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=m+1;i&lt;=2*m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   u[i]=v[i-m];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   v[i]=u[i-m];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   w[i]=w[i-m];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   for(int i=1;i&lt;=2*m;i++)\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   {\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   next[i]=first[u[i]];\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   first[u[i]]=i;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   }\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   root=1;\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   dfs(1,root);\n   <br/>\n   <span style=\'white-space:pre\'>\n   </span>\n   return 0;\n   <br/>\n   }\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('605204b93bc6d2ed3b9e5b072628e220','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题目：\n    <a href=\'https://www.hackerrank.com/challenges/predicting-office-space-price\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      https://www.hackerrank.com/challenges/predicting-office-space-price\n     </span>\n    </a>\n   </strong>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    分析：\n   </strong>\n   还是上次的房价预测题目，指明要用多项式回归拟合。在多元多项式拟合时候，目标函数表示如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150528162348149\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   对其目标函数求偏导得到\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150528162759476\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   很容易写出代码。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    代码：\n   </strong>\n  </span>\n </p>\n <pre class=\'python\' code_snippet_id=\'678116\' name=\'code\' snippet_file_name=\'blog_20150528_1_9129150\'>#coding:utf-8\n\nimport math\n\nclass Data:\n	def __init__(self):\n		self.x = []\n		self.y = 0.0\n\ndef makeMatrix(row, col, fill = 0.0):\n	mat = []\n	for i in range(row):\n		mat.append([fill] * col)\n	return mat\n\ndef WX(d, w, b):\n	res = 0.0\n	for k in range(len(d.x)):\n		for j in range(b + 1):\n			res += w[k][j] * math.pow(d.x[k], j)\n	return res\n\ndef Gradient(d, w, f, b, alpha):\n	for k in range(f):\n		for j in range(b + 1):\n			t1, t2 = 0.0, 0.0\n			for i in range(len(d)):\n				t1 += (WX(d[i], w, b) - d[i].y) * math.pow(d[i].x[k], j)\n			w[k][j] -= alpha * t1\n\ndef getValues(d, w, b):\n	res = 0.0\n	for i in range(len(d)):\n		tmp = WX(d[i], w, b)\n		res += 0.5 * (d[i].y - tmp) * (d[i].y - tmp)\n	return res\n\ndef Iterator(d, w, f, b):\n	alpha = 0.003\n	delta = 0.5\n	oldVal = getValues(d, w, b)\n	Gradient(d, w, f, b, alpha)\n	newVal = getValues(d, w, b)\n	while abs(oldVal - newVal) &gt; delta:\n		oldVal = newVal\n		Gradient(d, w, f, b, alpha)\n		newVal = getValues(d, w, b)\n\ndef main():\n	while True:\n		try:\n			F, N = map(int, raw_input().split())\n			d = []\n			b = 5\n			w = makeMatrix(F, b + 1)\n			for i in range(0, N):\n				t = Data()\n				t.x = map(float, raw_input().split())\n				t.y = t.x.pop()\n				d.append(t)\n			Iterator(d, w, F, b)\n			N = int(raw_input())\n			for i in range(0, N):\n				t = Data()\n				t.x = map(float, raw_input().split())\n				print \'%.2f\'% WX(t, w, b)\n		except EOFError:\n			break\n\nif __name__ == \'__main__\':\n	main()\n</pre>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   不过，上述代码得到的结果偏差比较大，需要重新考虑。除了上述方式外，还有一种特征组合方法效果不错。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    代码：\n   </strong>\n  </span>\n </p>\n <pre class=\'cpp\' code_snippet_id=\'678116\' name=\'code\' snippet_file_name=\'blog_20150528_2_9885367\'>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;fstream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;vector&gt;\n \n#define Vector vector\nusing namespace std;\n \nstruct Data\n{\n    Vector&lt;double&gt; x;\n    double y;\n};\n\ndouble WX(const Data&amp; d, const Vector&lt;double&gt;&amp; w)\n{\n    double ans = 0;\n    for(int i = 0; i &lt; w.size(); i++)\n        ans += w[i] * d.x[i];\n    return ans;\n}\n\nvoid Gradient(const Vector&lt;Data&gt;&amp; d, Vector&lt;double&gt; &amp;w, double alpha)\n{\n    for(int i = 0; i &lt; w.size(); i++)\n    {\n        double tmp = 0;\n        for(int j = 0; j &lt; d.size(); j++)\n			tmp += alpha * d[j].x[i] * (WX(d[j], w) - d[j].y);\n        w[i] -= tmp;\n    }\n}\n\ndouble getValues(const Vector&lt;Data&gt;&amp; d, Vector&lt;double&gt; w)\n{\n	double res = 0;\n	for(int i = 0; i &lt; d.size(); i++)\n	{\n		double tmp = WX(d[i], w);\n		res += fabs(d[i].y - tmp);\n	}\n	return res;\n}\n\nvoid Iterator(const Vector&lt;Data&gt;&amp; d, Vector&lt;double&gt; &amp;w)\n{\n	double alpha = 0.3 / d.size();\n	double delta = 0.5;\n	double oldVal = getValues(d, w);  \n	Gradient(d, w, alpha);  \n	double newVal = getValues(d, w); \n	while(fabs(oldVal - newVal) &gt; delta)\n	{\n		oldVal = newVal;\n		Gradient(d, w, alpha);\n		newVal = getValues(d, w);\n	}\n}\n\nVector&lt;double&gt; getFeatures(Vector&lt;double&gt; x)\n{\n	Vector&lt;double&gt; res;\n	int n = x.size();\n	for(int i = 0; i &lt; n; i++)\n		for(int j = i; j &lt; n; j++)\n			for(int k = j; k &lt; n; k++)\n				res.push_back(x[i] * x[j] * x[k]);\n	return res;\n}\n \nint main()\n{\n	int F, N;\n    Vector&lt;double&gt; w;\n    Vector&lt;Data&gt; d;\n    while(scanf(\'%d %d\', &amp;F, &amp;N) != EOF)\n	{\n		d.clear();\n		w.clear();\n		int features = 0;\n        for(int i = 0; i &lt; N; i++)\n		{\n			Data t;\n			double _x, _y;\n			t.x.push_back(1);\n			for(int j = 1; j &lt;= F; j++)\n			{\n				scanf(\'%lf\', &amp;_x);\n				t.x.push_back(_x);\n			}\n			t.x = getFeatures(t.x);\n			features = t.x.size();\n			scanf(\'%lf\', &amp;_y);\n			t.y = _y;\n			d.push_back(t);\n		}\n		for(int i = 0; i &lt; features; i++)\n			w.push_back(0);\n		Iterator(d, w);\n		d.clear();\n		scanf(\'%d\', &amp;N);\n		for(int i = 0; i &lt; N; i++)\n		{\n			Data t;\n			double _x;\n			t.x.push_back(1);\n			for(int j = 1; j &lt;= F; j++)\n			{\n				scanf(\'%lf\', &amp;_x);\n				t.x.push_back(_x);\n			}\n			t.x = getFeatures(t.x);\n			printf(\'%.2lf\n\', WX(t, w));\n		}\n	}\n    return 0;\n}\n</pre>\n <p>\n  <br/>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   另外利用Python的机器学习开源库sklearn很方便处理。具体可以参考如下链接。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题解：\n   </strong>\n   <a href=\'http://blog.guozengxin.cn/2015/01/08/hackerrank-predicting-office-space-price/\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://blog.guozengxin.cn/2015/01/08/hackerrank-predicting-office-space-price/\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    sklearn官网：\n   </strong>\n   <a href=\'http://scikit-learn.org/stable/\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://scikit-learn.org/stable/\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    sklearn源代码：\n   </strong>\n   <a href=\'https://github.com/scikit-learn/scikit-learn/\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      https://github.com/scikit-learn/scikit-learn/\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n</div>\n</body></html>'),('41b3f8acb0cad8220c5af12f8be9d72e','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   从今天开始要多做一些关于机器学习方面的竞赛题目，题目来源主要是\n   <strong>\n    Hackerrank\n   </strong>\n   和\n   <strong>\n    Kaggle\n   </strong>\n   。链接如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    Hackerrank：\n   </strong>\n   <a href=\'https://www.hackerrank.com/\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      https://www.hackerrank.com/\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    Kaggle：\n   </strong>\n   <a href=\'https://www.kaggle.com/\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      https://www.kaggle.com/\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   在Hackerrank中提交源代码，这就使得很多库都需要自己写，限制比较多。而Kaggle只需要提交数据，所以随便怎么搞都行。现在来讲第一道题，房价预测，这是Andrew Ng课程里的比较经典的例子。题目描述如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题目：\n    <a href=\'https://www.hackerrank.com/challenges/predicting-house-prices\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      https://www.hackerrank.com/challenges/predicting-house-prices\n     </span>\n    </a>\n   </strong>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    分析：\n   </strong>\n   比较简单，用梯度下降法即可。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    代码：\n   </strong>\n  </span>\n </p>\n <pre class=\'python\' code_snippet_id=\'1953483\' name=\'code\' snippet_file_name=\'blog_20161028_1_3252483\'>#coding:utf-8\n\nclass Data:\n	def __init__(self):\n		self.x = []\n		self.y = 0.0\n\ndef WX(d, w):\n	ans = 0.0\n	for i in range(0, len(w)):\n		ans += w[i] * d.x[i]\n	return ans\n\ndef Gradient(d, w, alpha):\n	for i in range(0, len(w)):\n		tmp = 0.0\n		for j in range(0, len(d)):\n			tmp += alpha * d[j].x[i] * (WX(d[j], w) - d[j].y)\n		w[i] -= tmp\n\ndef getValues(d, w):\n	res = 0.0\n	for i in range(0, len(d)):\n		tmp = WX(d[i], w)\n		res += (d[i].y - tmp) * (d[i].y - tmp)\n	return res\n\ndef Iterator(d, w):\n	alpha = 0.005\n	delta = 0.000001\n	oldVal = getValues(d, w)\n	Gradient(d, w, alpha)\n	newVal = getValues(d, w)\n	while abs(oldVal - newVal) &gt; delta:\n		oldVal = newVal\n		Gradient(d, w, alpha)\n		newVal = getValues(d, w)\n\ndef main():\n	while True:\n		try:\n			d = []\n			w = []\n			F, N = map(int, raw_input().split())\n			for i in range(0, N):\n				t = Data()\n				t.x = map(float, raw_input().split())\n				t.x.insert(0, 1.0)\n				t.y = t.x.pop()\n				d.append(t)\n			for i in range(0, F + 1):\n				w.append(0)\n			Iterator(d, w)\n			N = int(raw_input())\n			for i in range(0, N):\n				t = Data()\n				t.x = map(float, raw_input().split())\n				t.x.insert(0, 1.0)\n				print \'%.2f\'% WX(t, w)\n		except EOFError:\n			break\n\nif __name__ == \'__main__\':\n	main()\n</pre>\n <p>\n  <br/>\n </p>\n</div>\n</body></html>'),('2eb43c3df59f66b0c87c7ea08716bfa5','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   今天来讲的是在欧拉工程上的一道递推题，题目描述如下链接。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题目：\n   </strong>\n   <a href=\'https://projecteuler.net/problem=492\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      https://projecteuler.net/problem=492\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   当然，这道题在51Nod上有一个比较通用的版本，链接如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题目：\n   </strong>\n   <a href=\'http://www.51nod.com/contest/problem.html#!problemId=1361\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://www.51nod.com/contest/problem.html#!problemId=1361\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题意：\n   </strong>\n   给定\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181148492\'/>\n   ，并且有\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181258755\'/>\n   ，给定两个数\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181337131\'/>\n   和\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181408690\'/>\n   ，求\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181506086\'/>\n   的值。其中\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   满足\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181926197\'/>\n   和\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411182001594\'/>\n   ，并且\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181408690\'/>\n   为素数。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    分析：\n   </strong>\n   首先对原递推式进行变换得到\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n    <img alt=\'\' src=\'http://img.blog.csdn.net/20150411182315174\'/>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   那么令\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411182325427\'/>\n   ，继而有\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411182459944\'/>\n   ，而\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411182541366\'/>\n   。\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   到了这里，假设\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411182914178\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   那么我们带入继续递推会发现一个神奇的结论\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183046046\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   其中假设\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183158212\'/>\n   取其中一个解如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183356620\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   那么得到\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183535708\'/>\n   如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183638064\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   好了，到了这里，最直观的做法就是根据上述公式求出\n  </span>\n  <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183535708\'/>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   ，然后会带回去求出\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183932563\'/>\n   即可。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   如果想用二次剩余的方法来做，因为\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411184122718\'/>\n   可能无解，所以不能用这种方法做。看成更一般\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   形式的求解，比如下面\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411184615995\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   那么回忆之前的一篇文章：\n   <a href=\'http://blog.csdn.net/acdreamers/article/details/8994222\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://blog.csdn.net/acdreamers/article/details/8994222\n     </span>\n    </strong>\n   </a>\n   ，重\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   点是\n   <strong>\n    HDU4565\n   </strong>\n   题，这是明显可以构造矩阵的，具体如何构造不再赘述。然后先得到递推式如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411185010233\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   所以最终得到\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411183535708\'/>\n   如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411190553719\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   可以看到矩阵的指数很大，所以需要降小，而这是一个经典的矩阵找寻环节问题。之前有篇文章，如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    链接：\n   </strong>\n   <a href=\'http://blog.csdn.net/acdreamers/article/details/25616461\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://blog.csdn.net/acdreamers/article/details/25616461\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   当时那道题由于要求最小的循环节，所以要求比较精确，必须枚举因子。但是对于本题不同，我们只要能\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   求出一个合理的\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   循环节即可，不要求最小的，因为不影响最终结果。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   参照当时的结论，由于117不是素数，所以只有两种情况。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （1）如果117是\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181408690\'/>\n   的二次剩余时，最小循环节是\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411191324969\'/>\n   的因子，我们可以取\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411191324969\'/>\n   作为循环节。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （2）如果117是\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411181408690\'/>\n   的二次非剩余时，最小循环节是\n  </span>\n  <img alt=\'\' src=\'http://img.blog.csdn.net/20150411191625396\'/>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   的因子，可以取\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411191625396\'/>\n   作\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   为循环节。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   到了这里大部分问题都已经解决。实际上当117是\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411202154887\'/>\n   的二次非剩余时，循环节可以为\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411202347226\'/>\n   ，至于为什么是\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   正确的，请来个大神证明！ 另外\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150411202612056\'/>\n   为2或者3时，需要特判。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    代码：\n   </strong>\n  </span>\n </p>\n <pre class=\'cpp\' code_snippet_id=\'641438\' name=\'code\' snippet_file_name=\'blog_20150411_1_6824118\'>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;math.h&gt;\n\nusing namespace std;\ntypedef long long LL;\n\nconst int N = 2;\n\nstruct Matrix\n{\n    LL m[N][N];\n};\n\nMatrix I =\n{\n    1, 0,\n    0, 1\n};\n\nLL quick_mod(LL a, LL b, LL m)\n{\n	LL ans = 1;\n	a %= m;\n	while(b)\n	{\n		if(b &amp; 1)\n		{\n			ans = ans * a % m;\n			b--;\n		}\n		b &gt;&gt;= 1;\n		a = a * a % m;\n	}\n	return ans;\n}\n\nLL Legendre(LL a, LL p)  \n{  \n    LL t = quick_mod(a, (p - 1) &gt;&gt; 1, p);  \n    if(t == 1) return 1;  \n    return -1;  \n}  \n\nMatrix multi(Matrix a, Matrix b, LL m)\n{\n    Matrix c;\n    for(int i = 0; i &lt; N; i++)\n    {\n        for(int j = 0; j &lt; N; j++)\n        {\n            c.m[i][j] = 0;\n            for(int k = 0; k &lt; N; k++)\n                c.m[i][j] += a.m[i][k] * b.m[k][j] % m;\n            c.m[i][j] %= m;\n        }\n    }\n    return c;\n}\n\nMatrix power(Matrix A, LL k, LL m)\n{\n    Matrix ans = I, p = A;\n    while(k)\n    {\n        if(k &amp; 1)\n        {\n            ans = multi(ans, p, m);\n            k--;\n        }\n        k &gt;&gt;= 1;\n        p = multi(p, p, m);\n    }\n    return ans;\n}\n\nLL GetLoop(LL p)\n{\n	if(Legendre(117, p) == -1)\n		return p + 1;\n	return p - 1;\n}\n\nint main()\n{\n    int T;\n	scanf(\'%d\', &amp;T);\n    while(T--)\n    {\n		LL n, p;\n		scanf(\'%lld %lld\', &amp;n, &amp;p);\n		if(p == 2 || p == 3)\n		{\n			puts(\'1\');\n			continue;\n		}\n		Matrix A;\n        A.m[0][0] = 11 % p;\n		A.m[0][1] = p - 1;\n		A.m[1][0] = 1;\n		A.m[1][1] = 0;\n		LL loop = GetLoop(p);\n        LL x = quick_mod(2, n - 1, loop);\n		x = ((x - 1) % loop + loop) % loop;\n		Matrix ans = power(A, x, p);\n		LL res = (ans.m[1][0] * 119 % p + ans.m[1][1] * 11 % p) % p;\n		res = ((res - 5) % p + p) % p;\n		res = res * quick_mod(6, p - 2, p) % p;\n		printf(\'%lld\n\', res);\n    }\n    return 0;\n}\n</pre>\n <p>\n  <br/>\n </p>\n</div>\n</body></html>'),('5ffb51f5dcb0dc87e1697ffc33b97176','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   今天要讲的主要内容是\n   <strong>\n    协同过滤\n   </strong>\n   ，即Collaborative Filtering，简称\n   <strong>\n    CF\n   </strong>\n   。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:24px; color:#006600\'>\n   <strong>\n    Contents\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    1. 协同过滤的简介\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    2. 协同过滤的核心\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    3. 协同过滤的实现\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    4. 协同过滤的应用\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    1. 协同过滤的简介\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   关于协同过滤的一个最经典的例子\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   就是看电影，有时候不知道哪一部电影是我们喜欢的或者评分比较高的，那\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   么通常\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   的做法就是问问周围的朋友，看看\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   最近有什么好的电影推荐。在问的时候，都习惯于问跟自己口味差不\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   多的朋友，这\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   就是协同过滤的核心思想。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   协同过滤是在海量数据中挖掘出小部分与你品味类似的用户，在协同过滤中，这些用户成为邻居，然后根据他\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   们喜欢\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   的东西组织成一个排序的目录推荐给你。所以就有如下两个核心问题\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （1）如何确定一个用户是否与你有相似的品味？\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （2）如何将邻居们的喜好组织成一个排序目录？\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   协同过滤算法的出现标志着推荐系统的产生，协同过滤算法包括基于用户和基于物品的协同过滤算法。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    2. 协同过滤的核心\n   </strong>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   要实现协同过滤，需要进行如下几个步骤\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （1）收集用户偏好\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （2）找到相似的用户或者物品\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （3）计算并推荐\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    收集用户偏好\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   从用户的行为和偏好中发现规律，并基于此进行推荐，所以如何收集用户的偏好信息成为系统推荐效果最基础\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   的决定因素。用户有很多种方式向系统提供自己的偏好信息，比如：评分，投票，转发，保存书签，购买，点\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   击流，页面停留时间等等。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   以上的用户行为都是通用的，在实际推荐引擎设计中可以自己多添加一些特定的用户行为，并用它们表示用户\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   对物品的喜好程度。\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   通常情况下，在一个推荐系统中，用户行为都会多于一种，那么如何组合这些不同的用户\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   行为呢 ？基本上有如\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   下两种方式\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （1）将不同的行为分组\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   一般可以分为查看和购买，然后基于不同的用户行为，计算不同用户或者物品的相似度。类似与当当网或者\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   亚马逊给出的“购买了该书的人还购买了”，“查看了该书的人还查看了”等等。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （2）不同行为产生的用户喜好对它们进行加权\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   对不同行为产生的用户喜好进行加权，然后求出用户对物品的总体喜好。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   好了，当我们收集好用户的行为数据后，还要对数据进行预处理，最核心的工作就是\n   <strong>\n    减噪\n   </strong>\n   和\n   <strong>\n    归一化\n   </strong>\n   。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    减噪：\n   </strong>\n   因为用户数据在使用过程中可能存在大量噪音和误操作，所以需要过滤掉这些噪音。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    归一化：\n   </strong>\n   不同行为数据的取值相差可能很好，例如用户的查看数据肯定比购买数据大得多。通过归一化，才能\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   使数据更加准确。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   通过上述步骤的处理，就得到了一张二维表，其中一维是用户列表，另一维是商品列表，值是用户对商品的喜\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   好。还是以电影推荐为例，如下表\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150327122314630\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    找到相似的用户或物品\n   </strong>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n   </strong>\n   对用户的行为分析得到用户的喜好后，可以根据用户的喜好计算相似用户和物品，然后可以基于相似用户或物\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   品进行推荐。这就是协同过滤中的两个分支了，基于用户的和基于物品的协同过滤。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   关于相似度的计算有很多种方法，比如常用的余弦夹角，欧几里德距离度量，皮尔逊相关系数等等。而如果采\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   用欧几里德度量，那么可以用如下公式来表示相似度\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150327212205940\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   在计算用户之间的相似度时，是将一个用户对所有物品的偏好作为一个向量，而在计算物品之间的相似度时，\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   是将所有用户对某个物品的偏好作为一个向量。\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   求出相似度后，接下来可以求相似邻居了。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    计算并推荐\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   在上面，我们求出了相邻用户和相邻物品，接下来就应该进行推荐了。当然从这一步开始，分为两方面，分别\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   是基于用户的协同过滤和基于物品的协同过滤。我会分别介绍它们的原理\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （1）基于用户的协同过滤算法\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   在上面求相似邻居的时候，通常是求出TOP K邻居，然后根据邻居的相似度权重以及它们对物品的偏好，\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表进行推荐。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   （2）基于物品的协同过滤算法\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   跟上述的基于用户的协同过滤算法类似，但它从物品本身，而不是用户角度。比如喜欢物品A的用户都喜\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   欢物品C，那么可以知道物品A与物品C的相似度很高，而用户C喜欢物品A，那么可以推断出用户C也可能\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   喜欢物品C。如下图\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150327130918393\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   上面的相似度权重有时候需要加入惩罚因子，举个例子，在日常生活中，我们每个人购买卫生纸的的频率比\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   较高，但是不能说明这些用户的兴趣点相似，但是如果它们都买了照相机，那么就可以大致推出它们都是摄\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   影爱好者。所以像卫生纸这样的物品在计算时，相似度权重需要加上惩罚因子或者干脆直接去掉这类数据。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    适用场景\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   对于一个在线网站，用户的数量往往超过物品的数量，同时物品数据相对稳定，因此计算物品的相似度不但\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   计算量小，同时不必频繁更新。但是这种情况只适用于电子商务类型的网站，像新闻类，博客等这类网站的\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   系统推荐，情况往往是相反的，物品数量是海量的，而且频繁更新。所以从算法复杂度角度来说，两种算法\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   各有优势。关于协同过滤的文章，可以参考这里：\n   <a href=\'http://www.tuicool.com/articles/6vqyYfR\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://www.tuicool.com/articles/6vqyYfR\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    3. 协同过滤的实现\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   上面已经介绍了协同过滤的核心思想，现在就来实战一下吧！ 采用数据集如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    链接：\n   </strong>\n   <a href=\'http://grouplens.org/datasets/movielens/\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://grouplens.org/datasets/movielens/\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   这个数据集是很多用户对各种电影的评分。\n  </span>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   接下来先采用Python实现基于用户的协同过滤算法。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   首先，我们需要以表格形式读取数据，需要用到Texttable第三方包。安装包如下链接\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    链接：\n   </strong>\n   <a href=\'https://pypi.python.org/pypi/texttable/\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      https://pypi.python.org/pypi/texttable/\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   大致用法如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150327170420257\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   更多方法的使用需要参考Textdtable的源文件texttable.py。接下来可以实现协同过滤算法了。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    代码：\n   </strong>\n  </span>\n </p>\n <pre class=\'python\' code_snippet_id=\'631043\' name=\'code\' snippet_file_name=\'blog_20150330_1_835805\'># -*-coding=utf-8 -*-\r\n\r\nimport sys\r\nimport math\r\nfrom texttable import Texttable\r\n\r\n#计算余弦距离\r\ndef getCosDist(user1, user2):\r\n	sum_x = 0.0\r\n	sum_y = 0.0\r\n	sum_xy = 0.0\r\n	for key1 in user1:\r\n		for key2 in user2:\r\n			if key1[0] == key2[0]:\r\n				sum_x += key1[1] * key1[1]\r\n				sum_y += key2[1] * key2[1]\r\n				sum_xy += key1[1] * key2[1]\r\n	if sum_xy == 0.0:\r\n		return 0\r\n	demo = math.sqrt(sum_x * sum_y)\r\n	return sum_xy / demo\r\n\r\n#读取文件，读取以行为单位，每一行是列表里的一个元素\r\ndef readFile(filename):\r\n	contents = []\r\n	f = open(filename, \'r\')\r\n	contents = f.readlines()\r\n	f.close()\r\n	return contents\r\n\r\n#数据格式化为二维数组\r\ndef getRatingInfo(ratings):\r\n	rates = []\r\n	for line in ratings:\r\n		rate = line.split(\'	\')\r\n		rates.append([int(rate[0]), int(rate[1]), int(rate[2])])\r\n	return rates\r\n\r\n#生成用户评分数据结构\r\ndef getUserScoreDataStructure(rates):\r\n	\r\n	#userDict[2]=[(1,5),(4,2)].... 表示用户2对电影1的评分是5，对电影4的评分是2\r\n	userDict = {}\r\n	itemUser = {}\r\n	for k in rates:\r\n		user_rank = (k[1], k[2])\r\n		if k[0] in userDict:\r\n			userDict[k[0]].append(user_rank)\r\n		else:\r\n			userDict[k[0]] = [user_rank]\r\n\r\n		if k[1] in itemUser:\r\n			itemUser[k[1]].append(k[0])\r\n		else:\r\n			itemUser[k[1]] = [k[0]]\r\n	return userDict, itemUser\r\n\r\n#计算与指定用户最相近的邻居\r\ndef getNearestNeighbor(userId, userDict, itemUser):\r\n	neighbors = []\r\n	for item in userDict[userId]:\r\n		for neighbor in itemUser[item[0]]:\r\n			if neighbor != userId and neighbor not in neighbors:\r\n				neighbors.append(neighbor)\r\n	neighbors_dist = []\r\n	for neighbor in neighbors:\r\n		dist = getCosDist(userDict[userId], userDict[neighbor])\r\n		neighbors_dist.append([dist, neighbor])\r\n	neighbors_dist.sort(reverse = True)\r\n	return neighbors_dist\r\n\r\n#使用UserFC进行推荐，输入：文件名,用户ID,邻居数量\r\ndef recommendByUserFC(filename, userId, k = 5):\r\n	\r\n	#读取文件\r\n	contents = readFile(filename)\r\n\r\n	#文件格式数据转化为二维数组\r\n	rates = getRatingInfo(contents)\r\n\r\n	#格式化成字典数据\r\n	userDict, itemUser = getUserScoreDataStructure(rates)\r\n\r\n	#找邻居\r\n	neighbors = getNearestNeighbor(userId, userDict, itemUser)[:5]\r\n\r\n	#建立推荐字典\r\n	recommand_dict = {}\r\n	for neighbor in neighbors:\r\n		neighbor_user_id = neighbor[1]\r\n		movies = userDict[neighbor_user_id]\r\n		for movie in movies:\r\n			if movie[0] not in recommand_dict:\r\n				recommand_dict[movie[0]] = neighbor[0]\r\n			else:\r\n				recommand_dict[movie[0]] += neighbor[0]\r\n\r\n	#建立推荐列表\r\n	recommand_list = []\r\n	for key in recommand_dict:\r\n		recommand_list.append([recommand_dict[key], key])\r\n	recommand_list.sort(reverse = True)\r\n	user_movies = [k[0] for k in userDict[userId]]\r\n	return [k[1] for k in recommand_list], user_movies, itemUser, neighbors\r\n\r\n#获取电影的列表\r\ndef getMovieList(filename):\r\n	contents = readFile(filename)\r\n	movies_info = {}\r\n	for movie in contents:\r\n		single_info = movie.split(\'|\')\r\n		movies_info[int(single_info[0])] = single_info[1:]\r\n	return movies_info\r\n\r\n#从这里开始运行	\r\nif __name__ == \'__main__\':\r\n\r\n	reload(sys)\r\n	sys.setdefaultencoding(\'utf-8\')\r\n	\r\n	#获取所有电影的列表\r\n	movies = getMovieList(\'u.item\')\r\n	recommend_list, user_movie, items_movie, neighbors = recommendByUserFC(\'u.data\', 50, 80)\r\n	neighbors_id=[ i[1] for i in neighbors]\r\n	table = Texttable()\r\n	table.set_deco(Texttable.HEADER)\r\n	table.set_cols_dtype([\'t\', \'t\', \'t\'])\r\n	table.set_cols_align([\'l\', \'l\', \'l\'])\r\n	rows=[]\r\n	rows.append([u\'movie name\',u\'release\', u\'from userid\'])\r\n	for movie_id in recommend_list[:20]:\r\n		from_user=[]\r\n		for user_id in items_movie[movie_id]:\r\n			if user_id in neighbors_id:\r\n				from_user.append(user_id)\r\n		rows.append([movies[movie_id][0],movies[movie_id][1],\'\'])\r\n	table.add_rows(rows)\r\n	print table.draw()\r\n\r\n</pre>\n <p>\n  <br/>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   推荐结果如下\n  </span>\n </p>\n <p>\n  <img alt=\'\' src=\'http://img.blog.csdn.net/20150327222010019\'/>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   接下来再来看一个题目，这个题目是2014年阿里的大数据竞赛题目，描述可以参考如下链接\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题目：\n   </strong>\n   <a href=\'http://102.alibaba.com/competition/addDiscovery/gameIntroduce.htm\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://102.alibaba.com/competition/addDiscovery/gameIntroduce.htm\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    题意：\n   </strong>\n   根据用户在天猫的4个月的行为日志，建立用户的品牌偏好，并预测他们在接下来的一个月内对品牌商品的\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   购买行为。开放的字段类型如下\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20150327225407507\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    解析：\n   </strong>\n   <a href=\'http://www.tuicool.com/articles/AN7Rf2\' target=\'_blank\'>\n    <strong>\n     <span style=\'color:#006600\'>\n      http://www.tuicool.com/articles/AN7Rf2\n     </span>\n    </strong>\n   </a>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   上面的是建立的简单的模型，实际上在天猫，有基于行为簇的用户偏好分析。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n   <strong>\n    协同过滤资料\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px; color:#006600\'>\n   <strong>\n    <a href=\'http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/index.html\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      1. 推荐引擎算法\n     </span>\n    </a>\n   </strong>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n    <span style=\'color:#006600\'>\n    </span>\n    <a href=\'http://www.oschina.net/news/51297/top-10-open-source-recommendation-systems\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      2. 开源推荐引擎框架\n     </span>\n    </a>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n    <span style=\'color:#006600\'>\n    </span>\n    <a href=\'http://blog.163.com/lnhenrylee@126/blog/static/2414832520123269713813/\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      3. 协调过滤介绍\n     </span>\n    </a>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px; color:#006600\'>\n    <a href=\'http://zh.wikipedia.org/wiki/Slope_one\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      4. Slop one\n     </span>\n    </a>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n    <span style=\'color:#006600\'>\n    </span>\n    <a href=\'http://www.doc88.com/p-0774360741317.html\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      5. 基于Map Reduce的协同过滤推荐算法的并行实现\n     </span>\n    </a>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n    <span style=\'color:#006600\'>\n    </span>\n    <a href=\'http://www.doc88.com/p-7148014126505.html\' target=\'_blank\'>\n     <span style=\'color:#006600\'>\n      6. 并行协同过滤推荐模型的研究\n     </span>\n    </a>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px; color:#006600\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px; color:#006600\'>\n   </span>\n  </strong>\n </p>\n</div>\n</body></html>'),('b734649389d73b4c3003d375a698754a','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    KNN算法\n   </strong>\n   是机器学习里面常用的一种分类算法，假设一个样本空间被分为几类，然后给定一个待分类所有的特征数\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   据，通过\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   计算距离该数据的最近的K个样本来判断这个数据属于哪一类。如果距离待分类属性最近的K个类大多数都\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   属于某一个特定的\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   类，那么这个待分类的数据也就属于这个类。\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'line-height:19.5px\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#006600; line-height:27px\'>\n     <span style=\'line-height:36px; font-size:18pt\'>\n      Contents\n     </span>\n    </span>\n   </strong>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     1. KNN算法介绍\n    </span>\n   </strong>\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     2. KNN算法的C++实现\n    </span>\n   </strong>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     1. KNN算法介绍\n    </span>\n   </strong>\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   K Nearest Neighbor算法，简称KNN算法，它是一种比较简单的机器学习算法，它的原理也比较简单。下面用\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   网上最\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   经典的一张图来说明，如下图\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201501/071503127503882.jpg\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   如图所示，假设现在需要对中间绿色的圆进行分类，假设我们寻找距离这个绿色圆最近的3个样本，即K=3，那么\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   可以看\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   出这个绿色圆属于红色三角形所在的类；如果K=5，因为蓝色方框最多，所以此时绿色圆属于蓝色方框所在\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   的类。从而得\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   到当K值取值不同时，得到的分类结果也可能不一样，所以很多时候K值得选取很关键，这就是KNN的\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   核心思想。如果类别\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   个数为偶数，那么K通常会设置为\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   一个奇数；如果类别个数为奇数，K通常设置为偶数，这样就\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   能保证不\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   会有平局的发生。\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    2. KNN算法的C++实现\n   </span>\n  </strong>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在求最邻近的K个样本数据时，可以采用高效的\n   <strong>\n    K-D树\n   </strong>\n   ，以后再详细讲，现在先通过暴力方法求解。代码如下\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    KNN.h\n   </span>\n  </strong>\n </p>\n <pre class=\'cpp\' code_snippet_id=\'628995\' name=\'code\' snippet_file_name=\'blog_20150327_1_6733924\'>#ifndef _KNN_H_\n#define _KNN_H_\n \nclass KNN{\n \npublic:\n    KNN(double **DataSet, int nFeatures, int nSamples);   //获取样本数据集等数据\n    ~KNN();\n    double Predict(double *data, int K);   //根据新的数据预测分类\n \nprivate:\n    void getMeans();      //获取样本属性的均值\n    void getStdDev();     //获取样本属性的标准差，即standard deviation\n    void getNormal();     //对样本数据进行归一化\n    double getDistance(double *x, double *y);  //计算两个样本属性之间的距离\n \nprivate:\n    double **DataSet;     //样本训练数据\n    double *means;        //样本的每一个属性的均值\n    double *stddev;       //样本的每一个属性的标准差\n    int nFeatures;        //每个样本的维度，实际上特征个数为nFeatures - 1\n    int nSamples;         //样本的个数\n};\n \n#endif //_KNN_H_</pre>\n <p style=\'\'>\n  <br/>\n  <span style=\'font-family:Courier New; font-size:18px; color:#000000; line-height:27px\'>\n   <strong>\n    KNN.cpp\n   </strong>\n  </span>\n </p>\n <pre class=\'cpp\' code_snippet_id=\'628995\' name=\'code\' snippet_file_name=\'blog_20150327_2_6271648\'>#include &lt;math.h&gt;\n#include &lt;map&gt;\n \n#include \'KNN.h\'\n \nusing namespace std;\n \nKNN::KNN(double **DataSet, int nFeatures, int nSamples)\n{\n    this-&gt;DataSet = DataSet;\n    this-&gt;nFeatures = nFeatures;\n    this-&gt;nSamples = nSamples;\n \n    getMeans();\n    getStdDev();\n    getNormal();\n}\n \nKNN::~KNN()\n{\n    delete[] means;\n    delete[] stddev;\n}\n \n//获取样本每个特征的均值\nvoid KNN::getMeans()\n{\n    means = new double[nFeatures - 1];\n    for(int i = 0; i &lt; nFeatures - 1; i++)\n    {\n        double ans = 0;\n        for(int j = 0; j &lt; nSamples; j++)\n            ans += DataSet[j][i];\n        means[i] = ans / nSamples;\n    }\n}\n \n//获取样本每个特征的标准差\nvoid KNN::getStdDev()\n{\n    stddev = new double[nFeatures - 1];\n    for(int i = 0; i &lt; nFeatures - 1; i++)\n    {\n        double ans = 0;\n        for(int j = 0; j &lt; nSamples; j++)\n            ans += (DataSet[j][i] - means[i]) * (DataSet[j][i] - means[i]);\n        stddev[i] = sqrt(ans / nSamples);\n    }\n}\n \n//利用Z-score标准化对数据进行归一化\nvoid KNN::getNormal()\n{\n    for(int i = 0; i &lt; nSamples; i++)\n    {\n        for(int j = 0; j &lt; nFeatures - 1; j++)\n            DataSet[i][j] = (DataSet[i][j] - means[i]) / stddev[i];\n    }\n}\n \n//计算两个特征之间的距离，采用欧式距离度量法\ndouble KNN::getDistance(double *x, double *y)\n{\n    double ans = 0;\n    for(int i = 0; i &lt; nFeatures - 1; i++)\n        ans += (x[i] - y[i]) * (x[i] - y[i]);\n    return sqrt(ans);\n}\n \n//对新样本进行分类预测\ndouble KNN::Predict(double *data, int K)\n{\n    //对输入的新数据特征进行归一化\n    for(int i = 0; i &lt; nFeatures - 1; i++)\n        data[i] = (data[i] - means[i]) / stddev[i];\n \n    //存放K邻近的样本下标及距离值\n    map&lt;int, double&gt; kmins;    \n    //寻找距离data的最近的K个样本\n    for(int i = 0; i &lt; nSamples; i++)   \n    {\n        double dist = getDistance(data, DataSet[i]);\n        if(kmins.size() &lt; K)\n            kmins.insert(map&lt;int, double&gt;::value_type(i, dist));\n        else\n        {\n            //指向kmins中当前距离最大元素对应的位置\n            map&lt;int, double&gt;::iterator max = kmins.begin();\n            for(map&lt;int, double&gt;::iterator it = kmins.begin(); it != kmins.end(); it++)\n            {\n                if(it-&gt;second &gt; max-&gt;second)\n                    max = it;\n            }\n            if(dist &lt; max-&gt;second)\n            {\n                kmins.erase(max);\n                kmins.insert(map&lt;int, double&gt;::value_type(i, dist));\n            }\n        }\n    }\n \n    //统计这K个样本分别在分类中出现的次数\n    map&lt;double, int&gt; votes;\n    for(map&lt;int, double&gt;::iterator it = kmins.begin(); it != kmins.end(); it++)\n    {\n        double tmp = DataSet[it-&gt;first][nFeatures - 1];\n        map&lt;double, int&gt;::iterator voteIt = votes.find(tmp);\n        if(voteIt != votes.end())\n            voteIt-&gt;second++;\n        else\n            votes.insert(map&lt;double, int&gt;::value_type(tmp, 1));\n    }\n \n    //计算这K个样本所属最多的类\n    map&lt;double, int&gt;::iterator maxVote = votes.begin();\n    for(map&lt;double, int&gt;::iterator it = votes.begin(); it != votes.end(); it++)\n    {\n        if(it-&gt;second &gt; maxVote-&gt;second)\n            maxVote = it;\n    }\n    data[nFeatures - 1] = maxVote-&gt;first;\n    return maxVote-&gt;first;\n}</pre>\n <p style=\'\'>\n  <br/>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   <strong>\n    main.cpp\n   </strong>\n  </span>\n </p>\n <pre class=\'cpp\' code_snippet_id=\'628995\' name=\'code\' snippet_file_name=\'blog_20150327_3_7369910\'>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n \n#include \'KNN.h\'\n \nusing namespace std;\n \ndouble Array[14][5] = {\n{0, 0, 0, 0, 0},\n{0, 0, 0, 1, 0},\n{1, 0, 0, 0, 1},\n{2, 1, 0, 0, 1},\n{2, 2, 1, 0, 1},\n{2, 2, 1, 1, 0},\n{1, 2, 1, 1, 1},\n{0, 1, 0, 0, 0},\n{0, 2, 1, 0, 1},\n{2, 1, 1, 0, 1},\n{0, 1, 1, 1, 1},\n{1, 1, 0, 1, 1},\n{1, 0, 1, 0, 1},\n{2, 1, 0, 1, 0}\n};\n \nint main()\n{\n    double **DataSet = new double*[14];\n    for(int i = 0; i &lt; 14; i++)\n        DataSet[i] = new double[5];\n \n    for(int i = 0; i &lt; 14; i++)\n        for(int j = 0; j &lt; 5; j++)\n            DataSet[i][j] = Array[i][j];\n    KNN knn(DataSet, 5, 14);\n    double data[5] = {2, 2, 0, 1, 0};\n    cout &lt;&lt; knn.Predict(data, 3) &lt;&lt; endl;\n \n    for(int i = 0; i &lt; 14; i++)\n        delete[] DataSet[i];\n    delete[] DataSet;\n    return 0;\n}</pre>\n <p style=\'\'>\n  <br/>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   可以看出，每预测一个新样本的所属类别时，都会对整体样本进行遍历，可以看出KNN的效率实际上是十分低下的，\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   后\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   面会用K-D树进行优化。\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在Julia语言中，有KNN的开发包，链接为：\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <strong>\n    <a href=\'https://github.com/johnmyleswhite/kNN.jl\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n     <span style=\'color:#006600; line-height:27px\'>\n      https://github.com/johnmyleswhite/kNN.jl\n     </span>\n    </a>\n   </strong>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n</div>\n</body></html>'),('dc77ac49f267391f6f5962dc0b71ff85','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   通常的矩阵分解会把一个大的矩阵分解为多个小的矩阵，但是这些矩阵的元素有正有负。而在现实世界中，比如图\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   像，文本\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   等形成的矩阵中负数的存在是没有意义的，所以如果能把一个矩阵分解成全是非负元素是很有意义的。在\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   NMF中要求原始的\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291441314669071.png\' style=\'border:0px currentColor\'/>\n   的所有元素的均是非负的，那么矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291442210595819.png\' style=\'border:0px currentColor\'/>\n   可以分解为两个更小的非负矩阵的乘积，这个矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291443034661232.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   有且仅有一个这样的分解，\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   即满足\n   <strong>\n    存在性\n   </strong>\n   和\n   <strong>\n    唯一性\n   </strong>\n   。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'line-height:19.5px\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; color:#006600; line-height:36px; font-size:18pt\'>\n     Contents\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <strong>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n    </span>\n    <span>\n    </span>\n    1. NMF问题描述\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    2. NMF实现原理\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    3. NMF的应用\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    4. NMF的R实现\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    5. NMF的Julia实现\n   </span>\n  </strong>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    6. 结束语\n   </span>\n  </strong>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    1. NMF问题描述\n   </span>\n  </strong>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   传统的NMF问题可以描述如下\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   给定矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291449570912768.png\' style=\'border:0px currentColor\'/>\n   ，寻找非负矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291450460445345.png\' style=\'border:0px currentColor\'/>\n   和非负矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291451313418040.png\' style=\'border:0px currentColor\'/>\n   ，使得\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291452154668193.png\' style=\'border:0px currentColor\'/>\n   。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   分解前后可理解为：原始矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291453346531833.png\' style=\'border:0px currentColor\'/>\n   的列向量是对左矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291455493098161.png\' style=\'border:0px currentColor\'/>\n   中所有列向量的加权和，而权重系数就是右矩阵对\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   应列\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   向量\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   的元素，故称\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291457575916038.png\' style=\'border:0px currentColor\'/>\n   为基矩阵，\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291458464032659.png\' style=\'border:0px currentColor\'/>\n   为系数矩阵。一般情况下\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291459390135119.png\' style=\'border:0px currentColor\'/>\n   的选择要比\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291500129342522.png\' style=\'border:0px currentColor\'/>\n   小，即满足\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291500574341861.png\' style=\'border:0px currentColor\'/>\n   ，\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   这时用系数矩\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   阵代替原始矩阵，就可以实现对原始矩阵进行降维，得到数据特征的降维矩阵，从而减少存储空\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   间，减少计算机资源。\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    2. NMF实现原理\n   </span>\n  </strong>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   <span style=\'color:#000000\'>\n    NMF求解问题实际上是一个最优化问题，利用乘性迭代的方法求解\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291506334667469.png\' style=\'border:0px currentColor\'/>\n    和\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291506432164291.png\' style=\'border:0px currentColor\'/>\n    ，非负矩阵分解是一个NP问题。NMF\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    问题的目\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    标函数有很多种，应用最广泛\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    的\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    就是\n    <strong>\n     欧几里得距离\n    </strong>\n    和\n    <strong>\n     KL散度。\n    </strong>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000\'>\n    <strong>\n    </strong>\n    <span>\n    </span>\n    在NMF的分解问题中，假设噪声矩阵为\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291541514502579.png\' style=\'border:0px currentColor\'/>\n    ，那么有\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291542399344999.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   现在要找出合适的\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291557344191464.png\' style=\'border:0px currentColor\'/>\n   和\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291557443564527.png\' style=\'border:0px currentColor\'/>\n   使得\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291543274035064.png\' style=\'border:0px currentColor\'/>\n   最小。假设噪声服从不同的概率分布，通过最大似然函数会得到不同类型\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    的目标函\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    数。接下来会分别以噪声服从\n    <strong>\n     高斯分布\n    </strong>\n    和\n    <strong>\n     泊松分布\n    </strong>\n    来说明。\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    （1）噪声服从高斯分布\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   假设噪声服从高斯分布，那么得到最大似然函数为\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291610179034781.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n     取对数后，得到对数似然函数为\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291618384974581.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   假设各数据点噪声的方差一样，那么接下来要使得对数似然函数取值最大，只需要下面目标函数值最小。\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291633021388165.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   该损失函数为\n   <strong>\n    2范数损失函数\n   </strong>\n   ，它是基于欧几里得距离的度量。又因为\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291635239817232.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n     那么得到\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291643422009190.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   同理有\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291647512311077.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n     接下来就可以使用梯度下降法进行迭代了。如下\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291653155755721.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   如果选取\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291823454507097.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   那么最终得到迭代式为\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291701447637327.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   可看出这是乘性迭代规则，每一步都保证了结果为正数，一直迭代下去就会收敛，当然收敛性的证明省略。\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n     （2）噪声服从泊松分布\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    </span>\n   </strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span>\n    </span>\n    若噪声为泊松噪声，那么得到损失函数为\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291945518411392.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   同样经过推到得到\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/291956023729036.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n     3. NMF的应用\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   NMF能用于发现数据库中图像的特征，便于快速识别应用，比如实现录入恐怖分子的照片，然后在安检口对可疑\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    人员进\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    行盘查。在文档方面，NMF能够发现文档的语义相关度，用于信息的自动索引和提取。在生物学中，在\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    DNA阵列分析中\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    识别基因等。在语音识别系统中NMF也能发挥重要作用。\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n     4. NMF的R实现\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span style=\'color:#000000\'>\n    <strong>\n     <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     </span>\n    </strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     先说NMF的R使用，R语言中已经有NMF包可用于NMF。非负矩阵分解已经有了很多算法，例如Multiplicative\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    Update，Projected Gradient Method，Gradient\r\n Descent。交替最小二乘法比较符合上面的解释，具\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     有更好\n    </span>\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     的统计意义，而且收敛性质很好，计算速度快。已有的交替最小二乘法都使用冷冰冰的二次规划算法求解\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     非负回归，在\n    </span>\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     bignmf中使用的最小角回归的思路解非负回归，更有统计的感觉，而且速度更快。安装包如下\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n    <span>\n    </span>\n   </span>\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#0800; line-height:27px\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <strong>\n     <span style=\'color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n      bignmf：\n     </span>\n     <a href=\'https://github.com/panlanfeng/bignmf\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n      <span style=\'color:#006600; line-height:27px\'>\n       https://github.com/panlanfeng/bignmf\n      </span>\n     </a>\n    </strong>\n   </span>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span style=\'color:#000000\'>\n    bignmf的部分源码如下\n   </span>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/301035181534215.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span style=\'color:#000000\'>\n    从上面代码可以看出，当矩阵V中元素是非double时，会强制转化为double类型。而\n    <strong>\n     W\n    </strong>\n    和\n    <strong>\n     H\n    </strong>\n    矩阵是服从高斯分布\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    的\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    随机\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    矩阵，随后传入参数调用\n    <strong>\n     whupdate\n    </strong>\n    ，如果迭代次数太少会打印警告Iteration\r\n doesn\'t converge!\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   所以用bignmf分解非负矩阵调用如下函数就行了\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/301049151534107.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   代码：\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/301105449815941.jpg\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n     以上是NMF分解的R语言实现，bignmf借助伟大的Rcpp和RcppEigen包，算法内层用C++ 代码实现接下来会接\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n     着\n    </span>\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n     讲\n    </span>\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n     NMF在Julia中的实现。\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n     5. NMF的Julia实现\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在Julia语言中，有一个NMF包专门用来进行NMF分解的，现在就来详细了解它。首先来安装NMF，在Julia交互\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    式环\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px; background-color:rgb(255,255,255)\'>\n    境下使用如下命令\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/301642055594161.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在Julia中，关于NMF的计算有很多方法，详见：\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <strong>\n    <a href=\'https://github.com/JuliaStats/NMF.jl\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n     <span style=\'color:#006600; line-height:27px\'>\n      https://github.com/JuliaStats/NMF.jl\n     </span>\n    </a>\n   </strong>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   NMF分解的一个例子如下\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/301648086841391.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     6. 结束语\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   关于NMF的解的收敛性和唯一性以后再证明，除了NMF分解以外，还有一种非负分解也用的比较多，而且很有\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   效，\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px\'>\n   叫做\n  </span>\n  <span style=\'color:#000000; line-height:19.5px\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <strong>\n     非\n    </strong>\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <strong>\n     负张量分解法\n    </strong>\n    。可以参考如下论文\n   </span>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span>\n    </span>\n    论文链接：\n   </span>\n   <span style=\'line-height:27px; background-color:rgb(255,255,255)\'>\n    <strong>\n     <a href=\'http://www.doc88.com/p-8942237517189.html\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n      <span style=\'color:#006600; line-height:27px; background-color:rgb(255,255,255)\'>\n       http://www.doc88.com/p-8942237517189.html\n      </span>\n     </a>\n    </strong>\n   </span>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New; font-size:18px\'>\n   </span>\n  </strong>\n </p>\n</div>\n</body></html>'),('f206b9071a1f77c923af056378a217c2','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在线性回归中，我们以最小二乘来作为损失函数，然后使得这个损失函数的值最小。那么为什么会选择最小二乘\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   而不是其它的指标呢？ 今天就用概率方面的知识来解释。\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   首先，设\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251830456404070.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   其中\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251837483431798.png\' style=\'border:0px currentColor\'/>\n   是样本的误差纠正量。由于我们目的是训练出合适的参数\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251841300939118.png\' style=\'border:0px currentColor\'/>\n   ，使得\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251842068906277.png\' style=\'border:0px currentColor\'/>\n   的绝对值尽量小，那么可以确定\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   大部分\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251842472189589.png\' style=\'border:0px currentColor\'/>\n   的值集中在\n   <strong>\n    0\n   </strong>\n   附近，而少数值离\n   <strong>\n    0\n   </strong>\n   较远，很明显，这可以看成随机变量\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251844223744420.png\' style=\'border:0px currentColor\'/>\n   服从\n   <strong>\n    高斯分布\n   </strong>\n   。即\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251849483741293.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   那么概率密度函数为\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251853324833225.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   那么也就是说有\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251859273124389.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   亦即\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251905417805154.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   那么进一步得到联合概率密度函数为\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251909528124695.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   现在我们来求最大似然估计，即找到合适的参数\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251910456089099.png\' style=\'border:0px currentColor\'/>\n   ，使得上述概率取值最大。两边分别取对数得到\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251924068582646.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   要是上述目标函数值最大，那么只需要\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/251926382189604.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   最小即可。这就解释了线性回归为什么要选用最小二乘作为衡量指标了。多么美的自然科学啊！！！\n  </span>\n </p>\n <p style=\'\'>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   现在想想\n   <strong>\n    Logistic\n   </strong>\n   回归也是基于一个假设，即概率只能为0或者1，它是用一个\n   <strong>\n    Sigmoid\n   </strong>\n   函数来把数据范围映\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   射\n  </span>\n </p>\n <p style=\'\'>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   到区间\n   <strong>\n    [0,1]\n   </strong>\n   上的，最后根据联合概率密度函数求最大似然估计。\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n</div>\n</body></html>'),('ed876a9c2c78e459df4dee6e151fce7a','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   今天，来学习文本的\n   <strong>\n    特征属性选择\n   </strong>\n   ，在机器学习中，特征属性的选择通常关系到训练结果的可靠性，一个好的\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   特征属性通常能起到满意的分类效果。凡是特征选择，总是在将特征的重要程度量化后再进行选择，而如何量\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   化特征的重要性，就成了各种方法间最大的不同。接下来就介绍如何有效地进行文本的特征属性选择。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'line-height:36px; font-size:18pt\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; color:#006600; line-height:36px\'>\n     Contents\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   </span>\n  </strong>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     1. TF-IDF与特征属性选择\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     2. 信息增益与特征属性选择\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     3. 卡方检验与特征属性选择\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     4. 互信息与特征属性选择\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   文本分类作为一种有效的信息检索和信息过滤的关键技术，能按预定义的类别将待分类的文本进行归类。文本\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    分类中常用到\n    <strong>\n     向量空间模型（VSM\n    </strong>\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <strong>\n     ）\n    </strong>\n    ，然而高维的向量空间模型严重影响了计算机的处理速度，因此需要对文\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   本的向量进行降维，那么就需要对文本进行特征属性选择。\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   目前在文本分类领域中常用的文本特征属性选择算法有：\n   <strong>\n    TF-IDF\n   </strong>\n   ，\n   <strong>\n    信息增益\n   </strong>\n   ，\n   <strong>\n    卡方检验\n   </strong>\n   ，\n   <strong>\n    互信息\n   </strong>\n   等。\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    1. TF-IDF与特征属性选择\n   </span>\n  </strong>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    TF\n   </span>\n  </strong>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   即\n  </span>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    词频（Term\r\n Frequency）\n   </span>\n  </strong>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   ，\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   表示词条在某个文档\n   <strong>\n    d\n   </strong>\n   中出现的频率。\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    IDF\n   </span>\n  </strong>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   即\n   <strong>\n    逆向文件频率（Inverse\r\n Document Frequency），\n   </strong>\n   如果包含词条\n   <strong>\n    t\n   </strong>\n   的文档越少，那么\n   <strong>\n    IDF\n   </strong>\n   值\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   越大，则说明词条\n   <strong>\n    t\n   </strong>\n   具有很好的类别区分能力。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span>\n    </span>\n    TF-IDF算法\n   </strong>\n   的主要思想是：如果某个词或短语在某一篇文章中的出现频率\n   <strong>\n    TF\n   </strong>\n   越高，而且在其它文章中很\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   少出现，那么认为此词或者短语具有很好的类别区分能力，适合用来分类。举个例子\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   假设某篇文档的总词语数为\n   <strong>\n    100\n   </strong>\n   个，而“蜜蜂”出现了\n   <strong>\n    5\n   </strong>\n   次，那么“蜜蜂”的词频就是\n   <strong>\n    0.05\n   </strong>\n   。如\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   果“蜜蜂”这个\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   词在\n   <strong>\n    100\n   </strong>\n   份文档中出现，而文档总数为\n   <strong>\n    1000000\n   </strong>\n   ，那么逆向文件频率就是\n   <strong>\n    log10(1000000/1\n   </strong>\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    00)=4\n   </strong>\n   。最\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   后\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    TF-IDF\n   </strong>\n   的值为\n   <strong>\n    0.05\r\n * 4 = 0.2\n   </strong>\n   。具体公式如下\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/131628359155724.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   当然在统计之前必须要过滤掉文档中的停用词。当然\n   <strong>\n    TF-IDF\n   </strong>\n   的精确度有时候可能不太高，它仍有不足之处，\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   单纯地认为文本频率越小的单词就越重要，而文本频率越大的单词就越无用，显然这并不完全正确。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   接下来就可以用上面所学的\n   <strong>\n    TF-IDF\n   </strong>\n   来对文本进行特征属性选择了。计算出文档中每个词的\n   <strong>\n    TF-IDF\n   </strong>\n   的值，然\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   后按照\n   <strong>\n    降序排列\n   </strong>\n   ，取前面的几个词作为特征属性。这里由于只取前\n   <strong>\n    K\n   </strong>\n   大的，有比较优秀的\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/141508437752319.png\' style=\'border:0px currentColor\'/>\n   算法。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在文本分类中单纯地用\n   <strong>\n    TF-IDF\n   </strong>\n   来判断一个特征属性是否具有区分度是不够的，原因主要有如下两个\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    （1）没有考虑特征词在类间的分布\n   </span>\n  </strong>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   如果一个特征词在各个类之间分布都比较均匀，那么这样的词对分类没有任何贡献；而如果一个特征\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   词集中分布在某个类中，在其它类中都出现但是出现的频率很小很小，那么这个词能很好地代表这个\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   类的特征属性，\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   但\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   是\n   <strong>\n    TF-IDF\n   </strong>\n   不能很好地区别这两种情况。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    （2）没有考虑特征词在类内部文档中的分布\n   </strong>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在类内部文档中，如果特征词均匀分布在其中，那么这个特征词能够很好地代表这个类的特征，如果\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   只在几篇文档中出现，那么不能够代表这个类的特征。\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     2. 信息增益与特征属性选择\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    关于信息增益的概念，在之前的\n    <strong>\n     《决策树之ID3算法》\n    </strong>\n    中已经说过。在信息增益中，重要的衡量标准就是\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    看这个特征能够为分类系统带来多少信息，带来的信息越多，那么该特征就越重要。\n   </span>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    通过信息增益选择的特征属性只能考察一个特征对整个系统的贡献，而不能具体到某个类别上，这就使得\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    它只能做全局特征选择，即所有的类使用相同的特征集合。\n   </span>\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     3. 卡方检验与特征属性选择\n    </span>\n   </span>\n  </strong>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   卡方检验是数理统计中一种常用的检验两个变量是否独立的方法。在卡方检验中使用特征与类别间的关联\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   性来进行量化，关联性越强，特征属性得分就越高，该特征越应该被保留。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    卡方检验最基本的思想是观察实际值和理论值的偏差来确定理论的正确性。通常先假设两个变量确实是\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    独\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   立的，然后观察实际值与理论值的偏差程度，如果偏差足够小，那么就认为这两个变量确实是独立的，否\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   则偏差很大，那么就认为这两个变量是相关的。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在文本特征属性选择阶段，一般用“词\n   <strong>\n    t\n   </strong>\n   与类别\n   <strong>\n    c\n   </strong>\n   不相关”作出假设，计算出的卡方值越大，说明假设偏离就\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   越大，假设越不正确。文本特征属性选择过程为：计算每个词与类别\n   <strong>\n    c\n   </strong>\n   的卡方值，然后排序取前\n   <strong>\n    K\n   </strong>\n   大的即可。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   接下来，就来学习如何计算卡方值。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   假设\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/131956295093343.png\' style=\'border:0px currentColor\'/>\n   个样本的观测值分别为\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/131957126812033.png\' style=\'border:0px currentColor\'/>\n   ，它们的均值（期望）为\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/131958054155844.png\' style=\'border:0px currentColor\'/>\n   ，那么卡方值计算如下\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/131959101347248.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   如果计算出的\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/131959583373042.png\' style=\'border:0px currentColor\'/>\n   值与事先设定的阀值进行比较，如果\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/132000391656815.png\' style=\'border:0px currentColor\'/>\n   小于阀值，则原假设成立，否则原假设不成立。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在文本特征选择阶段，我们关心的是一个词\n   <strong>\n    t\n   </strong>\n   与一个类别\n   <strong>\n    c\n   </strong>\n   之间是否独立，如果独立，则词t对类别c完全\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   没有表征作用。下面以一个例子来推导文本特征选择中卡方值得计算公式\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    假设现在有\n    <strong>\n     N\n    </strong>\n    篇文档，其中有\n    <strong>\n     M\n    </strong>\n    篇是关于体育的，我们想知道词“篮球”与类别“体育”的相关性。接下来设\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     包含“篮球”且属于“体育”类别的文档数为A\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     包含“篮球”但不属于“体育”类别的文档数为B\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     不包含“篮球”但属于“体育”类别的文档数为C\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     不包含“篮球”也不属于“体育”类别的文档数为D\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   即得到如下表格\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/132022219468855.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   那么，很明显有\n   <strong>\n    A + B + C + D = N\n   </strong>\n   ，\n   <strong>\n    A + C = M\n   </strong>\n   。假设词“篮球”与“体育”不相关，那么“篮球”这\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   个词在所有的文档中以等概率的形式出现，这个概率值接近\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/132024589006873.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   而属于“体育”类的文章数为\n   <strong>\n    A + C\n   </strong>\n   ，在这些文档中，应该有\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/132028309934402.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   篇文章包含“篮球”这个词，这是假设条件下的理论值，而实际值从表格中可以看出是\n   <strong>\n    A\n   </strong>\n   ，那么偏差为\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/141224044789871.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   同理，可以计算出\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/141230125562787.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    那么继续得到\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/141257112597976.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    而对于同一类别文档中的所有词来说，\n    <strong>\n     N = A + B + C + D，M = A + C，N - M = B + D\n    </strong>\n   </span>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    这\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   三个值不变，那么只需要计算如下值，然后从大到小取前\n   <strong>\n    K\n   </strong>\n   大的就行了。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/141310171182262.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span style=\'color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span>\n    </span>\n    卡方检验也有缺陷，因为\n    <strong>\n     A\n    </strong>\n    和\n    <strong>\n     B\n    </strong>\n    在统计词\n    <strong>\n     t\n    </strong>\n    在文章中出没出现过，却不管词\n    <strong>\n     t\n    </strong>\n    在文档中出现了几次，这\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   样的话会对低频词有所偏袒，甚至会出现有些情况，一个词在一类文章的每篇文档中都只出现了一次，\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   其卡方值却大过了在该类文章\n   <strong>\n    99%\n   </strong>\n   的文档中出现了\n   <strong>\n    10\n   </strong>\n   次的词，其实后面的词才是更具代表性的，但只\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   因为它出现的文档数比前面的词少了“\n   <strong>\n    1\n   </strong>\n   ”，特征选择的时候就可能筛掉后面的词而保留了前者。这就\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   是开方检验著名的“\n   <strong>\n    低频词缺陷\n   </strong>\n   “。因此开方检验也经常同其他因素如词频综合考虑来扬长避短。\n  </span>\n </p>\n <p>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     4. 互信息与特征属性选择\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   接下来，开始学习互信息与特征选择，其实互信息相比前面几种特征属性选择方法来说，效果是最差\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   的。互信息是事件A和事件B发生相关联而提供的信息量，在处理分类问题提取特征的时候就可以用互\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   信息来衡量某个特征和特定类别的相关性，如果信息量越大，那么特征和这个类别的相关性越大。反\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   之也是成立的。计算方法如下\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/141407307127443.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   低词频对于互信息的影响还是蛮大的，一个词如果频次不够多，但是又主要出现在某个类别里，那么就\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   会出现较高的互信息，从而给筛选带来噪音。所以为了避免出现这种情况可以采用先对词按照词频排序\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   取然后按照互信息大小进行排序，然后再选择自己想要的词，这样就能比较好的解决这个问题。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:Courier New; font-size:18px\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    推荐文章：\n   </strong>\n  </span>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <strong>\n    <a href=\'http://blog.csdn.net/chl033/article/details/2731701\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n     <span style=\'color:#006600; line-height:27px\'>\n      http://blog.csdn.net/chl033/article/details/2731701\n     </span>\n    </a>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-weight:bold\'>\n   <span style=\'font-family:\'courier new\',courier; line-height:28px; font-size:14pt\'>\n    <span style=\'color:#000000; line-height:28px; background-color:rgb(255,255,255)\'>\n     搜狗语料库：\n    </span>\n    <span style=\'line-height:28px; background-color:rgb(255,255,255)\'>\n     <a href=\'http://www.sogou.com/labs/dl/c.html\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n      <span style=\'color:#006600; line-height:28px; background-color:rgb(255,255,255)\'>\n       http://www.sogou.com/labs/dl/c.html\n      </span>\n     </a>\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:Courier New\'>\n   </span>\n  </strong>\n </p>\n</div>\n</body></html>'),('d55e92af46f1db9f6591e5b63282a09c','<html><head><meta charset=\'utf8\'></head><body><div class=\'article_content tracking-ad\' data-dsm=\'post\' data-mod=\'popu_307\' id=\'article_content\'>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在上一篇文章中，我讲述了Logistic回归的原理以及它的梯度上升法实现。现在来研究Logistic回归的另一种\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   实现，即\n   <strong>\n    牛顿迭代法\n   </strong>\n   。\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   在上篇文章中，我们求出Logistic回归的似然函数的偏导数为\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202017211401159.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   由于\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202020235783224.png\' style=\'border:0px currentColor\'/>\n   是一个多元函数，变元是\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202021478122989.png\' style=\'border:0px currentColor\'/>\n   ，多元函数求极值问题以前已经讲过，参考如下文章\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:rgb(0,0,0); line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     链接：\n     <span style=\'line-height:27px\'>\n      <a href=\'http://blog.csdn.net/acdreamers/article/details/41413787\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n       <span style=\'color:#006600; line-height:27px\'>\n        http://blog.csdn.net/acdreamers/article/details/41413787\n       </span>\n      </a>\n     </span>\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   我们知道，极值点的导数一定均为零，所以一共需要列出\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202030540006927.png\' style=\'border:0px currentColor\'/>\n   个方程，联立解出所有的参数\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202027360005017.png\' style=\'border:0px currentColor\'/>\n   。\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   当然，这里首先需要用\n   <strong>\n    Hessian矩阵\n   </strong>\n   来判断极值的存在性。方程组如下\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202045453438248.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   这一共是\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202036344064330.png\' style=\'border:0px currentColor\'/>\n   个方程，现在的问题变为如何解这个方程组。求\n   <strong>\n    Hessian矩阵\n   </strong>\n   就得先求二阶偏导，即\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202112499532756.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   把\n   <strong>\n    Hessian矩阵\n   </strong>\n   表示出来，那么有\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202135592659578.png\' style=\'border:0px currentColor\'/>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202141595468810.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   所以得到\n   <strong>\n    Hessian\n   </strong>\n   矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202144166403194.png\' style=\'border:0px currentColor\'/>\n   ，可以看出矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241323052659871.png\' style=\'border:0px currentColor\'/>\n   是负定的，那么现在我来证明\n   <strong>\n    如果\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241324107802823.png\' style=\'border:0px currentColor\'/>\n    是负定的，那\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    么Hessian矩阵\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241325250159310.png\' style=\'border:0px currentColor\'/>\n    也是负定的\n   </strong>\n   。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    证明：\n   </span>\n  </strong>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   设任意的\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241328048273521.png\' style=\'border:0px currentColor\'/>\n   是\n   <strong>\n    n\n   </strong>\n   维列向量，因为\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241330522334710.png\' style=\'border:0px currentColor\'/>\n   是负定的，那么\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241332005152216.png\' style=\'border:0px currentColor\'/>\n   为二次型，也是负定的，又因为\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241343474836733.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   所以\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201412/241335145934557.png\' style=\'border:0px currentColor\'/>\n   也是负定的。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    <strong>\n     Hessian\n    </strong>\n    矩阵\n    <strong>\n     <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/202146576095718.png\' style=\'border:0px currentColor\'/>\n    </strong>\n    是负定的，\n   </span>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    也就是说\n   </span>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    多元函数存在局部极大值，这符合开始需求的最大似然估计。\n    <strong>\n     Hessian\n    </strong>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    <strong>\n     矩\n    </strong>\n   </span>\n  </span>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    <strong>\n     阵\n    </strong>\n    描述\n   </span>\n  </span>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   了多元函数的局部曲率。有了这个Hessian矩阵，我们就可以用\n   <strong>\n    牛顿迭代法\n   </strong>\n   继续进行计算啦！\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   回想一下，对于一元函数\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210934077185946.png\' style=\'border:0px currentColor\'/>\n   我们是怎样通过牛顿迭代法求解零点的？\r\n 假设现在要求方程\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210935442964074.png\' style=\'border:0px currentColor\'/>\n   的解，\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   那么首先选取一个点\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210938288904724.png\' style=\'border:0px currentColor\'/>\n   作为迭代起始点，然后通过下面式子进行迭代，直到达到指定的精度为止。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210943086409058.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   原理详见：\n   <strong>\n    <span style=\'line-height:27px\'>\n     <a href=\'http://zh.m.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95\' style=\'color:rgb(67,113,166)\' target=\'_blank\'>\n      <span style=\'color:#006600; line-height:27px\'>\n       http://zh.m.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95\n      </span>\n     </a>\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n    有时候这个起始点的选取很关键，因为牛顿迭代法得到的是局部最优解，\n   </span>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    如\n   </span>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    果函数只存在一个零点，那么这个\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210946413433943.png\' style=\'border:0px currentColor\'/>\n    点选取无关重要，但是如果存在多个局部最优解，一般是求指定在某个点\n    <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210947179533860.png\' style=\'border:0px currentColor\'/>\n   </span>\n   <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n    附近的零点。对于\n    <strong>\n     Logistic\n    </strong>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <strong>\n    回归\n   </strong>\n   问题，\n   <strong>\n    Hessian\n   </strong>\n   矩阵对于任意数据都是负定的，所以说极值点只有一个，初始点选取无关紧要。\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   对于多元函数求解零点，同样可以用牛顿迭代法，对于上面的Logistic回归，可以得到如下迭代式子\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'Courier New\'; font-size:18px; line-height:27px\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210952434686345.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   其中\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210953140463837.png\' style=\'border:0px currentColor\'/>\n   为Hessian矩阵，而\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/210955053903154.png\' style=\'border:0px currentColor\'/>\n   的表示如下\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211002536409034.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   由于Hessian矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211004055316139.png\' style=\'border:0px currentColor\'/>\n   是对称负定的，将矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211005432653580.png\' style=\'border:0px currentColor\'/>\n   提取一个负号出来，得到\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n   </span>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211008292813229.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   然后Hessian矩阵\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211009209213618.png\' style=\'border:0px currentColor\'/>\n   变为\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211010341259221.png\' style=\'border:0px currentColor\'/>\n   ，这样\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211011097652366.png\' style=\'border:0px currentColor\'/>\n   就是对称正定的了。那么现在牛顿迭代式变为\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211014236879221.png\' style=\'border:0px currentColor\'/>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   现在的重点是如何快速并有效计算\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211016022181020.png\' style=\'border:0px currentColor\'/>\n   ，即解方程组\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211018086252970.png\' style=\'border:0px currentColor\'/>\n   ，通常的做法是直接用高斯消元法求解，\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   但是这样做有弊端，弊端有两个：（1）效率低；（2）数值稳定性差。\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   由于\n   <img alt=\'\' src=\'http://images.cnitblog.com/blog/571227/201411/211019269374510.png\' style=\'border:0px currentColor\'/>\n   是对称正定的，可以用\n   <strong>\n    Cholesky矩阵\n   </strong>\n   <span>\n    分解法来解。\n    <strong>\n     Cholesky\n    </strong>\n    <span>\n     分解\n    </span>\n    原理如下\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'color:rgb(0,0,0); line-height:19.5px; background-color:rgb(255,255,255)\'>\n   <strong>\n    <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n     <span>\n      <span style=\'color:#000000\'>\n       链接：\n       <span style=\'line-height:27px\'>\n        <a href=\'http://blog.csdn.net/acdreamers/article/details/44656847\' target=\'_blank\'>\n         http://blog.csdn.net/acdreamers/article/details/44656847\n        </a>\n       </span>\n      </span>\n     </span>\n    </span>\n   </strong>\n  </span>\n </p>\n <p>\n  <span style=\'color:#000000; line-height:19.5px; background-color:rgb(255,255,255)\'>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n   <span>\n    至此，牛顿迭代法求解Logistic回归的精髓基本讲完。现在开始用C++代码来实现它。\n   </span>\n  </span>\n </p>\n <p>\n </p>\n <p>\n  <strong>\n   <span style=\'font-family:\'courier new\',courier; font-size:18px; color:#000000; line-height:27px; background-color:rgb(255,255,255)\'>\n    <span>\n     代码：\n    </span>\n   </span>\n  </strong>\n </p>\n <pre class=\'cpp\' code_snippet_id=\'628931\' name=\'code\' snippet_file_name=\'blog_20150326_1_6391568\'>#include &lt;string.h&gt;\n#include &lt;fstream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n \n#include \'matrix.h\'\n#define Type double\n#define Vector vector\n \nusing namespace std;\n \n/** 定义数据集结构体 */\nstruct Data\n{\n    Vector&lt;Type&gt; x;\n    Type y;\n};\n \n/** 预处理数据给data */\nvoid PreProcessData(Vector&lt;Data&gt;&amp; data, string path)\n{\n    string filename = path;\n    ifstream file(filename.c_str());\n    char s[1024];\n    if(file.is_open())\n    {\n        while(file.getline(s, 1024))\n        {\n            Data tmp;\n            Type x1, x2, x3, x4, x5, x6, x7;\n            sscanf(s,\'%lf %lf %lf %lf %lf %lf %lf\', &amp;x1, &amp;x2, &amp;x3, &amp;x4, &amp;x5, &amp;x6, &amp;x7);\n            tmp.x.push_back(1);\n            tmp.x.push_back(x2);\n            tmp.x.push_back(x3);\n            tmp.x.push_back(x4);\n            tmp.x.push_back(x5);\n            tmp.x.push_back(x6);\n            tmp.y = x7;\n            data.push_back(tmp);\n        }\n    }\n}\n \nvoid Init(Vector&lt;Data&gt; &amp;data, Vector&lt;Type&gt; &amp;w)\n{\n    w.clear();\n    data.clear();\n    PreProcessData(data, \'TrainData.txt\');\n    for(int i = 0; i &lt; data[0].x.size(); i++)\n        w.push_back(0);\n}\n \nType WX(const Vector&lt;Type&gt;&amp; w, const Data&amp; data)\n{\n    Type ans = 0;\n    for(int i = 0; i &lt; w.size(); i++)\n        ans += w[i] * data.x[i];\n    return ans;\n}\n \nType Sigmoid(const Vector&lt;Type&gt;&amp; w, const Data&amp; data)\n{\n    Type x = WX(w, data);\n    Type ans = exp(x) / (1 + exp(x));\n    return ans;\n}\n \nvoid PreMatrix(Matrix&lt;Type&gt; &amp;H, Matrix&lt;Type&gt; &amp;U, const Vector&lt;Data&gt; &amp;data, Vector&lt;Type&gt; &amp;w)\n{\n    int ROWS = data[0].x.size();\n    int COLS = data.size();\n    Matrix&lt;Type&gt; A(COLS, COLS), P(ROWS, COLS), Q(COLS, 1), X(COLS, ROWS);\n    for(int i = 0; i &lt; COLS; i++)\n    {\n        Type t = Sigmoid(w, data[i]);\n        A.put(i, i, t *(1 - t));\n        Q.put(i, 0, data[i].y - t);\n    }\n    for(int i = 0; i &lt; ROWS; i++)\n    {\n        for(int j = 0; j &lt; COLS; j++)\n            P.put(i, j, data[j].x[i]);\n    }\n    X = P.getTranspose();\n \n    /** 计算矩阵U和矩阵H的值 */\n    U = P * Q;\n    H = X.getTranspose() * A * X;\n}\n \nVector&lt;Type&gt; Matrix2Vector(Matrix&lt;Type&gt; &amp;M)\n{\n    Vector&lt;Type&gt; X;\n    X.clear();\n    int ROWS = M.getRows();\n    for(int i = 0; i &lt; ROWS; i++)\n        X.push_back(M.get(i, 0));\n    return X;\n}\n \nMatrix&lt;Type&gt; Vector2Matrix(Vector&lt;Type&gt; &amp;X)\n{\n    int ROWS = X.size();\n    Matrix&lt;Type&gt; matrix(ROWS, 1);\n    for(int i = 0; i &lt; ROWS; i++)\n        matrix.put(i, 0, X[i]);\n    return matrix;\n}\n \n/** Cholesky分解得到矩阵L和矩阵D */\nvoid Cholesky(Matrix&lt;Type&gt; &amp;H, Matrix&lt;Type&gt; &amp;L, Matrix&lt;Type&gt; &amp;D)\n{\n    Type t = 0;\n    int n = H.getRows();\n    for(int k = 0; k &lt; n; k++)\n    {\n        for(int i = 0; i &lt; k; i++)\n        {\n            t = H.get(i, i) * H.get(k, i) * H.get(k, i);\n            H.put(k, k, H.get(k, k) - t);\n        }\n        for(int j = k + 1; j &lt; n; j++)\n        {\n            for(int i = 0; i &lt; k; i++)\n            {\n                t = H.get(j, i) * H.get(i, i) * H.get(k, i);\n                H.put(j, k, H.get(j, k) - t);\n            }\n            t = H.get(j, k) / H.get(k, k);\n            H.put(j, k, t);\n        }\n    }\n    for(int i = 0; i &lt; n; i++)\n    {\n        D.put(i, i, H.get(i, i));\n        L.put(i, i, 1);\n        for(int j = 0; j &lt; i; j++)\n            L.put(i, j, H.get(i, j));\n    }\n}\n \n/** 回带求出线性方程组的解 */\nvoid Solve(Matrix&lt;Type&gt; &amp;H, Vector&lt;Type&gt; &amp;X)\n{\n    int ROWS = H.getRows();\n    int COLS = H.getColumns();\n    Matrix&lt;Type&gt; L(ROWS, COLS), D(ROWS, COLS);\n    Cholesky(H, L, D);\n \n    int n = ROWS;\n    for(int k = 0; k &lt; n; k++)\n    {\n        for(int i = 0; i &lt; k; i++)\n            X[k] -= X[i] * L.get(k, i);\n        X[k] /= L.get(k, k);\n    }\n    L = D * L.getTranspose();\n    for(int k = n - 1; k &gt;= 0; k--)\n    {\n        for(int i = k + 1; i &lt; n; i++)\n            X[k] -= X[i] * L.get(k, i);\n        X[k] /= L.get(k, k);\n    }\n}\n \n/** 打印迭代步骤 */\nvoid Display(int cnt, Type error, Vector&lt;Type&gt; w)\n{\n    cout&lt;&lt;\'第\'&lt;&lt;cnt&lt;&lt;\'次迭代前后的目标差为: \'&lt;&lt;error&lt;&lt;endl;\n    cout&lt;&lt;\'参数w为: \';\n    for(int i = 0; i &lt; w.size(); i++)\n        cout&lt;&lt;w[i]&lt;&lt;\' \';\n    cout&lt;&lt;endl;\n    cout&lt;&lt;endl;\n}\n \nType StopFlag(Vector&lt;Type&gt; w1, Vector&lt;Type&gt; w2)\n{\n    Type ans = 0;\n    int size = w1.size();\n    for(int i = 0; i &lt; size; i++)\n        ans += 0.5 * (w1[i] - w2[i]) * (w1[i] - w2[i]);\n    return ans;\n}\n \n/** 牛顿迭代步骤 */\nvoid NewtonIter(Vector&lt;Data&gt; &amp;data, Vector&lt;Type&gt; &amp;w)\n{\n    int cnt = 0;\n    Type delta = 0.0001;\n    int ROWS = data[0].x.size();\n    int COLS = data.size();\n \n    while(1)\n    {\n        Matrix&lt;Type&gt; H(ROWS, ROWS), U(ROWS, 1), W(ROWS, 1);\n        PreMatrix(H, U, data, w);\n        Vector&lt;Type&gt; X = Matrix2Vector(U);\n        Solve(H, X);\n        Matrix&lt;Type&gt; x = Vector2Matrix(X);\n        W = Vector2Matrix(w);\n        W += x;\n        Vector&lt;Type&gt; _w = Matrix2Vector(W);\n        Type error = StopFlag(_w, w);\n        w = _w;\n        cnt++;\n        Display(cnt, error, w);\n        if(error &lt; delta) break;\n    }\n}\n \n/** 训练数据得到w数组，构造分类器 */\nvoid TrainData(Vector&lt;Data&gt; &amp;data, Vector&lt;Type&gt; &amp;w)\n{\n    Init(data, w);\n    NewtonIter(data, w);\n}\n \n/** 根据构造好的分类器对数据进行分类 */\nvoid Separator(Vector&lt;Type&gt; w)\n{\n    vector&lt;Data&gt; data;\n    PreProcessData(data, \'TestData.txt\');\n    cout&lt;&lt;\'预测分类结果：\'&lt;&lt;endl;\n    for(int i = 0; i &lt; data.size(); i++)\n    {\n        Type p0 = 0;\n        Type p1 = 0;\n        Type x = WX(w, data[i]);\n        p1 = exp(x) / (1 + exp(x));\n        p0 = 1 - p1;\n        cout&lt;&lt;\'实例: \';\n        for(int j = 0; j &lt; data[i].x.size(); j++)\n            cout&lt;&lt;data[i].x[j]&lt;&lt;\' \';\n        cout&lt;&lt;\'所属类别为：\';\n        if(p1 &gt;= p0) cout&lt;&lt;1&lt;&lt;endl;\n        else cout&lt;&lt;0&lt;&lt;endl;\n    }\n}\n \nint main()\n{\n    Vector&lt;Type&gt; w;\n    Vector&lt;Data&gt; data;\n    TrainData(data, w);\n    Separator(w);\n    return 0;\n}</pre>\n <p>\n  <span style=\'font-size:18px\'>\n   <span style=\'font-family:Courier New\'>\n    <span>\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-size:18px\'>\n   <span style=\'font-family:Courier New\'>\n    <span>\n     上面的牛顿迭代法代码中用到了矩阵操作，使用头文件\n    </span>\n    <strong>\n     matrix.h\n    </strong>\n    <span>\n     ，这是一个很优秀的矩阵第三方库，代码如下\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-size:18px\'>\n   <span style=\'font-family:Courier New\'>\n    <span>\n    </span>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span>\n    <strong>\n     代码：matrix.h\n    </strong>\n   </span>\n  </span>\n </p>\n <p>\n  <span style=\'font-family:\'courier new\',courier; font-size:18px; line-height:27px\'>\n   <span>\n   </span>\n  </span>\n </p>\n <pre class=\'cpp\' code_snippet_id=\'628931\' name=\'code\' snippet_file_name=\'blog_20150326_2_9342618\'>/*****************************************************************************/\n/* Name: matrix.h                                                            */\n/* Uses: Class for matrix math functions.                                    */\n/* Date: 4/19/2011                                                           */\n/* Author: Andrew Que &lt;http://www.DrQue.net/&gt;                                */\n/* Revisions:                                                                */\n/*   0.1 - 2011/04/19 - QUE - Creation.                                      */\n/*   0.5 - 2011/04/24 - QUE - Most functions are complete.                   */\n/*   0.8 - 2011/05/01 - QUE -                                                */\n/*     = Bug fixes.                                                          */\n/*     + Dot product.                                                        */\n/*   1.0 - 2011/11/26 - QUE - Release.                                       */\n/*                                                                           */\n/* Notes:                                                                    */\n/*   This unit implements some very basic matrix functions, which include:   */\n/*    + Addition/subtraction                                                 */\n/*    + Transpose                                                            */\n/*    + Row echelon reduction                                                */\n/*    + Determinant                                                          */\n/*    + Dot product                                                          */\n/*    + Matrix product                                                       */\n/*    + Scalar product                                                       */\n/*    + Inversion                                                            */\n/*    + LU factorization/decomposition                                       */\n/*     There isn\'t much for optimization in this unit as it was designed as  */\n/*   more of a learning experience.                                          */\n/*                                                                           */\n/* License:                                                                  */\n/*   This program is free software: you can redistribute it and/or modify    */\n/*   it under the terms of the GNU General Public License as published by    */\n/*   the Free Software Foundation, either version 3 of the License, or       */\n/*   (at your option) any later version.                                     */\n/*                                                                           */\n/*   This program is distributed in the hope that it will be useful,         */\n/*   but WITHOUT ANY WARRANTY; without even the implied warranty of          */\n/*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */\n/*   GNU General Public License for more details.                            */\n/*                                                                           */\n/*   You should have received a copy of the GNU General Public License       */\n/*   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.   */\n/*                                                                           */\n/*                     (C) Copyright 2011 by Andrew Que                      */\n/*                           http://www.DrQue.net/                           */\n/*****************************************************************************/\n#ifndef _MATRIX_H_\n#define _MATRIX_H_\n \n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;vector&gt;\n \n// Class forward for identity matrix.\ntemplate&lt; class TYPE &gt; class IdentityMatrix;\n \n//=============================================================================\n// Matrix template class\n//   Contains a set of matrix manipulation functions.  The template is designed\n// so that the values of the matrix can be of any type that allows basic\n// arithmetic.\n//=============================================================================\ntemplate&lt; class TYPE = int &gt;\n  class Matrix\n  {\n    protected:\n      // Matrix data.\n      unsigned rows;\n      unsigned columns;\n \n      // Storage for matrix data.\n      std::vector&lt; std::vector&lt; TYPE &gt; &gt; matrix;\n \n      // Order sub-index for rows.\n      //   Use: matrix[ order[ row ] ][ column ].\n      unsigned * order;\n \n      //-------------------------------------------------------------\n      // Return the number of leading zeros in the given row.\n      //-------------------------------------------------------------\n      unsigned getLeadingZeros\n      (\n        // Row to count\n        unsigned row\n      ) const\n      {\n        TYPE const ZERO = static_cast&lt; TYPE &gt;( 0 );\n        unsigned column = 0;\n        while ( ZERO == matrix[ row ][ column ] )\n          ++column;\n \n        return column;\n      }\n \n      //-------------------------------------------------------------\n      // Reorder the matrix so the rows with the most zeros are at\n      // the end, and those with the least at the beginning.\n      //\n      // NOTE: The matrix data itself is not manipulated, just the\n      // \'order\' sub-indexes.\n      //-------------------------------------------------------------\n      void reorder()\n      {\n        unsigned * zeros = new unsigned[ rows ];\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n        {\n          order[ row ] = row;\n          zeros[ row ] = getLeadingZeros( row );\n        }\n \n        for ( unsigned row = 0; row &lt; (rows-1); ++row )\n        {\n          unsigned swapRow = row;\n          for ( unsigned subRow = row + 1; subRow &lt; rows; ++subRow )\n          {\n            if ( zeros[ order[ subRow ] ] &lt; zeros[ order[ swapRow ] ] )\n              swapRow = subRow;\n          }\n \n          unsigned hold    = order[ row ];\n          order[ row ]     = order[ swapRow ];\n          order[ swapRow ] = hold;\n        }\n \n        delete zeros;\n      }\n \n      //-------------------------------------------------------------\n      // Divide a row by given value.  An elementary row operation.\n      //-------------------------------------------------------------\n      void divideRow\n      (\n        // Row to divide.\n        unsigned row,\n \n        // Divisor.\n        TYPE const &amp; divisor\n      )\n      {\n        for ( unsigned column = 0; column &lt; columns; ++column )\n          matrix[ row ][ column ] /= divisor;\n      }\n \n      //-------------------------------------------------------------\n      // Modify a row by adding a scaled row. An elementary row\n      // operation.\n      //-------------------------------------------------------------\n      void rowOperation\n      (\n        unsigned row,\n        unsigned addRow,\n        TYPE const &amp; scale\n      )\n      {\n        for ( unsigned column = 0; column &lt; columns; ++column )\n          matrix[ row ][ column ] += matrix[ addRow ][ column ] * scale;\n      }\n \n      //-------------------------------------------------------------\n      // Allocate memory for matrix data.\n      //-------------------------------------------------------------\n      void allocate\n      (\n        unsigned rowNumber,\n        unsigned columnNumber\n      )\n      {\n        // Allocate order integers.\n        order = new unsigned[ rowNumber ];\n \n        // Setup matrix sizes.\n        matrix.resize( rowNumber );\n        for ( unsigned row = 0; row &lt; rowNumber; ++row )\n          matrix[ row ].resize( columnNumber );\n      }\n \n      //-------------------------------------------------------------\n      // Free memory used for matrix data.\n      //-------------------------------------------------------------\n      void deallocate\n      (\n        unsigned rowNumber,\n        unsigned columnNumber\n      )\n      {\n        // Free memory used for storing order (if there is any).\n        if ( 0 != rowNumber )\n          delete[] order;\n      }\n \n    public:\n      // Used for matrix concatenation.\n      typedef enum\n      {\n        TO_RIGHT,\n        TO_BOTTOM\n      } Position;\n \n      //-------------------------------------------------------------\n      // Return the number of rows in this matrix.\n      //-------------------------------------------------------------\n      unsigned getRows() const\n      {\n        return rows;\n      }\n \n      //-------------------------------------------------------------\n      // Return the number of columns in this matrix.\n      //-------------------------------------------------------------\n      unsigned getColumns() const\n      {\n        return columns;\n      }\n \n      //-------------------------------------------------------------\n      // Get an element of the matrix.\n      //-------------------------------------------------------------\n      TYPE get\n      (\n        unsigned row,   // Which row.\n        unsigned column // Which column.\n      ) const\n      {\n        assert( row &lt; rows );\n        assert( column &lt; columns );\n \n        return matrix[ row ][ column ];\n      }\n \n      //-------------------------------------------------------------\n      // Proform LU decomposition.\n      // This will create matrices L and U such that A=LxU\n      //-------------------------------------------------------------\n      void LU_Decomposition\n      (\n        Matrix &amp; upper,\n        Matrix &amp; lower\n      ) const\n      {\n        assert( rows == columns );\n \n        TYPE const ZERO = static_cast&lt; TYPE &gt;( 0 );\n \n        upper = *this;\n        lower = *this;\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            lower.matrix[ row ][ column ] = ZERO;\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n        {\n          TYPE value = upper.matrix[ row ][ row ];\n          if ( ZERO != value )\n          {\n            upper.divideRow( row, value );\n            lower.matrix[ row ][ row ] = value;\n          }\n \n          for ( unsigned subRow = row + 1; subRow &lt; rows; ++subRow )\n          {\n            TYPE value = upper.matrix[ subRow ][ row ];\n            upper.rowOperation( subRow, row, -value );\n            lower.matrix[ subRow ][ row ] = value;\n          }\n        }\n      }\n \n      //-------------------------------------------------------------\n      // Set an element in the matrix.\n      //-------------------------------------------------------------\n      void put\n      (\n        unsigned row,\n        unsigned column,\n        TYPE const &amp; value\n      )\n      {\n        assert( row &lt; rows );\n        assert( column &lt; columns );\n \n        matrix[ row ][ column ] = value;\n      }\n \n      //-------------------------------------------------------------\n      // Return part of the matrix.\n      // NOTE: The end points are the last elements copied.  They can\n      // be equal to the first element when wanting just a single row\n      // or column.  However, the span of the total matrix is\n      // ( 0, rows - 1, 0, columns - 1 ).\n      //-------------------------------------------------------------\n      Matrix getSubMatrix\n      (\n        unsigned startRow,\n        unsigned endRow,\n        unsigned startColumn,\n        unsigned endColumn,\n        unsigned const * newOrder = NULL\n      )\n      {\n        Matrix subMatrix( endRow - startRow + 1, endColumn - startColumn + 1 );\n \n        for ( unsigned row = startRow; row &lt;= endRow; ++row )\n        {\n          unsigned subRow;\n          if ( NULL == newOrder )\n            subRow = row;\n          else\n            subRow = newOrder[ row ];\n \n          for ( unsigned column = startColumn; column &lt;= endColumn; ++column )\n            subMatrix.matrix[ row - startRow ][ column - startColumn ] =\n              matrix[ subRow ][ column ];\n        }\n \n        return subMatrix;\n      }\n \n      //-------------------------------------------------------------\n      // Return a single column from the matrix.\n      //-------------------------------------------------------------\n      Matrix getColumn\n      (\n        unsigned column\n      )\n      {\n        return getSubMatrix( 0, rows - 1, column, column );\n      }\n \n      //-------------------------------------------------------------\n      // Return a single row from the matrix.\n      //-------------------------------------------------------------\n      Matrix getRow\n      (\n        unsigned row\n      )\n      {\n        return getSubMatrix( row, row, 0, columns - 1 );\n      }\n \n      //-------------------------------------------------------------\n      // Place matrix in reduced row echelon form.\n      //-------------------------------------------------------------\n      void reducedRowEcholon()\n      {\n        TYPE const ZERO = static_cast&lt; TYPE &gt;( 0 );\n \n        // For each row...\n        for ( unsigned rowIndex = 0; rowIndex &lt; rows; ++rowIndex )\n        {\n          // Reorder the rows.\n          reorder();\n \n          unsigned row = order[ rowIndex ];\n \n          // Divide row down so first term is 1.\n          unsigned column = getLeadingZeros( row );\n          TYPE divisor = matrix[ row ][ column ];\n          if ( ZERO != divisor )\n          {\n            divideRow( row, divisor );\n \n            // Subtract this row from all subsequent rows.\n            for ( unsigned subRowIndex = ( rowIndex + 1 ); subRowIndex &lt; rows; ++subRowIndex )\n            {\n              unsigned subRow = order[ subRowIndex ];\n              if ( ZERO != matrix[ subRow ][ column ] )\n                rowOperation\n                (\n                  subRow,\n                  row,\n                  -matrix[ subRow ][ column ]\n                );\n            }\n          }\n \n        }\n \n        // Back substitute all lower rows.\n        for ( unsigned rowIndex = ( rows - 1 ); rowIndex &gt; 0; --rowIndex )\n        {\n          unsigned row = order[ rowIndex ];\n          unsigned column = getLeadingZeros( row );\n          for ( unsigned subRowIndex = 0; subRowIndex &lt; rowIndex; ++subRowIndex )\n          {\n            unsigned subRow = order[ subRowIndex ];\n            rowOperation\n            (\n              subRow,\n              row,\n              -matrix[ subRow ][ column ]\n            );\n          }\n        }\n \n      } // reducedRowEcholon\n \n      //-------------------------------------------------------------\n      // Return the determinant of the matrix.\n      // Recursive function.\n      //-------------------------------------------------------------\n      TYPE determinant() const\n      {\n        TYPE result = static_cast&lt; TYPE &gt;( 0 );\n \n        // Must have a square matrix to even bother.\n        assert( rows == columns );\n \n        if ( rows &gt; 2 )\n        {\n          int sign = 1;\n          for ( unsigned column = 0; column &lt; columns; ++column )\n          {\n            TYPE subDeterminant;\n \n            Matrix subMatrix = Matrix( *this, 0, column );\n \n            subDeterminant  = subMatrix.determinant();\n            subDeterminant *= matrix[ 0 ][ column ];\n \n            if ( sign &gt; 0 )\n              result += subDeterminant;\n            else\n              result -= subDeterminant;\n \n            sign = -sign;\n          }\n        }\n        else\n        {\n          result = ( matrix[ 0 ][ 0 ] * matrix[ 1 ][ 1 ] )\n                 - ( matrix[ 0 ][ 1 ] * matrix[ 1 ][ 0 ] );\n        }\n \n        return result;\n \n      } // determinant\n \n      //-------------------------------------------------------------\n      // Calculate a dot product between this and an other matrix.\n      //-------------------------------------------------------------\n      TYPE dotProduct\n      (\n        Matrix const &amp; otherMatrix\n      ) const\n      {\n        // Dimentions of each matrix must be the same.\n        assert( rows == otherMatrix.rows );\n        assert( columns == otherMatrix.columns );\n \n        TYPE result = static_cast&lt; TYPE &gt;( 0 );\n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n          {\n            result +=\n              matrix[ row ][ column ]\n              * otherMatrix.matrix[ row ][ column ];\n          }\n \n        return result;\n \n      } // dotProduct\n \n      //-------------------------------------------------------------\n      // Return the transpose of the matrix.\n      //-------------------------------------------------------------\n      Matrix const getTranspose() const\n      {\n        Matrix result( columns, rows );\n \n        // Transpose the matrix by filling the result\'s rows will\n        // these columns, and vica versa.\n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            result.matrix[ column ][ row ] = matrix[ row ][ column ];\n \n        return result;\n \n      } // transpose\n \n      //-------------------------------------------------------------\n      // Transpose the matrix.\n      //-------------------------------------------------------------\n      void transpose()\n      {\n        *this = getTranspose();\n      }\n \n      //-------------------------------------------------------------\n      // Return inverse matrix.\n      //-------------------------------------------------------------\n      Matrix const getInverse() const\n      {\n        // Concatenate the identity matrix onto this matrix.\n        Matrix inverseMatrix\n          (\n            *this,\n            IdentityMatrix&lt; TYPE &gt;( rows, columns ),\n            TO_RIGHT\n          );\n \n        // Row reduce this matrix.  This will result in the identity\n        // matrix on the left, and the inverse matrix on the right.\n        inverseMatrix.reducedRowEcholon();\n \n        // Copy the inverse matrix data back to this matrix.\n        Matrix result\n        (\n          inverseMatrix.getSubMatrix\n          (\n            0,\n            rows - 1,\n            columns,\n            columns + columns - 1,\n            inverseMatrix.order\n          )\n        );\n \n        return result;\n \n      } // invert\n \n \n      //-------------------------------------------------------------\n      // Invert this matrix.\n      //-------------------------------------------------------------\n      void invert()\n      {\n        *this = getInverse();\n \n      } // invert\n \n      //=======================================================================\n      // Operators.\n      //=======================================================================\n \n      //-------------------------------------------------------------\n      // Add by an other matrix.\n      //-------------------------------------------------------------\n      Matrix const operator +\n      (\n        Matrix const &amp; otherMatrix\n      ) const\n      {\n        assert( otherMatrix.rows == rows );\n        assert( otherMatrix.columns == columns );\n \n        Matrix result( rows, columns );\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            result.matrix[ row ][ column ] =\n              matrix[ row ][ column ]\n              + otherMatrix.matrix[ row ][ column ];\n \n        return result;\n      }\n \n      //-------------------------------------------------------------\n      // Add self by an other matrix.\n      //-------------------------------------------------------------\n      Matrix const &amp; operator +=\n      (\n        Matrix const &amp; otherMatrix\n      )\n      {\n        *this = *this + otherMatrix;\n        return *this;\n      }\n \n      //-------------------------------------------------------------\n      // Subtract by an other matrix.\n      //-------------------------------------------------------------\n      Matrix const operator -\n      (\n        Matrix const &amp; otherMatrix\n      ) const\n      {\n        assert( otherMatrix.rows == rows );\n        assert( otherMatrix.columns == columns );\n \n        Matrix result( rows, columns );\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            result.matrix[ row ][ column ] =\n              matrix[ row ][ column ]\n              - otherMatrix.matrix[ row ][ column ];\n \n        return result;\n      }\n \n      //-------------------------------------------------------------\n      // Subtract self by an other matrix.\n      //-------------------------------------------------------------\n      Matrix const &amp; operator -=\n      (\n        Matrix const &amp; otherMatrix\n      )\n      {\n        *this = *this - otherMatrix;\n        return *this;\n      }\n \n      //-------------------------------------------------------------\n      // Matrix multiplication.\n      //-------------------------------------------------------------\n      Matrix const operator *\n      (\n        Matrix const &amp; otherMatrix\n      ) const\n      {\n        TYPE const ZERO = static_cast&lt; TYPE &gt;( 0 );\n \n        assert( otherMatrix.rows == columns );\n \n        Matrix result( rows, otherMatrix.columns );\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; otherMatrix.columns; ++column )\n          {\n            result.matrix[ row ][ column ] = ZERO;\n \n            for ( unsigned index = 0; index &lt; columns; ++index )\n              result.matrix[ row ][ column ] +=\n                matrix[ row ][ index ]\n                * otherMatrix.matrix[ index ][ column ];\n          }\n \n        return result;\n      }\n \n      //-------------------------------------------------------------\n      // Multiply self by matrix.\n      //-------------------------------------------------------------\n      Matrix const &amp; operator *=\n      (\n        Matrix const &amp; otherMatrix\n      )\n      {\n        *this = *this * otherMatrix;\n        return *this;\n      }\n \n      //-------------------------------------------------------------\n      // Multiply by scalar constant.\n      //-------------------------------------------------------------\n      Matrix const operator *\n      (\n        TYPE const &amp; scalar\n      ) const\n      {\n        Matrix result( rows, columns );\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            result.matrix[ row ][ column ] = matrix[ row ][ column ] * scalar;\n \n        return result;\n      }\n \n      //-------------------------------------------------------------\n      // Multiply self by scalar constant.\n      //-------------------------------------------------------------\n      Matrix const &amp; operator *=\n      (\n        TYPE const &amp; scalar\n      )\n      {\n        *this = *this * scalar;\n        return *this;\n      }\n \n      //-------------------------------------------------------------\n      // Copy matrix.\n      //-------------------------------------------------------------\n      Matrix &amp; operator =\n      (\n        Matrix const &amp; otherMatrix\n      )\n      {\n        if ( this == &amp;otherMatrix )\n          return *this;\n \n        // Release memory currently in use.\n        deallocate( rows, columns );\n \n        rows    = otherMatrix.rows;\n        columns = otherMatrix.columns;\n        allocate( rows, columns );\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            matrix[ row ][ column ] =\n            otherMatrix.matrix[ row ][ column ];\n \n        return *this;\n      }\n \n      //-------------------------------------------------------------\n      // Copy matrix data from array.\n      // Although matrix data is two dimensional, this copy function\n      // assumes the previous row is immediately followed by the next\n      // row\'s data.\n      //\n      // Example for 3x2 matrix:\n      //     int const data[ 3 * 2 ] =\n      //     {\n      //       1, 2, 3,\n      //       4, 5, 6\n      //     };\n      //    Matrix&lt; int &gt; matrix( 3, 2 );\n      //    matrix = data;\n      //-------------------------------------------------------------\n      Matrix &amp; operator =\n      (\n        TYPE const * data\n      )\n      {\n        unsigned index = 0;\n \n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            matrix[ row ][ column ] = data[ index++ ];\n \n        return *this;\n      }\n \n      //-----------------------------------------------------------------------\n      // Return true if this matrix is the same of parameter.\n      //-----------------------------------------------------------------------\n      bool operator ==\n      (\n        Matrix const &amp; value\n      ) const\n      {\n        bool isEqual = true;\n        for ( unsigned row = 0; row &lt; rows; ++row )\n          for ( unsigned column = 0; column &lt; columns; ++column )\n            if ( matrix[ row ][ column ] != value.matrix[ row ][ column ] )\n              isEqual = false;\n \n        return isEqual;\n      }\n \n      //-----------------------------------------------------------------------\n      // Return true if this matrix is NOT the same of parameter.\n      //-----------------------------------------------------------------------\n      bool operator !=\n      (\n        Matrix const &amp; value\n      ) const\n      {\n        return !( *this == value );\n      }\n \n      //-------------------------------------------------------------\n      // Constructor for empty matrix.\n      // Only useful if matrix is being assigned (i.e. copied) from\n      // somewhere else sometime after construction.\n      //-------------------------------------------------------------\n      Matrix()\n      :\n        rows( 0 ),\n        columns( 0 )\n      {\n        allocate( 0, 0 );\n      }\n \n      //-------------------------------------------------------------\n      // Constructor using rows and columns.\n      //-------------------------------------------------------------\n      Matrix\n      (\n        unsigned rowsParameter,\n        unsigned columnsParameter\n      )\n      :\n        rows( rowsParameter ),\n        columns( columnsParameter )\n      {\n        TYPE const ZERO = static_cast&lt; TYPE &gt;( 0 );\n \n        // Allocate memory for new matrix.\n        allocate( rows, columns );\n \n        // Fill matrix with zero.\n        for ( unsigned row = 0; row &lt; rows; ++row )\n        {\n          order[ row ] = row;\n \n          for ( unsigned column = 0; column &lt; columns; ++column )\n            matrix[ row ][ column ] = ZERO;\n        }\n      }\n \n      //-------------------------------------------------------------\n      // This constructor will allow the creation of a matrix based off\n      // an other matrix.  It can copy the matrix entirely, or omitted a\n      // row/column.\n      //-------------------------------------------------------------\n      Matrix\n      (\n        Matrix const &amp; copyMatrix,\n        unsigned omittedRow    = INT_MAX,\n        unsigned omittedColumn = INT_MAX\n      )\n      {\n        // Start with the number of rows/columns from matrix to be copied.\n        rows    = copyMatrix.getRows();\n        columns = copyMatrix.getColumns();\n \n        // If a row is omitted, then there is one less row.\n        if ( INT_MAX != omittedRow  )\n          rows--;\n \n        // If a column is omitted, then there is one less column.\n        if ( INT_MAX != omittedColumn )\n          columns--;\n \n        // Allocate memory for new matrix.\n        allocate( rows, columns );\n \n        unsigned rowIndex = 0;\n        for ( unsigned row = 0; row &lt; rows; ++row )\n        {\n          // If this row is to be skipped...\n          if ( rowIndex == omittedRow )\n            rowIndex++;\n \n          // Set default order.\n          order[ row ] = row;\n \n          unsigned columnIndex = 0;\n          for ( unsigned column = 0; column &lt; columns; ++column )\n          {\n            // If this column is to be skipped...\n            if ( columnIndex == omittedColumn )\n              columnIndex++;\n \n            matrix[ row ][ column ] = copyMatrix.matrix[ rowIndex ][ columnIndex ];\n \n            columnIndex++;\n          }\n \n          ++rowIndex;\n        }\n \n      }\n \n      //-------------------------------------------------------------\n      // Constructor to concatenate two matrices.  Concatenation\n      // can be done to the right, or to the bottom.\n      //   A = [B | C]\n      //-------------------------------------------------------------\n      Matrix\n      (\n        Matrix const &amp; copyMatrixA,\n        Matrix const &amp; copyMatrixB,\n        Position position = TO_RIGHT\n      )\n      {\n        unsigned rowOffset    = 0;\n        unsigned columnOffset = 0;\n \n        if ( TO_RIGHT == position )\n          columnOffset = copyMatrixA.columns;\n        else\n          rowOffset = copyMatrixA.rows;\n \n        rows    = copyMatrixA.rows    + rowOffset;\n        columns = copyMatrixA.columns + columnOffset;\n \n        // Allocate memory for new matrix.\n        allocate( rows, columns );\n \n        for ( unsigned row = 0; row &lt; copyMatrixA.rows; ++row )\n          for ( unsigned column = 0; column &lt; copyMatrixA.columns; ++column )\n            matrix[ row ][ column ] = copyMatrixA.matrix[ row ][ column ];\n \n        for ( unsigned row = 0; row &lt; copyMatrixB.rows; ++row )\n          for ( unsigned column = 0; column &lt; copyMatrixB.columns; ++column )\n            matrix[ row + rowOffset ][ column + columnOffset ] =\n              copyMatrixB.matrix[ row ][ column ];\n      }\n \n      //-------------------------------------------------------------\n      // Destructor.\n      //-------------------------------------------------------------\n      ~Matrix()\n      {\n        // Release memory.\n        deallocate( rows, columns );\n      }\n \n  };\n \n//=============================================================================\n// Class for identity matrix.\n//=============================================================================\ntemplate&lt; class TYPE &gt;\n  class IdentityMatrix : public Matrix&lt; TYPE &gt;\n  {\n    public:\n      IdentityMatrix\n      (\n        unsigned rowsParameter,\n        unsigned columnsParameter\n      )\n      :\n        Matrix&lt; TYPE &gt;( rowsParameter, columnsParameter )\n      {\n        TYPE const ZERO = static_cast&lt; TYPE &gt;( 0 );\n        TYPE const ONE  = static_cast&lt; TYPE &gt;( 1 );\n \n        for ( unsigned row = 0; row &lt; Matrix&lt; TYPE &gt;::rows; ++row )\n        {\n          for ( unsigned column = 0; column &lt; Matrix&lt; TYPE &gt;::columns; ++column )\n            if ( row == column )\n              Matrix&lt; TYPE &gt;::matrix[ row ][ column ] = ONE;\n            else\n              Matrix&lt; TYPE &gt;::matrix[ row ][ column ] = ZERO;\n        }\n      }\n  };\n \n//-----------------------------------------------------------------------------\n// Stream operator used to convert matrix class to a string.\n//-----------------------------------------------------------------------------\ntemplate&lt; class TYPE &gt;\n  std::ostream &amp; operator&lt;&lt;\n  (\n    // Stream data to place string.\n    std::ostream &amp; stream,\n \n    // A matrix.\n    Matrix&lt; TYPE &gt; const &amp; matrix\n  )\n  {\n    for ( unsigned row = 0; row &lt; matrix.getRows(); ++row )\n    {\n      for ( unsigned column = 0; column &lt; matrix.getColumns(); ++column )\n        stream &lt;&lt; \'	\' &lt;&lt; matrix.get( row , column );\n \n      stream &lt;&lt; std::endl;\n    }\n \n    return stream;\n  }\n \n#endif // _MATRIX_H_</pre>\n <p>\n  <br/>\n </p>\n</div>\n</body></html>'),('22c84dab5069fb06b3f2064f569bbc57','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  EditText作为密码输入框，隐藏输入密码\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <pre><code>        android:inputType=\'textPassword\'\n</code></pre>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c15acf0441d2dfd9aeda6b43e859f7a9','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  win10和ubuntu双系统安装后用easybcd添加ubuntu引导无效\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <p>\n    关于如何安装系统网上已经一大堆的教程，推荐\n    <a href=\'http://www.jianshu.com/p/2eebd6ad284d\'>\n     http://www.jianshu.com/p/2eebd6ad284d\n    </a>\n    此教程。\n    <br/>\n    本次教程是使用传统bios,在bios设置里面改成了leagual suport 和 leagual first，以及other os.\n    <br/>\n    在安装过程中\n    <img alt=\'这里写图片描述\' src=\'http://img.blog.csdn.net/20170204122732364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNTENFUg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\' title=\'\'/>\n    要注意安装启动器的设备要和/boot的盘保持一致。\n    <br/>\n    否则会出现用easybcd添加ubuntu加载项失败的情况\n   </p>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('cedb01cd68b6f4d3779ee2b4ad266851','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  谷歌键盘切换26键与九宫格中文输入法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <p>\n    今天不小心把手输入法改成了九宫格，很不习惯，在设置里面找了很久也没找到，百度也没有找到答案。\n    <br/>\n    最终偶然发现解决方案。\n    <br/>\n    <img alt=\'这里写图片描述\' src=\'http://img.blog.csdn.net/20170204120458103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNTENFUg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\' title=\'\'/>\n    <br/>\n    长按【中】出现如下界面，即可切换26键与九宫格。\n   </p>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('e0c9b990f04a2e0e8533c503a8e5c693','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  用matlab实现自定义函数的数据拟合\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <ol>\n    <li>\n     <p>\n      matlab版本以及问题数据介绍\n      <br/>\n      本人使用的matlab为2012b，数据见下图\n      <img alt=\'这里写图片描述\' src=\'http://img.blog.csdn.net/20160802082957764\' title=\'\'/>\n     </p>\n    </li>\n    <li>\n     <p>\n      实现过程\n     </p>\n     <ol>\n      <li>\n       <p>\n        输入数据\n        <br/>\n        <img alt=\'这里写图片描述\' src=\'http://img.blog.csdn.net/20160802083530533\' title=\'\'/>\n       </p>\n      </li>\n      <li>\n       <p>\n        打开Curve Fiting Tools\n        <br/>\n        位于apps第一个工具\n       </p>\n      </li>\n      <li>\n       <p>\n        设置变量并输入自定义函数\n        <br/>\n        <img alt=\'设置x、y\' src=\'http://img.blog.csdn.net/20160802084233099\' title=\'\'/>\n       </p>\n       <p>\n        <img alt=\'输入自定义函数\' src=\'http://img.blog.csdn.net/20160802084410024\' title=\'\'/>\n       </p>\n      </li>\n      <li>\n       <p>\n        输出结果\n        <br/>\n        <img alt=\'这里写图片描述\' src=\'http://img.blog.csdn.net/20160802084604569\' title=\'\'/>\n        <br/>\n        左侧为数据参数，右侧为拟合图像。\n       </p>\n      </li>\n     </ol>\n    </li>\n   </ol>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('36059f5c40734914bfc32082dd42db45','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Kruskal算法\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <ol>\n    <li>\n     <p>\n      算法实现思想及功能\n      <br/>\n      Kruskal算法是求解最小生成树的一种算法。实现思想是首先将边按照权值大小排列，然后从权值最小的边开始加入最小生成树中，但是如果出现新加入的边与原来的图连成环，则不取该边。（这里使用查找根节点的方法实现，如果相同，则成环。如果不同，则加入，并把新加入的边的权值根节点更新。）\n     </p>\n    </li>\n    <li>\n     <p>\n      代码展示\n     </p>\n    </li>\n   </ol>\n   <pre class=\'prettyprint\'><code class=\' hljs cpp\'><span class=\'hljs-preprocessor\'>#include &lt;iostream&gt;</span>\n<span class=\'hljs-preprocessor\'>#include &lt;cstring&gt;</span>\n<span class=\'hljs-preprocessor\'>#include &lt;string&gt;</span>\n<span class=\'hljs-preprocessor\'>#include &lt;cstdio&gt;</span>\n<span class=\'hljs-preprocessor\'>#include &lt;algorithm&gt;</span>\n<span class=\'hljs-keyword\'>using</span> <span class=\'hljs-keyword\'>namespace</span> <span class=\'hljs-built_in\'>std</span>;\n<span class=\'hljs-preprocessor\'>#define MAX 1000</span>\n<span class=\'hljs-keyword\'>int</span> father[MAX], son[MAX];\n<span class=\'hljs-keyword\'>int</span> v, l;\n\n<span class=\'hljs-keyword\'>typedef</span> <span class=\'hljs-keyword\'>struct</span> Kruskal <span class=\'hljs-comment\'>//存储边的信息</span>\n{\n    <span class=\'hljs-keyword\'>int</span> a;\n    <span class=\'hljs-keyword\'>int</span> b;\n    <span class=\'hljs-keyword\'>int</span> value;\n};\n\n<span class=\'hljs-keyword\'>bool</span> cmp(<span class=\'hljs-keyword\'>const</span> Kruskal &amp; a, <span class=\'hljs-keyword\'>const</span> Kruskal &amp; b)\n{\n    <span class=\'hljs-keyword\'>return</span> a.value &lt; b.value;\n}\n\n<span class=\'hljs-keyword\'>int</span> unionsearch(<span class=\'hljs-keyword\'>int</span> x) <span class=\'hljs-comment\'>//查找根结点+路径压缩</span>\n{\n    <span class=\'hljs-keyword\'>return</span> x == father[x] ? x : unionsearch(father[x]);\n}\n\n<span class=\'hljs-keyword\'>bool</span> join(<span class=\'hljs-keyword\'>int</span> x, <span class=\'hljs-keyword\'>int</span> y) <span class=\'hljs-comment\'>//合并</span>\n{\n    <span class=\'hljs-keyword\'>int</span> root1, root2;\n    root1 = unionsearch(x);\n    root2 = unionsearch(y);\n    <span class=\'hljs-keyword\'>if</span>(root1 == root2) <span class=\'hljs-comment\'>//为环</span>\n        <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>false</span>;\n    <span class=\'hljs-keyword\'>else</span> <span class=\'hljs-keyword\'>if</span>(son[root1] &gt;= son[root2])   father[root2] = root1;\n    <span class=\'hljs-keyword\'>else</span>    father[root1] = root2;\n    <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-keyword\'>true</span>;\n}\n\n<span class=\'hljs-keyword\'>int</span> main()\n{\n    <span class=\'hljs-keyword\'>int</span> ncase, ltotal, sum, flag;\n    Kruskal edge[MAX];\n    <span class=\'hljs-built_in\'>scanf</span>(<span class=\'hljs-string\'>\'%d\'</span>, &amp;ncase);\n    <span class=\'hljs-keyword\'>while</span>(ncase--)\n    {\n        <span class=\'hljs-built_in\'>scanf</span>(<span class=\'hljs-string\'>\'%d%d\'</span>, &amp;v, &amp;l);\n        ltotal = <span class=\'hljs-number\'>0</span>, sum = <span class=\'hljs-number\'>0</span>, flag = <span class=\'hljs-number\'>0</span>;\n\n        <span class=\'hljs-keyword\'>for</span>(<span class=\'hljs-keyword\'>int</span> i = <span class=\'hljs-number\'>1</span>; i &lt;= v; ++i) <span class=\'hljs-comment\'>//初始化</span>\n        father[i] = i;\n\n        <span class=\'hljs-keyword\'>for</span>(<span class=\'hljs-keyword\'>int</span> i = <span class=\'hljs-number\'>1</span>; i &lt;= l ; ++i)\n        <span class=\'hljs-built_in\'>scanf</span>(<span class=\'hljs-string\'>\'%d%d%d\'</span>, &amp;edge[i].a, &amp;edge[i].b, &amp;edge[i].value);\n\n        sort(edge + <span class=\'hljs-number\'>1</span>, edge + <span class=\'hljs-number\'>1</span> + l, cmp); <span class=\'hljs-comment\'>//按权值由小到大排序</span>\n        <span class=\'hljs-keyword\'>for</span>(<span class=\'hljs-keyword\'>int</span> i = <span class=\'hljs-number\'>1</span>; i &lt;= l; ++i)\n        {\n            <span class=\'hljs-keyword\'>if</span>(join(edge[i].a, edge[i].b))\n            {\n                ltotal++;               <span class=\'hljs-comment\'>//边数加1</span>\n                sum += edge[i].value;   <span class=\'hljs-comment\'>//记录权值之和</span>\n                <span class=\'hljs-built_in\'>cout</span>&lt;&lt;edge[i].a&lt;&lt;<span class=\'hljs-string\'>\'-&gt;\'</span>&lt;&lt;edge[i].b&lt;&lt;endl;\n            }\n            <span class=\'hljs-keyword\'>if</span>(ltotal == v - <span class=\'hljs-number\'>1</span>)         <span class=\'hljs-comment\'>//最小生成树条件：边数=顶点数-1</span>\n            {\n                flag = <span class=\'hljs-number\'>1</span>;\n                <span class=\'hljs-keyword\'>break</span>;\n            }\n        }\n        <span class=\'hljs-keyword\'>if</span>(flag) <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'%d\n\'</span>, sum);\n        <span class=\'hljs-keyword\'>else</span> <span class=\'hljs-built_in\'>printf</span>(<span class=\'hljs-string\'>\'data error.\n\'</span>);\n    }\n    <span class=\'hljs-keyword\'>return</span> <span class=\'hljs-number\'>0</span>;\n}</code></pre>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('ed70f3689645512220f95a29fe978061','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Floyd算法及代码演示\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   Floyd算法与Dijstra的区别在于Floyd计算的是任意两点间的最短路径。\n  </p>\n  <p>\n   可以这样思考，首先是各点都不允许借路通过，然后依次从第一个点到最后一个点均允许借路通过，每次均取最短路，则到最后求得的就是各个点的最短路。\n  </p>\n  <p>\n   状态转移公式为Dk(i,j)=min(Dk-1(i,j),Dk-1(i,k)+Dk-1(k,j));\n  </p>\n  <p>\n   测试样例\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20160720181440392?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\'/>\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1773899\' name=\'code\' snippet_file_name=\'blog_20160720_1_7249373\'>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;stdio.h&gt;\nusing namespace std;\n#define MaxVertexNum 100\n#define INF 32767\ntypedef struct\n{\n        char vertex[MaxVertexNum];\n        int edges[MaxVertexNum][MaxVertexNum];\n        int n,e;\n}MGraph;\nvoid CreateMGraph(MGraph &amp;G)\n{\n     int i,j,k,p;\n     cout &lt;&lt; \'请输入顶点数和边数:\'; \n     cin &gt;&gt; G.n &gt;&gt; G.e;\n     cout &lt;&lt; \'请输入顶点元素：\';\n     for(i = 0;i &lt; G.n;i++)\n         cin &gt;&gt; G.vertex[i];\n     for(i = 0;i &lt; G.n;i++)\n           for(j = 0;j &lt; G.n;j++)\n           {\n                 G.edges[i][j] = INF;\n                 if(i == j)\n                      G.edges[i][j] = 0;\n           }\n     for(k = 0;k &lt; G.e;k++)\n     {\n           cout &lt;&lt; \'请输入第\' &lt;&lt; k+1 &lt;&lt; \'条弧头弧尾序号和相应的权值:\';\n           cin &gt;&gt; i &gt;&gt; j &gt;&gt; p;\n           G.edges[i][j] = p;\n     }\n}\nvoid Ppath(MGraph &amp;G,int path[][MaxVertexNum],int i,int j)\n{\n     int k;\n     k = path[i][j];\n     if (k == -1)\n        return;\n     Ppath(G,path,i,k);\n     printf(\'%c\',G.vertex[k]); \n     Ppath(G,path,k,j);\n}\nvoid Dispath(MGraph &amp;G,int A[][MaxVertexNum],int path[][MaxVertexNum],int n)\n{\n     int i,j;\n     for(i = 0;i &lt; n;i++)\n     for(j = 0;j &lt; n;j++)\n     {\n           if(A[i][j] == INF)\n           {\n                if(i != j)\n                     printf(\'从%d到%d没有路径\n\',i,j);\n           }\n           else\n           {\n               printf(\'从%c到%c=&gt;路径长度：%d 路径：\',G.vertex[i],G.vertex[j],A[i][j]);\n               printf(\'%c\',G.vertex[i]);\n               Ppath(G,path,i,j);\n               printf(\'%c\n\',G.vertex[j]);\n           }\n     }\n}\nvoid Floyd(MGraph &amp;G)\n{\n     int i,j,k;\n     int A[MaxVertexNum][MaxVertexNum];\n     int path[MaxVertexNum][MaxVertexNum];\n     for(i = 0;i &lt; G.n;i++)\n           for(j = 0;j &lt; G.n;j++)\n           {\n                 A[i][j] = G.edges[i][j];\n                 path[i][j] = -1;\n           }\n     for(k = 0;k &lt; G.n;k++)\n     for(i = 0;i &lt; G.n;i++)\n     for(j = 0;j &lt; G.n;j++)\n           if(A[i][j] &gt; A[i][k] + A[k][j])\n           {\n                      A[i][j] = A[i][k] + A[k][j];\n                      path[i][j] = k; \n           }\n     Dispath(G,A,path,G.n);\n}\nint main()\n{\n    MGraph G;\n    CreateMGraph(G);\n    Floyd(G);\n    return 0;\n}</pre>\n  <br/>\n  运行结果：\n  <p>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20160720181905991?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\'/>\n   <br/>\n  </p>\n  <p>\n   <br/>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('46b7c5ddc82af44de04e08c46223dbd9','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Dijstra算法代码描述\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   图论学过很多次的最短路问题，其中Dijstra算法是一个经典的解决求图中某一点到其他所有点的算法，思想理解了很多遍，但是不知道代码怎么写！\n  </p>\n  <p>\n   如果要理解算法的话网上很多博客都有讲的，这里把代码和运行过程来分享一下。\n  </p>\n  <p>\n   代码是根据http://blog.csdn.net/hackerain/article/details/6055925稍加修改的，原文是使用文件读写，但是没有把文件贴出来，这里我自己画了一张图，采用标准输入（键盘输入），最终打印出路径和路径长度。\n  </p>\n  <p>\n   此图有6个顶点，十条边。依次输入图的信息。\n  </p>\n  <p>\n   <img alt=\'\' src=\'http://img.blog.csdn.net/20160720153026415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\'/>\n  </p>\n  <p>\n  </p>\n  <pre class=\'cpp\' code_snippet_id=\'1773380\' name=\'code\' snippet_file_name=\'blog_20160720_1_919544\'>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n/*邻接矩阵的类型定义*/\n#define MAX 10000000\n#define MAX_VERTEX_NUM 20\ntypedef struct\n{\n	string vexs[MAX_VERTEX_NUM];//用一维数组存储顶点信息\n	int edges[MAX_VERTEX_NUM][MAX_VERTEX_NUM];//用二维数组充当矩阵，来存储顶点边的信息\n	int vexnum,edgenum;//顶点树和边数\n}MGraph;\n/*构造有向网的邻接矩阵*/\nvoid CreateDN_AM(MGraph &amp;G,int n,int e)\n{\n	G.vexnum=n;\n	G.edgenum=e;\n	\n	int i,j,k;\n	int weight;\n	for(i=0;i&lt;n;i++){\n		cout&lt;&lt;\'请输入第\'&lt;&lt;i+1&lt;&lt;\'顶点信息：\';\n		cin&gt;&gt;G.vexs[i];//输入顶点信息\n	}\n	for(i=0;i&lt;n;i++)\n		for(j=0;j&lt;n;j++)\n			G.edges[i][j]=MAX;//将矩阵初始化为MAX\n	for(k=0;k&lt;e;k++)\n	{\n		cout&lt;&lt;\'依次输入第\'&lt;&lt;k+1&lt;&lt;\'边的顶点，终点，权值：\';\n		cin&gt;&gt;i&gt;&gt;j&gt;&gt;weight;\n		G.edges[i][j]=weight;\n		G.edges[j][i]=weight;\n	}\n}\n/*迪杰斯特拉算法求某个顶点到其余顶点的最短路径*/\nvoid ShortestPath_DJ(MGraph &amp;G,int v)\n{\n	int i,j,k,min;\n	int final[MAX_VERTEX_NUM];//该数组用来标识顶点是否已确定了最短路径\n	int dist[MAX_VERTEX_NUM];\n	string path[2*MAX_VERTEX_NUM];\n	for(i=0;i&lt;G.vexnum;i++)\n	{									//初始化工作\n		dist[i]=G.edges[v][i];			//dist数组用来存储当前找到的v到其他各顶点的最短路径\n		if(dist[i]&lt;MAX)\n			path[i]=G.vexs[v]+G.vexs[i];//如果v到i有边的话，把顶点字符存到path字符数组中，表示路径\n		else\n			path[i]=\'\';\n		final[i]=0;//初始化标识数组为0\n	}\n	dist[v]=0;\n	final[v]=1;\n	for(j=1;j&lt;G.vexnum;j++)\n	{\n		min=MAX;\n		for(i=0;i&lt;G.vexnum;i++)\n			if(dist[i]&lt;min &amp;&amp; final[i]==0)\n			{\n				min=dist[i];\n				k=i;\n			}//找到dist数组中最小值的位置k\n		cout&lt;&lt;path[k]&lt;&lt;\' \'&lt;&lt;dist[k]&lt;&lt;endl;//输出最短路径\n		final[k]=1;//设置标志位\n		for(i=0;i&lt;G.vexnum;i++)\n		{//遍历每个顶点i和当前的已求出的最短路径的顶点k作比较，若从源点经过顶点k到顶点i的路径，比dist[i]小，\n			//则更新顶点dist[i]\n			if(dist[i]&gt;dist[k]+G.edges[k][i] &amp;&amp; final[i]==0)\n			{\n				dist[i]=dist[k]+G.edges[k][i];\n				path[i]=path[k]+G.vexs[i];\n			}\n		}//从整体上来看就是算出k的邻接点的当前最短路径\n	}\n}\nint main()\n{\n	MGraph G;\n	CreateDN_AM(G,6,10);\n	ShortestPath_DJ(G,0);\n}</pre>\n  <img alt=\'\' src=\'http://img.blog.csdn.net/20160720153410545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\'/>\n  <br/>\n  <p>\n   运行结果如图所示，最终输出A到各个点的最短路径及路径长度。\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('443fc92e998f5737d6b29a1e8f1c7bab','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  eclipse开发的安卓程序如何在手机上运行\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.通过usb接口把手机与电脑相连。\n  </p>\n  <p>\n   2.打开手机的设置，开发者选项，usb调试，允许手机与电脑相连即可。\n  </p>\n  <p>\n   有时候可能需要下载手机助手，博主手机为vivo y33.\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('a4f145f1afb8fa8dd4bc1a05efe8f9f2','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  eclipse关闭项目\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <p>\n    在eclipse每次使用开发不同项目时，最好把不相关的项目关闭，否则很容易发生错误，比如把需要的图片扔进另一个项目的drawable文件夹里面，在需要的项目里面就无法显示。\n    <br/>\n    关闭步骤：\n    <br/>\n    1.在Package Explorer中选中想要关闭的项目\n    <br/>\n    2.在上部工具栏中选择Project，close project 即可关闭当前项目\n   </p>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('dff68f3da21c455027057a454f2d5ddd','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  安卓TextView设置字体竖直排列\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <p>\n    1.属性介绍：\n    <br/>\n    安卓中有一个属性为android:ems=”x”\n    <br/>\n    x表示一行显示的字符个数。\n    <br/>\n    2.具体操作\n    <br/>\n    第一步：设置控件宽度为包裹内容android:layout_width=”wrap_content”\n    <br/>\n    第二步：设置每行显示一个字符\n    <br/>\n    android:ems=”1”\n   </p>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('5a251e1310c21914932022862a7fcd87','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  安卓按钮背景透明及按钮透明\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div class=\'markdown_views\'>\n   <p>\n    1.两大属性介绍：\n    <br/>\n    android:alpha=”0”       //实现按钮透明化，按钮就不可见了，包括上面的文字\n    <br/>\n    android:background=”#00000000”//设置按钮背景，背景透明，但是按钮上的文字仍然可见。也可以把图片设置为背景\n   </p>\n   <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('7c7519badd7e95230c38c7f7c27873fd','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  设置安卓背景图片\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   1.首先找到一张大小合适的图片，或者把它裁剪成大小合适的图片（可以用画图或者ps等工具），最后将其格式改成png(假设图片名为pic)。\n  </p>\n  <p>\n   2.在安卓工程目录res下创建新的文件夹drawable，并把图片拖入其中。\n  </p>\n  <p>\n   3.在布局中加入android:background=\'@drawable/pic\'（不用加文件扩展名png）\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('933abebb16b8d0ba1310601628878085','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  转折——新的征途\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <p>\n   <span style=\'font-size:18px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    <span style=\'white-space:pre\'>\n    </span>\n    夏天的风在傍晚显的格外清凉，隐约有种熟悉的味道，不知不觉我来到这个大学已经快一年了，一年前，独自一个人拖着行李箱，\n    <span style=\'font-size:18px\'>\n     踏上了火车，\n    </span>\n    来到了离家1000里以外的古都西安。高考填报志愿的时候，\n    <span style=\'font-size:18px\'>\n     没有理会家里人的反对，我把所有的专业都填了信息方面的专业，\n    </span>\n    也许对一个学信息的人来说，在这所学校并不是很好的归宿，但是觉得复习可能自己真的不喜欢，既然这样，不管在哪里，能够学到自己喜欢的专业也差不多了。\n   </span>\n  </p>\n  <p>\n   <span style=\'font-size:18px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    <span style=\'white-space:pre\'>\n    </span>\n    花了半年的时间勉强达到了标准，进入了ACM竞赛部，后来班里有同学要做APP，感觉精力不够分，于是开始专心学Java，安卓，以前一起训练的队友们都已经开始讲课了，他们的水平已经很不错了，因为分心的原因，自己各个方面都不是很出色，不过碰到了机遇，就去努力吧！这个暑假只有20多天在家，本来不想留任科协，想去专心学习的，结果。。。不管中间过程怎样，反正最后还是留任了，下一个学年的计划大概就是继续在科协举办比赛，顺便帮助A协办比赛，帮助15级软件学弟的成长，再带一个学习兴趣小组，其他的小组就交给Lee去带吧！还有就是努力做APP，不知道这个暑假能够学到什么水平，太差的话就又拖后腿了，我一直不是最出色的，我所能做的就是让自己尽量去努力。细细算来这些事情也不算少，足够自己下一年的忙碌了，总之，加油吧！纵有疾风起，人生不言弃。\n   </span>\n  </p>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('c12f3a16c70cf9cabf4463f744d08777','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  Java中对象数组的创建于使用\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <h1>\n   Java中创建对象数组的几种基本方法\n  </h1>\n  <div>\n   首先我们需要创建一个class\n  </div>\n  <div>\n   <pre class=\'java\' name=\'code\'>class Student{\n	String name;\n	double score;\n	String num;\n	\n	Student(String n,double s,String m){\n		name=n;\n		s=score;\n		num=m;\n	}\n\n	public static void printInfo(){\n		System.out.println(num+\',\'+name+\',\'+score);\n	}\n\n}</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   接下来我们对此类进行数组的创建：\n  </div>\n  <h2>\n   <pre class=\'java\' name=\'code\'>//1\nStudent stu[];&lt;span style=\'white-space:pre\'&gt;		&lt;/span&gt;//声明数组。\nstu=new Student [3];&lt;span style=\'white-space:pre\'&gt;	&lt;/span&gt;//创建数组，这里是创建的一个引用的数组，每一个引用并没有确切的地址。\nfor(int i=0;i&lt;3;i++){&lt;span style=\'white-space:pre\'&gt;	&lt;/span&gt;//为数组创建对象，也就是说为创建的引用关联到确切的地址。\n	stu[i]=new Student();\n}\n//2\nStudent stu[]=new Student [3];\nfor(int i=0;i&lt;3;i++){\n	stu[i]=new Student();\n}\n//3\nStudent stu[]=new Student{new Student(sjl,87,01),new Student(ljs,98,02),new Student(lls,92,03)};</pre>\n   <br/>\n   <br/>\n  </h2>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>'),('1f714067d27988d93910597155cb6c85','<html><head><meta charset=\'utf8\'></head><body><article>\n <h1 class=\'csdn_top\'>\n  字符串最短距离问题\n </h1>\n <div class=\'article_content csdn-tracking-statistics\' data-dsm=\'post\' data-mod=\'popu_519\' id=\'article_content\'>\n  <div>\n   <span style=\'font-size:32px\'>\n    <strong>\n     Question：\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    设有字符串X，称在X的头尾及中间插入任意多个空格后构成的新字符串为X的扩展串，如字符串X为“abcbcd”，则字符串“abcb□cd”，“□a□bcbcd□”和“abcb□cd□”都是X的扩展串，这里“□”代表空格字符。 如果A1是字符串A的扩展串，B1是字符串B的扩展串，A1与B1具有相同的长度，那么定义字符串A1与B1的距离为相应位置上的字符的距离总和，而两个非空格字符的距离定义为它们的ASCII码的差的绝对值，而空格字符与其它任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为0。在字符串A、B的所有扩展串中，必定存在两个等长的扩展串A1、B1，使得A1与B1之间的距离达到最小，将这一距离定义为字符串A、B的距离。请编写程序，求出字符串A、B的距离。\n   </span>\n  </div>\n  <div>\n   <strong>\n    <span style=\'font-size:24px\'>\n     Input\n    </span>\n   </strong>\n   <br/>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    每组数据输入字符串A1和B1以及常数K\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    <span style=\'font-size:24px\'>\n     <strong>\n      Output\n     </strong>\n    </span>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    输出字符串最短距离\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:32px\'>\n    <strong>\n     Sample:\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:24px\'>\n    <strong>\n     Input\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    cmc\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    snmn\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    2\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:24px\'>\n    <strong>\n     Output\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    10\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:32px\'>\n    <strong>\n     Analysis：\n    </strong>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    假设串A1,B1具有最短距离，那么A1[0],B1[0]只有如下三种情况：\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    <span style=\'white-space:pre\'>\n    </span>\n    Case 1\n    <span style=\'white-space:pre\'>\n    </span>\n    Case 2\n    <span style=\'white-space:pre\'>\n    </span>\n    Case 3\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    <br/>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    A\n    <span style=\'white-space:pre\'>\n    </span>\n    <span style=\'white-space:pre\'>\n    </span>\n    A1[0]\n    <span style=\'white-space:pre\'>\n    </span>\n    <span style=\'white-space:pre\'>\n    </span>\n    <span style=\'font-size:18px\'>\n     ____\n    </span>\n    <span style=\'white-space:pre\'>\n    </span>\n    <span style=\'font-size:18px\'>\n     A1[0]\n    </span>\n   </span>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    <span style=\'font-size:18px\'>\n     <br/>\n    </span>\n   </span>\n  </div>\n  <div>\n  </div>\n  <div>\n   <span style=\'font-size:18px\'>\n    B      ____\n    <span style=\'white-space:pre\'>\n    </span>\n    B1[0]\n    <span style=\'font-size:18px\'>\n     B1[0]\n    </span>\n    <span style=\'white-space:pre\'>\n    </span>\n   </span>\n  </div>\n  <div>\n   <br/>\n  </div>\n  <div>\n   每种情况我们需要求出后继子串的最短距离加上当前字符的距离，就得倒最短距离。\n  </div>\n  <div>\n   伪代码\n  </div>\n  <div>\n   <div>\n    <img alt=\'\' src=\'file:///C:UserssunshineAppDataRoamingTencentUsers2465637185QQWinTempRichOleAI5JRNZ$A%LXP$P3@Q~O[26.png\'/>\n   </div>\n   <pre class=\'cpp\' name=\'code\'>StrDis(s[0...slen],t[0...tlen])=min{\n    k+StrDis(s[1...len],t[0...tlen]),\n    k+StrDis(s[0...len],t[1...tlen]),\n    abs(s[0]-t[0])+StrDis(s[1..slen],t[1..tlen])\n}</pre>\n   代码\n  </div>\n  <div>\n   <pre class=\'cpp\' name=\'code\'>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\n#include &lt;cmath&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int Max=1050;int k,sum;\n#define LL long long\n#define CLR(a,b) memset(a,b,sizeof(a))\n\nint StrDis(char *s,char *t)\n{\n    int sum,i,temp[3];\n    if(s[0]==\'\0\'&amp;&amp;t[0]==\'\0\')\n        return 0;\n    if(s[0]!=\'\0\'&amp;&amp;t[0]==\'\0\')\n    {\n        for(sum=0,i=0;s[i]!=\'\0\';i++)\n            sum+=k;\n        return sum;\n    }\n    if(s[0]==\'\0\'&amp;&amp;t[0]!=\'\0\')\n    {\n        for(sum=0,i=0;t[i]!=\'\0\';i++)\n            sum+=k;\n        return sum;\n    }\n    temp[0]=StrDis(s+1,t)+k;\n    temp[1]=StrDis(s,t+1)+k;\n    temp[2]=StrDis(s+1,t+1)+abs(s[0]-t[0]);\n    sum=temp[0]&lt;temp[1]?temp[0]:temp[1];\n    sum=sum&lt;temp[2]?sum:temp[2];\n    return sum;\n}\nint main()\n{\n    char s[Max],t[Max];\n    while(~scanf(\'%s%s%d\',s,t,&amp;k))\n    {\n        sum=0;\n        sum=StrDis(s,t);\n        cout&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}\n</pre>\n   <br/>\n   <br/>\n  </div>\n  <div>\n   <div>\n    <img alt=\'\' src=\'file:///C:UserssunshineAppDataRoamingTencentUsers2465637185QQWinTempRichOleAI5JRNZ$A%LXP$P3@Q~O[26.png\'/>\n   </div>\n   <br/>\n  </div>\n  <link href=\'http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0\' rel=\'stylesheet\'/>\n </div>\n</article>\n</body></html>');
/*!40000 ALTER TABLE `page` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `name` char(20) DEFAULT NULL,
  `passwd` char(20) DEFAULT NULL,
  `photo` longtext,
  `model` longtext
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-11-04 16:20:11
