<html><head><meta charset="utf8"></head><body><article>
 <h1 class="csdn_top">
  POJ1182——带权并查集
 </h1>
 <div class="article_content csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" id="article_content">
  <p>
   1.问题描述：
  </p>
  <p>
  </p>
  <div class="ptt" lang="en-US" style="text-align:center; font-size:18pt; font-weight:bold; color:blue">
   食物链
  </div>
  <div class="plm" style="text-align:center; font-size:14px">
   <table align="center">
    <tbody>
     <tr>
      <td>
       <strong>
        Time Limit:
       </strong>
       1000MS
      </td>
      <td width="10px">
      </td>
      <td>
       <strong>
        Memory Limit:
       </strong>
       10000K
      </td>
     </tr>
     <tr>
      <td>
       <strong>
        Total Submissions:
       </strong>
       64435
      </td>
      <td width="10px">
      </td>
      <td>
       <strong>
        Accepted:
       </strong>
       18933
      </td>
     </tr>
    </tbody>
   </table>
  </div>
  <p>
  </p>
  <p class="pst" style="font-size:18pt; font-weight:bold; color:blue">
   Description
  </p>
  <div class="ptx" lang="en-US" style="font-family:'Times New Roman',Times,serif; font-size:14px">
   动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。
   <br/>
   现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。
   <br/>
   有人用两种说法对这N个动物所构成的食物链关系进行描述：
   <br/>
   第一种说法是"1 X Y"，表示X和Y是同类。
   <br/>
   第二种说法是"2 X Y"，表示X吃Y。
   <br/>
   此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。
   <br/>
   1） 当前的话与前面的某些真的话冲突，就是假话；
   <br/>
   2） 当前的话中X或Y比N大，就是假话；
   <br/>
   3） 当前的话表示X吃X，就是假话。
   <br/>
   你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。
   <br/>
  </div>
  <p class="pst" style="font-size:18pt; font-weight:bold; color:blue">
   Input
  </p>
  <div class="ptx" lang="en-US" style="font-family:'Times New Roman',Times,serif; font-size:14px">
   第一行是两个整数N和K，以一个空格分隔。
   <br/>
   以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。
   <br/>
   若D=1，则表示X和Y是同类。
   <br/>
   若D=2，则表示X吃Y。
  </div>
  <p class="pst" style="font-size:18pt; font-weight:bold; color:blue">
   Output
  </p>
  <div class="ptx" lang="en-US" style="font-family:'Times New Roman',Times,serif; font-size:14px">
   只有一个整数，表示假话的数目。
  </div>
  <p class="pst" style="font-size:18pt; font-weight:bold; color:blue">
   Sample Input
  </p>
  <pre class="sio" style="font-family:'Courier New',Courier,monospace; font-size:14px">100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
</pre>
  <p class="pst" style="font-size:18pt; font-weight:bold; color:blue">
   Sample Output
  </p>
  <pre class="sio" style="font-family:'Courier New',Courier,monospace; font-size:14px">3</pre>
  2.算法描述：
  <p>
   本题有两种思路，第一是开辟三个并查集同时进行维护
  </p>
  <p>
   第二是开辟一个带权并查集我们来记录，不相交集合中的元素之间的相对关系
  </p>
  <p>
   3.解释：
  </p>
  <p>
   3.1三个并查集：
  </p>
  <p>
   首先，我们先要明确一下三个并查集是如何作用的
  </p>
  <p>
   1.fa[1-n] 代表的全是A物种，fa[n+1-2*n]代表的全是B物种,fa[2*n+1-3*n]代表的全是C物种
  </p>
  <p>
   这是三个并查集，我们进行合并操作的额时候，首先需要明确一点，并查集的作用是将有“关系”的两个元素拉进同一颗树中，那么我们对于合法（真话）的操作如何进行合并操作呢
  </p>
  <p>
   如果关系值是1，说明是同类，我们unit(x,y),unit(x+n,y+n),unit(x+2*n,y+2*n)
  </p>
  <p>
   这三句话的含义是在这句话我们判断合法的前提下，我们认为A物种的x,y是同一物种，B物种的x,y是同一物种,C物种的x,y是同一物种（他们是有关系的）
  </p>
  <p>
   我们认为阿门是有关系的，并且在合法的前提下，他们既然有关系，说明他们的关系是同一物种
  </p>
  <p>
   <br/>
  </p>
  <p>
   如果关系值是2，代表x吃y，我们在判断该句话的真实性的前提下，unit(x,y+n),unit(x+n,y+2*n),unit(x+2*n,y)这三句话的含义是我们认为在这句话的正确的前提下，我们认为Ax与By,Bx与Cy,Cx与Ay是有关系的，也就是说我们认为他们存在前者对后者的捕食关系
  </p>
  <p>
   <br/>
  </p>
  <p>
   对于判断我们的思路也是一样的
  </p>
  <p>
   归根到底，我们对于same(A,B)里面的结果认为是正确的，我们根据其正确性来判断当前的话的正确性，否则我们进行相应的合并操作
  </p>
  <p>
   <br/>
  </p>
  <p>
   AC代码：
  </p>
  <p>
  </p>
  <pre class="cpp" name="code">#include"iostream"
#include"cstdio"
#include"cstring"
#include"cstdlib"
#define N 150010

using namespace std;

int fa[N];
int n,m;

void init()
{
	for(int i=1;i&lt;=3*n;i++)
	{
		fa[i]=i;
	}
}

int find(int x)
{
	if(x==fa[x]) return x;
	else return fa[x]=find(fa[x]);
}

void unit(int x,int y)
{
	x=find(x);
	y=find(y);
	if(x==y) return ;
	else fa[y]=x;
    return ;
}

bool same(int x,int y)
{
	return find(x)==find(y);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	init();
	int sum=0;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&amp;z,&amp;x,&amp;y);
		if(x&gt;n||y&gt;n) sum++;
		else if(z==2&amp;&amp;x==y) sum++;
		else
		{
			if(z==1)
			{
				if(same(x,y+n)||same(x,y+2*n)) sum++;
				else
				{
					unit(x,y);
					unit(x+n,y+n);
					unit(x+2*n,y+2*n);
				}
			}
			else
			{
				if(same(x,y)||same(x,y+2*n)) sum++;   //这里我们只判断一次same(x,y)的原因而不用same(x+n,y+n)等都判断在于我们如果same(x,y)成立，那么same(x+n,y+n)等必然也成立，我们判断一个就可以代表全部的信息了
				else
				{
					unit(x,y+n);
					unit(x+n,y+2*n);
					unit(x+2*n,y);
				}
			}
		}
	}
	printf("%d\n",sum);
	return 0;
}</pre>
  <br/>
  3.2带权并查集
  <p>
   我们都知道，并查集作为不相交集合，他的优势在于我们将有关系的两个数据进行合并，然后我们用一个根节点代表着一整个数据，从未实现我们队位置关系的快速判断，现在我们的手段对于解决高级的并查集的题目已经远远不能适应了，我们不仅要知道所谓的两者之间有没有关系，我们还要知道，两者之间的相对关系，本体作为一个绝好的例子，向我们说明了，相对的关系我们如何进行判断，我们采用带权的并查集
  </p>
  <p>
   这里我们首先要明确，我们的权是带有方向的
  </p>
  <p>
   在这里我先致歉，本人愚笨未能考虑出大神的向量思维的玄妙，这我只能证明方法的正确性，对于方法的来源 和具体作用却是真的一知半解
  </p>
  <p>
   在这里我的讲解这是局限于我们对这道题的理解，非常的抱歉
  </p>
  <p>
   <br/>
  </p>
  <p>
   首先我们将节点重新进行定义，我们不仅需要父亲域，我们还需要对于父亲的关系域，注意，在这里我们对于发亲的关系域是从本节点指向父亲节点的向量
  </p>
  <p>
  </p>
  <pre class="cpp" name="code">typedef struct node
{
       int fa;
       int re;   //记录和父亲之间的关系，0代表同类，1代表被父亲吃，2代表吃父亲
};</pre>
  <p>
   之后对于find函数我们不仅要进行路径压缩（在本题的带权并查集的问题中，路径压缩是必须的，因为我们要通过根节点进行比较，我们对于根节点的额直接关系是必须要知道的，不进行路径压缩，我们的父亲节点就不一定是根节点，那么我们的关系域就不一定是针对根节点的），我们还要对关系域进行更新
  </p>
  <p>
   <br/>
  </p>
  <p>
   在这里我本人对计算关系域的正确性的所有情况都进行了证明，是完全正确的也是非常玄妙的，为什么取模就可以实现这么完美有优秀的思想转变？百思不得其解
  </p>
  <p>
   在这里，详细注释参考代码或者网上大神的讲解
   <a href="http://blog.csdn.net/niushuai666/article/details/6981689" target="_blank">
    点击打开链接
   </a>
  </p>
  <p>
   AC代码：
  </p>
  <p>
  </p>
  <pre class="cpp" name="code">#include"iostream"
#include"cstdio"
#include"cstdlib"
#include"cstring"
#define N 50010

using namespace std;

typedef struct node
{
	int fa;
	int re;
}point;

point data[N];
int n,m;

void init()
{
	for(int i=1;i&lt;=n;i++)
	{
		data[i].fa=i;
		data[i].re=0;
	}
}

int find(int x)
{
	if(x==data[x].fa) return x;
	else
	{
		int temp=data[x].fa;   //注意，这里我们要首先保存该节点的父亲节点，因为我们修改关系域的时候要用到和原父亲的关系，本人在这里WA了，没有保存，直接原父亲的标号
		data[x].fa=find(temp);
		data[x].re=(data[x].re+data[temp].re)%3;   //该式子可以证明
		return data[x].fa;
	}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	init();
	int count=0;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&amp;z,&amp;x,&amp;y);
		if(x&gt;n||y&gt;n) count++;
		else if(z==2&amp;&amp;x==y)	count++;
		else
		{
			int rootx=find(x);
			int rooty=find(y);
			if(rootx==rooty)
			{
				if(z==2&amp;&amp;(z-1!=(data[y].re+3-data[x].re)%3)) count++;   //向量的表示法
				if(z==1&amp;&amp;data[x].re!=data[y].re) count++;
			}
			else
			{
				data[rooty].fa=rootx;
				data[rooty].re=(z-1+3-data[y].re+data[x].re)%3;   //向量的表示法
			}
		}
	}
	printf("%d\n",count);
	return 0;
}</pre>
  <br/>
  <br/>
  <link href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0" rel="stylesheet"/>
 </div>
</article>
</body></html>